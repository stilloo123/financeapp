"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-auth-library";
exports.ids = ["vendor-chunks/google-auth-library"];
exports.modules = {

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/authclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2012 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AuthClient = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nclass AuthClient extends events_1.EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.transporter = new transporters_1.DefaultTransporter();\n        this.credentials = {};\n        this.eagerRefreshThresholdMillis = 5 * 60 * 1000;\n        this.forceRefreshOnFailure = false;\n    }\n    /**\n     * Sets the auth credentials.\n     */\n    setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    /**\n     * Append additional headers, e.g., x-goog-user-project, shared across the\n     * classes inheriting AuthClient. This method should be used by any method\n     * that overrides getRequestMetadataAsync(), which is a shared helper for\n     * setting request information in both gRPC and HTTP API calls.\n     *\n     * @param headers object to append additional headers to.\n     */\n    addSharedMetadataHeaders(headers) {\n        // quota_project_id, stored in application_default_credentials.json, is set in\n        // the x-goog-user-project header, to indicate an alternate account for\n        // billing and quota:\n        if (!headers['x-goog-user-project'] && // don't override a value the user sets.\n            this.quotaProjectId) {\n            headers['x-goog-user-project'] = this.quotaProjectId;\n        }\n        return headers;\n    }\n}\nexports.AuthClient = AuthClient;\n//# sourceMappingURL=authclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hdXRoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXV0aGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDEyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdXRoQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgdHJhbnNwb3J0ZXJzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0ZXJzXCIpO1xuY2xhc3MgQXV0aENsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIgPSBuZXcgdHJhbnNwb3J0ZXJzXzEuRGVmYXVsdFRyYW5zcG9ydGVyKCk7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSA1ICogNjAgKiAxMDAwO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdXRoIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFkZGl0aW9uYWwgaGVhZGVycywgZS5nLiwgeC1nb29nLXVzZXItcHJvamVjdCwgc2hhcmVkIGFjcm9zcyB0aGVcbiAgICAgKiBjbGFzc2VzIGluaGVyaXRpbmcgQXV0aENsaWVudC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgYnkgYW55IG1ldGhvZFxuICAgICAqIHRoYXQgb3ZlcnJpZGVzIGdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKCksIHdoaWNoIGlzIGEgc2hhcmVkIGhlbHBlciBmb3JcbiAgICAgKiBzZXR0aW5nIHJlcXVlc3QgaW5mb3JtYXRpb24gaW4gYm90aCBnUlBDIGFuZCBIVFRQIEFQSSBjYWxscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIG9iamVjdCB0byBhcHBlbmQgYWRkaXRpb25hbCBoZWFkZXJzIHRvLlxuICAgICAqL1xuICAgIGFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIC8vIHF1b3RhX3Byb2plY3RfaWQsIHN0b3JlZCBpbiBhcHBsaWNhdGlvbl9kZWZhdWx0X2NyZWRlbnRpYWxzLmpzb24sIGlzIHNldCBpblxuICAgICAgICAvLyB0aGUgeC1nb29nLXVzZXItcHJvamVjdCBoZWFkZXIsIHRvIGluZGljYXRlIGFuIGFsdGVybmF0ZSBhY2NvdW50IGZvclxuICAgICAgICAvLyBiaWxsaW5nIGFuZCBxdW90YTpcbiAgICAgICAgaWYgKCFoZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gJiYgLy8gZG9uJ3Qgb3ZlcnJpZGUgYSB2YWx1ZSB0aGUgdXNlciBzZXRzLlxuICAgICAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCkge1xuICAgICAgICAgICAgaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID0gdGhpcy5xdW90YVByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLkF1dGhDbGllbnQgPSBBdXRoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = __webpack_require__(/*! ./awsrequestsigner */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        this.environmentId = options.credential_source.environment_id;\n        // This is only required if the AWS region is not available in the\n        // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n        this.regionUrl = options.credential_source.region_url;\n        // This is only required if AWS security credentials are not available in\n        // environment variables.\n        this.securityCredentialsUrl = options.credential_source.url;\n        this.regionalCredVerificationUrl =\n            options.credential_source.regional_cred_verification_url;\n        this.imdsV2SessionTokenUrl =\n            options.credential_source.imdsv2_session_token_url;\n        this.awsRequestSigner = null;\n        this.region = '';\n        // Data validators.\n        this.validateEnvironmentId();\n    }\n    validateEnvironmentId() {\n        var _a;\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        }\n        else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\n     * endpoint.\n     * The logic is summarized as:\n     * 1. If imdsv2_session_token_url is provided in the credential source, then\n     *    fetch the aws session token and include it in the headers of the\n     *    metadata requests. This is a requirement for IDMSv2 but optional\n     *    for IDMSv1.\n     * 2. Retrieve AWS region from availability-zone.\n     * 3a. Check AWS credentials in environment variables. If not found, get\n     *     from security-credentials endpoint.\n     * 3b. Get AWS credentials from security-credentials endpoint. In order\n     *     to retrieve this, the AWS role needs to be determined by calling\n     *     security-credentials endpoint without any argument. Then the\n     *     credentials can be retrieved via: security-credentials/role_name\n     * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n     * 5. Inject x-goog-cloud-target-resource into header and serialize the\n     *    signed request. This will be the subject-token to pass to GCP STS.\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            const metadataHeaders = {};\n            // Only retrieve the IMDSv2 session token if both the security credentials and region are\n            // not retrievable through the environment.\n            // The credential config contains all the URLs by default but clients may be running this\n            // where the metadata server is not available and returning the credentials through the environment.\n            // Removing this check may break them.\n            if (this.shouldUseMetadataServer() && this.imdsV2SessionTokenUrl) {\n                metadataHeaders['x-aws-ec2-metadata-token'] =\n                    await this.getImdsV2SessionToken();\n            }\n            this.region = await this.getAwsRegion(metadataHeaders);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n                // Check environment variables for permanent credentials first.\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n                if (this.securityCredentialsFromEnv) {\n                    return this.securityCredentialsFromEnv;\n                }\n                // Since the role on a VM can change, we don't need to cache it.\n                const roleName = await this.getAwsRoleName(metadataHeaders);\n                // Temporary credentials typically last for several hours.\n                // Expiration is returned in response.\n                // Consider future optimization of this logic to cache AWS tokens\n                // until their natural expiration.\n                const awsCreds = await this.getAwsSecurityCredentials(roleName, metadataHeaders);\n                return {\n                    accessKeyId: awsCreds.AccessKeyId,\n                    secretAccessKey: awsCreds.SecretAccessKey,\n                    token: awsCreds.Token,\n                };\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n            method: 'POST',\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            'x-goog-cloud-target-resource': this.audience,\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for (const key in extendedHeaders) {\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key],\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader,\n        }));\n    }\n    /**\n     * @return A promise that resolves with the IMDSv2 Session Token.\n     */\n    async getImdsV2SessionToken() {\n        const opts = {\n            url: this.imdsV2SessionTokenUrl,\n            method: 'PUT',\n            responseType: 'text',\n            headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '300' },\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the current AWS region.\n     */\n    async getAwsRegion(headers) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (this.regionFromEnv) {\n            return this.regionFromEnv;\n        }\n        if (!this.regionUrl) {\n            throw new Error('Unable to determine AWS region due to missing ' +\n                '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            url: this.regionUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the assigned role to the current\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\n     */\n    async getAwsRoleName(headers) {\n        if (!this.securityCredentialsUrl) {\n            throw new Error('Unable to determine AWS role name due to missing ' +\n                '\"options.credential_source.url\"');\n        }\n        const opts = {\n            url: this.securityCredentialsUrl,\n            method: 'GET',\n            responseType: 'text',\n            headers: headers,\n        };\n        const response = await this.transporter.request(opts);\n        return response.data;\n    }\n    /**\n     * Retrieves the temporary AWS credentials by calling the security-credentials\n     * endpoint as specified in the `credential_source` object.\n     * @param roleName The role attached to the current VM.\n     * @param headers The headers to be used in the metadata request.\n     * @return A promise that resolves with the temporary AWS credentials\n     *   needed for creating the GetCallerIdentity signed request.\n     */\n    async getAwsSecurityCredentials(roleName, headers) {\n        const response = await this.transporter.request({\n            url: `${this.securityCredentialsUrl}/${roleName}`,\n            responseType: 'json',\n            headers: headers,\n        });\n        return response.data;\n    }\n    shouldUseMetadataServer() {\n        // The metadata server must be used when either the AWS region or AWS security\n        // credentials cannot be retrieved through their defined environment variables.\n        return !this.regionFromEnv || !this.securityCredentialsFromEnv;\n    }\n    get regionFromEnv() {\n        // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n        // Only one is required.\n        return (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'] || null);\n    }\n    get securityCredentialsFromEnv() {\n        // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n        if (process.env['AWS_ACCESS_KEY_ID'] &&\n            process.env['AWS_SECRET_ACCESS_KEY']) {\n            return {\n                accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n                secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n                token: process.env['AWS_SESSION_TOKEN'],\n            };\n        }\n        return null;\n    }\n}\nexports.AwsClient = AwsClient;\nAwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = '169.254.169.254';\nAwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = 'fd00:ec2::254';\n//# sourceMappingURL=awsclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsMkJBQTJCLG1CQUFPLENBQUMsdUdBQW9CO0FBQ3ZELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUErQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEIsR0FBRyxTQUFTO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bd3NDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBhd3NyZXF1ZXN0c2lnbmVyXzEgPSByZXF1aXJlKFwiLi9hd3NyZXF1ZXN0c2lnbmVyXCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG4vKipcbiAqIEFXUyBleHRlcm5hbCBhY2NvdW50IGNsaWVudC4gVGhpcyBpcyB1c2VkIGZvciBBV1Mgd29ya2xvYWRzLCB3aGVyZVxuICogQVdTIFNUUyBHZXRDYWxsZXJJZGVudGl0eSBzZXJpYWxpemVkIHNpZ25lZCByZXF1ZXN0cyBhcmUgZXhjaGFuZ2VkIGZvclxuICogR0NQIGFjY2VzcyB0b2tlbi5cbiAqL1xuY2xhc3MgQXdzQ2xpZW50IGV4dGVuZHMgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEF3c0NsaWVudCBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTlxuICAgICAqIG9iamVjdCBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZpbGUuXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBjcmVkZW50aWFsIGlzIG5vdCBhIHZhbGlkIEFXUyBjcmVkZW50aWFsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnRJZCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZW52aXJvbm1lbnRfaWQ7XG4gICAgICAgIC8vIFRoaXMgaXMgb25seSByZXF1aXJlZCBpZiB0aGUgQVdTIHJlZ2lvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoZVxuICAgICAgICAvLyBBV1NfUkVHSU9OIG9yIEFXU19ERUZBVUxUX1JFR0lPTiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgIHRoaXMucmVnaW9uVXJsID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5yZWdpb25fdXJsO1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgcmVxdWlyZWQgaWYgQVdTIHNlY3VyaXR5IGNyZWRlbnRpYWxzIGFyZSBub3QgYXZhaWxhYmxlIGluXG4gICAgICAgIC8vIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS51cmw7XG4gICAgICAgIHRoaXMucmVnaW9uYWxDcmVkVmVyaWZpY2F0aW9uVXJsID1cbiAgICAgICAgICAgIG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UucmVnaW9uYWxfY3JlZF92ZXJpZmljYXRpb25fdXJsO1xuICAgICAgICB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCA9XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmltZHN2Ml9zZXNzaW9uX3Rva2VuX3VybDtcbiAgICAgICAgdGhpcy5hd3NSZXF1ZXN0U2lnbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpb24gPSAnJztcbiAgICAgICAgLy8gRGF0YSB2YWxpZGF0b3JzLlxuICAgICAgICB0aGlzLnZhbGlkYXRlRW52aXJvbm1lbnRJZCgpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVudmlyb25tZW50SWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoX2EgPSB0aGlzLmVudmlyb25tZW50SWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvXihhd3MpKFxcZCspJC8pO1xuICAgICAgICBpZiAoIW1hdGNoIHx8ICF0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBBV1MgXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhd3MgdmVyc2lvbiBcIiR7bWF0Y2hbMl19XCIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBidWlsZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGFcbiAgICAgKiBHQ1AgYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgdXNlcyBhIHNlcmlhbGl6ZWQgQVdTIHNpZ25lZCByZXF1ZXN0IHRvIHRoZSBTVFMgR2V0Q2FsbGVySWRlbnRpdHlcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKiBUaGUgbG9naWMgaXMgc3VtbWFyaXplZCBhczpcbiAgICAgKiAxLiBJZiBpbWRzdjJfc2Vzc2lvbl90b2tlbl91cmwgaXMgcHJvdmlkZWQgaW4gdGhlIGNyZWRlbnRpYWwgc291cmNlLCB0aGVuXG4gICAgICogICAgZmV0Y2ggdGhlIGF3cyBzZXNzaW9uIHRva2VuIGFuZCBpbmNsdWRlIGl0IGluIHRoZSBoZWFkZXJzIG9mIHRoZVxuICAgICAqICAgIG1ldGFkYXRhIHJlcXVlc3RzLiBUaGlzIGlzIGEgcmVxdWlyZW1lbnQgZm9yIElETVN2MiBidXQgb3B0aW9uYWxcbiAgICAgKiAgICBmb3IgSURNU3YxLlxuICAgICAqIDIuIFJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBhdmFpbGFiaWxpdHktem9uZS5cbiAgICAgKiAzYS4gQ2hlY2sgQVdTIGNyZWRlbnRpYWxzIGluIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgbm90IGZvdW5kLCBnZXRcbiAgICAgKiAgICAgZnJvbSBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludC5cbiAgICAgKiAzYi4gR2V0IEFXUyBjcmVkZW50aWFscyBmcm9tIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LiBJbiBvcmRlclxuICAgICAqICAgICB0byByZXRyaWV2ZSB0aGlzLCB0aGUgQVdTIHJvbGUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBieSBjYWxsaW5nXG4gICAgICogICAgIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50IHdpdGhvdXQgYW55IGFyZ3VtZW50LiBUaGVuIHRoZVxuICAgICAqICAgICBjcmVkZW50aWFscyBjYW4gYmUgcmV0cmlldmVkIHZpYTogc2VjdXJpdHktY3JlZGVudGlhbHMvcm9sZV9uYW1lXG4gICAgICogNC4gR2VuZXJhdGUgdGhlIHNpZ25lZCByZXF1ZXN0IHRvIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgYWN0aW9uLlxuICAgICAqIDUuIEluamVjdCB4LWdvb2ctY2xvdWQtdGFyZ2V0LXJlc291cmNlIGludG8gaGVhZGVyIGFuZCBzZXJpYWxpemUgdGhlXG4gICAgICogICAgc2lnbmVkIHJlcXVlc3QuIFRoaXMgd2lsbCBiZSB0aGUgc3ViamVjdC10b2tlbiB0byBwYXNzIHRvIEdDUCBTVFMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlU3ViamVjdFRva2VuKCkge1xuICAgICAgICAvLyBJbml0aWFsaXplIEFXUyByZXF1ZXN0IHNpZ25lciBpZiBub3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKCF0aGlzLmF3c1JlcXVlc3RTaWduZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgLy8gT25seSByZXRyaWV2ZSB0aGUgSU1EU3YyIHNlc3Npb24gdG9rZW4gaWYgYm90aCB0aGUgc2VjdXJpdHkgY3JlZGVudGlhbHMgYW5kIHJlZ2lvbiBhcmVcbiAgICAgICAgICAgIC8vIG5vdCByZXRyaWV2YWJsZSB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgIC8vIFRoZSBjcmVkZW50aWFsIGNvbmZpZyBjb250YWlucyBhbGwgdGhlIFVSTHMgYnkgZGVmYXVsdCBidXQgY2xpZW50cyBtYXkgYmUgcnVubmluZyB0aGlzXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGUgbWV0YWRhdGEgc2VydmVyIGlzIG5vdCBhdmFpbGFibGUgYW5kIHJldHVybmluZyB0aGUgY3JlZGVudGlhbHMgdGhyb3VnaCB0aGUgZW52aXJvbm1lbnQuXG4gICAgICAgICAgICAvLyBSZW1vdmluZyB0aGlzIGNoZWNrIG1heSBicmVhayB0aGVtLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlTWV0YWRhdGFTZXJ2ZXIoKSAmJiB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhSGVhZGVyc1sneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuJ10gPVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEltZHNWMlNlc3Npb25Ub2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWdpb24gPSBhd2FpdCB0aGlzLmdldEF3c1JlZ2lvbihtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5hd3NSZXF1ZXN0U2lnbmVyID0gbmV3IGF3c3JlcXVlc3RzaWduZXJfMS5Bd3NSZXF1ZXN0U2lnbmVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHBlcm1hbmVudCBjcmVkZW50aWFscyBmaXJzdC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3IvYXdzLXNlYy1jcmVkLXR5cGVzLmh0bWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIHJvbGUgb24gYSBWTSBjYW4gY2hhbmdlLCB3ZSBkb24ndCBuZWVkIHRvIGNhY2hlIGl0LlxuICAgICAgICAgICAgICAgIGNvbnN0IHJvbGVOYW1lID0gYXdhaXQgdGhpcy5nZXRBd3NSb2xlTmFtZShtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSBjcmVkZW50aWFscyB0eXBpY2FsbHkgbGFzdCBmb3Igc2V2ZXJhbCBob3Vycy5cbiAgICAgICAgICAgICAgICAvLyBFeHBpcmF0aW9uIGlzIHJldHVybmVkIGluIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGZ1dHVyZSBvcHRpbWl6YXRpb24gb2YgdGhpcyBsb2dpYyB0byBjYWNoZSBBV1MgdG9rZW5zXG4gICAgICAgICAgICAgICAgLy8gdW50aWwgdGhlaXIgbmF0dXJhbCBleHBpcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGF3c0NyZWRzID0gYXdhaXQgdGhpcy5nZXRBd3NTZWN1cml0eUNyZWRlbnRpYWxzKHJvbGVOYW1lLCBtZXRhZGF0YUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiBhd3NDcmVkcy5BY2Nlc3NLZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBhd3NDcmVkcy5TZWNyZXRBY2Nlc3NLZXksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBhd3NDcmVkcy5Ub2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5yZWdpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIHNpZ25lZCByZXF1ZXN0IHRvIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgQVBJLlxuICAgICAgICAvLyBVc2UgdGhlIHJlcXVpcmVkIHJlZ2lvbmFsIGVuZHBvaW50LiBPdGhlcndpc2UsIHRoZSByZXF1ZXN0IHdpbGwgZmFpbC5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IHRoaXMuYXdzUmVxdWVzdFNpZ25lci5nZXRSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAgICB1cmw6IHRoaXMucmVnaW9uYWxDcmVkVmVyaWZpY2F0aW9uVXJsLnJlcGxhY2UoJ3tyZWdpb259JywgdGhpcy5yZWdpb24pLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgR0NQIFNUUyBlbmRwb2ludCBleHBlY3RzIHRoZSBoZWFkZXJzIHRvIGJlIGZvcm1hdHRlZCBhczpcbiAgICAgICAgLy8gW1xuICAgICAgICAvLyAgIHtrZXk6ICd4LWFtei1kYXRlJywgdmFsdWU6ICcuLi4nfSxcbiAgICAgICAgLy8gICB7a2V5OiAnQXV0aG9yaXphdGlvbicsIHZhbHVlOiAnLi4uJ30sXG4gICAgICAgIC8vICAgLi4uXG4gICAgICAgIC8vIF1cbiAgICAgICAgLy8gQW5kIHRoZW4gc2VyaWFsaXplZCBhczpcbiAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLy8gICB1cmw6ICcuLi4nLFxuICAgICAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAvLyAgIGhlYWRlcnM6IFt7a2V5OiAneC1hbXotZGF0ZScsIHZhbHVlOiAnLi4uJ30sIC4uLl1cbiAgICAgICAgLy8gfSkpXG4gICAgICAgIGNvbnN0IHJlZm9ybWF0dGVkSGVhZGVyID0gW107XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gVGhlIGZ1bGwsIGNhbm9uaWNhbCByZXNvdXJjZSBuYW1lIG9mIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sXG4gICAgICAgICAgICAvLyBwcm92aWRlciwgd2l0aCBvciB3aXRob3V0IHRoZSBIVFRQUyBwcmVmaXguXG4gICAgICAgICAgICAvLyBJbmNsdWRpbmcgdGhpcyBoZWFkZXIgYXMgcGFydCBvZiB0aGUgc2lnbmF0dXJlIGlzIHJlY29tbWVuZGVkIHRvXG4gICAgICAgICAgICAvLyBlbnN1cmUgZGF0YSBpbnRlZ3JpdHkuXG4gICAgICAgICAgICAneC1nb29nLWNsb3VkLXRhcmdldC1yZXNvdXJjZSc6IHRoaXMuYXVkaWVuY2UsXG4gICAgICAgIH0sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIC8vIFJlZm9ybWF0IGhlYWRlciB0byBHQ1AgU1RTIGV4cGVjdGVkIGZvcm1hdC5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5kZWRIZWFkZXJzKSB7XG4gICAgICAgICAgICByZWZvcm1hdHRlZEhlYWRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dGVuZGVkSGVhZGVyc1trZXldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSByZWZvcm1hdHRlZCBzaWduZWQgcmVxdWVzdC5cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlZm9ybWF0dGVkSGVhZGVyLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgSU1EU3YyIFNlc3Npb24gVG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1kc1YyU2Vzc2lvblRva2VuKCkge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbi10dGwtc2Vjb25kcyc6ICczMDAnIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gYmUgdXNlZCBpbiB0aGUgbWV0YWRhdGEgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGN1cnJlbnQgQVdTIHJlZ2lvbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBd3NSZWdpb24oaGVhZGVycykge1xuICAgICAgICAvLyBQcmlvcml0eSBvcmRlciBmb3IgcmVnaW9uIGRldGVybWluYXRpb246XG4gICAgICAgIC8vIEFXU19SRUdJT04gPiBBV1NfREVGQVVMVF9SRUdJT04gPiBtZXRhZGF0YSBzZXJ2ZXIuXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbkZyb21FbnYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbkZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lvblVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIEFXUyByZWdpb24gZHVlIHRvIG1pc3NpbmcgJyArXG4gICAgICAgICAgICAgICAgJ1wib3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5yZWdpb25fdXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLnJlZ2lvblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAvLyBSZW1vdmUgbGFzdCBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCBpZiB1cy1lYXN0LTJiIGlzIHJldHVybmVkLFxuICAgICAgICAvLyB0aGUgcmVnaW9uIHdvdWxkIGJlIHVzLWVhc3QtMi5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuc3Vic3RyKDAsIHJlc3BvbnNlLmRhdGEubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIFRoZSBoZWFkZXJzIHRvIGJlIHVzZWQgaW4gdGhlIG1ldGFkYXRhIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhc3NpZ25lZCByb2xlIHRvIHRoZSBjdXJyZW50XG4gICAgICogICBBV1MgVk0uIFRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIHRoZSBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBd3NSb2xlTmFtZShoZWFkZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUgQVdTIHJvbGUgbmFtZSBkdWUgdG8gbWlzc2luZyAnICtcbiAgICAgICAgICAgICAgICAnXCJvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHRlbXBvcmFyeSBBV1MgY3JlZGVudGlhbHMgYnkgY2FsbGluZyB0aGUgc2VjdXJpdHktY3JlZGVudGlhbHNcbiAgICAgKiBlbmRwb2ludCBhcyBzcGVjaWZpZWQgaW4gdGhlIGBjcmVkZW50aWFsX3NvdXJjZWAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByb2xlTmFtZSBUaGUgcm9sZSBhdHRhY2hlZCB0byB0aGUgY3VycmVudCBWTS5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSB1c2VkIGluIHRoZSBtZXRhZGF0YSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGVtcG9yYXJ5IEFXUyBjcmVkZW50aWFsc1xuICAgICAqICAgbmVlZGVkIGZvciBjcmVhdGluZyB0aGUgR2V0Q2FsbGVySWRlbnRpdHkgc2lnbmVkIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyhyb2xlTmFtZSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IGAke3RoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybH0vJHtyb2xlTmFtZX1gLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIHNob3VsZFVzZU1ldGFkYXRhU2VydmVyKCkge1xuICAgICAgICAvLyBUaGUgbWV0YWRhdGEgc2VydmVyIG11c3QgYmUgdXNlZCB3aGVuIGVpdGhlciB0aGUgQVdTIHJlZ2lvbiBvciBBV1Mgc2VjdXJpdHlcbiAgICAgICAgLy8gY3JlZGVudGlhbHMgY2Fubm90IGJlIHJldHJpZXZlZCB0aHJvdWdoIHRoZWlyIGRlZmluZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICByZXR1cm4gIXRoaXMucmVnaW9uRnJvbUVudiB8fCAhdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudjtcbiAgICB9XG4gICAgZ2V0IHJlZ2lvbkZyb21FbnYoKSB7XG4gICAgICAgIC8vIFRoZSBBV1MgcmVnaW9uIGNhbiBiZSBwcm92aWRlZCB0aHJvdWdoIEFXU19SRUdJT04gb3IgQVdTX0RFRkFVTFRfUkVHSU9OLlxuICAgICAgICAvLyBPbmx5IG9uZSBpcyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIChwcm9jZXNzLmVudlsnQVdTX1JFR0lPTiddIHx8IHByb2Nlc3MuZW52WydBV1NfREVGQVVMVF9SRUdJT04nXSB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2V0IHNlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52KCkge1xuICAgICAgICAvLyBCb3RoIEFXU19BQ0NFU1NfS0VZX0lEIGFuZCBBV1NfU0VDUkVUX0FDQ0VTU19LRVkgYXJlIHJlcXVpcmVkLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnZbJ0FXU19BQ0NFU1NfS0VZX0lEJ10gJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydBV1NfU0VDUkVUX0FDQ0VTU19LRVknXSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnZbJ0FXU19BQ0NFU1NfS0VZX0lEJ10sXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudlsnQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZJ10sXG4gICAgICAgICAgICAgICAgdG9rZW46IHByb2Nlc3MuZW52WydBV1NfU0VTU0lPTl9UT0tFTiddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkF3c0NsaWVudCA9IEF3c0NsaWVudDtcbkF3c0NsaWVudC5BV1NfRUMyX01FVEFEQVRBX0lQVjRfQUREUkVTUyA9ICcxNjkuMjU0LjE2OS4yNTQnO1xuQXdzQ2xpZW50LkFXU19FQzJfTUVUQURBVEFfSVBWNl9BRERSRVNTID0gJ2ZkMDA6ZWMyOjoyNTQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdzY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsRequestSigner = void 0;\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** AWS Signature Version 4 signing algorithm identifier.  */\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */\nconst AWS_REQUEST_TYPE = 'aws4_request';\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nclass AwsRequestSigner {\n    /**\n     * Instantiates an AWS API request signer used to send authenticated signed\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n     * This also provides a mechanism to generate the signed request without\n     * sending it.\n     * @param getCredentials A mechanism to retrieve AWS security credentials\n     *   when needed.\n     * @param region The AWS region to use.\n     */\n    constructor(getCredentials, region) {\n        this.getCredentials = getCredentials;\n        this.region = region;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Generates the signed request for the provided HTTP request for calling\n     * an AWS API. This follows the steps described at:\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n     * @param amzOptions The AWS request options that need to be signed.\n     * @return A promise that resolves with the GaxiosOptions containing the\n     *   signed HTTP request parameters.\n     */\n    async getRequestOptions(amzOptions) {\n        if (!amzOptions.url) {\n            throw new Error('\"url\" is required in \"amzOptions\"');\n        }\n        // Stringify JSON requests. This will be set in the request body of the\n        // generated signed request.\n        const requestPayloadData = typeof amzOptions.data === 'object'\n            ? JSON.stringify(amzOptions.data)\n            : amzOptions.data;\n        const url = amzOptions.url;\n        const method = amzOptions.method || 'GET';\n        const requestPayload = amzOptions.body || requestPayloadData;\n        const additionalAmzHeaders = amzOptions.headers;\n        const awsSecurityCredentials = await this.getCredentials();\n        const uri = new URL(url);\n        const headerMap = await generateAuthenticationHeaderMap({\n            crypto: this.crypto,\n            host: uri.host,\n            canonicalUri: uri.pathname,\n            canonicalQuerystring: uri.search.substr(1),\n            method,\n            region: this.region,\n            securityCredentials: awsSecurityCredentials,\n            requestPayload,\n            additionalAmzHeaders,\n        });\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        const headers = Object.assign(\n        // Add x-amz-date if available.\n        headerMap.amzDate ? { 'x-amz-date': headerMap.amzDate } : {}, {\n            Authorization: headerMap.authorizationHeader,\n            host: uri.host,\n        }, additionalAmzHeaders || {});\n        if (awsSecurityCredentials.token) {\n            Object.assign(headers, {\n                'x-amz-security-token': awsSecurityCredentials.token,\n            });\n        }\n        const awsSignedReq = {\n            url,\n            method: method,\n            headers,\n        };\n        if (typeof requestPayload !== 'undefined') {\n            awsSignedReq.body = requestPayload;\n        }\n        return awsSignedReq;\n    }\n}\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */\nasync function sign(crypto, key, msg) {\n    return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */\nasync function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n    const kRegion = await sign(crypto, kDate, region);\n    const kService = await sign(crypto, kRegion, serviceName);\n    const kSigning = await sign(crypto, kService, 'aws4_request');\n    return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */\nasync function generateAuthenticationHeaderMap(options) {\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\n    const requestPayload = options.requestPayload || '';\n    // iam.amazonaws.com host => iam service.\n    // sts.us-east-2.amazonaws.com => sts service.\n    const serviceName = options.host.split('.')[0];\n    const now = new Date();\n    // Format: '%Y%m%dT%H%M%SZ'.\n    const amzDate = now\n        .toISOString()\n        .replace(/[-:]/g, '')\n        .replace(/\\.[0-9]+/, '');\n    // Format: '%Y%m%d'.\n    const dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, '');\n    // Change all additional headers to be lower case.\n    const reformattedAdditionalAmzHeaders = {};\n    Object.keys(additionalAmzHeaders).forEach(key => {\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] =\n            additionalAmzHeaders[key];\n    });\n    // Add AWS token if available.\n    if (options.securityCredentials.token) {\n        reformattedAdditionalAmzHeaders['x-amz-security-token'] =\n            options.securityCredentials.token;\n    }\n    // Header keys need to be sorted alphabetically.\n    const amzHeaders = Object.assign({\n        host: options.host,\n    }, \n    // Previously the date was not fixed with x-amz- and could be provided manually.\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    reformattedAdditionalAmzHeaders.date ? {} : { 'x-amz-date': amzDate }, reformattedAdditionalAmzHeaders);\n    let canonicalHeaders = '';\n    const signedHeadersList = Object.keys(amzHeaders).sort();\n    signedHeadersList.forEach(key => {\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n    });\n    const signedHeaders = signedHeadersList.join(';');\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    const canonicalRequest = `${options.method}\\n` +\n        `${options.canonicalUri}\\n` +\n        `${options.canonicalQuerystring}\\n` +\n        `${canonicalHeaders}\\n` +\n        `${signedHeaders}\\n` +\n        `${payloadHash}`;\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    const stringToSign = `${AWS_ALGORITHM}\\n` +\n        `${amzDate}\\n` +\n        `${credentialScope}\\n` +\n        (await options.crypto.sha256DigestHex(canonicalRequest));\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n    const signature = await sign(options.crypto, signingKey, stringToSign);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` +\n        `${credentialScope}, SignedHeaders=${signedHeaders}, ` +\n        `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;\n    return {\n        // Do not return x-amz-date if date is available.\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n        authorizationHeader,\n        canonicalQuerystring: options.canonicalQuerystring,\n    };\n}\n//# sourceMappingURL=awsrequestsigner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NyZXF1ZXN0c2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLDZGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQyxJQUFJO0FBQ3BFO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDLElBQUksdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJLEdBQUcsZ0JBQWdCO0FBQ3RELEtBQUs7QUFDTCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsY0FBYztBQUN6QixXQUFXLFlBQVk7QUFDdkIsK0JBQStCLFVBQVUsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLGlCQUFpQjtBQUM5RjtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWUsYUFBYSx3Q0FBd0M7QUFDdkcsV0FBVyxnQkFBZ0Isa0JBQWtCLGNBQWM7QUFDM0QscUJBQXFCLDhDQUE4QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2F3c3JlcXVlc3RzaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzUmVxdWVzdFNpZ25lciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBhbGdvcml0aG0gaWRlbnRpZmllci4gICovXG5jb25zdCBBV1NfQUxHT1JJVEhNID0gJ0FXUzQtSE1BQy1TSEEyNTYnO1xuLyoqXG4gKiBUaGUgdGVybWluYXRpb24gc3RyaW5nIGZvciB0aGUgQVdTIGNyZWRlbnRpYWwgc2NvcGUgdmFsdWUgYXMgZGVmaW5lZCBpblxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1zdHJpbmctdG8tc2lnbi5odG1sXG4gKi9cbmNvbnN0IEFXU19SRVFVRVNUX1RZUEUgPSAnYXdzNF9yZXF1ZXN0Jztcbi8qKlxuICogSW1wbGVtZW50cyBhbiBBV1MgQVBJIHJlcXVlc3Qgc2lnbmVyIGJhc2VkIG9uIHRoZSBBV1MgU2lnbmF0dXJlIFZlcnNpb24gNFxuICogc2lnbmluZyBwcm9jZXNzLlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ25hdHVyZS12ZXJzaW9uLTQuaHRtbFxuICovXG5jbGFzcyBBd3NSZXF1ZXN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gQVdTIEFQSSByZXF1ZXN0IHNpZ25lciB1c2VkIHRvIHNlbmQgYXV0aGVudGljYXRlZCBzaWduZWRcbiAgICAgKiByZXF1ZXN0cyB0byBBV1MgQVBJcyBiYXNlZCBvbiB0aGUgQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBwcm9jZXNzLlxuICAgICAqIFRoaXMgYWxzbyBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBnZW5lcmF0ZSB0aGUgc2lnbmVkIHJlcXVlc3Qgd2l0aG91dFxuICAgICAqIHNlbmRpbmcgaXQuXG4gICAgICogQHBhcmFtIGdldENyZWRlbnRpYWxzIEEgbWVjaGFuaXNtIHRvIHJldHJpZXZlIEFXUyBzZWN1cml0eSBjcmVkZW50aWFsc1xuICAgICAqICAgd2hlbiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHJlZ2lvbiBUaGUgQVdTIHJlZ2lvbiB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2V0Q3JlZGVudGlhbHMsIHJlZ2lvbikge1xuICAgICAgICB0aGlzLmdldENyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc2lnbmVkIHJlcXVlc3QgZm9yIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QgZm9yIGNhbGxpbmdcbiAgICAgKiBhbiBBV1MgQVBJLiBUaGlzIGZvbGxvd3MgdGhlIHN0ZXBzIGRlc2NyaWJlZCBhdDpcbiAgICAgKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjRfc2lnbmluZy5odG1sXG4gICAgICogQHBhcmFtIGFtek9wdGlvbnMgVGhlIEFXUyByZXF1ZXN0IG9wdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHNpZ25lZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEdheGlvc09wdGlvbnMgY29udGFpbmluZyB0aGVcbiAgICAgKiAgIHNpZ25lZCBIVFRQIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0T3B0aW9ucyhhbXpPcHRpb25zKSB7XG4gICAgICAgIGlmICghYW16T3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ1cmxcIiBpcyByZXF1aXJlZCBpbiBcImFtek9wdGlvbnNcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmluZ2lmeSBKU09OIHJlcXVlc3RzLiBUaGlzIHdpbGwgYmUgc2V0IGluIHRoZSByZXF1ZXN0IGJvZHkgb2YgdGhlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBzaWduZWQgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWREYXRhID0gdHlwZW9mIGFtek9wdGlvbnMuZGF0YSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYW16T3B0aW9ucy5kYXRhKVxuICAgICAgICAgICAgOiBhbXpPcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IHVybCA9IGFtek9wdGlvbnMudXJsO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBhbXpPcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWQgPSBhbXpPcHRpb25zLmJvZHkgfHwgcmVxdWVzdFBheWxvYWREYXRhO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQW16SGVhZGVycyA9IGFtek9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgY29uc3QgYXdzU2VjdXJpdHlDcmVkZW50aWFscyA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHMoKTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBoZWFkZXJNYXAgPSBhd2FpdCBnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwKHtcbiAgICAgICAgICAgIGNyeXB0bzogdGhpcy5jcnlwdG8sXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVyaTogdXJpLnBhdGhuYW1lLFxuICAgICAgICAgICAgY2Fub25pY2FsUXVlcnlzdHJpbmc6IHVyaS5zZWFyY2guc3Vic3RyKDEpLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgICAgICAgIHNlY3VyaXR5Q3JlZGVudGlhbHM6IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMsXG4gICAgICAgICAgICByZXF1ZXN0UGF5bG9hZCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBbXpIZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwZW5kIGFkZGl0aW9uYWwgb3B0aW9uYWwgaGVhZGVycywgZWcuIFgtQW16LVRhcmdldCwgQ29udGVudC1UeXBlLCBldGMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAvLyBBZGQgeC1hbXotZGF0ZSBpZiBhdmFpbGFibGUuXG4gICAgICAgIGhlYWRlck1hcC5hbXpEYXRlID8geyAneC1hbXotZGF0ZSc6IGhlYWRlck1hcC5hbXpEYXRlIH0gOiB7fSwge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogaGVhZGVyTWFwLmF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgfSwgYWRkaXRpb25hbEFtekhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ3gtYW16LXNlY3VyaXR5LXRva2VuJzogYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF3c1NpZ25lZFJlcSA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UGF5bG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGF3c1NpZ25lZFJlcS5ib2R5ID0gcmVxdWVzdFBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3c1NpZ25lZFJlcTtcbiAgICB9XG59XG5leHBvcnRzLkF3c1JlcXVlc3RTaWduZXIgPSBBd3NSZXF1ZXN0U2lnbmVyO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBITUFDLVNIQTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlIHVzaW5nIHRoZVxuICogcHJvdmlkZWQga2V5LlxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgSE1BQy1TSEEyNTYga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEByZXR1cm4gVGhlIGNvbXB1dGVkIGhhc2ggYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ24oY3J5cHRvLCBrZXksIG1zZykge1xuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc2lnbldpdGhIbWFjU2hhMjU2KGtleSwgbXNnKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc2lnbmluZyBrZXkgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IGJhc2VkIG9uOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5LlxuICogQHBhcmFtIGRhdGVTdGFtcCBUaGUgJyVZJW0lZCcgZGF0ZSBmb3JtYXQuXG4gKiBAcGFyYW0gcmVnaW9uIFRoZSBBV1MgcmVnaW9uLlxuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBBV1Mgc2VydmljZSBuYW1lLCBlZy4gc3RzLlxuICogQHJldHVybiBUaGUgc2lnbmluZyBrZXkgYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFNpZ25pbmdLZXkoY3J5cHRvLCBrZXksIGRhdGVTdGFtcCwgcmVnaW9uLCBzZXJ2aWNlTmFtZSkge1xuICAgIGNvbnN0IGtEYXRlID0gYXdhaXQgc2lnbihjcnlwdG8sIGBBV1M0JHtrZXl9YCwgZGF0ZVN0YW1wKTtcbiAgICBjb25zdCBrUmVnaW9uID0gYXdhaXQgc2lnbihjcnlwdG8sIGtEYXRlLCByZWdpb24pO1xuICAgIGNvbnN0IGtTZXJ2aWNlID0gYXdhaXQgc2lnbihjcnlwdG8sIGtSZWdpb24sIHNlcnZpY2VOYW1lKTtcbiAgICBjb25zdCBrU2lnbmluZyA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrU2VydmljZSwgJ2F3czRfcmVxdWVzdCcpO1xuICAgIHJldHVybiBrU2lnbmluZztcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhdXRoZW50aWNhdGlvbiBoZWFkZXIgbWFwIG5lZWRlZCBmb3IgZ2VuZXJhdGluZyB0aGUgQVdTXG4gKiBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25lZCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb24gVGhlIG9wdGlvbnMgbmVlZGVkIHRvIGNvbXB1dGUgdGhlIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBtYXAuXG4gKiBAcmV0dXJuIFRoZSBBV1MgYXV0aGVudGljYXRpb24gaGVhZGVyIG1hcCB3aGljaCBjb25zdGl0dXRlcyBvZiB0aGUgZm9sbG93aW5nXG4gKiAgIGNvbXBvbmVudHM6IGFtei1kYXRlLCBhdXRob3JpemF0aW9uIGhlYWRlciBhbmQgY2Fub25pY2FsIHF1ZXJ5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkhlYWRlck1hcChvcHRpb25zKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbEFtekhlYWRlcnMgPSBvcHRpb25zLmFkZGl0aW9uYWxBbXpIZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0gb3B0aW9ucy5yZXF1ZXN0UGF5bG9hZCB8fCAnJztcbiAgICAvLyBpYW0uYW1hem9uYXdzLmNvbSBob3N0ID0+IGlhbSBzZXJ2aWNlLlxuICAgIC8vIHN0cy51cy1lYXN0LTIuYW1hem9uYXdzLmNvbSA9PiBzdHMgc2VydmljZS5cbiAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG9wdGlvbnMuaG9zdC5zcGxpdCgnLicpWzBdO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkVCVIJU0lU1onLlxuICAgIGNvbnN0IGFtekRhdGUgPSBub3dcbiAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1stOl0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5bMC05XSsvLCAnJyk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkJy5cbiAgICBjb25zdCBkYXRlU3RhbXAgPSBub3cudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bLV0vZywgJycpLnJlcGxhY2UoL1QuKi8sICcnKTtcbiAgICAvLyBDaGFuZ2UgYWxsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBsb3dlciBjYXNlLlxuICAgIGNvbnN0IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQW16SGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgICBhZGRpdGlvbmFsQW16SGVhZGVyc1trZXldO1xuICAgIH0pO1xuICAgIC8vIEFkZCBBV1MgdG9rZW4gaWYgYXZhaWxhYmxlLlxuICAgIGlmIChvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICAgICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9XG4gICAgICAgICAgICBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW47XG4gICAgfVxuICAgIC8vIEhlYWRlciBrZXlzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIGNvbnN0IGFtekhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgIH0sIFxuICAgIC8vIFByZXZpb3VzbHkgdGhlIGRhdGUgd2FzIG5vdCBmaXhlZCB3aXRoIHgtYW16LSBhbmQgY291bGQgYmUgcHJvdmlkZWQgbWFudWFsbHkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JvdG8vYm90b2NvcmUvYmxvYi84NzlmODQ0MGE0ZTlhY2U1ZDNjZjE0NWNlOGIzZDVlNWZmYjg5MmVmL3Rlc3RzL3VuaXQvYXV0aC9hd3M0X3Rlc3RzdWl0ZS9nZXQtaGVhZGVyLXZhbHVlLXRyaW0ucmVxXG4gICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVycy5kYXRlID8ge30gOiB7ICd4LWFtei1kYXRlJzogYW16RGF0ZSB9LCByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzKTtcbiAgICBsZXQgY2Fub25pY2FsSGVhZGVycyA9ICcnO1xuICAgIGNvbnN0IHNpZ25lZEhlYWRlcnNMaXN0ID0gT2JqZWN0LmtleXMoYW16SGVhZGVycykuc29ydCgpO1xuICAgIHNpZ25lZEhlYWRlcnNMaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY2Fub25pY2FsSGVhZGVycyArPSBgJHtrZXl9OiR7YW16SGVhZGVyc1trZXldfVxcbmA7XG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmVkSGVhZGVycyA9IHNpZ25lZEhlYWRlcnNMaXN0LmpvaW4oJzsnKTtcbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChyZXF1ZXN0UGF5bG9hZCk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1jYW5vbmljYWwtcmVxdWVzdC5odG1sXG4gICAgY29uc3QgY2Fub25pY2FsUmVxdWVzdCA9IGAke29wdGlvbnMubWV0aG9kfVxcbmAgK1xuICAgICAgICBgJHtvcHRpb25zLmNhbm9uaWNhbFVyaX1cXG5gICtcbiAgICAgICAgYCR7b3B0aW9ucy5jYW5vbmljYWxRdWVyeXN0cmluZ31cXG5gICtcbiAgICAgICAgYCR7Y2Fub25pY2FsSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7c2lnbmVkSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7cGF5bG9hZEhhc2h9YDtcbiAgICBjb25zdCBjcmVkZW50aWFsU2NvcGUgPSBgJHtkYXRlU3RhbXB9LyR7b3B0aW9ucy5yZWdpb259LyR7c2VydmljZU5hbWV9LyR7QVdTX1JFUVVFU1RfVFlQRX1gO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtc3RyaW5nLXRvLXNpZ24uaHRtbFxuICAgIGNvbnN0IHN0cmluZ1RvU2lnbiA9IGAke0FXU19BTEdPUklUSE19XFxuYCArXG4gICAgICAgIGAke2FtekRhdGV9XFxuYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX1cXG5gICtcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChjYW5vbmljYWxSZXF1ZXN0KSk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBhd2FpdCBnZXRTaWduaW5nS2V5KG9wdGlvbnMuY3J5cHRvLCBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCBkYXRlU3RhbXAsIG9wdGlvbnMucmVnaW9uLCBzZXJ2aWNlTmFtZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbihvcHRpb25zLmNyeXB0bywgc2lnbmluZ0tleSwgc3RyaW5nVG9TaWduKTtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjQtYWRkLXNpZ25hdHVyZS10by1yZXF1ZXN0Lmh0bWxcbiAgICBjb25zdCBhdXRob3JpemF0aW9uSGVhZGVyID0gYCR7QVdTX0FMR09SSVRITX0gQ3JlZGVudGlhbD0ke29wdGlvbnMuc2VjdXJpdHlDcmVkZW50aWFscy5hY2Nlc3NLZXlJZH0vYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX0sIFNpZ25lZEhlYWRlcnM9JHtzaWduZWRIZWFkZXJzfSwgYCArXG4gICAgICAgIGBTaWduYXR1cmU9JHsoMCwgY3J5cHRvXzEuZnJvbUFycmF5QnVmZmVyVG9IZXgpKHNpZ25hdHVyZSl9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBEbyBub3QgcmV0dXJuIHgtYW16LWRhdGUgaWYgZGF0ZSBpcyBhdmFpbGFibGUuXG4gICAgICAgIGFtekRhdGU6IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMuZGF0ZSA/IHVuZGVmaW5lZCA6IGFtekRhdGUsXG4gICAgICAgIGF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgIGNhbm9uaWNhbFF1ZXJ5c3RyaW5nOiBvcHRpb25zLmNhbm9uaWNhbFF1ZXJ5c3RyaW5nLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd3NyZXF1ZXN0c2lnbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/baseexternalclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** Default impersonated token lifespan in seconds.*/\nconst DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super();\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        this.clientAuth = options.client_id\n            ? {\n                confidentialClientType: 'basic',\n                clientId: options.client_id,\n                clientSecret: options.client_secret,\n            }\n            : undefined;\n        this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = options.audience;\n        this.subjectTokenType = options.subject_token_type;\n        this.quotaProjectId = options.quota_project_id;\n        this.workforcePoolUserProject = options.workforce_pool_user_project;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject &&\n            !this.audience.match(workforceAudiencePattern)) {\n            throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' +\n                'credentials.');\n        }\n        this.serviceAccountImpersonationUrl =\n            options.service_account_impersonation_url;\n        this.serviceAccountImpersonationLifetime =\n            (_b = (_a = options.service_account_impersonation) === null || _a === void 0 ? void 0 : _a.token_lifetime_seconds) !== null && _b !== void 0 ? _b : DEFAULT_TOKEN_LIFESPAN;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.projectId = null;\n        this.projectNumber = this.getProjectNumber(this.audience);\n        this.universeDomain = options.universe_domain;\n    }\n    /** The service account email to be impersonated, if available. */\n    getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${projectNumber}`,\n                responseType: 'json',\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        // Client auth is prioritized over passing the workforcePoolUserProject\n        // parameter for STS token exchange.\n        const additionalOptions = !this.clientAuth && this.workforcePoolUserProject\n            ? { userProject: this.workforcePoolUserProject }\n            : undefined;\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else if (stsResponse.expires_in) {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + 's',\n            },\n            responseType: 'json',\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        else if (typeof this.scopes === 'undefined') {\n            return [DEFAULT_OAUTH_SCOPE];\n        }\n        else {\n            return this.scopes;\n        }\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n//# sourceMappingURL=baseexternalclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRyw4QkFBOEI7QUFDbkksZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyxtR0FBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFVBQVU7QUFDN0UsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCLEVBQUUsY0FBYztBQUN2RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Jhc2VleHRlcm5hbGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuLyoqXG4gKiBUaGUgcmVxdWlyZWQgdG9rZW4gZXhjaGFuZ2UgZ3JhbnRfdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfR1JBTlRfVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTp0b2tlbi1leGNoYW5nZSc7XG4vKipcbiAqIFRoZSByZXF1ZXN0ZWQgdG9rZW4gZXhjaGFuZ2UgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuLyoqIFRoZSBkZWZhdWx0IE9BdXRoIHNjb3BlIHRvIHJlcXVlc3Qgd2hlbiBub25lIGlzIHByb3ZpZGVkLiAqL1xuY29uc3QgREVGQVVMVF9PQVVUSF9TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtJztcbi8qKiBEZWZhdWx0IGltcGVyc29uYXRlZCB0b2tlbiBsaWZlc3BhbiBpbiBzZWNvbmRzLiovXG5jb25zdCBERUZBVUxUX1RPS0VOX0xJRkVTUEFOID0gMzYwMDtcbi8qKlxuICogT2Zmc2V0IHRvIHRha2UgaW50byBhY2NvdW50IG5ldHdvcmsgZGVsYXlzIGFuZCBzZXJ2ZXIgY2xvY2sgc2tld3MuXG4gKi9cbmV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVCA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIFRoZSBjcmVkZW50aWFscyBKU09OIGZpbGUgdHlwZSBmb3IgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnRzLlxuICogVGhlcmUgYXJlIDMgdHlwZXMgb2YgSlNPTiBjb25maWdzOlxuICogMS4gYXV0aG9yaXplZF91c2VyID0+IEdvb2dsZSBlbmQgdXNlciBjcmVkZW50aWFsXG4gKiAyLiBzZXJ2aWNlX2FjY291bnQgPT4gR29vZ2xlIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFsXG4gKiAzLiBleHRlcm5hbF9BY2NvdW50ID0+IG5vbi1HQ1Agc2VydmljZSAoZWcuIEFXUywgQXp1cmUsIEs4cylcbiAqL1xuZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUgPSAnZXh0ZXJuYWxfYWNjb3VudCc7XG4vKiogQ2xvdWQgcmVzb3VyY2UgbWFuYWdlciBVUkwgdXNlZCB0byByZXRyaWV2ZSBwcm9qZWN0IGluZm9ybWF0aW9uLiAqL1xuZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gJ2h0dHBzOi8vY2xvdWRyZXNvdXJjZW1hbmFnZXIuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvJztcbi8qKiBUaGUgd29ya2ZvcmNlIGF1ZGllbmNlIHBhdHRlcm4uICovXG5jb25zdCBXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTiA9ICcvL2lhbS5nb29nbGVhcGlzLmNvbS9sb2NhdGlvbnMvW14vXSsvd29ya2ZvcmNlUG9vbHMvW14vXSsvcHJvdmlkZXJzLy4rJztcbi8qKlxuICogQmFzZSBleHRlcm5hbCBhY2NvdW50IGNsaWVudC4gVGhpcyBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIEF1dGhDbGllbnRzIGZvclxuICogZXhjaGFuZ2luZyBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZvciBHQ1AgYWNjZXNzIHRva2VuIGFuZCBhdXRob3JpemluZ1xuICogcmVxdWVzdHMgdG8gR0NQIEFQSXMuXG4gKiBUaGUgYmFzZSBjbGFzcyBpbXBsZW1lbnRzIGNvbW1vbiBsb2dpYyBmb3IgZXhjaGFuZ2luZyB2YXJpb3VzIHR5cGUgb2ZcbiAqIGV4dGVybmFsIGNyZWRlbnRpYWxzIGZvciBHQ1AgYWNjZXNzIHRva2VuLiBUaGUgbG9naWMgb2YgZGV0ZXJtaW5pbmcgYW5kXG4gKiByZXRyaWV2aW5nIHRoZSBleHRlcm5hbCBjcmVkZW50aWFsIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudCBhbmRcbiAqIGNyZWRlbnRpYWxfc291cmNlIHdpbGwgYmUgbGVmdCBmb3IgdGhlIHN1YmNsYXNzZXMuXG4gKi9cbmNsYXNzIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb25cbiAgICAgKiAgIG9wdGlvbnMuIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmRcbiAgICAgKiAgIHdoZXRoZXIgdG8gcmV0cnkgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgXCIke2V4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFfVwiIHR5cGUgYnV0IGAgK1xuICAgICAgICAgICAgICAgIGByZWNlaXZlZCBcIiR7b3B0aW9ucy50eXBlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRBdXRoID0gb3B0aW9ucy5jbGllbnRfaWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGNvbmZpZGVudGlhbENsaWVudFR5cGU6ICdiYXNpYycsXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnMuY2xpZW50X2lkLFxuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldDogb3B0aW9ucy5jbGllbnRfc2VjcmV0LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RzQ3JlZGVudGlhbCA9IG5ldyBzdHMuU3RzQ3JlZGVudGlhbHMob3B0aW9ucy50b2tlbl91cmwsIHRoaXMuY2xpZW50QXV0aCk7XG4gICAgICAgIC8vIERlZmF1bHQgT0F1dGggc2NvcGUuIFRoaXMgY291bGQgYmUgb3ZlcnJpZGRlbiB2aWEgcHVibGljIHByb3BlcnR5LlxuICAgICAgICB0aGlzLnNjb3BlcyA9IFtERUZBVUxUX09BVVRIX1NDT1BFXTtcbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYXVkaWVuY2UgPSBvcHRpb25zLmF1ZGllbmNlO1xuICAgICAgICB0aGlzLnN1YmplY3RUb2tlblR5cGUgPSBvcHRpb25zLnN1YmplY3RfdG9rZW5fdHlwZTtcbiAgICAgICAgdGhpcy5xdW90YVByb2plY3RJZCA9IG9wdGlvbnMucXVvdGFfcHJvamVjdF9pZDtcbiAgICAgICAgdGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3QgPSBvcHRpb25zLndvcmtmb3JjZV9wb29sX3VzZXJfcHJvamVjdDtcbiAgICAgICAgY29uc3Qgd29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuID0gbmV3IFJlZ0V4cChXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTik7XG4gICAgICAgIGlmICh0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCAmJlxuICAgICAgICAgICAgIXRoaXMuYXVkaWVuY2UubWF0Y2god29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZm9yY2VQb29sVXNlclByb2plY3Qgc2hvdWxkIG5vdCBiZSBzZXQgZm9yIG5vbi13b3JrZm9yY2UgcG9vbCAnICtcbiAgICAgICAgICAgICAgICAnY3JlZGVudGlhbHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwgPVxuICAgICAgICAgICAgb3B0aW9ucy5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmw7XG4gICAgICAgIHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRva2VuX2xpZmV0aW1lX3NlY29uZHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfVE9LRU5fTElGRVNQQU47XG4gICAgICAgIC8vIEFzIHRocmVzaG9sZCBjb3VsZCBiZSB6ZXJvLFxuICAgICAgICAvLyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgfHwgRVhQSVJBVElPTl9USU1FX09GRlNFVCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyB6ZXJvIHZhbHVlLlxuICAgICAgICBpZiAodHlwZW9mIChhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBhZGRpdGlvbmFsT3B0aW9uc1xuICAgICAgICAgICAgICAgIC5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAhIShhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2plY3ROdW1iZXIgPSB0aGlzLmdldFByb2plY3ROdW1iZXIodGhpcy5hdWRpZW5jZSk7XG4gICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4gPSBvcHRpb25zLnVuaXZlcnNlX2RvbWFpbjtcbiAgICB9XG4gICAgLyoqIFRoZSBzZXJ2aWNlIGFjY291bnQgZW1haWwgdG8gYmUgaW1wZXJzb25hdGVkLCBpZiBhdmFpbGFibGUuICovXG4gICAgZ2V0U2VydmljZUFjY291bnRFbWFpbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGVtYWlsIGZyb20gVVJMLiBUaGUgZm9ybWFsIGxvb2tzIGFzIGZvbGxvd3M6XG4gICAgICAgICAgICAvLyBodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tL3YxL3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzL25hbWVAcHJvamVjdC1pZC5pYW0uZ3NlcnZpY2VhY2NvdW50LmNvbTpnZW5lcmF0ZUFjY2Vzc1Rva2VuXG4gICAgICAgICAgICBjb25zdCByZSA9IC9zZXJ2aWNlQWNjb3VudHNcXC8oPzxlbWFpbD5bXjpdKyk6Z2VuZXJhdGVBY2Nlc3NUb2tlbiQvO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmUuZXhlYyh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCk7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5ncm91cHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWFpbCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gaW5qZWN0IEdDUCBhY2Nlc3MgdG9rZW5zIGRpcmVjdGx5LlxuICAgICAqIFdoZW4gdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWwgZXhwaXJlcywgYSBuZXcgY3JlZGVudGlhbCwgdXNpbmcgdGhlXG4gICAgICogZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zLCBpcyByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBDcmVkZW50aWFscyBvYmplY3QgdG8gc2V0IG9uIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICBzdXBlci5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBjcmVkZW50aWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjdXJyZW50IEdDUCBhY2Nlc3MgdG9rZW5cbiAgICAgKiAgIHJlc3BvbnNlLiBJZiB0aGUgY3VycmVudCBjcmVkZW50aWFsIGlzIGV4cGlyZWQsIGEgbmV3IG9uZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIC8vIElmIGNhY2hlZCBhY2Nlc3MgdG9rZW4gaXMgdW5hdmFpbGFibGUgb3IgZXhwaXJlZCwgZm9yY2UgcmVmcmVzaC5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuIHx8IHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIEdDUCBhY2Nlc3MgdG9rZW4gaW4gR2V0QWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICByZXM6IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4ucmVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBhdXRoZW50aWNhdGlvbiBpbnRlcmZhY2UuIEl0IHRha2VzIGFuIG9wdGlvbmFsIHVybCB3aGljaCB3aGVuXG4gICAgICogcHJlc2VudCBpcyB0aGUgZW5kcG9pbnQgYmVpbmcgYWNjZXNzZWQsIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHdpdGggYXV0aG9yaXphdGlvbiBoZWFkZXIgZmllbGRzLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdCBoYXMgdGhlIGZvcm06XG4gICAgICogeyBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDxhY2Nlc3NfdG9rZW5fdmFsdWU+JyB9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW5SZXNwb25zZS50b2tlbn1gLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcHJvamVjdCBJRCBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICAgY3VycmVudCB3b3JrbG9hZCBpZGVudGl0eSBwb29sIG9yIGN1cnJlbnQgd29ya2ZvcmNlIHBvb2wgaWZcbiAgICAgKiAgIGRldGVybWluYWJsZS4gRm9yIHdvcmtmb3JjZSBwb29sIGNyZWRlbnRpYWwsIGl0IHJldHVybnMgdGhlIHByb2plY3QgSURcbiAgICAgKiAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHdvcmtmb3JjZVBvb2xVc2VyUHJvamVjdC5cbiAgICAgKiAgIFRoaXMgaXMgaW50cm9kdWNlZCB0byBtYXRjaCB0aGUgY3VycmVudCBwYXR0ZXJuIG9mIHVzaW5nIHRoZSBBdXRoXG4gICAgICogICBsaWJyYXJ5OlxuICAgICAqICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgYXV0aC5nZXRQcm9qZWN0SWQoKTtcbiAgICAgKiAgIGNvbnN0IHVybCA9IGBodHRwczovL2Rucy5nb29nbGVhcGlzLmNvbS9kbnMvdjEvcHJvamVjdHMvJHtwcm9qZWN0SWR9YDtcbiAgICAgKiAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgdXJsIH0pO1xuICAgICAqICAgVGhlIHJlc291cmNlIG1heSBub3QgaGF2ZSBwZXJtaXNzaW9uXG4gICAgICogICAocmVzb3VyY2VtYW5hZ2VyLnByb2plY3RzLmdldCkgdG8gY2FsbCB0aGlzIEFQSSBvciB0aGUgcmVxdWlyZWRcbiAgICAgKiAgIHNjb3BlcyBtYXkgbm90IGJlIHNlbGVjdGVkOlxuICAgICAqICAgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3Jlc291cmNlLW1hbmFnZXIvcmVmZXJlbmNlL3Jlc3QvdjEvcHJvamVjdHMvZ2V0I2F1dGhvcml6YXRpb24tc2NvcGVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvamVjdElkKCkge1xuICAgICAgICBjb25zdCBwcm9qZWN0TnVtYmVyID0gdGhpcy5wcm9qZWN0TnVtYmVyIHx8IHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0O1xuICAgICAgICBpZiAodGhpcy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBwcmV2aW91c2x5IGRldGVybWluZWQgcHJvamVjdCBJRC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0TnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXJhYmxlIG5vdCB0byB1c2UgcmVxdWVzdCgpIHRvIGF2b2lkIHJldHJpYWwgcG9saWNpZXMuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgdXJsOiBgJHtleHBvcnRzLkNMT1VEX1JFU09VUkNFX01BTkFHRVJ9JHtwcm9qZWN0TnVtYmVyfWAsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdElkID0gcmVzcG9uc2UuZGF0YS5wcm9qZWN0SWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIHByb3ZpZGVkIEhUVFAgcmVxdWVzdCwgcHJvY2Vzc2VzIGl0IGFuZCByZXNvbHZlcyB3aXRoIHRoZVxuICAgICAqIHJldHVybmVkIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBIVFRQIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcmV0cnkgV2hldGhlciB0aGUgY3VycmVudCBhdHRlbXB0IGlzIGEgcmV0cnkgYWZ0ZXIgYSBmYWlsZWQgYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgZm9yIG1ldGFkYXRhIGlmIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSBpcyB0cnVlXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9IHJlcy5jb25maWcuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F1dGhFcnIgPSBzdGF0dXNDb2RlID09PSA0MDEgfHwgc3RhdHVzQ29kZSA9PT0gNDAzO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEV4dGVybmFsIGNyZWRlbnRpYWxzIGFyZSBleGNoYW5nZWQgZm9yIEdDUCBhY2Nlc3MgdG9rZW5zIHZpYSB0aGUgdG9rZW5cbiAgICAgKiBleGNoYW5nZSBlbmRwb2ludCBhbmQgb3RoZXIgc2V0dGluZ3MgcHJvdmlkZWQgaW4gdGhlIGNsaWVudCBvcHRpb25zXG4gICAgICogb2JqZWN0LlxuICAgICAqIElmIHRoZSBzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwgaXMgcHJvdmlkZWQsIGFuIGFkZGl0aW9uYWxcbiAgICAgKiBzdGVwIHRvIGV4Y2hhbmdlIHRoZSBleHRlcm5hbCBhY2NvdW50IEdDUCBhY2Nlc3MgdG9rZW4gZm9yIGEgc2VydmljZVxuICAgICAqIGFjY291bnQgaW1wZXJzb25hdGVkIHRva2VuIGlzIHBlcmZvcm1lZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZyZXNoIEdDUCBhY2Nlc3MgdG9rZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbC5cbiAgICAgICAgY29uc3Qgc3ViamVjdFRva2VuID0gYXdhaXQgdGhpcy5yZXRyaWV2ZVN1YmplY3RUb2tlbigpO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIFNUUyBjcmVkZW50aWFscyBvcHRpb25zLlxuICAgICAgICBjb25zdCBzdHNDcmVkZW50aWFsc09wdGlvbnMgPSB7XG4gICAgICAgICAgICBncmFudFR5cGU6IFNUU19HUkFOVF9UWVBFLFxuICAgICAgICAgICAgYXVkaWVuY2U6IHRoaXMuYXVkaWVuY2UsXG4gICAgICAgICAgICByZXF1ZXN0ZWRUb2tlblR5cGU6IFNUU19SRVFVRVNUX1RPS0VOX1RZUEUsXG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4sXG4gICAgICAgICAgICBzdWJqZWN0VG9rZW5UeXBlOiB0aGlzLnN1YmplY3RUb2tlblR5cGUsXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZUFjY2Vzc1Rva2VuIHJlcXVpcmVzIHRoZSBwcm92aWRlZCBhY2Nlc3MgdG9rZW4gdG8gaGF2ZVxuICAgICAgICAgICAgLy8gc2NvcGVzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9pYW0gb3JcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgc2VydmljZSBhY2NvdW50IGFjY2VzcyB0b2tlbiBzY29wZXMgd2lsbCBtYXRjaCB0aGUgdXNlclxuICAgICAgICAgICAgLy8gcHJvdmlkZWQgb25lcy5cbiAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybFxuICAgICAgICAgICAgICAgID8gW0RFRkFVTFRfT0FVVEhfU0NPUEVdXG4gICAgICAgICAgICAgICAgOiB0aGlzLmdldFNjb3Blc0FycmF5KCksXG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4Y2hhbmdlIHRoZSBleHRlcm5hbCBjcmVkZW50aWFscyBmb3IgYSBHQ1AgYWNjZXNzIHRva2VuLlxuICAgICAgICAvLyBDbGllbnQgYXV0aCBpcyBwcmlvcml0aXplZCBvdmVyIHBhc3NpbmcgdGhlIHdvcmtmb3JjZVBvb2xVc2VyUHJvamVjdFxuICAgICAgICAvLyBwYXJhbWV0ZXIgZm9yIFNUUyB0b2tlbiBleGNoYW5nZS5cbiAgICAgICAgY29uc3QgYWRkaXRpb25hbE9wdGlvbnMgPSAhdGhpcy5jbGllbnRBdXRoICYmIHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0XG4gICAgICAgICAgICA/IHsgdXNlclByb2plY3Q6IHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0IH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdHNSZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RzQ3JlZGVudGlhbC5leGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgdW5kZWZpbmVkLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0SW1wZXJzb25hdGVkQWNjZXNzVG9rZW4oc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHNSZXNwb25zZS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGluIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW4gKiAxMDAwLFxuICAgICAgICAgICAgICAgIHJlczogc3RzUmVzcG9uc2UucmVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgcmVzOiBzdHNSZXNwb25zZS5yZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNhdmUgY3JlZGVudGlhbHMuXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNyZWRlbnRpYWxzLCB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY3JlZGVudGlhbHMucmVzO1xuICAgICAgICAvLyBUcmlnZ2VyIHRva2VucyBldmVudCB0byBub3RpZnkgZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHtcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgICAgIGlkX3Rva2VuOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBwcm9qZWN0IG51bWJlciBpZiBpdCBpcyBkZXRlcm1pbmFibGVcbiAgICAgKiBmcm9tIHRoZSBhdWRpZW5jZSByZXNvdXJjZSBuYW1lLlxuICAgICAqIEBwYXJhbSBhdWRpZW5jZSBUaGUgU1RTIGF1ZGllbmNlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcm9qZWN0IG51bWJlci5cbiAgICAgKiBAcmV0dXJuIFRoZSBwcm9qZWN0IG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHdvcmtsb2FkIGlkZW50aXR5IHBvb2wsIGlmXG4gICAgICogICB0aGlzIGNhbiBiZSBkZXRlcm1pbmVkIGZyb20gdGhlIFNUUyBhdWRpZW5jZSBmaWVsZC4gT3RoZXJ3aXNlLCBudWxsIGlzXG4gICAgICogICByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXRQcm9qZWN0TnVtYmVyKGF1ZGllbmNlKSB7XG4gICAgICAgIC8vIFNUUyBhdWRpZW5jZSBwYXR0ZXJuOlxuICAgICAgICAvLyAvL2lhbS5nb29nbGVhcGlzLmNvbS9wcm9qZWN0cy8kUFJPSkVDVF9OVU1CRVIvbG9jYXRpb25zLy4uLlxuICAgICAgICBjb25zdCBtYXRjaCA9IGF1ZGllbmNlLm1hdGNoKC9cXC9wcm9qZWN0c1xcLyhbXi9dKykvKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNoYW5nZXMgYW4gZXh0ZXJuYWwgYWNjb3VudCBHQ1AgYWNjZXNzIHRva2VuIGZvciBhIHNlcnZpY2VcbiAgICAgKiBhY2NvdW50IGltcGVyc29uYXRlZCBhY2Nlc3MgdG9rZW4gdXNpbmcgaWFtY3JlZGVudGlhbHNcbiAgICAgKiBHZW5lcmF0ZUFjY2Vzc1Rva2VuIEFQSS5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFjY2VzcyB0b2tlbiB0byBleGNoYW5nZSBmb3IgYSBzZXJ2aWNlIGFjY291bnQgYWNjZXNzXG4gICAgICogICB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHNlcnZpY2UgYWNjb3VudCBpbXBlcnNvbmF0ZWRcbiAgICAgKiAgIGNyZWRlbnRpYWxzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEltcGVyc29uYXRlZEFjY2Vzc1Rva2VuKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuZ2V0U2NvcGVzQXJyYXkoKSxcbiAgICAgICAgICAgICAgICBsaWZldGltZTogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSArICdzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHN1Y2Nlc3NSZXNwb25zZS5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBJU08gZm9ybWF0IHRvIHRpbWVzdGFtcC5cbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBuZXcgRGF0ZShzdWNjZXNzUmVzcG9uc2UuZXhwaXJlVGltZSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgcmVzOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBUaGUgY3JlZGVudGlhbHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGVcbiAgICAgICAgICAgID8gbm93ID49IGFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlIC0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gVGhlIGxpc3Qgb2Ygc2NvcGVzIGZvciB0aGUgcmVxdWVzdGVkIEdDUCBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgZ2V0U2NvcGVzQXJyYXkoKSB7XG4gICAgICAgIC8vIFNpbmNlIHNjb3BlcyBjYW4gYmUgcHJvdmlkZWQgYXMgc3RyaW5nIG9yIGFycmF5LCB0aGUgdHlwZSBzaG91bGRcbiAgICAgICAgLy8gYmUgbm9ybWFsaXplZC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNjb3BlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zY29wZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNjb3BlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbREVGQVVMVF9PQVVUSF9TQ09QRV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgPSBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZWV4dGVybmFsY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/computeclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Compute = void 0;\nconst arrify = __webpack_require__(/*! arrify */ \"(rsc)/./node_modules/arrify/index.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass Compute extends oauth2client_1.OAuth2Client {\n    /**\n     * Google Compute Engine service account credentials.\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */\n    constructor(options = {}) {\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = { expiry_date: 1, refresh_token: 'compute-placeholder' };\n        this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n        this.scopes = arrify(options.scopes);\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n        let data;\n        try {\n            const instanceOptions = {\n                property: tokenPath,\n            };\n            if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                    scopes: this.scopes.join(','),\n                };\n            }\n            data = await gcpMetadata.instance(instanceOptions);\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError) {\n                e.message = `Could not refresh access token: ${e.message}`;\n                this.wrapError(e);\n            }\n            throw e;\n        }\n        const tokens = data;\n        if (data && data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res: null };\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n    async fetchIdToken(targetAudience) {\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` +\n            `?format=full&audience=${targetAudience}`;\n        let idToken;\n        try {\n            const instanceOptions = {\n                property: idTokenPath,\n            };\n            idToken = await gcpMetadata.instance(instanceOptions);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Could not fetch ID token: ${e.message}`;\n            }\n            throw e;\n        }\n        return idToken;\n    }\n    wrapError(e) {\n        const res = e.response;\n        if (res && res.status) {\n            e.code = res.status.toString();\n            if (res.status === 403) {\n                e.message =\n                    'A Forbidden error was returned while attempting to retrieve an access ' +\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n                        'Engine instance does not have the correct permission scopes specified: ' +\n                        e.message;\n            }\n            else if (res.status === 404) {\n                e.message =\n                    'A Not Found error was returned while attempting to retrieve an access' +\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\n                        'Engine instance does not have any permission scopes specified: ' +\n                        e.message;\n            }\n        }\n    }\n}\nexports.Compute = Compute;\n//# sourceMappingURL=computeclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9jb21wdXRlY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyw4REFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBYztBQUMxQyx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2NvbXB1dGVjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxMyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHV0ZSA9IHZvaWQgMDtcbmNvbnN0IGFycmlmeSA9IHJlcXVpcmUoXCJhcnJpZnlcIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNsYXNzIENvbXB1dGUgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBDb21wdXRlIEVuZ2luZSBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY29tcHV0ZS9kb2NzL2F1dGhlbnRpY2F0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICAvLyBTdGFydCB3aXRoIGFuIGV4cGlyZWQgcmVmcmVzaCB0b2tlbiwgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gICAgICAgIC8vIHJlZnJlc2hlZCBiZWZvcmUgdGhlIGZpcnN0IEFQSSBjYWxsIGlzIG1hZGUuXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7IGV4cGlyeV9kYXRlOiAxLCByZWZyZXNoX3Rva2VuOiAnY29tcHV0ZS1wbGFjZWhvbGRlcicgfTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEVtYWlsID0gb3B0aW9ucy5zZXJ2aWNlQWNjb3VudEVtYWlsIHx8ICdkZWZhdWx0JztcbiAgICAgICAgdGhpcy5zY29wZXMgPSBhcnJpZnkob3B0aW9ucy5zY29wZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIFVudXNlZCBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5QYXRoID0gYHNlcnZpY2UtYWNjb3VudHMvJHt0aGlzLnNlcnZpY2VBY2NvdW50RW1haWx9L3Rva2VuYDtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHRva2VuUGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlT3B0aW9ucy5wYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlczogdGhpcy5zY29wZXMuam9pbignLCcpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgZ2NwTWV0YWRhdGEuaW5zdGFuY2UoaW5zdGFuY2VPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBDb3VsZCBub3QgcmVmcmVzaCBhY2Nlc3MgdG9rZW46ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGRhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgdG9rZW5zLmV4cGlyeV9kYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBkYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICAgICAgZGVsZXRlIHRva2Vucy5leHBpcmVzX2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW5zLCByZXM6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbiBJRCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0QXVkaWVuY2UgdGhlIGF1ZGllbmNlIGZvciB0aGUgZmV0Y2hlZCBJRCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UpIHtcbiAgICAgICAgY29uc3QgaWRUb2tlblBhdGggPSBgc2VydmljZS1hY2NvdW50cy8ke3RoaXMuc2VydmljZUFjY291bnRFbWFpbH0vaWRlbnRpdHlgICtcbiAgICAgICAgICAgIGA/Zm9ybWF0PWZ1bGwmYXVkaWVuY2U9JHt0YXJnZXRBdWRpZW5jZX1gO1xuICAgICAgICBsZXQgaWRUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogaWRUb2tlblBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWRUb2tlbiA9IGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKGluc3RhbmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgQ291bGQgbm90IGZldGNoIElEIHRva2VuOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRUb2tlbjtcbiAgICB9XG4gICAgd3JhcEVycm9yKGUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgaWYgKHJlcyAmJiByZXMuc3RhdHVzKSB7XG4gICAgICAgICAgICBlLmNvZGUgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgJ0EgRm9yYmlkZGVuIGVycm9yIHdhcyByZXR1cm5lZCB3aGlsZSBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIGFuIGFjY2VzcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbiBmb3IgdGhlIENvbXB1dGUgRW5naW5lIGJ1aWx0LWluIHNlcnZpY2UgYWNjb3VudC4gVGhpcyBtYXkgYmUgYmVjYXVzZSB0aGUgQ29tcHV0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbmdpbmUgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBwZXJtaXNzaW9uIHNjb3BlcyBzcGVjaWZpZWQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgJ0EgTm90IEZvdW5kIGVycm9yIHdhcyByZXR1cm5lZCB3aGlsZSBhdHRlbXB0aW5nIHRvIHJldHJpZXZlIGFuIGFjY2VzcycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rva2VuIGZvciB0aGUgQ29tcHV0ZSBFbmdpbmUgYnVpbHQtaW4gc2VydmljZSBhY2NvdW50LiBUaGlzIG1heSBiZSBiZWNhdXNlIHRoZSBDb21wdXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0VuZ2luZSBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGFueSBwZXJtaXNzaW9uIHNjb3BlcyBzcGVjaWZpZWQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db21wdXRlID0gQ29tcHV0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXB1dGVjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/downscopedclient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @param quotaProjectId Optional quota project id for setting up in the\n     *   x-goog-user-project header.\n     */\n    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n        super();\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error('The provided access boundary has more than ' +\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary\n            .accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        this.cachedDownscopedAccessToken = null;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.quotaProjectId = quotaProjectId;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error('The access token expiry_date field is missing in the provided ' +\n                'credentials.');\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */\n        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in\n            ? new Date().getTime() + stsResponse.expires_in * 1000\n            : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceMappingURL=downscopedclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9kb3duc2NvcGVkY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsdUNBQXVDO0FBQ25HLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxZQUFZLG1CQUFPLENBQUMsbUdBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBeUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2Rvd25zY29wZWRjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG93bnNjb3BlZENsaWVudCA9IGV4cG9ydHMuRVhQSVJBVElPTl9USU1FX09GRlNFVCA9IGV4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3Qgc3RzID0gcmVxdWlyZShcIi4vc3RzY3JlZGVudGlhbHNcIik7XG4vKipcbiAqIFRoZSByZXF1aXJlZCB0b2tlbiBleGNoYW5nZSBncmFudF90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19HUkFOVF9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOnRva2VuLWV4Y2hhbmdlJztcbi8qKlxuICogVGhlIHJlcXVlc3RlZCB0b2tlbiBleGNoYW5nZSByZXF1ZXN0ZWRfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKipcbiAqIFRoZSByZXF1ZXN0ZWQgdG9rZW4gZXhjaGFuZ2Ugc3ViamVjdF90b2tlbl90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19TVUJKRUNUX1RPS0VOX1RZUEUgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6YWNjZXNzX3Rva2VuJztcbi8qKiBUaGUgU1RTIGFjY2VzcyB0b2tlbiBleGNoYW5nZSBlbmQgcG9pbnQuICovXG5jb25zdCBTVFNfQUNDRVNTX1RPS0VOX1VSTCA9ICdodHRwczovL3N0cy5nb29nbGVhcGlzLmNvbS92MS90b2tlbic7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMgYSBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeVxuICogY2FuIGNvbnRhaW4uXG4gKi9cbmV4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCA9IDEwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogRGVmaW5lcyBhIHNldCBvZiBHb29nbGUgY3JlZGVudGlhbHMgdGhhdCBhcmUgZG93bnNjb3BlZCBmcm9tIGFuIGV4aXN0aW5nIHNldFxuICogb2YgR29vZ2xlIE9BdXRoMiBjcmVkZW50aWFscy4gVGhpcyBpcyB1c2VmdWwgdG8gcmVzdHJpY3QgdGhlIElkZW50aXR5IGFuZFxuICogQWNjZXNzIE1hbmFnZW1lbnQgKElBTSkgcGVybWlzc2lvbnMgdGhhdCBhIHNob3J0LWxpdmVkIGNyZWRlbnRpYWwgY2FuIHVzZS5cbiAqIFRoZSBjb21tb24gcGF0dGVybiBvZiB1c2FnZSBpcyB0byBoYXZlIGEgdG9rZW4gYnJva2VyIHdpdGggZWxldmF0ZWQgYWNjZXNzXG4gKiBnZW5lcmF0ZSB0aGVzZSBkb3duc2NvcGVkIGNyZWRlbnRpYWxzIGZyb20gaGlnaGVyIGFjY2VzcyBzb3VyY2UgY3JlZGVudGlhbHNcbiAqIGFuZCBwYXNzIHRoZSBkb3duc2NvcGVkIHNob3J0LWxpdmVkIGFjY2VzcyB0b2tlbnMgdG8gYSB0b2tlbiBjb25zdW1lciB2aWFcbiAqIHNvbWUgc2VjdXJlIGF1dGhlbnRpY2F0ZWQgY2hhbm5lbCBmb3IgbGltaXRlZCBhY2Nlc3MgdG8gR29vZ2xlIENsb3VkIFN0b3JhZ2VcbiAqIHJlc291cmNlcy5cbiAqL1xuY2xhc3MgRG93bnNjb3BlZENsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBkb3duc2NvcGVkIGNsaWVudCBvYmplY3QgdXNpbmcgdGhlIHByb3ZpZGVkIHNvdXJjZVxuICAgICAqIEF1dGhDbGllbnQgYW5kIGNyZWRlbnRpYWwgYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLlxuICAgICAqIFRvIGRvd25zY29wZSBwZXJtaXNzaW9ucyBvZiBhIHNvdXJjZSBBdXRoQ2xpZW50LCBhIENyZWRlbnRpYWwgQWNjZXNzXG4gICAgICogQm91bmRhcnkgdGhhdCBzcGVjaWZpZXMgd2hpY2ggcmVzb3VyY2VzIHRoZSBuZXcgY3JlZGVudGlhbCBjYW4gYWNjZXNzLCBhc1xuICAgICAqIHdlbGwgYXMgYW4gdXBwZXIgYm91bmQgb24gdGhlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiBlYWNoXG4gICAgICogcmVzb3VyY2UsIGhhcyB0byBiZSBkZWZpbmVkLiBBIGRvd25zY29wZWQgY2xpZW50IGNhbiB0aGVuIGJlIGluc3RhbnRpYXRlZFxuICAgICAqIHVzaW5nIHRoZSBzb3VyY2UgQXV0aENsaWVudCBhbmQgdGhlIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSBhdXRoQ2xpZW50IFRoZSBzb3VyY2UgQXV0aENsaWVudCB0byBiZSBkb3duc2NvcGVkIGJhc2VkIG9uIHRoZVxuICAgICAqICAgcHJvdmlkZWQgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgcnVsZXMuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSBUaGUgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgd2hpY2hcbiAgICAgKiAgIGNvbnRhaW5zIGEgbGlzdCBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuIEVhY2ggcnVsZSBjb250YWlucyBpbmZvcm1hdGlvblxuICAgICAqICAgb24gdGhlIHJlc291cmNlIHRoYXQgdGhlIHJ1bGUgYXBwbGllcyB0bywgdGhlIHVwcGVyIGJvdW5kIG9mIHRoZVxuICAgICAqICAgcGVybWlzc2lvbnMgdGhhdCBhcmUgYXZhaWxhYmxlIG9uIHRoYXQgcmVzb3VyY2UgYW5kIGFuIG9wdGlvbmFsXG4gICAgICogICBjb25kaXRpb24gdG8gZnVydGhlciByZXN0cmljdCBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uXG4gICAgICogICBvcHRpb25zLiBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kXG4gICAgICogICB3aGV0aGVyIHRvIHJldHJ5IG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqIEBwYXJhbSBxdW90YVByb2plY3RJZCBPcHRpb25hbCBxdW90YSBwcm9qZWN0IGlkIGZvciBzZXR0aW5nIHVwIGluIHRoZVxuICAgICAqICAgeC1nb29nLXVzZXItcHJvamVjdCBoZWFkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXV0aENsaWVudCwgY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LCBhZGRpdGlvbmFsT3B0aW9ucywgcXVvdGFQcm9qZWN0SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdXRoQ2xpZW50ID0gYXV0aENsaWVudDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsQWNjZXNzQm91bmRhcnkgPSBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnk7XG4gICAgICAgIC8vIENoZWNrIDEtMTAgQWNjZXNzIEJvdW5kYXJ5IFJ1bGVzIGFyZSBkZWZpbmVkIHdpdGhpbiBDcmVkZW50aWFsIEFjY2Vzc1xuICAgICAgICAvLyBCb3VuZGFyeS5cbiAgICAgICAgaWYgKGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeVJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgYWNjZXNzIGJvdW5kYXJ5IHJ1bGUgbmVlZHMgdG8gYmUgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnlSdWxlcy5sZW5ndGggPlxuICAgICAgICAgICAgZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBhY2Nlc3MgYm91bmRhcnkgaGFzIG1vcmUgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBgJHtleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlR9IGFjY2VzcyBib3VuZGFyeSBydWxlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBlYWNoIEFjY2VzcyBCb3VuZGFyeVxuICAgICAgICAvLyBSdWxlLlxuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5XG4gICAgICAgICAgICAuYWNjZXNzQm91bmRhcnlSdWxlcykge1xuICAgICAgICAgICAgaWYgKHJ1bGUuYXZhaWxhYmxlUGVybWlzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHNDcmVkZW50aWFsID0gbmV3IHN0cy5TdHNDcmVkZW50aWFscyhTVFNfQUNDRVNTX1RPS0VOX1VSTCk7XG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgLy8gQXMgdGhyZXNob2xkIGNvdWxkIGJlIHplcm8sXG4gICAgICAgIC8vIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyB8fCBFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICAgIC8vIHplcm8gdmFsdWUuXG4gICAgICAgIGlmICh0eXBlb2YgKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgICAgICAgICAgLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9ICEhKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0gcXVvdGFQcm9qZWN0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbnMgZGlyZWN0bHkuXG4gICAgICogVGhlIGV4cGlyeV9kYXRlIGZpZWxkIGlzIHJlcXVpcmVkIHRvIGZhY2lsaXRhdGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdG9rZW5cbiAgICAgKiBleHBpcmF0aW9uIHdoaWNoIHdvdWxkIG1ha2UgaXQgZWFzaWVyIGZvciB0aGUgdG9rZW4gY29uc3VtZXIgdG8gaGFuZGxlLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscy5leHBpcnlfZGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWNjZXNzIHRva2VuIGV4cGlyeV9kYXRlIGZpZWxkIGlzIG1pc3NpbmcgaW4gdGhlIHByb3ZpZGVkICcgK1xuICAgICAgICAgICAgICAgICdjcmVkZW50aWFscy4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICAvLyBUaGUgRG93bnNjb3BlZCBhY2Nlc3MgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAgICAvLyBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gfHxcbiAgICAgICAgICAgIHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbiBpbiBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGF1dGhlbnRpY2F0aW9uIGludGVyZmFjZS4gSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IGhhcyB0aGUgZm9ybTpcbiAgICAgKiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgPGFjY2Vzc190b2tlbl92YWx1ZT4nIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZXRyeSBXaGV0aGVyIHRoZSBjdXJyZW50IGF0dGVtcHQgaXMgYSByZXRyeSBhZnRlciBhIGZhaWxlZCBhdHRlbXB0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmV0cnkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yY2VSZWZyZXNoT25GYWlsdXJlIGlzIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0gcmVzLmNvbmZpZy5kYXRhIGluc3RhbmNlb2Ygc3RyZWFtLlJlYWRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aEVyciA9IHN0YXR1c0NvZGUgPT09IDQwMSB8fCBzdGF0dXNDb2RlID09PSA0MDM7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b2tlbiByZWZyZXNoLCBldmVuIGlmIHVuZXhwaXJlZCB0b2tlbnMgYXJlIGN1cnJlbnRseSBjYWNoZWQuXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbnMgYXJlIHJldHJpZXZlZCBmcm9tIGF1dGhjbGllbnQgb2JqZWN0L3NvdXJjZSBjcmVkZW50aWFsLlxuICAgICAqIFRoZW4gR0NQIGFjY2VzcyB0b2tlbnMgYXJlIGV4Y2hhbmdlZCBmb3IgZG93bnNjb3BlZCBhY2Nlc3MgdG9rZW5zIHZpYSB0aGVcbiAgICAgKiB0b2tlbiBleGNoYW5nZSBlbmRwb2ludC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZyZXNoIGRvd25zY29wZWQgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFJldHJpZXZlIEdDUCBhY2Nlc3MgdG9rZW4gZnJvbSBzb3VyY2UgY3JlZGVudGlhbC5cbiAgICAgICAgY29uc3Qgc3ViamVjdFRva2VuID0gKGF3YWl0IHRoaXMuYXV0aENsaWVudC5nZXRBY2Nlc3NUb2tlbigpKS50b2tlbjtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBTVFMgY3JlZGVudGlhbHMgb3B0aW9ucy5cbiAgICAgICAgY29uc3Qgc3RzQ3JlZGVudGlhbHNPcHRpb25zID0ge1xuICAgICAgICAgICAgZ3JhbnRUeXBlOiBTVFNfR1JBTlRfVFlQRSxcbiAgICAgICAgICAgIHJlcXVlc3RlZFRva2VuVHlwZTogU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSxcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbjogc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdFRva2VuVHlwZTogU1RTX1NVQkpFQ1RfVE9LRU5fVFlQRSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhjaGFuZ2UgdGhlIHNvdXJjZSBBdXRoQ2xpZW50IGFjY2VzcyB0b2tlbiBmb3IgYSBEb3duc2NvcGVkIGFjY2Vzc1xuICAgICAgICAvLyB0b2tlbi5cbiAgICAgICAgY29uc3Qgc3RzUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0c0NyZWRlbnRpYWwuZXhjaGFuZ2VUb2tlbihzdHNDcmVkZW50aWFsc09wdGlvbnMsIHVuZGVmaW5lZCwgdGhpcy5jcmVkZW50aWFsQWNjZXNzQm91bmRhcnkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFNUUyBlbmRwb2ludCB3aWxsIG9ubHkgcmV0dXJuIHRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSBkb3duc2NvcGVkXG4gICAgICAgICAqIGFjY2VzcyB0b2tlbiBpZiB0aGUgb3JpZ2luYWwgYWNjZXNzIHRva2VuIHJlcHJlc2VudHMgYSBzZXJ2aWNlIGFjY291bnQuXG4gICAgICAgICAqIFRoZSBkb3duc2NvcGVkIHRva2VuJ3MgZXhwaXJhdGlvbiB0aW1lIHdpbGwgYWx3YXlzIG1hdGNoIHRoZSBzb3VyY2VcbiAgICAgICAgICogY3JlZGVudGlhbCBleHBpcmF0aW9uLiBXaGVuIG5vIGV4cGlyZXNfaW4gaXMgcmV0dXJuZWQsIHdlIGNhbiBjb3B5IHRoZVxuICAgICAgICAgKiBzb3VyY2UgY3JlZGVudGlhbCdzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNvdXJjZUNyZWRFeHBpcmVEYXRlID0gKChfYSA9IHRoaXMuYXV0aENsaWVudC5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cGlyeV9kYXRlKSB8fCBudWxsO1xuICAgICAgICBjb25zdCBleHBpcnlEYXRlID0gc3RzUmVzcG9uc2UuZXhwaXJlc19pblxuICAgICAgICAgICAgPyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW4gKiAxMDAwXG4gICAgICAgICAgICA6IHNvdXJjZUNyZWRFeHBpcmVEYXRlO1xuICAgICAgICAvLyBTYXZlIHJlc3BvbnNlIGluIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogZXhwaXJ5RGF0ZSxcbiAgICAgICAgICAgIHJlczogc3RzUmVzcG9uc2UucmVzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBTYXZlIGNyZWRlbnRpYWxzLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jcmVkZW50aWFscywgdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICBkZWxldGUgdGhpcy5jcmVkZW50aWFscy5yZXM7XG4gICAgICAgIC8vIFRyaWdnZXIgdG9rZW5zIGV2ZW50IHRvIG5vdGlmeSBleHRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgdG9rZW5fdHlwZTogJ0JlYXJlcicsXG4gICAgICAgICAgICBpZF90b2tlbjogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBJZiB0aGVyZSBpcyBubyBleHBpcnkgdGltZSwgYXNzdW1lcyB0aGUgdG9rZW4gaXMgbm90IGV4cGlyZWQgb3IgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIGRvd25zY29wZWRBY2Nlc3NUb2tlbiBUaGUgY3JlZGVudGlhbHMgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKGRvd25zY29wZWRBY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGRvd25zY29wZWRBY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZVxuICAgICAgICAgICAgPyBub3cgPj1cbiAgICAgICAgICAgICAgICBkb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUgLSB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBEb3duc2NvcGVkQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG93bnNjb3BlZGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/envDetect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnv = exports.clear = exports.GCPEnv = void 0;\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nvar GCPEnv;\n(function (GCPEnv) {\n    GCPEnv[\"APP_ENGINE\"] = \"APP_ENGINE\";\n    GCPEnv[\"KUBERNETES_ENGINE\"] = \"KUBERNETES_ENGINE\";\n    GCPEnv[\"CLOUD_FUNCTIONS\"] = \"CLOUD_FUNCTIONS\";\n    GCPEnv[\"COMPUTE_ENGINE\"] = \"COMPUTE_ENGINE\";\n    GCPEnv[\"CLOUD_RUN\"] = \"CLOUD_RUN\";\n    GCPEnv[\"NONE\"] = \"NONE\";\n})(GCPEnv = exports.GCPEnv || (exports.GCPEnv = {}));\nlet envPromise;\nfunction clear() {\n    envPromise = undefined;\n}\nexports.clear = clear;\nasync function getEnv() {\n    if (envPromise) {\n        return envPromise;\n    }\n    envPromise = getEnvMemoized();\n    return envPromise;\n}\nexports.getEnv = getEnv;\nasync function getEnvMemoized() {\n    let env = GCPEnv.NONE;\n    if (isAppEngine()) {\n        env = GCPEnv.APP_ENGINE;\n    }\n    else if (isCloudFunction()) {\n        env = GCPEnv.CLOUD_FUNCTIONS;\n    }\n    else if (await isComputeEngine()) {\n        if (await isKubernetesEngine()) {\n            env = GCPEnv.KUBERNETES_ENGINE;\n        }\n        else if (isCloudRun()) {\n            env = GCPEnv.CLOUD_RUN;\n        }\n        else {\n            env = GCPEnv.COMPUTE_ENGINE;\n        }\n    }\n    else {\n        env = GCPEnv.NONE;\n    }\n    return env;\n}\nfunction isAppEngine() {\n    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n}\nfunction isCloudFunction() {\n    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);\n}\n/**\n * This check only verifies that the environment is running knative.\n * This must be run *after* checking for Kubernetes, otherwise it will\n * return a false positive.\n */\nfunction isCloudRun() {\n    return !!process.env.K_CONFIGURATION;\n}\nasync function isKubernetesEngine() {\n    try {\n        await gcpMetadata.instance('attributes/cluster-name');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function isComputeEngine() {\n    return gcpMetadata.isAvailable();\n}\n//# sourceMappingURL=envDetect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsYUFBYSxHQUFHLGNBQWM7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsMEVBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZW52RGV0ZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVudiA9IGV4cG9ydHMuY2xlYXIgPSBleHBvcnRzLkdDUEVudiA9IHZvaWQgMDtcbmNvbnN0IGdjcE1ldGFkYXRhID0gcmVxdWlyZShcImdjcC1tZXRhZGF0YVwiKTtcbnZhciBHQ1BFbnY7XG4oZnVuY3Rpb24gKEdDUEVudikge1xuICAgIEdDUEVudltcIkFQUF9FTkdJTkVcIl0gPSBcIkFQUF9FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJLVUJFUk5FVEVTX0VOR0lORVwiXSA9IFwiS1VCRVJORVRFU19FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJDTE9VRF9GVU5DVElPTlNcIl0gPSBcIkNMT1VEX0ZVTkNUSU9OU1wiO1xuICAgIEdDUEVudltcIkNPTVBVVEVfRU5HSU5FXCJdID0gXCJDT01QVVRFX0VOR0lORVwiO1xuICAgIEdDUEVudltcIkNMT1VEX1JVTlwiXSA9IFwiQ0xPVURfUlVOXCI7XG4gICAgR0NQRW52W1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xufSkoR0NQRW52ID0gZXhwb3J0cy5HQ1BFbnYgfHwgKGV4cG9ydHMuR0NQRW52ID0ge30pKTtcbmxldCBlbnZQcm9taXNlO1xuZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW52UHJvbWlzZSA9IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmFzeW5jIGZ1bmN0aW9uIGdldEVudigpIHtcbiAgICBpZiAoZW52UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gZW52UHJvbWlzZTtcbiAgICB9XG4gICAgZW52UHJvbWlzZSA9IGdldEVudk1lbW9pemVkKCk7XG4gICAgcmV0dXJuIGVudlByb21pc2U7XG59XG5leHBvcnRzLmdldEVudiA9IGdldEVudjtcbmFzeW5jIGZ1bmN0aW9uIGdldEVudk1lbW9pemVkKCkge1xuICAgIGxldCBlbnYgPSBHQ1BFbnYuTk9ORTtcbiAgICBpZiAoaXNBcHBFbmdpbmUoKSkge1xuICAgICAgICBlbnYgPSBHQ1BFbnYuQVBQX0VOR0lORTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDbG91ZEZ1bmN0aW9uKCkpIHtcbiAgICAgICAgZW52ID0gR0NQRW52LkNMT1VEX0ZVTkNUSU9OUztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXdhaXQgaXNDb21wdXRlRW5naW5lKCkpIHtcbiAgICAgICAgaWYgKGF3YWl0IGlzS3ViZXJuZXRlc0VuZ2luZSgpKSB7XG4gICAgICAgICAgICBlbnYgPSBHQ1BFbnYuS1VCRVJORVRFU19FTkdJTkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDbG91ZFJ1bigpKSB7XG4gICAgICAgICAgICBlbnYgPSBHQ1BFbnYuQ0xPVURfUlVOO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW52ID0gR0NQRW52LkNPTVBVVEVfRU5HSU5FO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBHQ1BFbnYuTk9ORTtcbiAgICB9XG4gICAgcmV0dXJuIGVudjtcbn1cbmZ1bmN0aW9uIGlzQXBwRW5naW5lKCkge1xuICAgIHJldHVybiAhIShwcm9jZXNzLmVudi5HQUVfU0VSVklDRSB8fCBwcm9jZXNzLmVudi5HQUVfTU9EVUxFX05BTUUpO1xufVxuZnVuY3Rpb24gaXNDbG91ZEZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIShwcm9jZXNzLmVudi5GVU5DVElPTl9OQU1FIHx8IHByb2Nlc3MuZW52LkZVTkNUSU9OX1RBUkdFVCk7XG59XG4vKipcbiAqIFRoaXMgY2hlY2sgb25seSB2ZXJpZmllcyB0aGF0IHRoZSBlbnZpcm9ubWVudCBpcyBydW5uaW5nIGtuYXRpdmUuXG4gKiBUaGlzIG11c3QgYmUgcnVuICphZnRlciogY2hlY2tpbmcgZm9yIEt1YmVybmV0ZXMsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiByZXR1cm4gYSBmYWxzZSBwb3NpdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNDbG91ZFJ1bigpIHtcbiAgICByZXR1cm4gISFwcm9jZXNzLmVudi5LX0NPTkZJR1VSQVRJT047XG59XG5hc3luYyBmdW5jdGlvbiBpc0t1YmVybmV0ZXNFbmdpbmUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZ2NwTWV0YWRhdGEuaW5zdGFuY2UoJ2F0dHJpYnV0ZXMvY2x1c3Rlci1uYW1lJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNDb21wdXRlRW5naW5lKCkge1xuICAgIHJldHVybiBnY3BNZXRhZGF0YS5pc0F2YWlsYWJsZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52RGV0ZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js":
/*!********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/executable-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;\nconst SAML_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:saml2';\nconst OIDC_SUBJECT_TOKEN_TYPE1 = 'urn:ietf:params:oauth:token-type:id_token';\nconst OIDC_SUBJECT_TOKEN_TYPE2 = 'urn:ietf:params:oauth:token-type:jwt';\n/**\n * Defines the response of a 3rd party executable run by the pluggable auth client.\n */\nclass ExecutableResponse {\n    /**\n     * Instantiates an ExecutableResponse instance using the provided JSON object\n     * from the output of the executable.\n     * @param responseJson Response from a 3rd party executable, loaded from a\n     * run of the executable or a cached output file.\n     */\n    constructor(responseJson) {\n        // Check that the required fields exist in the json response.\n        if (!responseJson.version) {\n            throw new InvalidVersionFieldError(\"Executable response must contain a 'version' field.\");\n        }\n        if (responseJson.success === undefined) {\n            throw new InvalidSuccessFieldError(\"Executable response must contain a 'success' field.\");\n        }\n        this.version = responseJson.version;\n        this.success = responseJson.success;\n        // Validate required fields for a successful response.\n        if (this.success) {\n            this.expirationTime = responseJson.expiration_time;\n            this.tokenType = responseJson.token_type;\n            // Validate token type field.\n            if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE &&\n                this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 &&\n                this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {\n                throw new InvalidTokenTypeFieldError(\"Executable response must contain a 'token_type' field when successful \" +\n                    `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);\n            }\n            // Validate subject token.\n            if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {\n                if (!responseJson.saml_response) {\n                    throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);\n                }\n                this.subjectToken = responseJson.saml_response;\n            }\n            else {\n                if (!responseJson.id_token) {\n                    throw new InvalidSubjectTokenError(\"Executable response must contain a 'id_token' field when \" +\n                        `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);\n                }\n                this.subjectToken = responseJson.id_token;\n            }\n        }\n        else {\n            // Both code and message must be provided for unsuccessful responses.\n            if (!responseJson.code) {\n                throw new InvalidCodeFieldError(\"Executable response must contain a 'code' field when unsuccessful.\");\n            }\n            if (!responseJson.message) {\n                throw new InvalidMessageFieldError(\"Executable response must contain a 'message' field when unsuccessful.\");\n            }\n            this.errorCode = responseJson.code;\n            this.errorMessage = responseJson.message;\n        }\n    }\n    /**\n     * @return A boolean representing if the response has a valid token. Returns\n     * true when the response was successful and the token is not expired.\n     */\n    isValid() {\n        return !this.isExpired() && this.success;\n    }\n    /**\n     * @return A boolean representing if the response is expired. Returns true if the\n     * provided timeout has passed.\n     */\n    isExpired() {\n        return (this.expirationTime !== undefined &&\n            this.expirationTime < Math.round(Date.now() / 1000));\n    }\n}\nexports.ExecutableResponse = ExecutableResponse;\n/**\n * An error thrown by the ExecutableResponse class.\n */\nclass ExecutableResponseError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableResponseError = ExecutableResponseError;\n/**\n * An error thrown when the 'version' field in an executable response is missing or invalid.\n */\nclass InvalidVersionFieldError extends ExecutableResponseError {\n}\nexports.InvalidVersionFieldError = InvalidVersionFieldError;\n/**\n * An error thrown when the 'success' field in an executable response is missing or invalid.\n */\nclass InvalidSuccessFieldError extends ExecutableResponseError {\n}\nexports.InvalidSuccessFieldError = InvalidSuccessFieldError;\n/**\n * An error thrown when the 'expiration_time' field in an executable response is missing or invalid.\n */\nclass InvalidExpirationTimeFieldError extends ExecutableResponseError {\n}\nexports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;\n/**\n * An error thrown when the 'token_type' field in an executable response is missing or invalid.\n */\nclass InvalidTokenTypeFieldError extends ExecutableResponseError {\n}\nexports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;\n/**\n * An error thrown when the 'code' field in an executable response is missing or invalid.\n */\nclass InvalidCodeFieldError extends ExecutableResponseError {\n}\nexports.InvalidCodeFieldError = InvalidCodeFieldError;\n/**\n * An error thrown when the 'message' field in an executable response is missing or invalid.\n */\nclass InvalidMessageFieldError extends ExecutableResponseError {\n}\nexports.InvalidMessageFieldError = InvalidMessageFieldError;\n/**\n * An error thrown when the subject token in an executable response is missing or invalid.\n */\nclass InvalidSubjectTokenError extends ExecutableResponseError {\n}\nexports.InvalidSubjectTokenError = InvalidSubjectTokenError;\n//# sourceMappingURL=executable-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leGVjdXRhYmxlLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsa0NBQWtDLEdBQUcsdUNBQXVDLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCO0FBQ3ZUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCLElBQUkseUJBQXlCLE9BQU8sd0JBQXdCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLHdCQUF3QjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEJBQTBCLEtBQUsseUJBQXlCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXhlY3V0YWJsZS1yZXNwb25zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkU3ViamVjdFRva2VuRXJyb3IgPSBleHBvcnRzLkludmFsaWRNZXNzYWdlRmllbGRFcnJvciA9IGV4cG9ydHMuSW52YWxpZENvZGVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3IgPSBleHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yID0gZXhwb3J0cy5FeGVjdXRhYmxlUmVzcG9uc2UgPSB2b2lkIDA7XG5jb25zdCBTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTpzYW1sMic7XG5jb25zdCBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTEgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6aWRfdG9rZW4nO1xuY29uc3QgT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmp3dCc7XG4vKipcbiAqIERlZmluZXMgdGhlIHJlc3BvbnNlIG9mIGEgM3JkIHBhcnR5IGV4ZWN1dGFibGUgcnVuIGJ5IHRoZSBwbHVnZ2FibGUgYXV0aCBjbGllbnQuXG4gKi9cbmNsYXNzIEV4ZWN1dGFibGVSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEV4ZWN1dGFibGVSZXNwb25zZSBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgSlNPTiBvYmplY3RcbiAgICAgKiBmcm9tIHRoZSBvdXRwdXQgb2YgdGhlIGV4ZWN1dGFibGUuXG4gICAgICogQHBhcmFtIHJlc3BvbnNlSnNvbiBSZXNwb25zZSBmcm9tIGEgM3JkIHBhcnR5IGV4ZWN1dGFibGUsIGxvYWRlZCBmcm9tIGFcbiAgICAgKiBydW4gb2YgdGhlIGV4ZWN1dGFibGUgb3IgYSBjYWNoZWQgb3V0cHV0IGZpbGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVzcG9uc2VKc29uKSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHJlcXVpcmVkIGZpZWxkcyBleGlzdCBpbiB0aGUganNvbiByZXNwb25zZS5cbiAgICAgICAgaWYgKCFyZXNwb25zZUpzb24udmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRWZXJzaW9uRmllbGRFcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ3ZlcnNpb24nIGZpZWxkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VKc29uLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdWNjZXNzRmllbGRFcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ3N1Y2Nlc3MnIGZpZWxkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSByZXNwb25zZUpzb24udmVyc2lvbjtcbiAgICAgICAgdGhpcy5zdWNjZXNzID0gcmVzcG9uc2VKc29uLnN1Y2Nlc3M7XG4gICAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcyBmb3IgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAgICBpZiAodGhpcy5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gcmVzcG9uc2VKc29uLmV4cGlyYXRpb25fdGltZTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlID0gcmVzcG9uc2VKc29uLnRva2VuX3R5cGU7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0b2tlbiB0eXBlIGZpZWxkLlxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5UeXBlICE9PSBTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlICE9PSBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTEgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuVHlwZSAhPT0gT0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAndG9rZW5fdHlwZScgZmllbGQgd2hlbiBzdWNjZXNzZnVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgYGFuZCBpdCBtdXN0IGJlIG9uZSBvZiAke09JRENfU1VCSkVDVF9UT0tFTl9UWVBFMX0sICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyfSwgb3IgJHtTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBzdWJqZWN0IHRva2VuLlxuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5UeXBlID09PSBTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLnNhbWxfcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdWJqZWN0VG9rZW5FcnJvcihgRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnc2FtbF9yZXNwb25zZScgZmllbGQgd2hlbiB0b2tlbl90eXBlPSR7U0FNTF9TVUJKRUNUX1RPS0VOX1RZUEV9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RUb2tlbiA9IHJlc3BvbnNlSnNvbi5zYW1sX3Jlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24uaWRfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdWJqZWN0VG9rZW5FcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ2lkX3Rva2VuJyBmaWVsZCB3aGVuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0b2tlbl90eXBlPSR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxfSBvciAke09JRENfU1VCSkVDVF9UT0tFTl9UWVBFMn0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdFRva2VuID0gcmVzcG9uc2VKc29uLmlkX3Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQm90aCBjb2RlIGFuZCBtZXNzYWdlIG11c3QgYmUgcHJvdmlkZWQgZm9yIHVuc3VjY2Vzc2Z1bCByZXNwb25zZXMuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5jb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb2RlRmllbGRFcnJvcihcIkV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIGEgJ2NvZGUnIGZpZWxkIHdoZW4gdW5zdWNjZXNzZnVsLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnbWVzc2FnZScgZmllbGQgd2hlbiB1bnN1Y2Nlc3NmdWwuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvckNvZGUgPSByZXNwb25zZUpzb24uY29kZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gcmVzcG9uc2VKc29uLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIGlmIHRoZSByZXNwb25zZSBoYXMgYSB2YWxpZCB0b2tlbi4gUmV0dXJuc1xuICAgICAqIHRydWUgd2hlbiB0aGUgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwgYW5kIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNFeHBpcmVkKCkgJiYgdGhpcy5zdWNjZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgaWYgdGhlIHJlc3BvbnNlIGlzIGV4cGlyZWQuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICAgKiBwcm92aWRlZCB0aW1lb3V0IGhhcyBwYXNzZWQuXG4gICAgICovXG4gICAgaXNFeHBpcmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXhwaXJhdGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA8IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZSA9IEV4ZWN1dGFibGVSZXNwb25zZTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIGJ5IHRoZSBFeGVjdXRhYmxlUmVzcG9uc2UgY2xhc3MuXG4gKi9cbmNsYXNzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvciA9IEV4ZWN1dGFibGVSZXNwb25zZUVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ3ZlcnNpb24nIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkVmVyc2lvbkZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRWZXJzaW9uRmllbGRFcnJvciA9IEludmFsaWRWZXJzaW9uRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdzdWNjZXNzJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgPSBJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnZXhwaXJhdGlvbl90aW1lJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvciA9IEludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAndG9rZW5fdHlwZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkVG9rZW5UeXBlRmllbGRFcnJvciA9IEludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ2NvZGUnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkQ29kZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRDb2RlRmllbGRFcnJvciA9IEludmFsaWRDb2RlRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdtZXNzYWdlJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IgPSBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSBzdWJqZWN0IHRva2VuIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkU3ViamVjdFRva2VuRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTdWJqZWN0VG9rZW5FcnJvciA9IEludmFsaWRTdWJqZWN0VG9rZW5FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4ZWN1dGFibGUtcmVzcG9uc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */\nexports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = 'external_account_authorized_user';\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */\nclass ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */\n    constructor(url, transporter, clientAuthentication) {\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */\n    async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n        });\n        const headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            ...additionalHeaders,\n        };\n        const opts = {\n            url: this.url,\n            method: 'POST',\n            headers,\n            data: values.toString(),\n            responseType: 'json',\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        }\n        catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \n                // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */\nclass ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super();\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: 'basic',\n            clientId: options.client_id,\n            clientSecret: options.client_secret,\n        };\n        this.externalAccountAuthorizedUserHandler =\n            new ExternalAccountAuthorizedUserHandler(options.token_url, this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */\n    async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res,\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date\n            ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\n//# sourceMappingURL=externalAccountAuthorizedUserClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJDQUEyQyxHQUFHLDZDQUE2QztBQUMzRixxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsOERBQVE7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgPSBleHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUgPSB2b2lkIDA7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY29uc3Qgb2F1dGgyY29tbW9uXzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjb21tb25cIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG4vKipcbiAqIFRoZSBjcmVkZW50aWFscyBKU09OIGZpbGUgdHlwZSBmb3IgZXh0ZXJuYWwgYWNjb3VudCBhdXRob3JpemVkIHVzZXIgY2xpZW50cy5cbiAqL1xuZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFID0gJ2V4dGVybmFsX2FjY291bnRfYXV0aG9yaXplZF91c2VyJztcbi8qKlxuICogSGFuZGxlciBmb3IgdG9rZW4gcmVmcmVzaCByZXF1ZXN0cyBzZW50IHRvIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgZm9yIGV4dGVybmFsXG4gKiBhdXRob3JpemVkIHVzZXIgY3JlZGVudGlhbHMuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgb2YgdGhlIHRva2VuIHJlZnJlc2ggZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydGVyIFRoZSB0cmFuc3BvcnRlciB0byB1c2UgZm9yIHRoZSByZWZyZXNoIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgdG8gdXNlXG4gICAgICogICBmb3IgdGhlIHJlZnJlc2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHRyYW5zcG9ydGVyLCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBzdXBlcihjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gdHJhbnNwb3J0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgbmV3IGFjY2VzcyB0b2tlbiBmcm9tIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogICByZWZyZXNoIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVGhlIHJlZnJlc2ggdG9rZW4gdG8gdXNlIHRvIGdlbmVyYXRlIGEgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEhlYWRlcnMgT3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHBhc3MgYWxvbmcgdGhlXG4gICAgICogICByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gcmVmcmVzaCByZXNwb25zZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcmVxdWVzdGVkIGFjY2VzcyB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsSGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBcHBseSBPQXV0aCBjbGllbnQgYXV0aGVudGljYXRpb24uXG4gICAgICAgIHRoaXMuYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCB0b2tlblJlZnJlc2hSZXNwb25zZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB0b2tlblJlZnJlc2hSZXNwb25zZS5yZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlblJlZnJlc2hSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBlcnJvciB0byBPQXV0aEVycm9yLlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb2F1dGgyY29tbW9uXzEuZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlKShlcnJvci5yZXNwb25zZS5kYXRhLCBcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBvdGhlciBmaWVsZHMgZnJvbSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICAgICAgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb3VsZCBmYWlsIGJlZm9yZSB0aGUgc2VydmVyIHJlc3BvbmRzLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dGVybmFsIEFjY291bnQgQXV0aG9yaXplZCBVc2VyIENsaWVudC4gVGhpcyBpcyB1c2VkIGZvciBPQXV0aDIgY3JlZGVudGlhbHNcbiAqIHNvdXJjZWQgdXNpbmcgZXh0ZXJuYWwgaWRlbnRpdGllcyB0aHJvdWdoIFdvcmtmb3JjZSBJZGVudGl0eSBGZWRlcmF0aW9uLlxuICogT2J0YWluaW5nIHRoZSBpbml0aWFsIGFjY2VzcyBhbmQgcmVmcmVzaCB0b2tlbiBjYW4gYmUgZG9uZSB0aHJvdWdoIHRoZVxuICogR29vZ2xlIENsb3VkIENMSS5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IGluc3RhbmNlcyB1c2luZyB0aGVcbiAgICAgKiBwcm92aWRlZCBKU09OIG9iamVjdCBsb2FkZWQgZnJvbSBhIGNyZWRlbnRpYWxzIGZpbGVzLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93cyBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgdmFsaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgYXV0aG9yaXplZCB1c2VyIG9wdGlvbiBvYmplY3QgdHlwaWNhbGx5XG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdXRuIGF1dGhvcml6ZWQgdXNlciBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uXG4gICAgICogICBvcHRpb25zLiBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kXG4gICAgICogICB3aGV0aGVyIHRvIHJldHJ5IG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gb3B0aW9ucy5yZWZyZXNoX3Rva2VuO1xuICAgICAgICBjb25zdCBjbGllbnRBdXRoID0ge1xuICAgICAgICAgICAgY29uZmlkZW50aWFsQ2xpZW50VHlwZTogJ2Jhc2ljJyxcbiAgICAgICAgICAgIGNsaWVudElkOiBvcHRpb25zLmNsaWVudF9pZCxcbiAgICAgICAgICAgIGNsaWVudFNlY3JldDogb3B0aW9ucy5jbGllbnRfc2VjcmV0LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciA9XG4gICAgICAgICAgICBuZXcgRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyKG9wdGlvbnMudG9rZW5fdXJsLCB0aGlzLnRyYW5zcG9ydGVyLCBjbGllbnRBdXRoKTtcbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBvcHRpb25zLnF1b3RhX3Byb2plY3RfaWQ7XG4gICAgICAgIC8vIEFzIHRocmVzaG9sZCBjb3VsZCBiZSB6ZXJvLFxuICAgICAgICAvLyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgfHwgRVhQSVJBVElPTl9USU1FX09GRlNFVCB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyB6ZXJvIHZhbHVlLlxuICAgICAgICBpZiAodHlwZW9mIChhZGRpdGlvbmFsT3B0aW9ucyA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRkaXRpb25hbE9wdGlvbnMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhQSVJBVElPTl9USU1FX09GRlNFVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gYWRkaXRpb25hbE9wdGlvbnNcbiAgICAgICAgICAgICAgICAuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlID0gISEoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiBjYWNoZWQgYWNjZXNzIHRva2VuIGlzIHVuYXZhaWxhYmxlIG9yIGV4cGlyZWQsIGZvcmNlIHJlZnJlc2guXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiB8fCB0aGlzLmlzRXhwaXJlZCh0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBHQ1AgYWNjZXNzIHRva2VuIGluIEdldEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW5SZXNwb25zZS50b2tlbn1gLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIHByb3ZpZGVkIEhUVFAgcmVxdWVzdCwgcHJvY2Vzc2VzIGl0IGFuZCByZXNvbHZlcyB3aXRoIHRoZVxuICAgICAqIHJldHVybmVkIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBIVFRQIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcmV0cnkgV2hldGhlciB0aGUgY3VycmVudCBhdHRlbXB0IGlzIGEgcmV0cnkgYWZ0ZXIgYSBmYWlsZWQgYXR0ZW1wdC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SGVhZGVycyAmJiByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgZm9yIG1ldGFkYXRhIGlmIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSBpcyB0cnVlXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9IHJlcy5jb25maWcuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F1dGhFcnIgPSBzdGF0dXNDb2RlID09PSA0MDEgfHwgc3RhdHVzQ29kZSA9PT0gNDAzO1xuICAgICAgICAgICAgICAgIGlmICghcmV0cnkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVmcmVzaGVkIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIC8vIFJlZnJlc2ggdGhlIGFjY2VzcyB0b2tlbiB1c2luZyB0aGUgcmVmcmVzaCB0b2tlbi5cbiAgICAgICAgY29uc3QgcmVmcmVzaFJlc3BvbnNlID0gYXdhaXQgdGhpcy5leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIucmVmcmVzaFRva2VuKHRoaXMucmVmcmVzaFRva2VuKTtcbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogcmVmcmVzaFJlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHJlZnJlc2hSZXNwb25zZS5leHBpcmVzX2luICogMTAwMCxcbiAgICAgICAgICAgIHJlczogcmVmcmVzaFJlc3BvbnNlLnJlcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZnJlc2hSZXNwb25zZS5yZWZyZXNoX3Rva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFJlc3BvbnNlLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlXG4gICAgICAgICAgICA/IG5vdyA+PSBjcmVkZW50aWFscy5leHBpcnlfZGF0ZSAtIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgPSBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAccountClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst identitypoolclient_1 = __webpack_require__(/*! ./identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nconst awsclient_1 = __webpack_require__(/*! ./awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\n/**\n * Dummy class with no constructor. Developers are expected to use fromJSON.\n */\nclass ExternalAccountClient {\n    constructor() {\n        throw new Error('ExternalAccountClients should be initialized via: ' +\n            'ExternalAccountClient.fromJSON(), ' +\n            'directly via explicit constructors, eg. ' +\n            'new AwsClient(options), new IdentityPoolClient(options), new' +\n            'PluggableAuthClientOptions, or via ' +\n            'new GoogleAuth(options).getClient()');\n    }\n    /**\n     * This static method will instantiate the\n     * corresponding type of external account credential depending on the\n     * underlying credential source.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @return A BaseExternalAccountClient instance or null if the options\n     *   provided do not correspond to an external account credential.\n     */\n    static fromJSON(options, additionalOptions) {\n        var _a, _b;\n        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {\n                return new awsclient_1.AwsClient(options, additionalOptions);\n            }\n            else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {\n                return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);\n            }\n            else {\n                return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);\n            }\n        }\n        else {\n            return null;\n        }\n    }\n}\nexports.ExternalAccountClient = ExternalAccountClient;\n//# sourceMappingURL=externalclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLGdDQUFnQyxtQkFBTyxDQUFDLGlIQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG5jb25zdCBpZGVudGl0eXBvb2xjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2lkZW50aXR5cG9vbGNsaWVudFwiKTtcbmNvbnN0IGF3c2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXdzY2xpZW50XCIpO1xuY29uc3QgcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9wbHVnZ2FibGUtYXV0aC1jbGllbnRcIik7XG4vKipcbiAqIER1bW15IGNsYXNzIHdpdGggbm8gY29uc3RydWN0b3IuIERldmVsb3BlcnMgYXJlIGV4cGVjdGVkIHRvIHVzZSBmcm9tSlNPTi5cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBY2NvdW50Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbEFjY291bnRDbGllbnRzIHNob3VsZCBiZSBpbml0aWFsaXplZCB2aWE6ICcgK1xuICAgICAgICAgICAgJ0V4dGVybmFsQWNjb3VudENsaWVudC5mcm9tSlNPTigpLCAnICtcbiAgICAgICAgICAgICdkaXJlY3RseSB2aWEgZXhwbGljaXQgY29uc3RydWN0b3JzLCBlZy4gJyArXG4gICAgICAgICAgICAnbmV3IEF3c0NsaWVudChvcHRpb25zKSwgbmV3IElkZW50aXR5UG9vbENsaWVudChvcHRpb25zKSwgbmV3JyArXG4gICAgICAgICAgICAnUGx1Z2dhYmxlQXV0aENsaWVudE9wdGlvbnMsIG9yIHZpYSAnICtcbiAgICAgICAgICAgICduZXcgR29vZ2xlQXV0aChvcHRpb25zKS5nZXRDbGllbnQoKScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2Qgd2lsbCBpbnN0YW50aWF0ZSB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHR5cGUgb2YgZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAgKiB1bmRlcmx5aW5nIGNyZWRlbnRpYWwgc291cmNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIEEgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCBpbnN0YW5jZSBvciBudWxsIGlmIHRoZSBvcHRpb25zXG4gICAgICogICBwcm92aWRlZCBkbyBub3QgY29ycmVzcG9uZCB0byBhbiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZSA9PT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVudmlyb25tZW50X2lkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhd3NjbGllbnRfMS5Bd3NDbGllbnQob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKF9iID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLlBsdWdnYWJsZUF1dGhDbGllbnQob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpZGVudGl0eXBvb2xjbGllbnRfMS5JZGVudGl0eVBvb2xDbGllbnQob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsQWNjb3VudENsaWVudCA9IEV4dGVybmFsQWNjb3VudENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVybmFsY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/googleauth.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst computeclient_1 = __webpack_require__(/*! ./computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nconst idtokenclient_1 = __webpack_require__(/*! ./idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nconst envDetect_1 = __webpack_require__(/*! ./envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nconst jwtclient_1 = __webpack_require__(/*! ./jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nconst refreshclient_1 = __webpack_require__(/*! ./refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nconst impersonated_1 = __webpack_require__(/*! ./impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nconst externalclient_1 = __webpack_require__(/*! ./externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst externalAccountAuthorizedUserClient_1 = __webpack_require__(/*! ./externalAccountAuthorizedUserClient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nconst GoogleAuthExceptionMessages = {\n    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \\n' +\n        'To learn more about authentication and Google APIs, visit: \\n' +\n        'https://cloud.google.com/docs/authentication/getting-started',\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    constructor(opts) {\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */\n        this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        opts = opts || {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.jsonContent = opts.credentials || null;\n        this.clientOptions = opts.clientOptions;\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */\n    async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        }\n        catch (e) {\n            if (e instanceof Error &&\n                e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /*\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */\n    async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        }\n        else {\n            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */\n    getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n        }\n        else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            return await this.prepareAndCacheADC(this.cachedCredential);\n        }\n        // Since this is a 'new' ADC to cache we will use the environment variable\n        // if it's available. We prefer this value over the value from ADC.\n        const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential =\n            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            }\n            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);\n        }\n        // Determine if we're running on GCE.\n        let isGCE;\n        try {\n            isGCE = await this._checkIsGCE();\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unexpected error determining execution environment: ${e.message}`;\n            }\n            throw e;\n        }\n        if (!isGCE) {\n            // We failed to find the default credentials. Bail out with an error.\n            throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n        }\n        // For GCE, just return a default ComputeClient. It will take care of\n        // the rest.\n        options.scopes = this.getAnyScopes();\n        return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);\n    }\n    async prepareAndCacheADC(credential, quotaProjectIdOverride) {\n        const projectId = await this.getProjectIdOptional();\n        if (quotaProjectIdOverride) {\n            credential.quotaProjectId = quotaProjectIdOverride;\n        }\n        this.cachedCredential = credential;\n        return { credential, projectId };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n    async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE =\n                gcpMetadata.getGCPResidency() || (await gcpMetadata.isAvailable());\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n            process.env['google_application_credentials'];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env['APPDATA'];\n        }\n        else {\n            // Linux or Mac\n            const home = process.env['HOME'];\n            if (home) {\n                location = path.join(home, '.config');\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, 'gcloud', 'application_default_credentials.json');\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error('The file path is invalid.');\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d;\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error('The incoming JSON object does not contain a source_credentials field');\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');\n        }\n        // Create source client for impersonation\n        const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);\n        // Extreact service account from service_account_impersonation_url\n        const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];\n        const client = new impersonated_1.Impersonated({\n            delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],\n            sourceClient: sourceClient,\n            targetPrincipal: targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],\n        });\n        return client;\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    fromJSON(json, options = {}) {\n        let client;\n        options = options || {};\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        }\n        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        }\n        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        }\n        else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        }\n        else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n    _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the Google auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    }\n                    catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename)\n                            throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename,\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n    fromAPIKey(apiKey, options) {\n        options = options || {};\n        const client = new jwtclient_1.JWT(options);\n        client.fromAPIKey(apiKey);\n        return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n    _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === 'win') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n    async getDefaultServiceProjectId() {\n        return new Promise(resolve => {\n            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => {\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    }\n                    catch (e) {\n                        // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n    getProductionProjectId() {\n        return (process.env['GCLOUD_PROJECT'] ||\n            process.env['GOOGLE_CLOUD_PROJECT'] ||\n            process.env['gcloud_project'] ||\n            process.env['google_cloud_project']);\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n    async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */\n    async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n    async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project('project-id');\n            return r;\n        }\n        catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return { client_email: serviceAccountEmail };\n            }\n        }\n        if (this.jsonContent) {\n            const credential = {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n            };\n            return credential;\n        }\n        const isGCE = await this._checkIsGCE();\n        if (!isGCE) {\n            throw new Error('Unknown error.');\n        }\n        // For GCE, return the service account details from the metadata server\n        // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n        // The GCF metadata server doesn't respect querystring params if this / is\n        // not included.\n        const data = await gcpMetadata.instance({\n            property: 'service-accounts/',\n            params: { recursive: 'true' },\n        });\n        if (!data || !data.default || !data.default.email) {\n            throw new Error('Failure from metadata server.');\n        }\n        return { client_email: data.default.email };\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */\n    async getClient() {\n        if (!this.cachedCredential) {\n            if (this.jsonContent) {\n                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n            }\n            else if (this.keyFilename) {\n                const filePath = path.resolve(this.keyFilename);\n                const stream = fs.createReadStream(filePath);\n                await this.fromStreamAsync(stream, this.clientOptions);\n            }\n            else {\n                await this.getApplicationDefaultAsync(this.clientOptions);\n            }\n        }\n        return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */\n    async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!('fetchIdToken' in client)) {\n            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n        }\n        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n    async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n    async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n    async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n    getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */\n    async sign(data) {\n        const client = await this.getClient();\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error('Cannot sign data without `client_email`.');\n        }\n        return this.signBlob(crypto, creds.client_email, data);\n    }\n    async signBlob(crypto, emailOrUniqueId, data) {\n        const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' +\n            `${emailOrUniqueId}:signBlob`;\n        const res = await this.request({\n            method: 'POST',\n            url,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data),\n            },\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n/**\n * Export DefaultTransporter as a static property of the class.\n */\nGoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n//# sourceMappingURL=googleauth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9nb29nbGVhdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsMkJBQTJCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLG9DQUFlO0FBQy9DLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLDBFQUFjO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsMkZBQWlCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBa0I7QUFDbkQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELDhDQUE4QyxtQkFBTyxDQUFDLDZJQUF1QztBQUM3RiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsVUFBVTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxVQUFVO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVSx1Q0FBdUMsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUseUNBQXlDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx1Q0FBdUM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5Q0FBeUM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9nb29nbGVhdXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBleHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSB2b2lkIDA7XG5jb25zdCBjaGlsZF9wcm9jZXNzXzEgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZ2NwTWV0YWRhdGEgPSByZXF1aXJlKFwiZ2NwLW1ldGFkYXRhXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuY29uc3QgdHJhbnNwb3J0ZXJzXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0ZXJzXCIpO1xuY29uc3QgY29tcHV0ZWNsaWVudF8xID0gcmVxdWlyZShcIi4vY29tcHV0ZWNsaWVudFwiKTtcbmNvbnN0IGlkdG9rZW5jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2lkdG9rZW5jbGllbnRcIik7XG5jb25zdCBlbnZEZXRlY3RfMSA9IHJlcXVpcmUoXCIuL2VudkRldGVjdFwiKTtcbmNvbnN0IGp3dGNsaWVudF8xID0gcmVxdWlyZShcIi4vand0Y2xpZW50XCIpO1xuY29uc3QgcmVmcmVzaGNsaWVudF8xID0gcmVxdWlyZShcIi4vcmVmcmVzaGNsaWVudFwiKTtcbmNvbnN0IGltcGVyc29uYXRlZF8xID0gcmVxdWlyZShcIi4vaW1wZXJzb25hdGVkXCIpO1xuY29uc3QgZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG5jb25zdCBleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudF8xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRcIik7XG5leHBvcnRzLkNMT1VEX1NES19DTElFTlRfSUQgPSAnNzY0MDg2MDUxODUwLTZxcjRwNmdwaTZobjUwNnB0OGVqdXE4M2RpMzQxaHVyLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tJztcbmNvbnN0IEdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyA9IHtcbiAgICBOT19QUk9KRUNUX0lEX0ZPVU5EOiAnVW5hYmxlIHRvIGRldGVjdCBhIFByb2plY3QgSWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFxcbicgK1xuICAgICAgICAnVG8gbGVhcm4gbW9yZSBhYm91dCBhdXRoZW50aWNhdGlvbiBhbmQgR29vZ2xlIEFQSXMsIHZpc2l0OiBcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctc3RhcnRlZCcsXG59O1xuY2xhc3MgR29vZ2xlQXV0aCB7XG4gICAgLy8gTm90ZTogIHRoaXMgcHJvcGVybHkgaXMgb25seSBwdWJsaWMgdG8gc2F0aXNpZnkgdW5pdCB0ZXN0cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzUyMjhcbiAgICBnZXQgaXNHQ0UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgYXV0aCBsYXllciBpcyBydW5uaW5nIG9uIEdvb2dsZVxuICAgICAgICAgKiBDb21wdXRlIEVuZ2luZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tJc0dDRSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVG8gc2F2ZSB0aGUgY29udGVudHMgb2YgdGhlIEpTT04gY3JlZGVudGlhbCBmaWxlXG4gICAgICAgIHRoaXMuanNvbkNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBudWxsO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5fY2FjaGVkUHJvamVjdElkID0gb3B0cy5wcm9qZWN0SWQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gb3B0cy5hdXRoQ2xpZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMua2V5RmlsZW5hbWUgPSBvcHRzLmtleUZpbGVuYW1lIHx8IG9wdHMua2V5RmlsZTtcbiAgICAgICAgdGhpcy5zY29wZXMgPSBvcHRzLnNjb3BlcztcbiAgICAgICAgdGhpcy5qc29uQ29udGVudCA9IG9wdHMuY3JlZGVudGlhbHMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gb3B0cy5jbGllbnRPcHRpb25zO1xuICAgIH1cbiAgICAvLyBHQVBJQyBjbGllbnQgbGlicmFyaWVzIHNob3VsZCBhbHdheXMgdXNlIHNlbGYtc2lnbmVkIEpXVHMuIFRoZSBmb2xsb3dpbmdcbiAgICAvLyB2YXJpYWJsZXMgYXJlIHNldCBvbiB0aGUgSldUIGNsaWVudCBpbiBvcmRlciB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsaWJyYXJ5LFxuICAgIC8vIGFuZCBzaWduIHRoZSBKV1Qgd2l0aCB0aGUgY29ycmVjdCBhdWRpZW5jZSBhbmQgc2NvcGVzIChpZiBub3Qgc3VwcGxpZWQpLlxuICAgIHNldEdhcGljSldUVmFsdWVzKGNsaWVudCkge1xuICAgICAgICBjbGllbnQuZGVmYXVsdFNlcnZpY2VQYXRoID0gdGhpcy5kZWZhdWx0U2VydmljZVBhdGg7XG4gICAgICAgIGNsaWVudC51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgPSB0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZTtcbiAgICAgICAgY2xpZW50LmRlZmF1bHRTY29wZXMgPSB0aGlzLmRlZmF1bHRTY29wZXM7XG4gICAgfVxuICAgIGdldFByb2plY3RJZChjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvamVjdElkQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2plY3RJZEFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcnkgbWV0aG9kIGZvciBpbnRlcm5hbCBgZ2V0UHJvamVjdElkYCB1c2FnZXMgd2hlcmUgYG51bGxgIGlzXG4gICAgICogYWNjZXB0YWJsZS4gSW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZSwgYGdldFByb2plY3RJZGAgc2hvdWxkIHJldHVybiBgbnVsbGBcbiAgICAgKiAoYXMgdGhlIGBQcm9taXNlPHN0cmluZyB8IG51bGw+YCBiYXNlIHNpZ25hdHVyZSBkZXNjcmliZXMpIGFuZCB0aGlzIHByaXZhdGVcbiAgICAgKiBtZXRob2Qgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBwcm9qZWN0IGlkIChvciBgbnVsbGApXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UHJvamVjdElkT3B0aW9uYWwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRQcm9qZWN0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9PT0gR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBBIHByaXZhdGUgbWV0aG9kIGZvciBmaW5kaW5nIGFuZCBjYWNoaW5nIGEgcHJvamVjdElkLlxuICAgICAqXG4gICAgICogU3VwcG9ydHMgZW52aXJvbm1lbnRzIGluIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gICAgICogLSBHQ0xPVURfUFJPSkVDVCBvciBHT09HTEVfQ0xPVURfUFJPSkVDVCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgICAqIC0gR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIEpTT04gZmlsZVxuICAgICAqIC0gQ2xvdWQgU0RLOiBgZ2Nsb3VkIGNvbmZpZyBjb25maWctaGVscGVyIC0tZm9ybWF0IGpzb25gXG4gICAgICogLSBHQ0UgcHJvamVjdCBJRCBmcm9tIG1ldGFkYXRhIHNlcnZlclxuICAgICAqXG4gICAgICogQHJldHVybnMgcHJvamVjdElkXG4gICAgICovXG4gICAgYXN5bmMgZmluZEFuZENhY2hlUHJvamVjdElkKCkge1xuICAgICAgICBsZXQgcHJvamVjdElkID0gbnVsbDtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldFByb2R1Y3Rpb25Qcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRGaWxlUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RGVmYXVsdFNlcnZpY2VQcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRHQ0VQcm9qZWN0SWQoKSk7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRFeHRlcm5hbEFjY291bnRDbGllbnRQcm9qZWN0SWQoKSk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZFByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RJZEFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkUHJvamVjdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZmluZFByb2plY3RJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRQcm9qZWN0SWRQcm9taXNlID0gdGhpcy5maW5kQW5kQ2FjaGVQcm9qZWN0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFByb2plY3RJZFByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFueSBzY29wZXMgKHVzZXItc3BlY2lmaWVkIG9yIGRlZmF1bHQgc2NvcGVzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgKiAgIGNsaWVudCBsaWJyYXJ5KSB0aGF0IG5lZWQgdG8gYmUgc2V0IG9uIHRoZSBjdXJyZW50IEF1dGggY2xpZW50LlxuICAgICAqL1xuICAgIGdldEFueVNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzIHx8IHRoaXMuZGVmYXVsdFNjb3BlcztcbiAgICB9XG4gICAgZ2V0QXBwbGljYXRpb25EZWZhdWx0KG9wdGlvbnNPckNhbGxiYWNrID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyhvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5jcmVkZW50aWFsLCByLnByb2plY3RJZCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhIGNhY2hlZCBjcmVkZW50aWFsLCByZXR1cm4gaXQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHByZXNlcnZlIG9uZSdzIGNvbmZpZ3VyZWQgcXVvdGEgcHJvamVjdCwgaW4gY2FzZSB0aGV5XG4gICAgICAgIC8vIHNldCBvbmUgZGlyZWN0bHkgb24gdGhlIGNyZWRlbnRpYWwgcHJldmlvdXNseS5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJlcGFyZUFuZENhY2hlQURDKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhICduZXcnIEFEQyB0byBjYWNoZSB3ZSB3aWxsIHVzZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgLy8gaWYgaXQncyBhdmFpbGFibGUuIFdlIHByZWZlciB0aGlzIHZhbHVlIG92ZXIgdGhlIHZhbHVlIGZyb20gQURDLlxuICAgICAgICBjb25zdCBxdW90YVByb2plY3RJZE92ZXJyaWRlID0gcHJvY2Vzcy5lbnZbJ0dPT0dMRV9DTE9VRF9RVU9UQV9QUk9KRUNUJ107XG4gICAgICAgIGxldCBjcmVkZW50aWFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhIGxvY2FsIGVudmlyb25tZW50IHZhcmlhYmxlIHBvaW50aW5nIHRvIHRoZVxuICAgICAgICAvLyBsb2NhdGlvbiBvZiB0aGUgY3JlZGVudGlhbCBmaWxlLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIGluIGxvY2FsXG4gICAgICAgIC8vIGRldmVsb3BlciBzY2VuYXJpb3MuXG4gICAgICAgIGNyZWRlbnRpYWwgPVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlKG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3JlZGVudGlhbCkge1xuICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWwgaW5zdGFuY2VvZiBqd3RjbGllbnRfMS5KV1QpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9vayBpbiB0aGUgd2VsbC1rbm93biBjcmVkZW50aWFsIGZpbGUgbG9jYXRpb24uXG4gICAgICAgIGNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhjcmVkZW50aWFsLCBxdW90YVByb2plY3RJZE92ZXJyaWRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBvbiBHQ0UuXG4gICAgICAgIGxldCBpc0dDRTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzR0NFID0gYXdhaXQgdGhpcy5fY2hlY2tJc0dDRSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYFVuZXhwZWN0ZWQgZXJyb3IgZGV0ZXJtaW5pbmcgZXhlY3V0aW9uIGVudmlyb25tZW50OiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzR0NFKSB7XG4gICAgICAgICAgICAvLyBXZSBmYWlsZWQgdG8gZmluZCB0aGUgZGVmYXVsdCBjcmVkZW50aWFscy4gQmFpbCBvdXQgd2l0aCBhbiBlcnJvci5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMuIEJyb3dzZSB0byBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIEdDRSwganVzdCByZXR1cm4gYSBkZWZhdWx0IENvbXB1dGVDbGllbnQuIEl0IHdpbGwgdGFrZSBjYXJlIG9mXG4gICAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgICBvcHRpb25zLnNjb3BlcyA9IHRoaXMuZ2V0QW55U2NvcGVzKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByZXBhcmVBbmRDYWNoZUFEQyhuZXcgY29tcHV0ZWNsaWVudF8xLkNvbXB1dGUob3B0aW9ucyksIHF1b3RhUHJvamVjdElkT3ZlcnJpZGUpO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlQW5kQ2FjaGVBREMoY3JlZGVudGlhbCwgcXVvdGFQcm9qZWN0SWRPdmVycmlkZSkge1xuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldFByb2plY3RJZE9wdGlvbmFsKCk7XG4gICAgICAgIGlmIChxdW90YVByb2plY3RJZE92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjcmVkZW50aWFsLnF1b3RhUHJvamVjdElkID0gcXVvdGFQcm9qZWN0SWRPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xuICAgICAgICByZXR1cm4geyBjcmVkZW50aWFsLCBwcm9qZWN0SWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhdXRoIGxheWVyIGlzIHJ1bm5pbmcgb24gR29vZ2xlIENvbXB1dGUgRW5naW5lLlxuICAgICAqIENoZWNrcyBmb3IgR0NQIFJlc2lkZW5jeSwgdGhlbiBmYWxsYmFjayB0byBjaGVja2luZyBpZiBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgKiBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBib29sZWFuLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGVja0lzR0NFKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0lzR0NFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJc0dDRSA9XG4gICAgICAgICAgICAgICAgZ2NwTWV0YWRhdGEuZ2V0R0NQUmVzaWRlbmN5KCkgfHwgKGF3YWl0IGdjcE1ldGFkYXRhLmlzQXZhaWxhYmxlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgZGVmYXVsdCBjcmVkZW50aWFscyBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBwYXRoLi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgT0F1dGgyQ2xpZW50IG9yIG51bGwuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRW52aXJvbm1lbnRWYXJpYWJsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzUGF0aCA9IHByb2Nlc3MuZW52WydHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2dvb2dsZV9hcHBsaWNhdGlvbl9jcmVkZW50aWFscyddO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzUGF0aCB8fCBjcmVkZW50aWFsc1BhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgoY3JlZGVudGlhbHNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBVbmFibGUgdG8gcmVhZCB0aGUgY3JlZGVudGlhbCBmaWxlIHNwZWNpZmllZCBieSB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIHdlbGwta25vd24gZmlsZSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIE9BdXRoMkNsaWVudCBvciBudWxsLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucykge1xuICAgICAgICAvLyBGaXJzdCwgZmlndXJlIG91dCB0aGUgbG9jYXRpb24gb2YgdGhlIGZpbGUsIGRlcGVuZGluZyB1cG9uIHRoZSBPUyB0eXBlLlxuICAgICAgICBsZXQgbG9jYXRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5faXNXaW5kb3dzKCkpIHtcbiAgICAgICAgICAgIC8vIFdpbmRvd3NcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvY2Vzcy5lbnZbJ0FQUERBVEEnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExpbnV4IG9yIE1hY1xuICAgICAgICAgICAgY29uc3QgaG9tZSA9IHByb2Nlc3MuZW52WydIT01FJ107XG4gICAgICAgICAgICBpZiAoaG9tZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGhvbWUsICcuY29uZmlnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgdGhlIHJvb3QgcGF0aCwgZXhwYW5kIGl0LlxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcGF0aC5qb2luKGxvY2F0aW9uLCAnZ2Nsb3VkJywgJ2FwcGxpY2F0aW9uX2RlZmF1bHRfY3JlZGVudGlhbHMuanNvbicpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbGUgc2VlbXMgdG8gZXhpc3QuIFRyeSB0byB1c2UgaXQuXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuX2dldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tRmlsZVBhdGgobG9jYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBsb2FkIGRlZmF1bHQgY3JlZGVudGlhbHMgZnJvbSBhIGZpbGUgYXQgdGhlIGdpdmVuIHBhdGguLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byByZWFkLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBPQXV0aDJDbGllbnRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aChmaWxlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF0aCBsb29rcyBsaWtlIGEgc3RyaW5nLlxuICAgICAgICBpZiAoIWZpbGVQYXRoIHx8IGZpbGVQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlsZSBwYXRoIGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGZzLnJlYWxwYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWZzLmxzdGF0U3luYyhmaWxlUGF0aCkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBvcGVuIGEgcmVhZCBzdHJlYW0gb24gdGhlIGZpbGUsIGFuZCBwYXJzZSBpdC5cbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtKHJlYWRTdHJlYW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyBhIGdpdmVuIGltcGVyc29uYXRlZCBpbnB1dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbXBlcnNvbmF0ZWQgaW5wdXQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEpXVCBvciBVc2VyUmVmcmVzaCBDbGllbnQgd2l0aCBkYXRhXG4gICAgICovXG4gICAgZnJvbUltcGVyc29uYXRlZEpTT04oanNvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIGFuICBpbXBlcnNvbmF0ZWQgcmVmcmVzaCB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgIT09IGltcGVyc29uYXRlZF8xLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGhhdmUgdGhlIFwiJHtpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFfVwiIHR5cGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uc291cmNlX2NyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgc291cmNlX2NyZWRlbnRpYWxzIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIHNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBzb3VyY2UgY2xpZW50IGZvciBpbXBlcnNvbmF0aW9uXG4gICAgICAgIGNvbnN0IHNvdXJjZUNsaWVudCA9IG5ldyByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQoanNvbi5zb3VyY2VfY3JlZGVudGlhbHMuY2xpZW50X2lkLCBqc29uLnNvdXJjZV9jcmVkZW50aWFscy5jbGllbnRfc2VjcmV0LCBqc29uLnNvdXJjZV9jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgLy8gRXh0cmVhY3Qgc2VydmljZSBhY2NvdW50IGZyb20gc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsXG4gICAgICAgIGNvbnN0IHRhcmdldFByaW5jaXBhbCA9IChfYiA9IChfYSA9IC8oPzx0YXJnZXQ+W14vXSspOmdlbmVyYXRlQWNjZXNzVG9rZW4kLy5leGVjKGpzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyb3VwcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRhcmdldDtcbiAgICAgICAgaWYgKCF0YXJnZXRQcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgZXh0cmFjdCB0YXJnZXQgcHJpbmNpcGFsIGZyb20gJHtqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTY29wZXMgPSAoX2MgPSB0aGlzLmdldEFueVNjb3BlcygpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGltcGVyc29uYXRlZF8xLkltcGVyc29uYXRlZCh7XG4gICAgICAgICAgICBkZWxlZ2F0ZXM6IChfZCA9IGpzb24uZGVsZWdhdGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudDogc291cmNlQ2xpZW50LFxuICAgICAgICAgICAgdGFyZ2V0UHJpbmNpcGFsOiB0YXJnZXRQcmluY2lwYWwsXG4gICAgICAgICAgICB0YXJnZXRTY29wZXM6IEFycmF5LmlzQXJyYXkodGFyZ2V0U2NvcGVzKSA/IHRhcmdldFNjb3BlcyA6IFt0YXJnZXRTY29wZXNdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgSldUIG9yIFVzZXJSZWZyZXNoIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKGpzb24udHlwZSA9PT0gcmVmcmVzaGNsaWVudF8xLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQob3B0aW9ucyk7XG4gICAgICAgICAgICBjbGllbnQuZnJvbUpTT04oanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlID09PSBpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSB0aGlzLmZyb21JbXBlcnNvbmF0ZWRKU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudC5mcm9tSlNPTihqc29uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNsaWVudC5zY29wZXMgPSB0aGlzLmdldEFueVNjb3BlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudChqc29uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgand0Y2xpZW50XzEuSldUKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpO1xuICAgICAgICAgICAgY2xpZW50LmZyb21KU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIEpXVCBvciBVc2VyUmVmcmVzaENsaWVudCBmcm9tIEphdmFTY3JpcHQgb2JqZWN0LCBjYWNoaW5nIGJvdGggdGhlXG4gICAgICogb2JqZWN0IHVzZWQgdG8gaW5zdGFudGlhdGUgYW5kIHRoZSBjbGllbnQuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgSldUIG9yIFVzZXJSZWZyZXNoIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIF9jYWNoZUNsaWVudEZyb21KU09OKGpzb24sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5mcm9tSlNPTihqc29uLCBvcHRpb25zKTtcbiAgICAgICAgLy8gY2FjaGUgYm90aCByYXcgZGF0YSB1c2VkIHRvIGluc3RhbnRpYXRlIGNsaWVudCBhbmQgY2xpZW50IGl0c2VsZi5cbiAgICAgICAgdGhpcy5qc29uQ29udGVudCA9IGpzb247XG4gICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IGNsaWVudDtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgb3B0aW9uc09yQ2FsbGJhY2sgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JDYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtLCBvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBzdHJlYW0gY29udGFpbmluZyB0aGUgR29vZ2xlIGF1dGggc2V0dGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9jYWNoZUNsaWVudEZyb21KU09OKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHBhcnNpbmcgdGhpcy5rZXlGaWxlTmFtZSwgYXNzdW1lIHRoYXQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGEgUEVNIG9yIHAxMiBjZXJ0aWZpY2F0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5rZXlGaWxlbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgand0Y2xpZW50XzEuSldUKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmNsaWVudE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gY2xpZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBBUEkga2V5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0gYXBpS2V5IFRoZSBBUEkga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEEgSldUIGxvYWRlZCBmcm9tIHRoZSBrZXlcbiAgICAgKi9cbiAgICBmcm9tQVBJS2V5KGFwaUtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGp3dGNsaWVudF8xLkpXVChvcHRpb25zKTtcbiAgICAgICAgY2xpZW50LmZyb21BUElLZXkoYXBpS2V5KTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0gaXMgV2luZG93cy5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNXaW5kb3dzKCkge1xuICAgICAgICBjb25zdCBzeXMgPSBvcy5wbGF0Zm9ybSgpO1xuICAgICAgICBpZiAoc3lzICYmIHN5cy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgaWYgKHN5cy5zdWJzdHJpbmcoMCwgMykudG9Mb3dlckNhc2UoKSA9PT0gJ3dpbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgR29vZ2xlIENsb3VkIFNESyBjb21tYW5kIHRoYXQgcHJpbnRzIHRoZSBkZWZhdWx0IHByb2plY3QgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWZhdWx0U2VydmljZVByb2plY3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjKSgnZ2Nsb3VkIGNvbmZpZyBjb25maWctaGVscGVyIC0tZm9ybWF0IGpzb24nLCAoZXJyLCBzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZCA9IEpTT04ucGFyc2Uoc3Rkb3V0KS5jb25maWd1cmF0aW9uLnByb3BlcnRpZXMuY29yZS5wcm9qZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9qZWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHByb2plY3QgaWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UHJvZHVjdGlvblByb2plY3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIChwcm9jZXNzLmVudlsnR0NMT1VEX1BST0pFQ1QnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ0dPT0dMRV9DTE9VRF9QUk9KRUNUJ10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52WydnY2xvdWRfcHJvamVjdCddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnZ29vZ2xlX2Nsb3VkX3Byb2plY3QnXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBwcm9qZWN0IGlkIGZyb20gdGhlIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBqc29uIGZpbGUuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmlsZVByb2plY3RJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgdGhlIHByb2plY3QgSUQgZnJvbSB0aGUgY2FjaGVkIGNyZWRlbnRpYWxzIGZpbGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZENyZWRlbnRpYWwucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcHJvamVjdElkIGlzIGxvYWRlZCBmcm9tIHRoZSBrZXlGaWxlIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgICAgIGlmIChjcmVkcyAmJiBjcmVkcy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlZHMucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBsb2FkIGEgY3JlZGVudGlhbHMgZmlsZSBhbmQgcmVhZCBpdHMgcHJvamVjdCBJRFxuICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5fdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9qZWN0IElEIGZyb20gZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQgaWYgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEV4dGVybmFsQWNjb3VudENsaWVudFByb2plY3RJZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25Db250ZW50IHx8IHRoaXMuanNvbkNvbnRlbnQudHlwZSAhPT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdW5kZXJseWluZyBlcnJvciwgYXMgdGhlIGVycm9yIGNvdWxkIGNvbnRhaW4gaGVscGZ1bFxuICAgICAgICAvLyBpbmZvcm1hdGlvbiBmb3IgZGVidWdnaW5nIGFuZCBmaXhpbmcuIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGZvclxuICAgICAgICAvLyBleHRlcm5hbCBhY2NvdW50IGNyZWRzIGFzIGluIG9yZGVyIHRvIGdldCB0aGUgcHJvamVjdCBJRCwgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBvcGVyYXRpb25zIGhhdmUgdG8gc3VjY2VlZDpcbiAgICAgICAgLy8gMS4gVmFsaWQgY3JlZGVudGlhbHMgZmlsZSBzaG91bGQgYmUgc3VwcGxpZWQuXG4gICAgICAgIC8vIDIuIEFiaWxpdHkgdG8gcmV0cmlldmUgYWNjZXNzIHRva2VucyBmcm9tIFNUUyB0b2tlbiBleGNoYW5nZSBBUEkuXG4gICAgICAgIC8vIDMuIEFiaWxpdHkgdG8gZXhjaGFuZ2UgZm9yIHNlcnZpY2UgYWNjb3VudCBpbXBlcnNvbmF0ZWQgY3JlZGVudGlhbHMgKGlmXG4gICAgICAgIC8vICAgIGVuYWJsZWQpLlxuICAgICAgICAvLyA0LiBBYmlsaXR5IHRvIGdldCBwcm9qZWN0IGluZm8gdXNpbmcgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHN0ZXAgMiBvciAzLlxuICAgICAgICAvLyBXaXRob3V0IHN1cmZhY2luZyB0aGUgZXJyb3IsIGl0IGlzIGhhcmRlciBmb3IgZGV2ZWxvcGVycyB0byBkZXRlcm1pbmVcbiAgICAgICAgLy8gd2hpY2ggc3RlcCB3ZW50IHdyb25nLlxuICAgICAgICByZXR1cm4gYXdhaXQgY3JlZHMuZ2V0UHJvamVjdElkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIENvbXB1dGUgRW5naW5lIHByb2plY3QgSUQgaWYgaXQgY2FuIGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEdDRVByb2plY3RJZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBnY3BNZXRhZGF0YS5wcm9qZWN0KCdwcm9qZWN0LWlkJyk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBlcnJvcnNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRDcmVkZW50aWFsc0FzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDcmVkZW50aWFsc0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3JlZGVudGlhbHNBc3luYygpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VBY2NvdW50RW1haWwgPSBjbGllbnQuZ2V0U2VydmljZUFjY291bnRFbWFpbCgpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VBY2NvdW50RW1haWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjbGllbnRfZW1haWw6IHNlcnZpY2VBY2NvdW50RW1haWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5qc29uQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRfZW1haWw6IHRoaXMuanNvbkNvbnRlbnQuY2xpZW50X2VtYWlsLFxuICAgICAgICAgICAgICAgIHByaXZhdGVfa2V5OiB0aGlzLmpzb25Db250ZW50LnByaXZhdGVfa2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzR0NFID0gYXdhaXQgdGhpcy5fY2hlY2tJc0dDRSgpO1xuICAgICAgICBpZiAoIWlzR0NFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIEdDRSwgcmV0dXJuIHRoZSBzZXJ2aWNlIGFjY291bnQgZGV0YWlscyBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgICAgLy8gTk9URTogVGhlIHRyYWlsaW5nICcvJyBhdCB0aGUgZW5kIG9mIHNlcnZpY2UtYWNjb3VudHMvIGlzIHZlcnkgaW1wb3J0YW50IVxuICAgICAgICAvLyBUaGUgR0NGIG1ldGFkYXRhIHNlcnZlciBkb2Vzbid0IHJlc3BlY3QgcXVlcnlzdHJpbmcgcGFyYW1zIGlmIHRoaXMgLyBpc1xuICAgICAgICAvLyBub3QgaW5jbHVkZWQuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZSh7XG4gICAgICAgICAgICBwcm9wZXJ0eTogJ3NlcnZpY2UtYWNjb3VudHMvJyxcbiAgICAgICAgICAgIHBhcmFtczogeyByZWN1cnNpdmU6ICd0cnVlJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRlZmF1bHQgfHwgIWRhdGEuZGVmYXVsdC5lbWFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsdXJlIGZyb20gbWV0YWRhdGEgc2VydmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNsaWVudF9lbWFpbDogZGF0YS5kZWZhdWx0LmVtYWlsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGEgY2xpZW50IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLiAgSWYgbm9cbiAgICAgKiBvcHRpb25zIHdlcmUgcGFzc2VkLCB1c2UgQXBwbGljYXRpb24gRGVmYXVsdCBDcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGllbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5qc29uQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlQ2xpZW50RnJvbUpTT04odGhpcy5qc29uQ29udGVudCwgdGhpcy5jbGllbnRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLmtleUZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZyb21TdHJlYW1Bc3luYyhzdHJlYW0sIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQ3JlZGVudGlhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsaWVudCB3aGljaCB3aWxsIGZldGNoIGFuIElEIHRva2VuIGZvciBhdXRob3JpemF0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqIEByZXR1cm5zIElkVG9rZW5DbGllbnQgZm9yIG1ha2luZyBIVFRQIGNhbGxzIGF1dGhlbnRpY2F0ZWQgd2l0aCBJRCB0b2tlbnMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWRUb2tlbkNsaWVudCh0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBpZiAoISgnZmV0Y2hJZFRva2VuJyBpbiBjbGllbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmZXRjaCBJRCB0b2tlbiBpbiB0aGlzIGVudmlyb25tZW50LCB1c2UgR0NFIG9yIHNldCB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGVudmlyb25tZW50IHZhcmlhYmxlIHRvIGEgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzIEpTT04gZmlsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGlkdG9rZW5jbGllbnRfMS5JZFRva2VuQ2xpZW50KHsgdGFyZ2V0QXVkaWVuY2UsIGlkVG9rZW5Qcm92aWRlcjogY2xpZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG9idGFpbiBhcHBsaWNhdGlvbiBkZWZhdWx0IGNyZWRlbnRpYWxzLCBhbmQgcmV0dXJuXG4gICAgICogYW4gYWNjZXNzIHRva2VuIGZvciBtYWtpbmcgcmVxdWVzdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgY2xpZW50LmdldEFjY2Vzc1Rva2VuKCkpLnRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gdGhlIEhUVFAgaGVhZGVycyB0aGF0IHdpbGwgcHJvdmlkZSBhdXRob3JpemF0aW9uIGZvciBhIGdpdmVuXG4gICAgICogcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyh1cmwpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW4gY3JlZGVudGlhbHMgZm9yIGEgcmVxdWVzdCwgdGhlbiBhdHRhY2ggdGhlIGFwcHJvcHJpYXRlIGhlYWRlcnMgdG9cbiAgICAgKiB0aGUgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIG9yIFJlcXVlc3Qgb3B0aW9ucyBvbiB3aGljaCB0byBhdHRhY2ggdGhlIGhlYWRlcnNcbiAgICAgKi9cbiAgICBhc3luYyBhdXRob3JpemVSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHVybCA9IG9wdHMudXJsIHx8IG9wdHMudXJpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzKHVybCk7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24ob3B0cy5oZWFkZXJzIHx8IHt9LCBoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFwcGxpY2F0aW9uIGRlZmF1bHQgY3JlZGVudGlhbHMsIGFuZCBtYWtlIGFuXG4gICAgICogSFRUUCByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzIEF4aW9zIHJlcXVlc3Qgb3B0aW9ucyBmb3IgdGhlIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHJlcXVlc3Qob3B0cykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qob3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tcHV0ZSBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGUgY29kZSBpcyBydW5uaW5nLlxuICAgICAqL1xuICAgIGdldEVudigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbnZEZXRlY3RfMS5nZXRFbnYpKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gdGhlIGdpdmVuIGRhdGEgd2l0aCB0aGUgY3VycmVudCBwcml2YXRlIGtleSwgb3IgZ28gb3V0XG4gICAgICogdG8gdGhlIElBTSBBUEkgdG8gc2lnbiBpdC5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBiZSBzaWduZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBqd3RjbGllbnRfMS5KV1QgJiYgY2xpZW50LmtleSkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbiA9IGF3YWl0IGNyeXB0by5zaWduKGNsaWVudC5rZXksIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmdldENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGlmICghY3JlZHMuY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzaWduIGRhdGEgd2l0aG91dCBgY2xpZW50X2VtYWlsYC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zaWduQmxvYihjcnlwdG8sIGNyZWRzLmNsaWVudF9lbWFpbCwgZGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25CbG9iKGNyeXB0bywgZW1haWxPclVuaXF1ZUlkLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHVybCA9ICdodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tL3YxL3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzLycgK1xuICAgICAgICAgICAgYCR7ZW1haWxPclVuaXF1ZUlkfTpzaWduQmxvYmA7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBjcnlwdG8uZW5jb2RlQmFzZTY0U3RyaW5nVXRmOChkYXRhKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLmRhdGEuc2lnbmVkQmxvYjtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUF1dGggPSBHb29nbGVBdXRoO1xuLyoqXG4gKiBFeHBvcnQgRGVmYXVsdFRyYW5zcG9ydGVyIGFzIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZSBjbGFzcy5cbiAqL1xuR29vZ2xlQXV0aC5EZWZhdWx0VHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGVhdXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js":
/*!****************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/iam.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IAMAuth = void 0;\nclass IAMAuth {\n    /**\n     * IAM credentials.\n     *\n     * @param selector the iam authority selector\n     * @param token the token\n     * @constructor\n     */\n    constructor(selector, token) {\n        this.selector = selector;\n        this.token = token;\n        this.selector = selector;\n        this.token = token;\n    }\n    /**\n     * Acquire the HTTP headers required to make an authenticated request.\n     */\n    getRequestHeaders() {\n        return {\n            'x-goog-iam-authority-selector': this.selector,\n            'x-goog-iam-authorization-token': this.token,\n        };\n    }\n}\nexports.IAMAuth = IAMAuth;\n//# sourceMappingURL=iam.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JQU1BdXRoID0gdm9pZCAwO1xuY2xhc3MgSUFNQXV0aCB7XG4gICAgLyoqXG4gICAgICogSUFNIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIHRoZSBpYW0gYXV0aG9yaXR5IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSB0b2tlblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCB0b2tlbikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgdGhlIEhUVFAgaGVhZGVycyByZXF1aXJlZCB0byBtYWtlIGFuIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd4LWdvb2ctaWFtLWF1dGhvcml0eS1zZWxlY3Rvcic6IHRoaXMuc2VsZWN0b3IsXG4gICAgICAgICAgICAneC1nb29nLWlhbS1hdXRob3JpemF0aW9uLXRva2VuJzogdGhpcy50b2tlbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklBTUF1dGggPSBJQU1BdXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWFtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/identitypoolclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentityPoolClient = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : (() => { }));\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : (() => { }));\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : (() => { }));\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        var _a, _b;\n        super(options, additionalOptions);\n        this.file = options.credential_source.file;\n        this.url = options.credential_source.url;\n        this.headers = options.credential_source.headers;\n        if (!this.file && !this.url) {\n            throw new Error('No valid Identity Pool \"credential_source\" provided');\n        }\n        // Text is the default format type.\n        this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n        this.formatSubjectTokenFieldName =\n            (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n        if (this.formatType !== 'json' && this.formatType !== 'text') {\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n        }\n        if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n            throw new Error('Missing subject_token_field_name for JSON credential_source format');\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this either retrieves the local credential from a file location (k8s\n     * workload) or by sending a GET request to a local metadata server (Azure\n     * workloads).\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        if (this.file) {\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n        }\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n    }\n    /**\n     * Looks up the external subject token in the file path provided and\n     * resolves with that token.\n     * @param file The file path where the external credential is located.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = await realpath(filePath);\n            if (!(await lstat(filePath)).isFile()) {\n                throw new Error();\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(filePath, { encoding: 'utf8' });\n        if (formatType === 'text') {\n            subjectToken = rawText;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source file');\n        }\n        return subjectToken;\n    }\n    /**\n     * Sends a GET request to the URL provided and resolves with the returned\n     * external subject token.\n     * @param url The URL to call to retrieve the subject token. This is typically\n     *   a local metadata server.\n     * @param formatType The token file or URL response type (JSON or text).\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\n     *   subject_token field name. For Azure, this is access_token. For text\n     *   response types, this is ignored.\n     * @param headers The optional additional headers to send with the request to\n     *   the metadata server url.\n     * @return A promise that resolves with the external subject token.\n     */\n    async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n        const opts = {\n            url,\n            method: 'GET',\n            headers,\n            responseType: formatType,\n        };\n        let subjectToken;\n        if (formatType === 'text') {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data;\n        }\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\n            const response = await this.transporter.request(opts);\n            subjectToken = response.data[formatSubjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error('Unable to parse the subject_token from the credential_source URL');\n        }\n        return subjectToken;\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n//# sourceMappingURL=identitypoolclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZGVudGl0eXBvb2xjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHLHFHQUFxRztBQUNyRywrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVSx1Q0FBdUMsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZGVudGl0eXBvb2xjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfYSwgX2IsIF9jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZGVudGl0eVBvb2xDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG4vLyBmcy5yZWFkZmlsZSBpcyB1bmRlZmluZWQgaW4gYnJvd3NlciBrYXJtYSB0ZXN0cyBjYXVzaW5nXG4vLyBgbnBtIHJ1biBicm93c2VyLXRlc3RgIHRvIGZhaWwgYXMgdGVzdC5vYXV0aDIudHMgaW1wb3J0cyB0aGlzIGZpbGUgdmlhXG4vLyBzcmMvaW5kZXgudHMuXG4vLyBGYWxsYmFjayB0byB2b2lkIGZ1bmN0aW9uIHRvIGF2b2lkIHByb21pc2lmeSB0aHJvd2luZyBhIFR5cGVFcnJvci5cbmNvbnN0IHJlYWRGaWxlID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKChfYSA9IGZzLnJlYWRGaWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKCkgPT4geyB9KSk7XG5jb25zdCByZWFscGF0aCA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSgoX2IgPSBmcy5yZWFscGF0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKCgpID0+IHsgfSkpO1xuY29uc3QgbHN0YXQgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoKF9jID0gZnMubHN0YXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICgoKSA9PiB7IH0pKTtcbi8qKlxuICogRGVmaW5lcyB0aGUgVXJsLXNvdXJjZWQgYW5kIGZpbGUtc291cmNlZCBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMgbWFpbmx5XG4gKiB1c2VkIGZvciBLOHMgYW5kIEF6dXJlIHdvcmtsb2Fkcy5cbiAqL1xuY2xhc3MgSWRlbnRpdHlQb29sQ2xpZW50IGV4dGVuZHMgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYW4gSWRlbnRpdHlQb29sQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgZmlsZS1zb3VyY2VkIG9yXG4gICAgICogdXJsLXNvdXJjZWQgY3JlZGVudGlhbCBvciBhIHdvcmtmb3JjZSBwb29sIHVzZXIgcHJvamVjdCBpcyBwcm92aWRlZFxuICAgICAqIHdpdGggYSBub24gd29ya2ZvcmNlIGF1ZGllbmNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZmlsZTtcbiAgICAgICAgdGhpcy51cmwgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5oZWFkZXJzO1xuICAgICAgICBpZiAoIXRoaXMuZmlsZSAmJiAhdGhpcy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgSWRlbnRpdHkgUG9vbCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXh0IGlzIHRoZSBkZWZhdWx0IGZvcm1hdCB0eXBlLlxuICAgICAgICB0aGlzLmZvcm1hdFR5cGUgPSAoKF9hID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5mb3JtYXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSB8fCAndGV4dCc7XG4gICAgICAgIHRoaXMuZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lID1cbiAgICAgICAgICAgIChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZm9ybWF0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3ViamVjdF90b2tlbl9maWVsZF9uYW1lO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlICE9PSAnanNvbicgJiYgdGhpcy5mb3JtYXRUeXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjcmVkZW50aWFsX3NvdXJjZSBmb3JtYXQgXCIke3RoaXMuZm9ybWF0VHlwZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiAhdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdWJqZWN0X3Rva2VuX2ZpZWxkX25hbWUgZm9yIEpTT04gY3JlZGVudGlhbF9zb3VyY2UgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGEgR0NQXG4gICAgICogYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LlxuICAgICAqIFRoaXMgdXNlcyB0aGUgYG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2VgIG9iamVjdCB0byBmaWd1cmUgb3V0IGhvd1xuICAgICAqIHRvIHJldHJpZXZlIHRoZSB0b2tlbiB1c2luZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAqIHRoaXMgZWl0aGVyIHJldHJpZXZlcyB0aGUgbG9jYWwgY3JlZGVudGlhbCBmcm9tIGEgZmlsZSBsb2NhdGlvbiAoazhzXG4gICAgICogd29ya2xvYWQpIG9yIGJ5IHNlbmRpbmcgYSBHRVQgcmVxdWVzdCB0byBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlciAoQXp1cmVcbiAgICAgKiB3b3JrbG9hZHMpLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0VG9rZW5Gcm9tRmlsZSh0aGlzLmZpbGUsIHRoaXMuZm9ybWF0VHlwZSwgdGhpcy5mb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFRva2VuRnJvbVVybCh0aGlzLnVybCwgdGhpcy5mb3JtYXRUeXBlLCB0aGlzLmZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgdGhpcy5oZWFkZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgdGhlIGV4dGVybmFsIHN1YmplY3QgdG9rZW4gaW4gdGhlIGZpbGUgcGF0aCBwcm92aWRlZCBhbmRcbiAgICAgKiByZXNvbHZlcyB3aXRoIHRoYXQgdG9rZW4uXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgcGF0aCB3aGVyZSB0aGUgZXh0ZXJuYWwgY3JlZGVudGlhbCBpcyBsb2NhdGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXRUeXBlIFRoZSB0b2tlbiBmaWxlIG9yIFVSTCByZXNwb25zZSB0eXBlIChKU09OIG9yIHRleHQpLlxuICAgICAqIEBwYXJhbSBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUgRm9yIEpTT04gcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgdGhlXG4gICAgICogICBzdWJqZWN0X3Rva2VuIGZpZWxkIG5hbWUuIEZvciBBenVyZSwgdGhpcyBpcyBhY2Nlc3NfdG9rZW4uIEZvciB0ZXh0XG4gICAgICogICByZXNwb25zZSB0eXBlcywgdGhpcyBpcyBpZ25vcmVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkZyb21GaWxlKGZpbGVQYXRoLCBmb3JtYXRUeXBlLCBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBmaWxlUGF0aCA9IGF3YWl0IHJlYWxwYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke2ZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGNvbnN0IHJhd1RleHQgPSBhd2FpdCByZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4gPSByYXdUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHJhd1RleHQpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0ganNvbltmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3ViamVjdFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSB0aGUgc3ViamVjdF90b2tlbiBmcm9tIHRoZSBjcmVkZW50aWFsX3NvdXJjZSBmaWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgVVJMIHByb3ZpZGVkIGFuZCByZXNvbHZlcyB3aXRoIHRoZSByZXR1cm5lZFxuICAgICAqIGV4dGVybmFsIHN1YmplY3QgdG9rZW4uXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGNhbGwgdG8gcmV0cmlldmUgdGhlIHN1YmplY3QgdG9rZW4uIFRoaXMgaXMgdHlwaWNhbGx5XG4gICAgICogICBhIGxvY2FsIG1ldGFkYXRhIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gZm9ybWF0VHlwZSBUaGUgdG9rZW4gZmlsZSBvciBVUkwgcmVzcG9uc2UgdHlwZSAoSlNPTiBvciB0ZXh0KS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lIEZvciBKU09OIHJlc3BvbnNlIHR5cGVzLCB0aGlzIGlzIHRoZVxuICAgICAqICAgc3ViamVjdF90b2tlbiBmaWVsZCBuYW1lLiBGb3IgQXp1cmUsIHRoaXMgaXMgYWNjZXNzX3Rva2VuLiBGb3IgdGV4dFxuICAgICAqICAgcmVzcG9uc2UgdHlwZXMsIHRoaXMgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBUaGUgb3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdCB0b1xuICAgICAqICAgdGhlIG1ldGFkYXRhIHNlcnZlciB1cmwuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuRnJvbVVybCh1cmwsIGZvcm1hdFR5cGUsIGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IGZvcm1hdFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGlmIChmb3JtYXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnanNvbicgJiYgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IHJlc3BvbnNlLmRhdGFbZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmplY3RUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHN1YmplY3RfdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2UgVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG59XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IElkZW50aXR5UG9vbENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5cG9vbGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/idtokenclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdTokenClient = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass IdTokenClient extends oauth2client_1.OAuth2Client {\n    /**\n     * Google ID Token client\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://developers.google.com/compute/docs/authentication\n     */\n    constructor(options) {\n        super();\n        this.targetAudience = options.targetAudience;\n        this.idTokenProvider = options.idTokenProvider;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        if (!this.credentials.id_token ||\n            !this.credentials.expiry_date ||\n            this.isTokenExpiring()) {\n            const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);\n            this.credentials = {\n                id_token: idToken,\n                expiry_date: this.getIdTokenExpiryDate(idToken),\n            };\n        }\n        const headers = {\n            Authorization: 'Bearer ' + this.credentials.id_token,\n        };\n        return { headers };\n    }\n    getIdTokenExpiryDate(idToken) {\n        const payloadB64 = idToken.split('.')[1];\n        if (payloadB64) {\n            const payload = JSON.parse(Buffer.from(payloadB64, 'base64').toString('ascii'));\n            return payload.exp * 1000;\n        }\n    }\n}\nexports.IdTokenClient = IdTokenClient;\n//# sourceMappingURL=idtokenclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZHRva2VuY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkdG9rZW5jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY2xhc3MgSWRUb2tlbkNsaWVudCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIElEIFRva2VuIGNsaWVudFxuICAgICAqXG4gICAgICogUmV0cmlldmUgYWNjZXNzIHRva2VuIGZyb20gdGhlIG1ldGFkYXRhIHNlcnZlci5cbiAgICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9hdXRoZW50aWNhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YXJnZXRBdWRpZW5jZSA9IG9wdGlvbnMudGFyZ2V0QXVkaWVuY2U7XG4gICAgICAgIHRoaXMuaWRUb2tlblByb3ZpZGVyID0gb3B0aW9ucy5pZFRva2VuUHJvdmlkZXI7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB1cmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLmlkX3Rva2VuIHx8XG4gICAgICAgICAgICAhdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Rva2VuRXhwaXJpbmcoKSkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuaWRUb2tlblByb3ZpZGVyLmZldGNoSWRUb2tlbih0aGlzLnRhcmdldEF1ZGllbmNlKTtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7XG4gICAgICAgICAgICAgICAgaWRfdG9rZW46IGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IHRoaXMuZ2V0SWRUb2tlbkV4cGlyeURhdGUoaWRUb2tlbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0aGlzLmNyZWRlbnRpYWxzLmlkX3Rva2VuLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBoZWFkZXJzIH07XG4gICAgfVxuICAgIGdldElkVG9rZW5FeHBpcnlEYXRlKGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZEI2NCA9IGlkVG9rZW4uc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgaWYgKHBheWxvYWRCNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHBheWxvYWRCNjQsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5leHAgKiAxMDAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JZFRva2VuQ2xpZW50ID0gSWRUb2tlbkNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkdG9rZW5jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/impersonated.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nexports.IMPERSONATED_ACCOUNT_TYPE = 'impersonated_service_account';\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */\n    constructor(options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: 'impersonated-placeholder',\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : '';\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : 'https://iamcredentials.googleapis.com';\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */\n    async refreshToken(refreshToken) {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = 'projects/-/serviceAccounts/' + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + 's',\n            };\n            const res = await this.sourceClient.request({\n                url: u,\n                data: body,\n                method: 'POST',\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res,\n            };\n        }\n        catch (error) {\n            if (!(error instanceof Error))\n                throw error;\n            let status = 0;\n            let message = '';\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            }\n            else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */\n    async fetchIdToken(targetAudience, options) {\n        var _a;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,\n        };\n        const res = await this.sourceClient.request({\n            url: u,\n            data: body,\n            method: 'POST',\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated;\n//# sourceMappingURL=impersonated.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pbXBlcnNvbmF0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsaUNBQWlDO0FBQ3hELHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBUTtBQUNqQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYyxNQUFNLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPLDJCQUEyQixRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCO0FBQ3hFLHFCQUFxQixjQUFjLE1BQU0sS0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2ltcGVyc29uYXRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1wZXJzb25hdGVkID0gZXhwb3J0cy5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFID0gdm9pZCAwO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5leHBvcnRzLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUgPSAnaW1wZXJzb25hdGVkX3NlcnZpY2VfYWNjb3VudCc7XG5jbGFzcyBJbXBlcnNvbmF0ZWQgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEltcGVyc29uYXRlZCBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWNjZXNzIHRva2VuIGJ5IGltcGVyc29uYXRpbmcgYW5vdGhlciBzZXJ2aWNlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBJbXBlcnNvbmF0ZWQgQ3JlZGVudGlhbHMgYWxsb3dpbmcgY3JlZGVudGlhbHMgaXNzdWVkIHRvIGEgdXNlciBvclxuICAgICAqIHNlcnZpY2UgYWNjb3VudCB0byBpbXBlcnNvbmF0ZSBhbm90aGVyLiBUaGUgc291cmNlIHByb2plY3QgdXNpbmdcbiAgICAgKiBJbXBlcnNvbmF0ZWQgQ3JlZGVudGlhbHMgbXVzdCBlbmFibGUgdGhlIFwiSUFNQ3JlZGVudGlhbHNcIiBBUEkuXG4gICAgICogQWxzbywgdGhlIHRhcmdldCBzZXJ2aWNlIGFjY291bnQgbXVzdCBncmFudCB0aGUgb3JnaW5hdGluZyBwcmluY2lwYWxcbiAgICAgKiB0aGUgXCJTZXJ2aWNlIEFjY291bnQgVG9rZW4gQ3JlYXRvclwiIElBTSByb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnNvdXJjZUNsaWVudF0gdGhlIHNvdXJjZSBjcmVkZW50aWFsIHVzZWQgYXMgdG9cbiAgICAgKiBhY3F1aXJlIHRoZSBpbXBlcnNvbmF0ZWQgY3JlZGVudGlhbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRhcmdldFByaW5jaXBhbF0gdGhlIHNlcnZpY2UgYWNjb3VudCB0b1xuICAgICAqIGltcGVyc29uYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLmRlbGVnYXRlc10gdGhlIGNoYWluZWQgbGlzdCBvZiBkZWxlZ2F0ZXNcbiAgICAgKiByZXF1aXJlZCB0byBncmFudCB0aGUgZmluYWwgYWNjZXNzX3Rva2VuLiBJZiBzZXQsIHRoZSBzZXF1ZW5jZSBvZlxuICAgICAqIGlkZW50aXRpZXMgbXVzdCBoYXZlIFwiU2VydmljZSBBY2NvdW50IFRva2VuIENyZWF0b3JcIiBjYXBhYmlsaXR5IGdyYW50ZWQgdG9cbiAgICAgKiB0aGUgcHJlY2VkaW5nIGlkZW50aXR5LiBGb3IgZXhhbXBsZSwgaWYgc2V0IHRvIFtzZXJ2aWNlQWNjb3VudEIsXG4gICAgICogc2VydmljZUFjY291bnRDXSwgdGhlIHNvdXJjZUNyZWRlbnRpYWwgbXVzdCBoYXZlIHRoZSBUb2tlbiBDcmVhdG9yIHJvbGUgb25cbiAgICAgKiBzZXJ2aWNlQWNjb3VudEIuIHNlcnZpY2VBY2NvdW50QiBtdXN0IGhhdmUgdGhlIFRva2VuIENyZWF0b3Igb25cbiAgICAgKiBzZXJ2aWNlQWNjb3VudEMuIEZpbmFsbHksIEMgbXVzdCBoYXZlIFRva2VuIENyZWF0b3Igb24gdGFyZ2V0X3ByaW5jaXBhbC5cbiAgICAgKiBJZiBsZWZ0IHVuc2V0LCBzb3VyY2VDcmVkZW50aWFsIG11c3QgaGF2ZSB0aGF0IHJvbGUgb24gdGFyZ2V0UHJpbmNpcGFsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLnRhcmdldFNjb3Blc10gc2NvcGVzIHRvIHJlcXVlc3QgZHVyaW5nIHRoZVxuICAgICAqIGF1dGhvcml6YXRpb24gZ3JhbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpZmV0aW1lXSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgZGVsZWdhdGVkXG4gICAgICogY3JlZGVudGlhbCBzaG91bGQgYmUgdmFsaWQgZm9yIHVwIHRvIDM2MDAgc2Vjb25kcyBieSBkZWZhdWx0LCBvciA0MywyMDBcbiAgICAgKiBzZWNvbmRzIGJ5IGV4dGVuZGluZyB0aGUgdG9rZW4ncyBsaWZldGltZSwgc2VlOlxuICAgICAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pYW0vZG9jcy9jcmVhdGluZy1zaG9ydC1saXZlZC1zZXJ2aWNlLWFjY291bnQtY3JlZGVudGlhbHMjc2EtY3JlZGVudGlhbHMtb2F1dGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kcG9pbnRdIGFwaSBlbmRwb2ludCBvdmVycmlkZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IDEsXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiAnaW1wZXJzb25hdGVkLXBsYWNlaG9sZGVyJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb3VyY2VDbGllbnQgPSAoX2EgPSBvcHRpb25zLnNvdXJjZUNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCgpO1xuICAgICAgICB0aGlzLnRhcmdldFByaW5jaXBhbCA9IChfYiA9IG9wdGlvbnMudGFyZ2V0UHJpbmNpcGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZXMgPSAoX2MgPSBvcHRpb25zLmRlbGVnYXRlcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgICAgIHRoaXMudGFyZ2V0U2NvcGVzID0gKF9kID0gb3B0aW9ucy50YXJnZXRTY29wZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdO1xuICAgICAgICB0aGlzLmxpZmV0aW1lID0gKF9lID0gb3B0aW9ucy5saWZldGltZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMzYwMDtcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IChfZiA9IG9wdGlvbnMuZW5kcG9pbnQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICdodHRwczovL2lhbWNyZWRlbnRpYWxzLmdvb2dsZWFwaXMuY29tJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBVbnVzZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gJ3Byb2plY3RzLy0vc2VydmljZUFjY291bnRzLycgKyB0aGlzLnRhcmdldFByaW5jaXBhbDtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBgJHt0aGlzLmVuZHBvaW50fS92MS8ke25hbWV9OmdlbmVyYXRlQWNjZXNzVG9rZW5gO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZXM6IHRoaXMuZGVsZWdhdGVzLFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnRhcmdldFNjb3BlcyxcbiAgICAgICAgICAgICAgICBsaWZldGltZTogdGhpcy5saWZldGltZSArICdzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNvdXJjZUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHUsXG4gICAgICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gPSB0b2tlblJlc3BvbnNlLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSA9IERhdGUucGFyc2UodG9rZW5SZXNwb25zZS5leHBpcmVUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gKF9jID0gKF9iID0gKF9hID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhdHVzO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAoX2YgPSAoX2UgPSAoX2QgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kYXRhKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZXJyb3IpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGAke3N0YXR1c306IHVuYWJsZSB0byBpbXBlcnNvbmF0ZTogJHttZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYHVuYWJsZSB0byBpbXBlcnNvbmF0ZTogJHtlcnJvcn1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBPcGVuSUQgQ29ubmVjdCBJRCB0b2tlbiBmb3IgYSBzZXJ2aWNlIGFjY291bnQuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lhbS9kb2NzL3JlZmVyZW5jZS9jcmVkZW50aWFscy9yZXN0L3YxL3Byb2plY3RzLnNlcnZpY2VBY2NvdW50cy9nZW5lcmF0ZUlkVG9rZW4gUmVmZXJlbmNlIERvY3VtZW50YXRpb259XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0QXVkaWVuY2UgdGhlIGF1ZGllbmNlIGZvciB0aGUgZmV0Y2hlZCBJRCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgZm9yIHRoZSByZXF1ZXN0XG4gICAgICogQHJldHVybiBhbiBPcGVuSUQgQ29ubmVjdCBJRCB0b2tlblxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgcHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvJHt0aGlzLnRhcmdldFByaW5jaXBhbH1gO1xuICAgICAgICBjb25zdCB1ID0gYCR7dGhpcy5lbmRwb2ludH0vdjEvJHtuYW1lfTpnZW5lcmF0ZUlkVG9rZW5gO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgZGVsZWdhdGVzOiB0aGlzLmRlbGVnYXRlcyxcbiAgICAgICAgICAgIGF1ZGllbmNlOiB0YXJnZXRBdWRpZW5jZSxcbiAgICAgICAgICAgIGluY2x1ZGVFbWFpbDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVFbWFpbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IHUsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLmRhdGEudG9rZW47XG4gICAgfVxufVxuZXhwb3J0cy5JbXBlcnNvbmF0ZWQgPSBJbXBlcnNvbmF0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbXBlcnNvbmF0ZWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtaccess.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JWTAccess = void 0;\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/google-auth-library/node_modules/lru-cache/index.js\");\nconst DEFAULT_HEADER = {\n    alg: 'RS256',\n    typ: 'JWT',\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */\n    constructor(email, key, keyId, eagerRefreshThresholdMillis) {\n        this.cache = new LRU({\n            max: 500,\n            maxAge: 60 * 60 * 1000,\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis =\n            eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */\n    getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\n        }\n        else if (typeof scopes === 'string') {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error('Scopes or url must be provided');\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */\n    getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken &&\n            cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(' ');\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat,\n            };\n        }\n        else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat,\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for (const claim in defaultClaims) {\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId\n            ? { ...DEFAULT_HEADER, kid: this.keyId }\n            : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\n        const headers = { Authorization: `Bearer ${signedJWT}` };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers,\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */\n    static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('data', chunk => (s += chunk))\n                .on('error', reject)\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceMappingURL=jwtaccess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RhY2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsWUFBWSxtQkFBTyxDQUFDLDhDQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQywyRkFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLEdBQUcsaUJBQWlCLE9BQU8saUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSSxHQUFHLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUNBQW1DO0FBQ3hFLDBCQUEwQix5QkFBeUIsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGFjY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE1IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KV1RBY2Nlc3MgPSB2b2lkIDA7XG5jb25zdCBqd3MgPSByZXF1aXJlKFwiandzXCIpO1xuY29uc3QgTFJVID0gcmVxdWlyZShcImxydS1jYWNoZVwiKTtcbmNvbnN0IERFRkFVTFRfSEVBREVSID0ge1xuICAgIGFsZzogJ1JTMjU2JyxcbiAgICB0eXA6ICdKV1QnLFxufTtcbmNsYXNzIEpXVEFjY2VzcyB7XG4gICAgLyoqXG4gICAgICogSldUQWNjZXNzIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4gYnkgdXNpbmcgdGhlIGNyZWRlbnRpYWwgdG8gY3JlYXRlIGEgbmV3IEpXVCB0b2tlblxuICAgICAqIHRoYXQncyByZWNvZ25pemVkIGFzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgdGhlIHNlcnZpY2UgYWNjb3VudCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBrZXlJZCB0aGUgSUQgb2YgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gc2lnbiB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW1haWwsIGtleSwga2V5SWQsIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IExSVSh7XG4gICAgICAgICAgICBtYXg6IDUwMCxcbiAgICAgICAgICAgIG1heEFnZTogNjAgKiA2MCAqIDEwMDAsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtYWlsID0gZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID1cbiAgICAgICAgICAgIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyAhPT0gbnVsbCAmJiBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgIT09IHZvaWQgMCA/IGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA6IDUgKiA2MCAqIDEwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB3ZSdyZSBjYWNoaW5nIGEga2V5IGFwcHJvcHJpYXRlbHksIGdpdmluZyBwcmVjZWRlbmNlIHRvIHNjb3BlcyB2cy4gdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkkgYmVpbmcgYXV0aG9yaXplZC5cbiAgICAgKiBAcGFyYW0gc2NvcGVzIFRoZSBzY29wZSBvciBzY29wZXMgYmVpbmcgYXV0aG9yaXplZFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHRoYXQgcmV0dXJucyB0aGUgY2FjaGVkIGtleS5cbiAgICAgKi9cbiAgICBnZXRDYWNoZWRLZXkodXJsLCBzY29wZXMpIHtcbiAgICAgICAgbGV0IGNhY2hlS2V5ID0gdXJsO1xuICAgICAgICBpZiAoc2NvcGVzICYmIEFycmF5LmlzQXJyYXkoc2NvcGVzKSAmJiBzY29wZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IHVybCA/IGAke3VybH1fJHtzY29wZXMuam9pbignXycpfWAgOiBgJHtzY29wZXMuam9pbignXycpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjb3BlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNhY2hlS2V5ID0gdXJsID8gYCR7dXJsfV8ke3Njb3Blc31gIDogc2NvcGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTY29wZXMgb3IgdXJsIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIG5vbi1leHBpcmVkIGFjY2VzcyB0b2tlbiwgYWZ0ZXIgcmVmcmVzaGluZyBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkkgYmVpbmcgYXV0aG9yaXplZC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENsYWltcyBBbiBvYmplY3Qgd2l0aCBhIHNldCBvZiBhZGRpdGlvbmFsIGNsYWltcyB0b1xuICAgICAqIGluY2x1ZGUgaW4gdGhlIHBheWxvYWQuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyLlxuICAgICAqL1xuICAgIGdldFJlcXVlc3RIZWFkZXJzKHVybCwgYWRkaXRpb25hbENsYWltcywgc2NvcGVzKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgYXV0aG9yaXphdGlvbiBoZWFkZXJzLCB1bmxlc3Mgd2UgYXJlIHdpdGhpblxuICAgICAgICAvLyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgbXMgb2YgdGhlbSBleHBpcmluZzpcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRDYWNoZWRLZXkodXJsLCBzY29wZXMpO1xuICAgICAgICBjb25zdCBjYWNoZWRUb2tlbiA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChjYWNoZWRUb2tlbiAmJlxuICAgICAgICAgICAgY2FjaGVkVG9rZW4uZXhwaXJhdGlvbiAtIG5vdyA+IHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVG9rZW4uaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgY29uc3QgZXhwID0gSldUQWNjZXNzLmdldEV4cGlyYXRpb25UaW1lKGlhdCk7XG4gICAgICAgIGxldCBkZWZhdWx0Q2xhaW1zO1xuICAgICAgICAvLyBUdXJuIHNjb3BlcyBpbnRvIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmdcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NvcGVzKSkge1xuICAgICAgICAgICAgc2NvcGVzID0gc2NvcGVzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzY29wZXMgYXJlIHNwZWNpZmllZCwgc2lnbiB3aXRoIHNjb3Blc1xuICAgICAgICBpZiAoc2NvcGVzKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2xhaW1zID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlcyxcbiAgICAgICAgICAgICAgICBleHAsXG4gICAgICAgICAgICAgICAgaWF0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRDbGFpbXMgPSB7XG4gICAgICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHN1YjogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBhdWQ6IHVybCxcbiAgICAgICAgICAgICAgICBleHAsXG4gICAgICAgICAgICAgICAgaWF0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhZGRpdGlvbmFsQ2xhaW1zIGFyZSBwcm92aWRlZCwgZW5zdXJlIHRoZXkgZG8gbm90IGNvbGxpZGUgd2l0aFxuICAgICAgICAvLyBvdGhlciByZXF1aXJlZCBjbGFpbXMuXG4gICAgICAgIGlmIChhZGRpdGlvbmFsQ2xhaW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsYWltIGluIGRlZmF1bHRDbGFpbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENsYWltc1tjbGFpbV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7Y2xhaW19JyBwcm9wZXJ0eSBpcyBub3QgYWxsb3dlZCB3aGVuIHBhc3NpbmcgYWRkaXRpb25hbENsYWltcy4gVGhpcyBjbGFpbSBpcyBpbmNsdWRlZCBpbiB0aGUgSldUIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMua2V5SWRcbiAgICAgICAgICAgID8geyAuLi5ERUZBVUxUX0hFQURFUiwga2lkOiB0aGlzLmtleUlkIH1cbiAgICAgICAgICAgIDogREVGQVVMVF9IRUFERVI7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRDbGFpbXMsIGFkZGl0aW9uYWxDbGFpbXMpO1xuICAgICAgICAvLyBTaWduIHRoZSBqd3QgYW5kIGFkZCBpdCB0byB0aGUgY2FjaGVcbiAgICAgICAgY29uc3Qgc2lnbmVkSldUID0gandzLnNpZ24oeyBoZWFkZXIsIHBheWxvYWQsIHNlY3JldDogdGhpcy5rZXkgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtzaWduZWRKV1R9YCB9O1xuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHtcbiAgICAgICAgICAgIGV4cGlyYXRpb246IGV4cCAqIDEwMDAsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgSldUIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlhdCBUaGUgaXNzdWVkIGF0IHRpbWUgZm9yIHRoZSBKV1QuXG4gICAgICogQHJldHVybnMgQW4gZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgSldULlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRFeHBpcmF0aW9uVGltZShpYXQpIHtcbiAgICAgICAgY29uc3QgZXhwID0gaWF0ICsgMzYwMDsgLy8gMzYwMCBzZWNvbmRzID0gMSBob3VyXG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEpXVEFjY2VzcyBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5jbGllbnRfZW1haWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBjbGllbnRfZW1haWwgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24ucHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBwcml2YXRlX2tleSBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGpzb24ga2V5IGZpbGUuXG4gICAgICAgIHRoaXMuZW1haWwgPSBqc29uLmNsaWVudF9lbWFpbDtcbiAgICAgICAgdGhpcy5rZXkgPSBqc29uLnByaXZhdGVfa2V5O1xuICAgICAgICB0aGlzLmtleUlkID0ganNvbi5wcml2YXRlX2tleV9pZDtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBqc29uLnByb2plY3RfaWQ7XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pLnRoZW4oKCkgPT4gY2FsbGJhY2soKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBzdHJlYW0gY29udGFpbmluZyB0aGUgc2VydmljZSBhY2NvdW50IGF1dGggc2V0dGluZ3MuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2RhdGEnLCBjaHVuayA9PiAocyArPSBjaHVuaykpXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkpXVEFjY2VzcyA9IEpXVEFjY2Vzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWp3dGFjY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JWT = void 0;\nconst gtoken_1 = __webpack_require__(/*! gtoken */ \"(rsc)/./node_modules/gtoken/build/src/index.js\");\nconst jwtaccess_1 = __webpack_require__(/*! ./jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {\n        const opts = optionsOrEmail && typeof optionsOrEmail === 'object'\n            ? optionsOrEmail\n            : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };\n        super({\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure,\n        });\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        this.credentials = { refresh_token: 'jwt-placeholder', expiry_date: 1 };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */\n    createScoped(scopes) {\n        return new JWT({\n            email: this.email,\n            keyFile: this.keyFile,\n            key: this.key,\n            keyId: this.keyId,\n            scopes,\n            subject: this.subject,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */\n    async getRequestMetadataAsync(url) {\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\n        const useSelfSignedJWT = (!this.hasUserScopes() && url) ||\n            (this.useJWTAccessWithScope && this.hasAnyScopes());\n        if (!this.apiKey && useSelfSignedJWT) {\n            if (this.additionalClaims &&\n                this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`,\n                    }),\n                };\n            }\n            else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                let scopes;\n                if (this.hasUserScopes()) {\n                    scopes = this.scopes;\n                }\n                else if (!url) {\n                    scopes = this.defaultScopes;\n                }\n                const headers = await this.access.getRequestHeaders(url !== null && url !== void 0 ? url : undefined, this.additionalClaims, \n                // Scopes take precedent over audience for signing,\n                // so we only provide them if useJWTAccessWithScope is on\n                this.useJWTAccessWithScope ? scopes : undefined);\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        }\n        else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return { headers: {} };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n    async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: { target_audience: targetAudience },\n            transporter: this.transporter,\n        });\n        await gtoken.getToken({\n            forceRefresh: true,\n        });\n        if (!gtoken.idToken) {\n            throw new Error('Unknown error: Failed to fetch ID token');\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */\n    hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */\n    hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0)\n            return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0)\n            return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error('No result returned');\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = 'jwt-placeholder';\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring(),\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: 'Bearer',\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken,\n        };\n        this.emit('tokens', tokens);\n        return { res: null, tokens };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */\n    createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n                transporter: this.transporter,\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the service account auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */\n    fromAPIKey(apiKey) {\n        if (typeof apiKey !== 'string') {\n            throw new Error('Must provide an API Key string.');\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */\n    async getCredentials() {\n        if (this.key) {\n            return { private_key: this.key, client_email: this.email };\n        }\n        else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return { private_key: creds.privateKey, client_email: creds.clientEmail };\n        }\n        throw new Error('A key or a keyFile must be provided to getCredentials.');\n    }\n}\nexports.JWT = JWT;\n//# sourceMappingURL=jwtclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsaUJBQWlCLG1CQUFPLENBQUMsOERBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsd0JBQXdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxMyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSldUID0gdm9pZCAwO1xuY29uc3QgZ3Rva2VuXzEgPSByZXF1aXJlKFwiZ3Rva2VuXCIpO1xuY29uc3Qgand0YWNjZXNzXzEgPSByZXF1aXJlKFwiLi9qd3RhY2Nlc3NcIik7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNsYXNzIEpXVCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc09yRW1haWwsIGtleUZpbGUsIGtleSwgc2NvcGVzLCBzdWJqZWN0LCBrZXlJZCkge1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc09yRW1haWwgJiYgdHlwZW9mIG9wdGlvbnNPckVtYWlsID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBvcHRpb25zT3JFbWFpbFxuICAgICAgICAgICAgOiB7IGVtYWlsOiBvcHRpb25zT3JFbWFpbCwga2V5RmlsZSwga2V5LCBrZXlJZCwgc2NvcGVzLCBzdWJqZWN0IH07XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpczogb3B0cy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsXG4gICAgICAgICAgICBmb3JjZVJlZnJlc2hPbkZhaWx1cmU6IG9wdHMuZm9yY2VSZWZyZXNoT25GYWlsdXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IG9wdHMuZW1haWw7XG4gICAgICAgIHRoaXMua2V5RmlsZSA9IG9wdHMua2V5RmlsZTtcbiAgICAgICAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IG9wdHMua2V5SWQ7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gb3B0cy5zY29wZXM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG9wdHMuc3ViamVjdDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsQ2xhaW1zID0gb3B0cy5hZGRpdGlvbmFsQ2xhaW1zO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0geyByZWZyZXNoX3Rva2VuOiAnand0LXBsYWNlaG9sZGVyJywgZXhwaXJ5X2RhdGU6IDEgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGNyZWRlbnRpYWwgd2l0aCB0aGUgc3BlY2lmaWVkIHNjb3Blcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVzIExpc3Qgb2YgcmVxdWVzdGVkIHNjb3BlcyBvciBhIHNpbmdsZSBzY29wZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBjbG9uZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGVkKHNjb3Blcykge1xuICAgICAgICByZXR1cm4gbmV3IEpXVCh7XG4gICAgICAgICAgICBlbWFpbDogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgIGtleUZpbGU6IHRoaXMua2V5RmlsZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBrZXlJZDogdGhpcy5rZXlJZCxcbiAgICAgICAgICAgIHNjb3BlcyxcbiAgICAgICAgICAgIHN1YmplY3Q6IHRoaXMuc3ViamVjdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFpbXM6IHRoaXMuYWRkaXRpb25hbENsYWltcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgdGhlIG1ldGFkYXRhIHRvIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgdGhlIFVSSSBiZWluZyBhdXRob3JpemVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCkge1xuICAgICAgICB1cmwgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlUGF0aCA/IGBodHRwczovLyR7dGhpcy5kZWZhdWx0U2VydmljZVBhdGh9L2AgOiB1cmw7XG4gICAgICAgIGNvbnN0IHVzZVNlbGZTaWduZWRKV1QgPSAoIXRoaXMuaGFzVXNlclNjb3BlcygpICYmIHVybCkgfHxcbiAgICAgICAgICAgICh0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZSAmJiB0aGlzLmhhc0FueVNjb3BlcygpKTtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSAmJiB1c2VTZWxmU2lnbmVkSldUKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRpdGlvbmFsQ2xhaW1zICYmXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLnRhcmdldF9hdWRpZW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbnMuaWRfdG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIHNjb3BlcyBoYXZlIGJlZW4gc2V0LCBidXQgYSB1cmkgaGFzIGJlZW4gcHJvdmlkZWQuIFVzZSBKV1RBY2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBjcmVkZW50aWFscy5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXNzID0gbmV3IGp3dGFjY2Vzc18xLkpXVEFjY2Vzcyh0aGlzLmVtYWlsLCB0aGlzLmtleSwgdGhpcy5rZXlJZCwgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1VzZXJTY29wZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZXMgPSB0aGlzLnNjb3BlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZXMgPSB0aGlzLmRlZmF1bHRTY29wZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCB0aGlzLmFjY2Vzcy5nZXRSZXF1ZXN0SGVhZGVycyh1cmwgIT09IG51bGwgJiYgdXJsICE9PSB2b2lkIDAgPyB1cmwgOiB1bmRlZmluZWQsIHRoaXMuYWRkaXRpb25hbENsYWltcywgXG4gICAgICAgICAgICAgICAgLy8gU2NvcGVzIHRha2UgcHJlY2VkZW50IG92ZXIgYXVkaWVuY2UgZm9yIHNpZ25pbmcsXG4gICAgICAgICAgICAgICAgLy8gc28gd2Ugb25seSBwcm92aWRlIHRoZW0gaWYgdXNlSldUQWNjZXNzV2l0aFNjb3BlIGlzIG9uXG4gICAgICAgICAgICAgICAgdGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgPyBzY29wZXMgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNBbnlTY29wZXMoKSB8fCB0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhdWRpZW5jZSwgYXBpS2V5LCBvciBzY29wZXMgYXJlIHByb3ZpZGVkLCB3ZSBzaG91bGQgbm90IGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIHBvcHVsYXRlIGFueSBoZWFkZXJzOlxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczoge30gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ1Rva2VuIGZvciBmZXRjaGluZyBhbiBJRCB0b2tlblxuICAgICAgICBjb25zdCBndG9rZW4gPSBuZXcgZ3Rva2VuXzEuR29vZ2xlVG9rZW4oe1xuICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgc3ViOiB0aGlzLnN1YmplY3QsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZXMgfHwgdGhpcy5kZWZhdWx0U2NvcGVzLFxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFpbXM6IHsgdGFyZ2V0X2F1ZGllbmNlOiB0YXJnZXRBdWRpZW5jZSB9LFxuICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHRoaXMudHJhbnNwb3J0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFndG9rZW4uaWRUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVycm9yOiBGYWlsZWQgdG8gZmV0Y2ggSUQgdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3Rva2VuLmlkVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGVyZSBhcmUgY3VycmVudGx5IHNjb3BlcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgaGFzVXNlclNjb3BlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcmUgdGhlcmUgYW55IGRlZmF1bHQgb3IgdXNlciBzY29wZXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBoYXNBbnlTY29wZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlcyAmJiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRTY29wZXMgJiYgdGhpcy5kZWZhdWx0U2NvcGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml6ZUFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemVBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF1dGhvcml6ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXN1bHQgcmV0dXJuZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gcmVzdWx0LnRva2VucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0gJ2p3dC1wbGFjZWhvbGRlcic7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5ndG9rZW4ua2V5O1xuICAgICAgICB0aGlzLmVtYWlsID0gdGhpcy5ndG9rZW4uaXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBpZ25vcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZ3Rva2VuID0gdGhpcy5jcmVhdGVHVG9rZW4oKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0aGlzLmlzVG9rZW5FeHBpcmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBndG9rZW4uZXhwaXJlc0F0LFxuICAgICAgICAgICAgaWRfdG9rZW46IGd0b2tlbi5pZFRva2VuLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHJlczogbnVsbCwgdG9rZW5zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdUb2tlbiBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgY3JlYXRlR1Rva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmd0b2tlbiA9IG5ldyBndG9rZW5fMS5Hb29nbGVUb2tlbih7XG4gICAgICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHN1YjogdGhpcy5zdWJqZWN0LFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlcyB8fCB0aGlzLmRlZmF1bHRTY29wZXMsXG4gICAgICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB0aGlzLnRyYW5zcG9ydGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1QgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0ganNvbi5xdW90YV9wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBzdHJlYW0gY29udGFpbmluZyB0aGUgc2VydmljZSBhY2NvdW50IGF1dGggc2V0dGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBKV1QgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgYW4gQVBJIEtleSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogQHBhcmFtIGFwaUtleSBUaGUgQVBJIEtleSBpbiBzdHJpbmcgZm9ybS5cbiAgICAgKi9cbiAgICBmcm9tQVBJS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIEFQSSBLZXkgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyB0aGUga2V5IG9yIGtleUZpbGUgb24gdGhlIEpXVCBjbGllbnQsIG9idGFpbiBhbiBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHRoZSBrZXkgYW5kIHRoZSBjbGllbnQgZW1haWwuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3JlZGVudGlhbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZV9rZXk6IHRoaXMua2V5LCBjbGllbnRfZW1haWw6IHRoaXMuZW1haWwgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmtleUZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGd0b2tlbiA9IHRoaXMuY3JlYXRlR1Rva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IGd0b2tlbi5nZXRDcmVkZW50aWFscyh0aGlzLmtleUZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZV9rZXk6IGNyZWRzLnByaXZhdGVLZXksIGNsaWVudF9lbWFpbDogY3JlZHMuY2xpZW50RW1haWwgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ega2V5IG9yIGEga2V5RmlsZSBtdXN0IGJlIHByb3ZpZGVkIHRvIGdldENyZWRlbnRpYWxzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuSldUID0gSldUO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9and0Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js":
/*!************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/loginticket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoginTicket = void 0;\nclass LoginTicket {\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @param {string} env Envelope of the jwt\n     * @param {TokenPayload} pay Payload of the jwt\n     * @constructor\n     */\n    constructor(env, pay) {\n        this.envelope = env;\n        this.payload = pay;\n    }\n    getEnvelope() {\n        return this.envelope;\n    }\n    getPayload() {\n        return this.payload;\n    }\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @return The user ID\n     */\n    getUserId() {\n        const payload = this.getPayload();\n        if (payload && payload.sub) {\n            return payload.sub;\n        }\n        return null;\n    }\n    /**\n     * Returns attributes from the login ticket.  This can contain\n     * various information about the user session.\n     *\n     * @return The envelope and payload\n     */\n    getAttributes() {\n        return { envelope: this.getEnvelope(), payload: this.getPayload() };\n    }\n}\nexports.LoginTicket = LoginTicket;\n//# sourceMappingURL=loginticket.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9sb2dpbnRpY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9sb2dpbnRpY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dpblRpY2tldCA9IHZvaWQgMDtcbmNsYXNzIExvZ2luVGlja2V0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW1wbGUgY2xhc3MgdG8gZXh0cmFjdCB1c2VyIElEIGZyb20gYW4gSUQgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnYgRW52ZWxvcGUgb2YgdGhlIGp3dFxuICAgICAqIEBwYXJhbSB7VG9rZW5QYXlsb2FkfSBwYXkgUGF5bG9hZCBvZiB0aGUgand0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZW52LCBwYXkpIHtcbiAgICAgICAgdGhpcy5lbnZlbG9wZSA9IGVudjtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5O1xuICAgIH1cbiAgICBnZXRFbnZlbG9wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW52ZWxvcGU7XG4gICAgfVxuICAgIGdldFBheWxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNpbXBsZSBjbGFzcyB0byBleHRyYWN0IHVzZXIgSUQgZnJvbSBhbiBJRCBUb2tlblxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgdXNlciBJRFxuICAgICAqL1xuICAgIGdldFVzZXJJZCgpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZCgpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLnN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuc3ViO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbG9naW4gdGlja2V0LiAgVGhpcyBjYW4gY29udGFpblxuICAgICAqIHZhcmlvdXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGVudmVsb3BlIGFuZCBwYXlsb2FkXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHsgZW52ZWxvcGU6IHRoaXMuZ2V0RW52ZWxvcGUoKSwgcGF5bG9hZDogdGhpcy5nZXRQYXlsb2FkKCkgfTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2luVGlja2V0ID0gTG9naW5UaWNrZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dpbnRpY2tldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2client.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst formatEcdsa = __webpack_require__(/*! ecdsa-sig-formatter */ \"(rsc)/./node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst loginticket_1 = __webpack_require__(/*! ./loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return (rootUrl +\n            '?' +\n            querystring.stringify(opts));\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: options.codeVerifier,\n        };\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(values),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n        }\n        catch (e) {\n            if (e instanceof gaxios_1.GaxiosError &&\n                e.message === 'invalid_grant' &&\n                ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) &&\n                /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return { token: this.credentials.access_token };\n                    }\n                }\n                else {\n                    throw new Error('No refresh token or refresh handler callback is set.');\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token &&\n            !thisCreds.refresh_token &&\n            !this.apiKey &&\n            !this.refreshHandler) {\n            throw new Error('No access, refresh token, API key or refresh handler callback is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            };\n            return { headers: this.addSharedMetadataHeaders(headers) };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: 'Bearer ' + this.credentials.access_token,\n                };\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        if (this.apiKey) {\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\n        };\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST',\n        };\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials &&\n                    this.credentials.access_token &&\n                    !this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&\n                    this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n                else if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                Authorization: `Bearer ${accessToken}`,\n            },\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp('max-age=([0-9]*)');\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */\n    async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error('No access token is returned by the refreshHandler callback.');\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = [\n    'accounts.google.com',\n    'https://accounts.google.com',\n];\n//# sourceMappingURL=oauth2client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkI7QUFDOUUsaUJBQWlCLG1CQUFPLENBQUMsOERBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLGdHQUFxQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBa0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RCwyQkFBMkIsS0FBSztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELHlCQUF5QixLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOERBQThELHNCQUFzQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQXFEO0FBQzVFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQXFEO0FBQ2hGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQsa0JBQWtCLHVDQUF1QyxHQUFHLFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRCxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxVQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxZQUFZLEtBQUssWUFBWTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gZXhwb3J0cy5DZXJ0aWZpY2F0ZUZvcm1hdCA9IGV4cG9ydHMuQ29kZUNoYWxsZW5nZU1ldGhvZCA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGZvcm1hdEVjZHNhID0gcmVxdWlyZShcImVjZHNhLXNpZy1mb3JtYXR0ZXJcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IGxvZ2ludGlja2V0XzEgPSByZXF1aXJlKFwiLi9sb2dpbnRpY2tldFwiKTtcbnZhciBDb2RlQ2hhbGxlbmdlTWV0aG9kO1xuKGZ1bmN0aW9uIChDb2RlQ2hhbGxlbmdlTWV0aG9kKSB7XG4gICAgQ29kZUNoYWxsZW5nZU1ldGhvZFtcIlBsYWluXCJdID0gXCJwbGFpblwiO1xuICAgIENvZGVDaGFsbGVuZ2VNZXRob2RbXCJTMjU2XCJdID0gXCJTMjU2XCI7XG59KShDb2RlQ2hhbGxlbmdlTWV0aG9kID0gZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kIHx8IChleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSB7fSkpO1xudmFyIENlcnRpZmljYXRlRm9ybWF0O1xuKGZ1bmN0aW9uIChDZXJ0aWZpY2F0ZUZvcm1hdCkge1xuICAgIENlcnRpZmljYXRlRm9ybWF0W1wiUEVNXCJdID0gXCJQRU1cIjtcbiAgICBDZXJ0aWZpY2F0ZUZvcm1hdFtcIkpXS1wiXSA9IFwiSldLXCI7XG59KShDZXJ0aWZpY2F0ZUZvcm1hdCA9IGV4cG9ydHMuQ2VydGlmaWNhdGVGb3JtYXQgfHwgKGV4cG9ydHMuQ2VydGlmaWNhdGVGb3JtYXQgPSB7fSkpO1xuY2xhc3MgT0F1dGgyQ2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnNPckNsaWVudElkLCBjbGllbnRTZWNyZXQsIHJlZGlyZWN0VXJpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0ID0gQ2VydGlmaWNhdGVGb3JtYXQuUEVNO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc09yQ2xpZW50SWQgJiYgdHlwZW9mIG9wdGlvbnNPckNsaWVudElkID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBvcHRpb25zT3JDbGllbnRJZFxuICAgICAgICAgICAgOiB7IGNsaWVudElkOiBvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWRpcmVjdFVyaSB9O1xuICAgICAgICB0aGlzLl9jbGllbnRJZCA9IG9wdHMuY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IG9wdHMuY2xpZW50U2VjcmV0O1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJpID0gb3B0cy5yZWRpcmVjdFVyaTtcbiAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPVxuICAgICAgICAgICAgb3B0cy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgfHwgNSAqIDYwICogMTAwMDtcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSAhIW9wdHMuZm9yY2VSZWZyZXNoT25GYWlsdXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgVVJMIGZvciBjb25zZW50IHBhZ2UgbGFuZGluZy5cbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zLlxuICAgICAqIEByZXR1cm4gVVJMIHRvIGNvbnNlbnQgcGFnZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUF1dGhVcmwob3B0cyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRzLmNvZGVfY2hhbGxlbmdlX21ldGhvZCAmJiAhb3B0cy5jb2RlX2NoYWxsZW5nZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiBhIGNvZGVfY2hhbGxlbmdlX21ldGhvZCBpcyBwcm92aWRlZCwgY29kZV9jaGFsbGVuZ2UgbXVzdCBiZSBpbmNsdWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLnJlc3BvbnNlX3R5cGUgPSBvcHRzLnJlc3BvbnNlX3R5cGUgfHwgJ2NvZGUnO1xuICAgICAgICBvcHRzLmNsaWVudF9pZCA9IG9wdHMuY2xpZW50X2lkIHx8IHRoaXMuX2NsaWVudElkO1xuICAgICAgICBvcHRzLnJlZGlyZWN0X3VyaSA9IG9wdHMucmVkaXJlY3RfdXJpIHx8IHRoaXMucmVkaXJlY3RVcmk7XG4gICAgICAgIC8vIEFsbG93IHNjb3BlcyB0byBiZSBwYXNzZWQgZWl0aGVyIGFzIGFycmF5IG9yIGEgc3RyaW5nXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdHMuc2NvcGUpKSB7XG4gICAgICAgICAgICBvcHRzLnNjb3BlID0gb3B0cy5zY29wZS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdFVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0FVVEhfQkFTRV9VUkxfO1xuICAgICAgICByZXR1cm4gKHJvb3RVcmwgK1xuICAgICAgICAgICAgJz8nICtcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShvcHRzKSk7XG4gICAgfVxuICAgIGdlbmVyYXRlQ29kZVZlcmlmaWVyKCkge1xuICAgICAgICAvLyBUbyBtYWtlIHRoZSBjb2RlIGNvbXBhdGlibGUgd2l0aCBicm93c2VyIFN1YnRsZUNyeXB0byB3ZSBuZWVkIHRvIG1ha2VcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgYXN5bmMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVDb2RlVmVyaWZpZXIgaXMgcmVtb3ZlZCwgcGxlYXNlIHVzZSBnZW5lcmF0ZUNvZGVWZXJpZmllckFzeW5jIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGEgY29kZV92ZXJpZmllciwgYW5kIGl0c1xuICAgICAqIHJlc3VsdGluZyBTSEEyNTYuIElmIHVzZWQsIHRoaXMgbXVzdCBiZSBwYWlyZWQgd2l0aCBhIFMyNTZcbiAgICAgKiBjb2RlX2NoYWxsZW5nZV9tZXRob2QuXG4gICAgICpcbiAgICAgKiBGb3IgYSBmdWxsIGV4YW1wbGUgc2VlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZS1hdXRoLWxpYnJhcnktbm9kZWpzL2Jsb2IvbWFpbi9zYW1wbGVzL29hdXRoMi1jb2RlVmVyaWZpZXIuanNcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUNvZGVWZXJpZmllckFzeW5jKCkge1xuICAgICAgICAvLyBiYXNlNjQgZW5jb2RpbmcgdXNlcyA2IGJpdHMgcGVyIGNoYXJhY3RlciwgYW5kIHdlIHdhbnQgdG8gZ2VuZXJhdGUxMjhcbiAgICAgICAgLy8gY2hhcmFjdGVycy4gNioxMjgvOCA9IDk2LlxuICAgICAgICBjb25zdCBjcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgICAgICBjb25zdCByYW5kb21TdHJpbmcgPSBjcnlwdG8ucmFuZG9tQnl0ZXNCYXNlNjQoOTYpO1xuICAgICAgICAvLyBUaGUgdmFsaWQgY2hhcmFjdGVycyBpbiB0aGUgY29kZV92ZXJpZmllciBhcmUgW0EtWl0vW2Etel0vWzAtOV0vXG4gICAgICAgIC8vIFwiLVwiL1wiLlwiL1wiX1wiL1wiflwiLiBCYXNlNjQgZW5jb2RlZCBzdHJpbmdzIGFyZSBwcmV0dHkgY2xvc2UsIHNvIHdlJ3JlIGp1c3RcbiAgICAgICAgLy8gc3dhcHBpbmcgb3V0IGEgZmV3IGNoYXJzLlxuICAgICAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSByYW5kb21TdHJpbmdcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJ34nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz0vZywgJ18nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnLScpO1xuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgYmFzZTY0IGVuY29kZWQgU0hBMjU2XG4gICAgICAgIGNvbnN0IHVuZW5jb2RlZENvZGVDaGFsbGVuZ2UgPSBhd2FpdCBjcnlwdG8uc2hhMjU2RGlnZXN0QmFzZTY0KGNvZGVWZXJpZmllcik7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGJhc2U2NFVybEVuY29kaW5nIGluc3RlYWQgb2Ygc3RhbmRhcmQgYmFzZTY0XG4gICAgICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSB1bmVuY29kZWRDb2RlQ2hhbGxlbmdlXG4gICAgICAgICAgICAuc3BsaXQoJz0nKVswXVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG4gICAgICAgIHJldHVybiB7IGNvZGVWZXJpZmllciwgY29kZUNoYWxsZW5nZSB9O1xuICAgIH1cbiAgICBnZXRUb2tlbihjb2RlT3JPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGNvZGVPck9wdGlvbnMgPT09ICdzdHJpbmcnID8geyBjb2RlOiBjb2RlT3JPcHRpb25zIH0gOiBjb2RlT3JPcHRpb25zO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5Bc3luYyhvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci50b2tlbnMsIHIucmVzKSwgZSA9PiBjYWxsYmFjayhlLCBudWxsLCBlLnJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkFzeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuQXN5bmMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9UT0tFTl9VUkxfO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICBjb2RlOiBvcHRpb25zLmNvZGUsXG4gICAgICAgICAgICBjbGllbnRfaWQ6IG9wdGlvbnMuY2xpZW50X2lkIHx8IHRoaXMuX2NsaWVudElkLFxuICAgICAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5fY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgcmVkaXJlY3RfdXJpOiBvcHRpb25zLnJlZGlyZWN0X3VyaSB8fCB0aGlzLnJlZGlyZWN0VXJpLFxuICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBvcHRpb25zLmNvZGVWZXJpZmllcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgZGF0YTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHZhbHVlcyksXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gcmVzLmRhdGE7XG4gICAgICAgIGlmIChyZXMuZGF0YSAmJiByZXMuZGF0YS5leHBpcmVzX2luKSB7XG4gICAgICAgICAgICB0b2tlbnMuZXhwaXJ5X2RhdGUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHJlcy5kYXRhLmV4cGlyZXNfaW4gKiAxMDAwO1xuICAgICAgICAgICAgZGVsZXRlIHRva2Vucy5leHBpcmVzX2luO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndG9rZW5zJywgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW5zLCByZXMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hfdG9rZW4gRXhpc3RpbmcgcmVmcmVzaCB0b2tlbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hUb2tlbk5vQ2FjaGUocmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHJlcXVlc3QgdG8gcmVmcmVzaCB1c2luZyB0aGUgc2FtZSB0b2tlbiBoYXMgc3RhcnRlZCxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzYW1lIHByb21pc2UuXG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmhhcyhyZWZyZXNoVG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5nZXQocmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gdGhpcy5yZWZyZXNoVG9rZW5Ob0NhY2hlKHJlZnJlc2hUb2tlbikudGhlbihyID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuZGVsZXRlKHJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmRlbGV0ZShyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuc2V0KHJlZnJlc2hUb2tlbiwgcCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKHJlZnJlc2hUb2tlbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gaXMgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX1RPS0VOX1VSTF87XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuX2NsaWVudElkLFxuICAgICAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5fY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBmb3IgbmV3IHRva2VuXG4gICAgICAgICAgICByZXMgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID09PSAnaW52YWxpZF9ncmFudCcgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gZS5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICYmXG4gICAgICAgICAgICAgICAgL1JlQXV0aC9pLnRlc3QoZS5yZXNwb25zZS5kYXRhLmVycm9yX2Rlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGUucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHJlcy5kYXRhO1xuICAgICAgICAvLyBUT0RPOiBkZS1kdXBsaWNhdGUgdGhpcyBjb2RlIGZyb20gYSBmZXcgc3BvdHNcbiAgICAgICAgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcmVzLmRhdGEuZXhwaXJlc19pbiAqIDEwMDA7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW5zLmV4cGlyZXNfaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4geyB0b2tlbnMsIHJlcyB9O1xuICAgIH1cbiAgICByZWZyZXNoQWNjZXNzVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIuY3JlZGVudGlhbHMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbik7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHIudG9rZW5zO1xuICAgICAgICB0b2tlbnMucmVmcmVzaF90b2tlbiA9IHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRva2VucztcbiAgICAgICAgcmV0dXJuIHsgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsIHJlczogci5yZXMgfTtcbiAgICB9XG4gICAgZ2V0QWNjZXNzVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFjY2Vzc1Rva2VuQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci50b2tlbiwgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVmcmVzaCA9ICF0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiB8fCB0aGlzLmlzVG9rZW5FeHBpcmluZygpO1xuICAgICAgICBpZiAoc2hvdWxkUmVmcmVzaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVmcmVzaCB0b2tlbiBvciByZWZyZXNoIGhhbmRsZXIgY2FsbGJhY2sgaXMgc2V0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICBpZiAoIXIuY3JlZGVudGlhbHMgfHwgKHIuY3JlZGVudGlhbHMgJiYgIXIuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHIuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuLCByZXM6IHIucmVzIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b2tlbjogdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBhdXRoZW50aWNhdGlvbiBpbnRlcmZhY2UuICBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEluIE9BdXRoMkNsaWVudCwgdGhlIHJlc3VsdCBoYXMgdGhlIGZvcm06XG4gICAgICogeyBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDxhY2Nlc3NfdG9rZW5fdmFsdWU+JyB9XG4gICAgICogQHBhcmFtIHVybCBUaGUgb3B0aW9uYWwgdXJsIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyh1cmwpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IChhd2FpdCB0aGlzLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCkpLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdXJsKSB7XG4gICAgICAgIGNvbnN0IHRoaXNDcmVkcyA9IHRoaXMuY3JlZGVudGlhbHM7XG4gICAgICAgIGlmICghdGhpc0NyZWRzLmFjY2Vzc190b2tlbiAmJlxuICAgICAgICAgICAgIXRoaXNDcmVkcy5yZWZyZXNoX3Rva2VuICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlLZXkgJiZcbiAgICAgICAgICAgICF0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcywgcmVmcmVzaCB0b2tlbiwgQVBJIGtleSBvciByZWZyZXNoIGhhbmRsZXIgY2FsbGJhY2sgaXMgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzQ3JlZHMuYWNjZXNzX3Rva2VuICYmICF0aGlzLmlzVG9rZW5FeHBpcmluZygpKSB7XG4gICAgICAgICAgICB0aGlzQ3JlZHMudG9rZW5fdHlwZSA9IHRoaXNDcmVkcy50b2tlbl90eXBlIHx8ICdCZWFyZXInO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzQ3JlZHMudG9rZW5fdHlwZSArICcgJyArIHRoaXNDcmVkcy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiByZWZyZXNoSGFuZGxlciBleGlzdHMsIGNhbGwgcHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKS5cbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5wcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENyZWRlbnRpYWxzKHJlZnJlc2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB7ICdYLUdvb2ctQXBpLUtleSc6IHRoaXMuYXBpS2V5IH0gfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgciA9IG51bGw7XG4gICAgICAgIGxldCB0b2tlbnMgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgciA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKHRoaXNDcmVkcy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIHRva2VucyA9IHIudG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcnI7XG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgIChlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzIHx8IGUucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCByZWZyZXNoIGFjY2VzcyB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmNyZWRlbnRpYWxzO1xuICAgICAgICBjcmVkZW50aWFscy50b2tlbl90eXBlID0gY3JlZGVudGlhbHMudG9rZW5fdHlwZSB8fCAnQmVhcmVyJztcbiAgICAgICAgdG9rZW5zLnJlZnJlc2hfdG9rZW4gPSBjcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdG9rZW5zO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogY3JlZGVudGlhbHMudG9rZW5fdHlwZSArICcgJyArIHRva2Vucy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpLCByZXM6IHIucmVzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBVUkwgdG8gcmV2b2tlIHRoZSBnaXZlbiB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGV4aXN0aW5nIHRva2VuIHRvIGJlIHJldm9rZWQuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJldm9rZVRva2VuVXJsKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkoeyB0b2tlbiB9KTtcbiAgICAgICAgcmV0dXJuIGAke09BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX1JFVk9LRV9VUkxffT8ke3BhcmFtZXRlcnN9YDtcbiAgICB9XG4gICAgcmV2b2tlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IE9BdXRoMkNsaWVudC5nZXRSZXZva2VUb2tlblVybCh0b2tlbiksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyXG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qob3B0cylcbiAgICAgICAgICAgICAgICAudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldm9rZUNyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXZva2VDcmVkZW50aWFsc0FzeW5jKCkudGhlbihyZXMgPT4gY2FsbGJhY2sobnVsbCwgcmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2b2tlQ3JlZGVudGlhbHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldm9rZUNyZWRlbnRpYWxzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZva2VUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiB0byByZXZva2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJldHJ5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdE1ldGFkYXRhQXN5bmMob3B0cy51cmwpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHIuaGVhZGVycyAmJiByLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddID0gci5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoci5oZWFkZXJzICYmIHIuaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSByLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snWC1Hb29nLUFwaS1LZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcjIgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgZm9yIG1ldGFkYXRhIGlmIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIEFuIGFjY2Vzc190b2tlbiBhbmQgcmVmcmVzaF90b2tlbiB3ZXJlIGF2YWlsYWJsZSwgYnV0IGVpdGhlciBub1xuICAgICAgICAgICAgICAgIC8vICAgZXhwaXJ5X2RhdGUgd2FzIGF2YWlsYWJsZSBvciB0aGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlIGZsYWcgaXMgc2V0LlxuICAgICAgICAgICAgICAgIC8vICAgVGhlIGFic2VudCBleHBpcnlfZGF0ZSBjYXNlIGNhbiBoYXBwZW4gd2hlbiBkZXZlbG9wZXJzIHN0YXNoIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgYWNjZXNzX3Rva2VuIGFuZCByZWZyZXNoX3Rva2VuIGZvciBsYXRlciB1c2UsIGJ1dCB0aGUgYWNjZXNzX3Rva2VuXG4gICAgICAgICAgICAgICAgLy8gICBmYWlscyBvbiB0aGUgZmlyc3QgdHJ5IGJlY2F1c2UgaXQncyBleHBpcmVkLiBTb21lIGRldmVsb3BlcnMgbWF5XG4gICAgICAgICAgICAgICAgLy8gICBjaG9vc2UgdG8gZW5hYmxlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSB0byBtaXRpZ2F0ZSB0aW1lLXJlbGF0ZWRcbiAgICAgICAgICAgICAgICAvLyAgIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBPciB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBObyByZWZyZXNoX3Rva2VuIHdhcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAvLyAtIEFuIGFjY2Vzc190b2tlbiBhbmQgYSByZWZyZXNoSGFuZGxlciBjYWxsYmFjayB3ZXJlIGF2YWlsYWJsZSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gICBlaXRoZXIgbm8gZXhwaXJ5X2RhdGUgd2FzIGF2YWlsYWJsZSBvciB0aGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gICBmbGFnIGlzIHNldC4gVGhlIGFjY2Vzc190b2tlbiBmYWlscyBvbiB0aGUgZmlyc3QgdHJ5IGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgICAgIC8vICAgZXhwaXJlZC4gU29tZSBkZXZlbG9wZXJzIG1heSBjaG9vc2UgdG8gZW5hYmxlIGZvcmNlUmVmcmVzaE9uRmFpbHVyZVxuICAgICAgICAgICAgICAgIC8vICAgdG8gbWl0aWdhdGUgdGltZS1yZWxhdGVkIGVycm9ycy5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXlSZXF1aXJlUmVmcmVzaCA9IHRoaXMuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5jcmVkZW50aWFscy5leHBpcnlfZGF0ZSB8fCB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5UmVxdWlyZVJlZnJlc2hXaXRoTm9SZWZyZXNoVG9rZW4gPSB0aGlzLmNyZWRlbnRpYWxzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIHx8IHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIYW5kbGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5ICYmIGlzQXV0aEVyciAmJiAhaXNSZWFkYWJsZVN0cmVhbSAmJiBtYXlSZXF1aXJlUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJldHJ5ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMjtcbiAgICB9XG4gICAgdmVyaWZ5SWRUb2tlbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZWQgdG8gYWNjZXB0IHR3byBhcmd1bWVudHMgaW5zdGVhZCBvZiBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHR5cGVzIHRvIGhlbHAgdXNlcnMgdXBncmFkZSB3aXRoIGxlc3MgcGFpbi5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBjYW4gYmUgcmVtb3ZlZCBhZnRlciBhIDIuMCByZWxlYXNlLlxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgd2hpY2ggaW5jbHVkZXMgdGhlIGlkVG9rZW4sIGF1ZGllbmNlLCBhbmQgbWF4RXhwaXJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5SWRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZlcmlmeUlkVG9rZW4gbWV0aG9kIHJlcXVpcmVzIGFuIElEIFRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKTtcbiAgICAgICAgY29uc3QgbG9naW4gPSBhd2FpdCB0aGlzLnZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jKG9wdGlvbnMuaWRUb2tlbiwgcmVzcG9uc2UuY2VydHMsIG9wdGlvbnMuYXVkaWVuY2UsIE9BdXRoMkNsaWVudC5JU1NVRVJTXywgb3B0aW9ucy5tYXhFeHBpcnkpO1xuICAgICAgICByZXR1cm4gbG9naW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3Zpc2lvbmVkIGFjY2VzcyB0b2tlbi4gIEVzcGVjaWFsbHkgdXNlZnVsXG4gICAgICogaWYgeW91IHdhbnQgdG8gY2hlY2sgdGhlIHNjb3BlcyB0aGF0IHdlcmUgcHJvdmlzaW9uZWQgdG8gYSBnaXZlbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBSZXF1aXJlZC4gIFRoZSBBY2Nlc3MgVG9rZW4gZm9yIHdoaWNoIHlvdSB3YW50IHRvIGdldFxuICAgICAqIHVzZXIgaW5mby5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkluZm8oYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVybDogT0F1dGgyQ2xpZW50LkdPT0dMRV9UT0tFTl9JTkZPX1VSTCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGRhdGEuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgICBzY29wZXM6IGRhdGEuc2NvcGUuc3BsaXQoJyAnKSxcbiAgICAgICAgfSwgZGF0YSk7XG4gICAgICAgIGRlbGV0ZSBpbmZvLmV4cGlyZXNfaW47XG4gICAgICAgIGRlbGV0ZSBpbmZvLnNjb3BlO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHMoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5jZXJ0cywgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpIHtcbiAgICAgICAgY29uc3Qgbm93VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAoMCwgY3J5cHRvXzEuaGFzQnJvd3NlckNyeXB0bykoKVxuICAgICAgICAgICAgPyBDZXJ0aWZpY2F0ZUZvcm1hdC5KV0tcbiAgICAgICAgICAgIDogQ2VydGlmaWNhdGVGb3JtYXQuUEVNO1xuICAgICAgICBpZiAodGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeSAmJlxuICAgICAgICAgICAgbm93VGltZSA8IHRoaXMuY2VydGlmaWNhdGVFeHBpcnkuZ2V0VGltZSgpICYmXG4gICAgICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGVGb3JtYXQgPT09IGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2VydHM6IHRoaXMuY2VydGlmaWNhdGVDYWNoZSwgZm9ybWF0IH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuUEVNOlxuICAgICAgICAgICAgICAgIHVybCA9IE9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0ZFREVSQVRFRF9TSUdOT05fUEVNX0NFUlRTX1VSTF87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LkpXSzpcbiAgICAgICAgICAgICAgICB1cmwgPSBPQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9GRURFUkFURURfU0lHTk9OX0pXS19DRVJUU19VUkxfO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNlcnRpZmljYXRlIGZvcm1hdCAke2Zvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHsgdXJsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYEZhaWxlZCB0byByZXRyaWV2ZSB2ZXJpZmljYXRpb24gY2VydGlmaWNhdGVzOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUNvbnRyb2wgPSByZXMgPyByZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2FjaGVBZ2UgPSAtMTtcbiAgICAgICAgaWYgKGNhY2hlQ29udHJvbCkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoJ21heC1hZ2U9KFswLTldKiknKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4UmVzdWx0ID0gcGF0dGVybi5leGVjKGNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICBpZiAocmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgcmVzdWx0cyB3aXRoIG1heC1hZ2UgKGluIHNlY29uZHMpXG4gICAgICAgICAgICAgICAgY2FjaGVBZ2UgPSBOdW1iZXIocmVnZXhSZXN1bHRbMV0pICogMTAwMDsgLy8gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNlcnRpZmljYXRlcyA9IHt9O1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU06XG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGVzID0gcmVzLmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LkpXSzpcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXMuZGF0YS5rZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlc1trZXkua2lkXSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2VydGlmaWNhdGUgZm9ybWF0ICR7Zm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVFeHBpcnkgPVxuICAgICAgICAgICAgY2FjaGVBZ2UgPT09IC0xID8gbnVsbCA6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyBjYWNoZUFnZSk7XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZSA9IGNlcnRpZmljYXRlcztcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlRm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4geyBjZXJ0czogY2VydGlmaWNhdGVzLCBmb3JtYXQsIHJlcyB9O1xuICAgIH1cbiAgICBnZXRJYXBQdWJsaWNLZXlzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRJYXBQdWJsaWNLZXlzQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5wdWJrZXlzLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldElhcFB1YmxpY0tleXNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldElhcFB1YmxpY0tleXNBc3luYygpIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgY29uc3QgdXJsID0gT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfSUFQX1BVQkxJQ19LRVlfVVJMXztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gcmV0cmlldmUgdmVyaWZpY2F0aW9uIGNlcnRpZmljYXRlczogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHVia2V5czogcmVzLmRhdGEsIHJlcyB9O1xuICAgIH1cbiAgICB2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHMoKSB7XG4gICAgICAgIC8vIFRvIG1ha2UgdGhlIGNvZGUgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXIgU3VidGxlQ3J5cHRvIHdlIG5lZWQgdG8gbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHMgaXMgcmVtb3ZlZCwgcGxlYXNlIHVzZSB2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHNBc3luYyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIGlkIHRva2VuIGlzIHNpZ25lZCB3aXRoIHRoZSBjb3JyZWN0IGNlcnRpZmljYXRlXG4gICAgICogYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgYXVkaWVuY2UuXG4gICAgICogQHBhcmFtIGp3dCBUaGUgand0IHRvIHZlcmlmeSAoVGhlIElEIFRva2VuIGluIHRoaXMgY2FzZSkuXG4gICAgICogQHBhcmFtIGNlcnRzIFRoZSBhcnJheSBvZiBjZXJ0cyB0byB0ZXN0IHRoZSBqd3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gcmVxdWlyZWRBdWRpZW5jZSBUaGUgYXVkaWVuY2UgdG8gdGVzdCB0aGUgand0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIGlzc3VlcnMgVGhlIGFsbG93ZWQgaXNzdWVycyBvZiB0aGUgand0IChPcHRpb25hbCkuXG4gICAgICogQHBhcmFtIG1heEV4cGlyeSBUaGUgbWF4IGV4cGlyeSB0aGUgY2VydGlmaWNhdGUgY2FuIGJlIChPcHRpb25hbCkuXG4gICAgICogQHJldHVybiBSZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgdG8gTG9naW5UaWNrZXQgb24gdmVyaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jKGp3dCwgY2VydHMsIHJlcXVpcmVkQXVkaWVuY2UsIGlzc3VlcnMsIG1heEV4cGlyeSkge1xuICAgICAgICBjb25zdCBjcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgICAgICBpZiAoIW1heEV4cGlyeSkge1xuICAgICAgICAgICAgbWF4RXhwaXJ5ID0gT0F1dGgyQ2xpZW50Lk1BWF9UT0tFTl9MSUZFVElNRV9TRUNTXztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGp3dC5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBzZWdtZW50cyBpbiB0b2tlbjogJyArIGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmVkID0gc2VnbWVudHNbMF0gKyAnLicgKyBzZWdtZW50c1sxXTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHNlZ21lbnRzWzJdO1xuICAgICAgICBsZXQgZW52ZWxvcGU7XG4gICAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW52ZWxvcGUgPSBKU09OLnBhcnNlKGNyeXB0by5kZWNvZGVCYXNlNjRTdHJpbmdVdGY4KHNlZ21lbnRzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgQ2FuJ3QgcGFyc2UgdG9rZW4gZW52ZWxvcGU6ICR7c2VnbWVudHNbMF19JzogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW52ZWxvcGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBhcnNlIHRva2VuIGVudmVsb3BlOiBcIiArIHNlZ21lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY3J5cHRvLmRlY29kZUJhc2U2NFN0cmluZ1V0Zjgoc2VnbWVudHNbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDYW4ndCBwYXJzZSB0b2tlbiBwYXlsb2FkICcke3NlZ21lbnRzWzBdfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwYXJzZSB0b2tlbiBwYXlsb2FkOiBcIiArIHNlZ21lbnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjZXJ0cywgZW52ZWxvcGUua2lkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgcHJlc2VudCwgdGhlbiB0aGVyZSdzIG5vIHJlYXNvbiB0byBhdHRlbXB0IHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwZW0gZm91bmQgZm9yIGVudmVsb3BlOiAnICsgSlNPTi5zdHJpbmdpZnkoZW52ZWxvcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZXJ0ID0gY2VydHNbZW52ZWxvcGUua2lkXTtcbiAgICAgICAgaWYgKGVudmVsb3BlLmFsZyA9PT0gJ0VTMjU2Jykge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gZm9ybWF0RWNkc2Euam9zZVRvRGVyKHNpZ25hdHVyZSwgJ0VTMjU2JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgY3J5cHRvLnZlcmlmeShjZXJ0LCBzaWduZWQsIHNpZ25hdHVyZSk7XG4gICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b2tlbiBzaWduYXR1cmU6ICcgKyBqd3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF5bG9hZC5pYXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaXNzdWUgdGltZSBpbiB0b2tlbjogJyArIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBheWxvYWQuZXhwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV4cGlyYXRpb24gdGltZSBpbiB0b2tlbjogJyArIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpYXQgPSBOdW1iZXIocGF5bG9hZC5pYXQpO1xuICAgICAgICBpZiAoaXNOYU4oaWF0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWF0IGZpZWxkIHVzaW5nIGludmFsaWQgZm9ybWF0Jyk7XG4gICAgICAgIGNvbnN0IGV4cCA9IE51bWJlcihwYXlsb2FkLmV4cCk7XG4gICAgICAgIGlmIChpc05hTihleHApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHAgZmllbGQgdXNpbmcgaW52YWxpZCBmb3JtYXQnKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgICAgICBpZiAoZXhwID49IG5vdyArIG1heEV4cGlyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBpcmF0aW9uIHRpbWUgdG9vIGZhciBpbiBmdXR1cmU6ICcgKyBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWFybGllc3QgPSBpYXQgLSBPQXV0aDJDbGllbnQuQ0xPQ0tfU0tFV19TRUNTXztcbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gZXhwICsgT0F1dGgyQ2xpZW50LkNMT0NLX1NLRVdfU0VDU187XG4gICAgICAgIGlmIChub3cgPCBlYXJsaWVzdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiB1c2VkIHRvbyBlYXJseSwgJyArXG4gICAgICAgICAgICAgICAgbm93ICtcbiAgICAgICAgICAgICAgICAnIDwgJyArXG4gICAgICAgICAgICAgICAgZWFybGllc3QgK1xuICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm93ID4gbGF0ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHVzZWQgdG9vIGxhdGUsICcgK1xuICAgICAgICAgICAgICAgIG5vdyArXG4gICAgICAgICAgICAgICAgJyA+ICcgK1xuICAgICAgICAgICAgICAgIGxhdGVzdCArXG4gICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3N1ZXJzICYmIGlzc3VlcnMuaW5kZXhPZihwYXlsb2FkLmlzcykgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaXNzdWVyLCBleHBlY3RlZCBvbmUgb2YgWycgK1xuICAgICAgICAgICAgICAgIGlzc3VlcnMgK1xuICAgICAgICAgICAgICAgICddLCBidXQgZ290ICcgK1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGUgYXVkaWVuY2UgbWF0Y2hlcyBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkQXVkaWVuY2UgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmVkQXVkaWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZCA9IHBheWxvYWQuYXVkO1xuICAgICAgICAgICAgbGV0IGF1ZFZlcmlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWlyZWRBdWRpZW5jZSBpcyBhbiBhcnJheSwgY2hlY2sgaWYgaXQgY29udGFpbnMgdG9rZW5cbiAgICAgICAgICAgIC8vIGF1ZGllbmNlXG4gICAgICAgICAgICBpZiAocmVxdWlyZWRBdWRpZW5jZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhdWRWZXJpZmllZCA9IHJlcXVpcmVkQXVkaWVuY2UuaW5kZXhPZihhdWQpID4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdWRWZXJpZmllZCA9IGF1ZCA9PT0gcmVxdWlyZWRBdWRpZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXVkVmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHJlY2lwaWVudCwgcGF5bG9hZCBhdWRpZW5jZSAhPSByZXF1aXJlZEF1ZGllbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBsb2dpbnRpY2tldF8xLkxvZ2luVGlja2V0KGVudmVsb3BlLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIEFjY2Vzc1Rva2VuUmVzcG9uc2UgdHlwZSBpZlxuICAgICAqIHJlZnJlc2hIYW5kbGVyIGlzIGRlZmluZWQuXG4gICAgICogSWYgbm90LCBub3RoaW5nIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NBbmRWYWxpZGF0ZVJlZnJlc2hIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMucmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmICghYWNjZXNzVG9rZW5SZXNwb25zZS5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgcmVmcmVzaEhhbmRsZXIgY2FsbGJhY2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW5SZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIHRva2VuIGlzIGV4cGlyZWQgb3Igd2lsbCBleHBpcmUgd2l0aGluXG4gICAgICogZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzbWlsbGlzZWNvbmRzLlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKi9cbiAgICBpc1Rva2VuRXhwaXJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGV4cGlyeURhdGUgPSB0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlO1xuICAgICAgICByZXR1cm4gZXhwaXJ5RGF0ZVxuICAgICAgICAgICAgPyBleHBpcnlEYXRlIDw9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5PQXV0aDJDbGllbnQgPSBPQXV0aDJDbGllbnQ7XG5PQXV0aDJDbGllbnQuR09PR0xFX1RPS0VOX0lORk9fVVJMID0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuaW5mbyc7XG4vKipcbiAqIFRoZSBiYXNlIFVSTCBmb3IgYXV0aCBlbmRwb2ludHMuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX0FVVEhfQkFTRV9VUkxfID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi92Mi9hdXRoJztcbi8qKlxuICogVGhlIGJhc2UgZW5kcG9pbnQgZm9yIHRva2VuIHJldHJpZXZhbC5cbiAqL1xuT0F1dGgyQ2xpZW50LkdPT0dMRV9PQVVUSDJfVE9LRU5fVVJMXyA9ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbic7XG4vKipcbiAqIFRoZSBiYXNlIGVuZHBvaW50IHRvIHJldm9rZSB0b2tlbnMuXG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfT0FVVEgyX1JFVk9LRV9VUkxfID0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Jldm9rZSc7XG4vKipcbiAqIEdvb2dsZSBTaWduIG9uIGNlcnRpZmljYXRlcyBpbiBQRU0gZm9ybWF0LlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9GRURFUkFURURfU0lHTk9OX1BFTV9DRVJUU19VUkxfID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92MS9jZXJ0cyc7XG4vKipcbiAqIEdvb2dsZSBTaWduIG9uIGNlcnRpZmljYXRlcyBpbiBKV0sgZm9ybWF0LlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9GRURFUkFURURfU0lHTk9OX0pXS19DRVJUU19VUkxfID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92My9jZXJ0cyc7XG4vKipcbiAqIEdvb2dsZSBTaWduIG9uIGNlcnRpZmljYXRlcyBpbiBKV0sgZm9ybWF0LlxuICovXG5PQXV0aDJDbGllbnQuR09PR0xFX09BVVRIMl9JQVBfUFVCTElDX0tFWV9VUkxfID0gJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2lhcC92ZXJpZnkvcHVibGljX2tleSc7XG4vKipcbiAqIENsb2NrIHNrZXcgLSBmaXZlIG1pbnV0ZXMgaW4gc2Vjb25kc1xuICovXG5PQXV0aDJDbGllbnQuQ0xPQ0tfU0tFV19TRUNTXyA9IDMwMDtcbi8qKlxuICogTWF4IFRva2VuIExpZmV0aW1lIGlzIG9uZSBkYXkgaW4gc2Vjb25kc1xuICovXG5PQXV0aDJDbGllbnQuTUFYX1RPS0VOX0xJRkVUSU1FX1NFQ1NfID0gODY0MDA7XG4vKipcbiAqIFRoZSBhbGxvd2VkIG9hdXRoIHRva2VuIGlzc3VlcnMuXG4gKi9cbk9BdXRoMkNsaWVudC5JU1NVRVJTXyA9IFtcbiAgICAnYWNjb3VudHMuZ29vZ2xlLmNvbScsXG4gICAgJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbScsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2F1dGgyY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2common.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorFromOAuthErrorResponse = exports.OAuthClientAuthHandler = void 0;\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** List of HTTP methods that accept request bodies. */\nconst METHODS_SUPPORTING_REQUEST_BODY = ['PUT', 'POST', 'PATCH'];\n/**\n * Abstract class for handling client authentication in OAuth-based\n * operations.\n * When request-body client authentication is used, only application/json and\n * application/x-www-form-urlencoded content types for HTTP methods that support\n * request bodies are supported.\n */\nclass OAuthClientAuthHandler {\n    /**\n     * Instantiates an OAuth client authentication handler.\n     * @param clientAuthentication The client auth credentials.\n     */\n    constructor(clientAuthentication) {\n        this.clientAuthentication = clientAuthentication;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Applies client authentication on the OAuth request's headers or POST\n     * body but does not process the request.\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */\n    applyClientAuthenticationOptions(opts, bearerToken) {\n        // Inject authenticated header.\n        this.injectAuthenticatedHeaders(opts, bearerToken);\n        // Inject authenticated request body.\n        if (!bearerToken) {\n            this.injectAuthenticatedRequestBody(opts);\n        }\n    }\n    /**\n     * Applies client authentication on the request's header if either\n     * basic authentication or bearer token authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */\n    injectAuthenticatedHeaders(opts, bearerToken) {\n        var _a;\n        // Bearer token prioritized higher than basic Auth.\n        if (bearerToken) {\n            opts.headers = opts.headers || {};\n            Object.assign(opts.headers, {\n                Authorization: `Bearer ${bearerToken}}`,\n            });\n        }\n        else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === 'basic') {\n            opts.headers = opts.headers || {};\n            const clientId = this.clientAuthentication.clientId;\n            const clientSecret = this.clientAuthentication.clientSecret || '';\n            const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);\n            Object.assign(opts.headers, {\n                Authorization: `Basic ${base64EncodedCreds}`,\n            });\n        }\n    }\n    /**\n     * Applies client authentication on the request's body if request-body\n     * client authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     */\n    injectAuthenticatedRequestBody(opts) {\n        var _a;\n        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === 'request-body') {\n            const method = (opts.method || 'GET').toUpperCase();\n            // Inject authenticated request body.\n            if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {\n                // Get content-type.\n                let contentType;\n                const headers = opts.headers || {};\n                for (const key in headers) {\n                    if (key.toLowerCase() === 'content-type' && headers[key]) {\n                        contentType = headers[key].toLowerCase();\n                        break;\n                    }\n                }\n                if (contentType === 'application/x-www-form-urlencoded') {\n                    opts.data = opts.data || '';\n                    const data = querystring.parse(opts.data);\n                    Object.assign(data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || '',\n                    });\n                    opts.data = querystring.stringify(data);\n                }\n                else if (contentType === 'application/json') {\n                    opts.data = opts.data || {};\n                    Object.assign(opts.data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || '',\n                    });\n                }\n                else {\n                    throw new Error(`${contentType} content-types are not supported with ` +\n                        `${this.clientAuthentication.confidentialClientType} ` +\n                        'client authentication');\n                }\n            }\n            else {\n                throw new Error(`${method} HTTP method does not support ` +\n                    `${this.clientAuthentication.confidentialClientType} ` +\n                    'client authentication');\n            }\n        }\n    }\n}\nexports.OAuthClientAuthHandler = OAuthClientAuthHandler;\n/**\n * Converts an OAuth error response to a native JavaScript Error.\n * @param resp The OAuth error response to convert to a native Error object.\n * @param err The optional original error. If provided, the error properties\n *   will be copied to the new error.\n * @return The converted native Error object.\n */\nfunction getErrorFromOAuthErrorResponse(resp, err) {\n    // Error response.\n    const errorCode = resp.error;\n    const errorDescription = resp.error_description;\n    const errorUri = resp.error_uri;\n    let message = `Error code ${errorCode}`;\n    if (typeof errorDescription !== 'undefined') {\n        message += `: ${errorDescription}`;\n    }\n    if (typeof errorUri !== 'undefined') {\n        message += ` - ${errorUri}`;\n    }\n    const newError = new Error(message);\n    // Copy properties from original error to newly generated error.\n    if (err) {\n        const keys = Object.keys(err);\n        if (err.stack) {\n            // Copy error.stack if available.\n            keys.push('stack');\n        }\n        keys.forEach(key => {\n            // Do not overwrite the message field.\n            if (key !== 'message') {\n                Object.defineProperty(newError, key, {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    value: err[key],\n                    writable: false,\n                    enumerable: true,\n                });\n            }\n        });\n    }\n    return newError;\n}\nexports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;\n//# sourceMappingURL=oauth2common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyw4QkFBOEI7QUFDdkUsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNkZBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUyxHQUFHLGFBQWE7QUFDdEc7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BELDJCQUEyQixrREFBa0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyx1QkFBdUIsa0RBQWtEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlID0gZXhwb3J0cy5PQXV0aENsaWVudEF1dGhIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vY3J5cHRvXCIpO1xuLyoqIExpc3Qgb2YgSFRUUCBtZXRob2RzIHRoYXQgYWNjZXB0IHJlcXVlc3QgYm9kaWVzLiAqL1xuY29uc3QgTUVUSE9EU19TVVBQT1JUSU5HX1JFUVVFU1RfQk9EWSA9IFsnUFVUJywgJ1BPU1QnLCAnUEFUQ0gnXTtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGhhbmRsaW5nIGNsaWVudCBhdXRoZW50aWNhdGlvbiBpbiBPQXV0aC1iYXNlZFxuICogb3BlcmF0aW9ucy5cbiAqIFdoZW4gcmVxdWVzdC1ib2R5IGNsaWVudCBhdXRoZW50aWNhdGlvbiBpcyB1c2VkLCBvbmx5IGFwcGxpY2F0aW9uL2pzb24gYW5kXG4gKiBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgY29udGVudCB0eXBlcyBmb3IgSFRUUCBtZXRob2RzIHRoYXQgc3VwcG9ydFxuICogcmVxdWVzdCBib2RpZXMgYXJlIHN1cHBvcnRlZC5cbiAqL1xuY2xhc3MgT0F1dGhDbGllbnRBdXRoSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9BdXRoIGNsaWVudCBhdXRoZW50aWNhdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSBjbGllbnRBdXRoZW50aWNhdGlvbiBUaGUgY2xpZW50IGF1dGggY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbiA9IGNsaWVudEF1dGhlbnRpY2F0aW9uO1xuICAgICAgICB0aGlzLmNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG9uIHRoZSBPQXV0aCByZXF1ZXN0J3MgaGVhZGVycyBvciBQT1NUXG4gICAgICogYm9keSBidXQgZG9lcyBub3QgcHJvY2VzcyB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0gYmVhcmVyVG9rZW4gVGhlIG9wdGlvbmFsIGJlYXJlciB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqICAgV2hlbiB0aGlzIGlzIHVzZWQsIG5vIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBhcmUgbmVlZGVkLlxuICAgICAqL1xuICAgIGFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zKG9wdHMsIGJlYXJlclRva2VuKSB7XG4gICAgICAgIC8vIEluamVjdCBhdXRoZW50aWNhdGVkIGhlYWRlci5cbiAgICAgICAgdGhpcy5pbmplY3RBdXRoZW50aWNhdGVkSGVhZGVycyhvcHRzLCBiZWFyZXJUb2tlbik7XG4gICAgICAgIC8vIEluamVjdCBhdXRoZW50aWNhdGVkIHJlcXVlc3QgYm9keS5cbiAgICAgICAgaWYgKCFiZWFyZXJUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RBdXRoZW50aWNhdGVkUmVxdWVzdEJvZHkob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGllbnQgYXV0aGVudGljYXRpb24gb24gdGhlIHJlcXVlc3QncyBoZWFkZXIgaWYgZWl0aGVyXG4gICAgICogYmFzaWMgYXV0aGVudGljYXRpb24gb3IgYmVhcmVyIHRva2VuIGF1dGhlbnRpY2F0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEdheGlvc09wdGlvbnMgd2hvc2UgaGVhZGVycyBvciBkYXRhIGFyZSB0byBiZSBtb2RpZmllZFxuICAgICAqICAgZGVwZW5kaW5nIG9uIHRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIGJlYXJlclRva2VuIFRoZSBvcHRpb25hbCBiZWFyZXIgdG9rZW4gdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiAgIFdoZW4gdGhpcyBpcyB1c2VkLCBubyBjbGllbnQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgYXJlIG5lZWRlZC5cbiAgICAgKi9cbiAgICBpbmplY3RBdXRoZW50aWNhdGVkSGVhZGVycyhvcHRzLCBiZWFyZXJUb2tlbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEJlYXJlciB0b2tlbiBwcmlvcml0aXplZCBoaWdoZXIgdGhhbiBiYXNpYyBBdXRoLlxuICAgICAgICBpZiAoYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2JlYXJlclRva2VufX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChfYSA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWRlbnRpYWxDbGllbnRUeXBlKSA9PT0gJ2Jhc2ljJykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudElkO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50U2VjcmV0ID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRTZWNyZXQgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBiYXNlNjRFbmNvZGVkQ3JlZHMgPSB0aGlzLmNyeXB0by5lbmNvZGVCYXNlNjRTdHJpbmdVdGY4KGAke2NsaWVudElkfToke2NsaWVudFNlY3JldH1gKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7YmFzZTY0RW5jb2RlZENyZWRzfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiBvbiB0aGUgcmVxdWVzdCdzIGJvZHkgaWYgcmVxdWVzdC1ib2R5XG4gICAgICogY2xpZW50IGF1dGhlbnRpY2F0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEdheGlvc09wdGlvbnMgd2hvc2UgaGVhZGVycyBvciBkYXRhIGFyZSB0byBiZSBtb2RpZmllZFxuICAgICAqICAgZGVwZW5kaW5nIG9uIHRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGJlIHVzZWQuXG4gICAgICovXG4gICAgaW5qZWN0QXV0aGVudGljYXRlZFJlcXVlc3RCb2R5KG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWRlbnRpYWxDbGllbnRUeXBlKSA9PT0gJ3JlcXVlc3QtYm9keScpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIC8vIEluamVjdCBhdXRoZW50aWNhdGVkIHJlcXVlc3QgYm9keS5cbiAgICAgICAgICAgIGlmIChNRVRIT0RTX1NVUFBPUlRJTkdfUkVRVUVTVF9CT0RZLmluZGV4T2YobWV0aG9kKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29udGVudC10eXBlLlxuICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJyAmJiBoZWFkZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gaGVhZGVyc1trZXldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGF0YSA9IG9wdHMuZGF0YSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG9wdHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRTZWNyZXQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmRhdGEgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXRhID0gb3B0cy5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jbGllbnRTZWNyZXQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRlbnRUeXBlfSBjb250ZW50LXR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNvbmZpZGVudGlhbENsaWVudFR5cGV9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsaWVudCBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2R9IEhUVFAgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3RoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY29uZmlkZW50aWFsQ2xpZW50VHlwZX0gYCArXG4gICAgICAgICAgICAgICAgICAgICdjbGllbnQgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT0F1dGhDbGllbnRBdXRoSGFuZGxlciA9IE9BdXRoQ2xpZW50QXV0aEhhbmRsZXI7XG4vKipcbiAqIENvbnZlcnRzIGFuIE9BdXRoIGVycm9yIHJlc3BvbnNlIHRvIGEgbmF0aXZlIEphdmFTY3JpcHQgRXJyb3IuXG4gKiBAcGFyYW0gcmVzcCBUaGUgT0F1dGggZXJyb3IgcmVzcG9uc2UgdG8gY29udmVydCB0byBhIG5hdGl2ZSBFcnJvciBvYmplY3QuXG4gKiBAcGFyYW0gZXJyIFRoZSBvcHRpb25hbCBvcmlnaW5hbCBlcnJvci4gSWYgcHJvdmlkZWQsIHRoZSBlcnJvciBwcm9wZXJ0aWVzXG4gKiAgIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgZXJyb3IuXG4gKiBAcmV0dXJuIFRoZSBjb252ZXJ0ZWQgbmF0aXZlIEVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlKHJlc3AsIGVycikge1xuICAgIC8vIEVycm9yIHJlc3BvbnNlLlxuICAgIGNvbnN0IGVycm9yQ29kZSA9IHJlc3AuZXJyb3I7XG4gICAgY29uc3QgZXJyb3JEZXNjcmlwdGlvbiA9IHJlc3AuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgY29uc3QgZXJyb3JVcmkgPSByZXNwLmVycm9yX3VyaTtcbiAgICBsZXQgbWVzc2FnZSA9IGBFcnJvciBjb2RlICR7ZXJyb3JDb2RlfWA7XG4gICAgaWYgKHR5cGVvZiBlcnJvckRlc2NyaXB0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtZXNzYWdlICs9IGA6ICR7ZXJyb3JEZXNjcmlwdGlvbn1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVycm9yVXJpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtZXNzYWdlICs9IGAgLSAke2Vycm9yVXJpfWA7XG4gICAgfVxuICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIG9yaWdpbmFsIGVycm9yIHRvIG5ld2x5IGdlbmVyYXRlZCBlcnJvci5cbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhlcnIpO1xuICAgICAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICAvLyBDb3B5IGVycm9yLnN0YWNrIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGtleXMucHVzaCgnc3RhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgdGhlIG1lc3NhZ2UgZmllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3RXJyb3IsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXJyW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdFcnJvcjtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlID0gZ2V0RXJyb3JGcm9tT0F1dGhFcnJvclJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2F1dGgyY29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluggableAuthClient = exports.ExecutableError = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst pluggable_auth_handler_1 = __webpack_require__(/*! ./pluggable-auth-handler */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */\nclass ExecutableError extends Error {\n    constructor(message, code) {\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * The default executable timeout when none is provided, in milliseconds.\n */\nconst DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;\n/**\n * The minimum allowed executable timeout in milliseconds.\n */\nconst MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;\n/**\n * The maximum allowed executable timeout in milliseconds.\n */\nconst MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;\n/**\n * The environment variable to check to see if executable can be run.\n * Value must be set to '1' for the executable to run.\n */\nconst GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = 'GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES';\n/**\n * The maximum currently supported executable version.\n */\nconst MAXIMUM_EXECUTABLE_VERSION = 1;\n/**\n * PluggableAuthClient enables the exchange of workload identity pool external credentials for\n * Google access tokens by retrieving 3rd party tokens through a user supplied executable. These\n * scripts/executables are completely independent of the Google Cloud Auth libraries. These\n * credentials plug into ADC and will call the specified executable to retrieve the 3rd party token\n * to be exchanged for a Google access token.\n *\n * <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable\n * must be set to '1'. This is for security reasons.\n *\n * <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format\n * defined below.\n *\n * <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an\n * output_file is specified in the credential configuration, the executable must also handle writing the\n * JSON response to this file.\n *\n * <pre>\n * OIDC response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n *   \"id_token\": \"HEADER.PAYLOAD.SIGNATURE\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * SAML2 response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n *   \"saml_response\": \"...\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * Error response sample:\n * {\n *   \"version\": 1,\n *   \"success\": false,\n *   \"code\": \"401\",\n *   \"message\": \"Error message.\"\n * }\n * </pre>\n *\n * <p>The \"expiration_time\" field in the JSON response is only required for successful\n * responses when an output file was specified in the credential configuration\n *\n * <p>The auth libraries will populate certain environment variables that will be accessible by the\n * executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,\n * GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and\n * GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.\n *\n * <p>Please see this repositories README for a complete executable request/response specification.\n */\nclass PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates a PluggableAuthClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid pluggable auth credential.\n     * @param options The external account options object typically loaded from\n     *   the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super(options, additionalOptions);\n        if (!options.credential_source.executable) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        this.command = options.credential_source.executable.command;\n        if (!this.command) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        // Check if the provided timeout exists and if it is valid.\n        if (options.credential_source.executable.timeout_millis === undefined) {\n            this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;\n        }\n        else {\n            this.timeoutMillis = options.credential_source.executable.timeout_millis;\n            if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS ||\n                this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {\n                throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` +\n                    `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);\n            }\n        }\n        this.outputFile = options.credential_source.executable.output_file;\n        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({\n            command: this.command,\n            timeoutMillis: this.timeoutMillis,\n            outputFile: this.outputFile,\n        });\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this calls a user provided executable which returns the subject token.\n     * The logic is summarized as:\n     * 1. Validated that the executable is allowed to run. The\n     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to\n     *    1 for security reasons.\n     * 2. If an output file is specified by the user, check the file location\n     *    for a response. If the file exists and contains a valid response,\n     *    return the subject token from the file.\n     * 3. Call the provided executable and return response.\n     * @return A promise that resolves with the external subject token.\n     */\n    async retrieveSubjectToken() {\n        // Check if the executable is allowed to run.\n        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== '1') {\n            throw new Error('Pluggable Auth executables need to be explicitly allowed to run by ' +\n                'setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment ' +\n                'Variable to 1.');\n        }\n        let executableResponse = undefined;\n        // Try to get cached executable response from output file.\n        if (this.outputFile) {\n            executableResponse = await this.handler.retrieveCachedResponse();\n        }\n        // If no response from output file, call the executable.\n        if (!executableResponse) {\n            // Set up environment map with required values for the executable.\n            const envMap = new Map();\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE', this.audience);\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE', this.subjectTokenType);\n            // Always set to 0 because interactive mode is not supported.\n            envMap.set('GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE', '0');\n            if (this.outputFile) {\n                envMap.set('GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE', this.outputFile);\n            }\n            const serviceAccountEmail = this.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                envMap.set('GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL', serviceAccountEmail);\n            }\n            executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);\n        }\n        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {\n            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);\n        }\n        // Check that response was successful.\n        if (!executableResponse.success) {\n            throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);\n        }\n        // Check that response contains expiration time if output file was specified.\n        if (this.outputFile) {\n            if (!executableResponse.expirationTime) {\n                throw new executable_response_1.InvalidExpirationTimeFieldError('The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.');\n            }\n        }\n        // Check that response is not expired.\n        if (executableResponse.isExpired()) {\n            throw new Error('Executable response is expired.');\n        }\n        // Return subject token from response.\n        return executableResponse.subjectToken;\n    }\n}\nexports.PluggableAuthClient = PluggableAuthClient;\n//# sourceMappingURL=pluggable-auth-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyx1QkFBdUI7QUFDckQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyxtSEFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNLHFCQUFxQixRQUFRO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUNBQW1DO0FBQzlGLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RywyQkFBMkI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcGx1Z2dhYmxlLWF1dGgtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsdWdnYWJsZUF1dGhDbGllbnQgPSBleHBvcnRzLkV4ZWN1dGFibGVFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgZXhlY3V0YWJsZV9yZXNwb25zZV8xID0gcmVxdWlyZShcIi4vZXhlY3V0YWJsZS1yZXNwb25zZVwiKTtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWhhbmRsZXJcIik7XG4vKipcbiAqIEVycm9yIHRocm93biBmcm9tIHRoZSBleGVjdXRhYmxlIHJ1biBieSBQbHVnZ2FibGVBdXRoQ2xpZW50LlxuICovXG5jbGFzcyBFeGVjdXRhYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihgVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHdpdGggZXhpdCBjb2RlOiAke2NvZGV9IGFuZCBlcnJvciBtZXNzYWdlOiAke21lc3NhZ2V9LmApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZUVycm9yID0gRXhlY3V0YWJsZUVycm9yO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBleGVjdXRhYmxlIHRpbWVvdXQgd2hlbiBub25lIGlzIHByb3ZpZGVkLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmNvbnN0IERFRkFVTFRfRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUyA9IDMwICogMTAwMDtcbi8qKlxuICogVGhlIG1pbmltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSA1ICogMTAwMDtcbi8qKlxuICogVGhlIG1heGltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSAxMjAgKiAxMDAwO1xuLyoqXG4gKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gY2hlY2sgdG8gc2VlIGlmIGV4ZWN1dGFibGUgY2FuIGJlIHJ1bi5cbiAqIFZhbHVlIG11c3QgYmUgc2V0IHRvICcxJyBmb3IgdGhlIGV4ZWN1dGFibGUgdG8gcnVuLlxuICovXG5jb25zdCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyA9ICdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyc7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZXhlY3V0YWJsZSB2ZXJzaW9uLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTiA9IDE7XG4vKipcbiAqIFBsdWdnYWJsZUF1dGhDbGllbnQgZW5hYmxlcyB0aGUgZXhjaGFuZ2Ugb2Ygd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBleHRlcm5hbCBjcmVkZW50aWFscyBmb3JcbiAqIEdvb2dsZSBhY2Nlc3MgdG9rZW5zIGJ5IHJldHJpZXZpbmcgM3JkIHBhcnR5IHRva2VucyB0aHJvdWdoIGEgdXNlciBzdXBwbGllZCBleGVjdXRhYmxlLiBUaGVzZVxuICogc2NyaXB0cy9leGVjdXRhYmxlcyBhcmUgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiB0aGUgR29vZ2xlIENsb3VkIEF1dGggbGlicmFyaWVzLiBUaGVzZVxuICogY3JlZGVudGlhbHMgcGx1ZyBpbnRvIEFEQyBhbmQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZXhlY3V0YWJsZSB0byByZXRyaWV2ZSB0aGUgM3JkIHBhcnR5IHRva2VuXG4gKiB0byBiZSBleGNoYW5nZWQgZm9yIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiA8cD5UbyB1c2UgdGhlc2UgY3JlZGVudGlhbHMsIHRoZSBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogbXVzdCBiZSBzZXQgdG8gJzEnLiBUaGlzIGlzIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIDxwPkJvdGggT0lEQyBhbmQgU0FNTCBhcmUgc3VwcG9ydGVkLiBUaGUgZXhlY3V0YWJsZSBtdXN0IGFkaGVyZSB0byBhIHNwZWNpZmljIHJlc3BvbnNlIGZvcm1hdFxuICogZGVmaW5lZCBiZWxvdy5cbiAqXG4gKiA8cD5UaGUgZXhlY3V0YWJsZSBtdXN0IHByaW50IG91dCB0aGUgM3JkIHBhcnR5IHRva2VuIHRvIFNURE9VVCBpbiBKU09OIGZvcm1hdC4gV2hlbiBhblxuICogb3V0cHV0X2ZpbGUgaXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb24sIHRoZSBleGVjdXRhYmxlIG11c3QgYWxzbyBoYW5kbGUgd3JpdGluZyB0aGVcbiAqIEpTT04gcmVzcG9uc2UgdG8gdGhpcyBmaWxlLlxuICpcbiAqIDxwcmU+XG4gKiBPSURDIHJlc3BvbnNlIHNhbXBsZTpcbiAqIHtcbiAqICAgXCJ2ZXJzaW9uXCI6IDEsXG4gKiAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICogICBcInRva2VuX3R5cGVcIjogXCJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlblwiLFxuICogICBcImlkX3Rva2VuXCI6IFwiSEVBREVSLlBBWUxPQUQuU0lHTkFUVVJFXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBTQU1MMiByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAqICAgXCJ0b2tlbl90eXBlXCI6IFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6c2FtbDJcIixcbiAqICAgXCJzYW1sX3Jlc3BvbnNlXCI6IFwiLi4uXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBFcnJvciByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gKiAgIFwiY29kZVwiOiBcIjQwMVwiLFxuICogICBcIm1lc3NhZ2VcIjogXCJFcnJvciBtZXNzYWdlLlwiXG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiA8cD5UaGUgXCJleHBpcmF0aW9uX3RpbWVcIiBmaWVsZCBpbiB0aGUgSlNPTiByZXNwb25zZSBpcyBvbmx5IHJlcXVpcmVkIGZvciBzdWNjZXNzZnVsXG4gKiByZXNwb25zZXMgd2hlbiBhbiBvdXRwdXQgZmlsZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiA8cD5UaGUgYXV0aCBsaWJyYXJpZXMgd2lsbCBwb3B1bGF0ZSBjZXJ0YWluIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHdpbGwgYmUgYWNjZXNzaWJsZSBieSB0aGVcbiAqIGV4ZWN1dGFibGUsIHN1Y2ggYXM6IEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FVRElFTkNFLCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9UT0tFTl9UWVBFLFxuICogR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU5URVJBQ1RJVkUsIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lNUEVSU09OQVRFRF9FTUFJTCwgYW5kXG4gKiBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9PVVRQVVRfRklMRS5cbiAqXG4gKiA8cD5QbGVhc2Ugc2VlIHRoaXMgcmVwb3NpdG9yaWVzIFJFQURNRSBmb3IgYSBjb21wbGV0ZSBleGVjdXRhYmxlIHJlcXVlc3QvcmVzcG9uc2Ugc3BlY2lmaWNhdGlvbi5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aENsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgYSB2YWxpZCBwbHVnZ2FibGUgYXV0aCBjcmVkZW50aWFsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWQgZnJvbVxuICAgICAqICAgdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvblxuICAgICAqICAgb3B0aW9ucy4gVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZFxuICAgICAqICAgd2hldGhlciB0byByZXRyeSBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIFBsdWdnYWJsZSBBdXRoIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUuY29tbWFuZDtcbiAgICAgICAgaWYgKCF0aGlzLmNvbW1hbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgUGx1Z2dhYmxlIEF1dGggXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwcm92aWRlZCB0aW1lb3V0IGV4aXN0cyBhbmQgaWYgaXQgaXMgdmFsaWQuXG4gICAgICAgIGlmIChvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUudGltZW91dF9taWxsaXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gREVGQVVMVF9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLnRpbWVvdXRfbWlsbGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dE1pbGxpcyA8IE1JTklNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUyB8fFxuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dE1pbGxpcyA+IE1BWElNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGltZW91dCBtdXN0IGJlIGJldHdlZW4gJHtNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVN9IGFuZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7TUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTfSBtaWxsaXNlY29uZHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRGaWxlID0gb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS5leGVjdXRhYmxlLm91dHB1dF9maWxlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBuZXcgcGx1Z2dhYmxlX2F1dGhfaGFuZGxlcl8xLlBsdWdnYWJsZUF1dGhIYW5kbGVyKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IHRoaXMuY29tbWFuZCxcbiAgICAgICAgICAgIHRpbWVvdXRNaWxsaXM6IHRoaXMudGltZW91dE1pbGxpcyxcbiAgICAgICAgICAgIG91dHB1dEZpbGU6IHRoaXMub3V0cHV0RmlsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFuIGV4dGVybmFsIHN1YmplY3QgdG9rZW4gaXMgbmVlZGVkIHRvIGJlIGV4Y2hhbmdlZCBmb3IgYVxuICAgICAqIEdDUCBhY2Nlc3MgdG9rZW4gdmlhIEdDUCBTVFMgZW5kcG9pbnQuXG4gICAgICogVGhpcyB1c2VzIHRoZSBgb3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZWAgb2JqZWN0IHRvIGZpZ3VyZSBvdXQgaG93XG4gICAgICogdG8gcmV0cmlldmUgdGhlIHRva2VuIHVzaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBJbiB0aGlzIGNhc2UsXG4gICAgICogdGhpcyBjYWxscyBhIHVzZXIgcHJvdmlkZWQgZXhlY3V0YWJsZSB3aGljaCByZXR1cm5zIHRoZSBzdWJqZWN0IHRva2VuLlxuICAgICAqIFRoZSBsb2dpYyBpcyBzdW1tYXJpemVkIGFzOlxuICAgICAqIDEuIFZhbGlkYXRlZCB0aGF0IHRoZSBleGVjdXRhYmxlIGlzIGFsbG93ZWQgdG8gcnVuLiBUaGVcbiAgICAgKiAgICBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCBtdXN0IGJlIHNldCB0b1xuICAgICAqICAgIDEgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gICAgICogMi4gSWYgYW4gb3V0cHV0IGZpbGUgaXMgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLCBjaGVjayB0aGUgZmlsZSBsb2NhdGlvblxuICAgICAqICAgIGZvciBhIHJlc3BvbnNlLiBJZiB0aGUgZmlsZSBleGlzdHMgYW5kIGNvbnRhaW5zIGEgdmFsaWQgcmVzcG9uc2UsXG4gICAgICogICAgcmV0dXJuIHRoZSBzdWJqZWN0IHRva2VuIGZyb20gdGhlIGZpbGUuXG4gICAgICogMy4gQ2FsbCB0aGUgcHJvdmlkZWQgZXhlY3V0YWJsZSBhbmQgcmV0dXJuIHJlc3BvbnNlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4ZWN1dGFibGUgaXMgYWxsb3dlZCB0byBydW4uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudltHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFU10gIT09ICcxJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnZ2FibGUgQXV0aCBleGVjdXRhYmxlcyBuZWVkIHRvIGJlIGV4cGxpY2l0bHkgYWxsb3dlZCB0byBydW4gYnkgJyArXG4gICAgICAgICAgICAgICAgJ3NldHRpbmcgdGhlIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FMTE9XX0VYRUNVVEFCTEVTIGVudmlyb25tZW50ICcgK1xuICAgICAgICAgICAgICAgICdWYXJpYWJsZSB0byAxLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleGVjdXRhYmxlUmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgY2FjaGVkIGV4ZWN1dGFibGUgcmVzcG9uc2UgZnJvbSBvdXRwdXQgZmlsZS5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgZXhlY3V0YWJsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJldHJpZXZlQ2FjaGVkUmVzcG9uc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyByZXNwb25zZSBmcm9tIG91dHB1dCBmaWxlLCBjYWxsIHRoZSBleGVjdXRhYmxlLlxuICAgICAgICBpZiAoIWV4ZWN1dGFibGVSZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIGVudmlyb25tZW50IG1hcCB3aXRoIHJlcXVpcmVkIHZhbHVlcyBmb3IgdGhlIGV4ZWN1dGFibGUuXG4gICAgICAgICAgICBjb25zdCBlbnZNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BVURJRU5DRScsIHRoaXMuYXVkaWVuY2UpO1xuICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfVE9LRU5fVFlQRScsIHRoaXMuc3ViamVjdFRva2VuVHlwZSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0IHRvIDAgYmVjYXVzZSBpbnRlcmFjdGl2ZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9JTlRFUkFDVElWRScsICcwJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWxlKSB7XG4gICAgICAgICAgICAgICAgZW52TWFwLnNldCgnR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfT1VUUFVUX0ZJTEUnLCB0aGlzLm91dHB1dEZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZUFjY291bnRFbWFpbCA9IHRoaXMuZ2V0U2VydmljZUFjY291bnRFbWFpbCgpO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VBY2NvdW50RW1haWwpIHtcbiAgICAgICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9JTVBFUlNPTkFURURfRU1BSUwnLCBzZXJ2aWNlQWNjb3VudEVtYWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWN1dGFibGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuaGFuZGxlci5yZXRyaWV2ZVJlc3BvbnNlRnJvbUV4ZWN1dGFibGUoZW52TWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhlY3V0YWJsZVJlc3BvbnNlLnZlcnNpb24gPiBNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWZXJzaW9uIG9mIGV4ZWN1dGFibGUgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQsIG1heGltdW0gc3VwcG9ydGVkIHZlcnNpb24gaXMgJHtNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4ZWN1dGFibGVFcnJvcihleGVjdXRhYmxlUmVzcG9uc2UuZXJyb3JNZXNzYWdlLCBleGVjdXRhYmxlUmVzcG9uc2UuZXJyb3JDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHJlc3BvbnNlIGNvbnRhaW5zIGV4cGlyYXRpb24gdGltZSBpZiBvdXRwdXQgZmlsZSB3YXMgc3BlY2lmaWVkLlxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWxlKSB7XG4gICAgICAgICAgICBpZiAoIWV4ZWN1dGFibGVSZXNwb25zZS5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvcignVGhlIGV4ZWN1dGFibGUgcmVzcG9uc2UgbXVzdCBjb250YWluIHRoZSBgZXhwaXJhdGlvbl90aW1lYCBmaWVsZCBmb3Igc3VjY2Vzc2Z1bCByZXNwb25zZXMgd2hlbiBhbiBvdXRwdXRfZmlsZSBoYXMgYmVlbiBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBpcyBub3QgZXhwaXJlZC5cbiAgICAgICAgaWYgKGV4ZWN1dGFibGVSZXNwb25zZS5pc0V4cGlyZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGVjdXRhYmxlIHJlc3BvbnNlIGlzIGV4cGlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHN1YmplY3QgdG9rZW4gZnJvbSByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGVSZXNwb25zZS5zdWJqZWN0VG9rZW47XG4gICAgfVxufVxuZXhwb3J0cy5QbHVnZ2FibGVBdXRoQ2xpZW50ID0gUGx1Z2dhYmxlQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdnYWJsZS1hdXRoLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */\nclass PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */\n    constructor(options) {\n        if (!options.command) {\n            throw new Error('No command provided.');\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error('No timeoutMillis provided.');\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */\n    retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject) => {\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: { ...process.env, ...Object.fromEntries(envMap) },\n            });\n            let output = '';\n            // Append stdout to output as executable runs.\n            child.stdout.on('data', (data) => {\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on('data', (err) => {\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(() => {\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error('The executable failed to finish within the timeout specified.'));\n            }, this.timeoutMillis);\n            child.on('close', (code) => {\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    }\n                    catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                }\n                else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */\n    async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        }\n        catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: 'utf8',\n        });\n        if (responseString === '') {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        }\n        catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */\n    static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for (let i = 0; i < components.length; i++) {\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceMappingURL=pluggable-auth-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLGlIQUF5QjtBQUNqRSw4QkFBOEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMsb0NBQWU7QUFDNUMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQStDO0FBQ3RFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxPQUFPO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsZUFBZTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcGx1Z2dhYmxlLWF1dGgtaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QbHVnZ2FibGVBdXRoSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xID0gcmVxdWlyZShcIi4vcGx1Z2dhYmxlLWF1dGgtY2xpZW50XCIpO1xuY29uc3QgZXhlY3V0YWJsZV9yZXNwb25zZV8xID0gcmVxdWlyZShcIi4vZXhlY3V0YWJsZS1yZXNwb25zZVwiKTtcbmNvbnN0IGNoaWxkUHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4vKipcbiAqIEEgaGFuZGxlciB1c2VkIHRvIHJldHJpZXZlIDNyZCBwYXJ0eSB0b2tlbiByZXNwb25zZXMgZnJvbSB1c2VyIGRlZmluZWRcbiAqIGV4ZWN1dGFibGVzIGFuZCBjYWNoZWQgZmlsZSBvdXRwdXQgZm9yIHRoZSBQbHVnZ2FibGVBdXRoQ2xpZW50IGNsYXNzLlxuICovXG5jbGFzcyBQbHVnZ2FibGVBdXRoSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgUGx1Z2dhYmxlQXV0aEhhbmRsZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogUGx1Z2dhYmxlQXV0aEhhbmRsZXJPcHRpb25zIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5jb21tYW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbW1hbmQgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21tYW5kQ29tcG9uZW50cyA9IFBsdWdnYWJsZUF1dGhIYW5kbGVyLnBhcnNlQ29tbWFuZChvcHRpb25zLmNvbW1hbmQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBvcHRpb25zLnRpbWVvdXRNaWxsaXM7XG4gICAgICAgIGlmICghdGhpcy50aW1lb3V0TWlsbGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRpbWVvdXRNaWxsaXMgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRGaWxlID0gb3B0aW9ucy5vdXRwdXRGaWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB1c2VyIHByb3ZpZGVkIGV4ZWN1dGFibGUgdG8gZ2V0IGEgM3JkIHBhcnR5IHN1YmplY3QgdG9rZW4gYW5kXG4gICAgICogcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIGVudk1hcCBhIE1hcCBvZiBhZGRpdGlvbmFsIEVudmlyb25tZW50IFZhcmlhYmxlcyByZXF1aXJlZCBmb3JcbiAgICAgKiAgIHRoZSBleGVjdXRhYmxlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXhlY3V0YWJsZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVJlc3BvbnNlRnJvbUV4ZWN1dGFibGUoZW52TWFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBTcGF3biBwcm9jZXNzIHRvIHJ1biBleGVjdXRhYmxlIHVzaW5nIGFkZGVkIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRQcm9jZXNzLnNwYXduKHRoaXMuY29tbWFuZENvbXBvbmVudHNbMF0sIHRoaXMuY29tbWFuZENvbXBvbmVudHMuc2xpY2UoMSksIHtcbiAgICAgICAgICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLk9iamVjdC5mcm9tRW50cmllcyhlbnZNYXApIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzdGRvdXQgdG8gb3V0cHV0IGFzIGV4ZWN1dGFibGUgcnVucy5cbiAgICAgICAgICAgIGNoaWxkLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFwcGVuZCBzdGRlcnIgYXMgZXhlY3V0YWJsZSBydW5zLlxuICAgICAgICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBhIHRpbWVvdXQgdG8gZW5kIHRoZSBjaGlsZCBwcm9jZXNzIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBLaWxsIGNoaWxkIHByb2Nlc3MgYW5kIHJlbW92ZSBsaXN0ZW5lcnMgc28gJ2Nsb3NlJyBldmVudCBkb2Vzbid0IGdldFxuICAgICAgICAgICAgICAgIC8vIHJlYWQgYWZ0ZXIgY2hpbGQgcHJvY2VzcyBpcyBraWxsZWQuXG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdUaGUgZXhlY3V0YWJsZSBmYWlsZWQgdG8gZmluaXNoIHdpdGhpbiB0aGUgdGltZW91dCBzcGVjaWZpZWQuJykpO1xuICAgICAgICAgICAgfSwgdGhpcy50aW1lb3V0TWlsbGlzKTtcbiAgICAgICAgICAgIGNoaWxkLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRpbWVvdXQgaWYgZXhlY3V0YWJsZSBjbG9zZXMgYmVmb3JlIHRpbWVvdXQgaXMgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV4ZWN1dGFibGUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgdHJ5IHRvIHJldHVybiB0aGUgcGFyc2VkIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZShyZXNwb25zZUpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IoYFRoZSBleGVjdXRhYmxlIHJldHVybmVkIGFuIGludmFsaWQgcmVzcG9uc2U6ICR7b3V0cHV0fWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEuRXhlY3V0YWJsZUVycm9yKG91dHB1dCwgY29kZS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdXNlciBwcm92aWRlZCBvdXRwdXQgZmlsZSBmb3IgcmVzcG9uc2UgZnJvbSBwcmV2aW91cyBydW4gb2ZcbiAgICAgKiBleGVjdXRhYmxlIGFuZCByZXR1cm4gdGhlIHJlc3BvbnNlIGlmIGl0IGV4aXN0cywgaXMgZm9ybWF0dGVkIGNvcnJlY3RseSwgYW5kIGlzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlQ2FjaGVkUmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRGaWxlIHx8IHRoaXMub3V0cHV0RmlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVQYXRoO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZVBhdGggPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFscGF0aCh0aGlzLm91dHB1dEZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gSWYgZmlsZSBwYXRoIGNhbm5vdCBiZSByZXNvbHZlZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYXdhaXQgZnMucHJvbWlzZXMubHN0YXQoZmlsZVBhdGgpKS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgLy8gSWYgcGF0aCBkb2VzIG5vdCBsZWFkIHRvIGZpbGUsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlU3RyaW5nID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoZmlsZVBhdGgsIHtcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2VTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSBKU09OLnBhcnNlKHJlc3BvbnNlU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwgYW5kIHVuZXhwaXJlZC5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IoYFRoZSBvdXRwdXQgZmlsZSBjb250YWluZWQgYW4gaW52YWxpZCByZXNwb25zZTogJHtyZXNwb25zZVN0cmluZ31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgZ2l2ZW4gY29tbWFuZCBzdHJpbmcgaW50byBjb21wb25lbnQgYXJyYXksIHNwbGl0dGluZyBvbiBzcGFjZXMgdW5sZXNzXG4gICAgICogc3BhY2VzIGFyZSBiZXR3ZWVuIHF1b3RhdGlvbiBtYXJrcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgLy8gU3BsaXQgdGhlIGNvbW1hbmQgaW50byBjb21wb25lbnRzIGJ5IHNwbGl0dGluZyBvbiBzcGFjZXMsXG4gICAgICAgIC8vIHVubGVzcyBzcGFjZXMgYXJlIGNvbnRhaW5lZCBpbiBxdW90YXRpb24gbWFya3MuXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBjb21tYW5kLm1hdGNoKC8oPzpbXlxcc1wiXSt8XCJbXlwiXSpcIikrL2cpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgY29tbWFuZDogXCIke2NvbW1hbmR9XCIgY291bGQgbm90IGJlIHBhcnNlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcXVvdGF0aW9uIG1hcmtzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGVhY2ggY29tcG9uZW50IGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHNbaV1bMF0gPT09ICdcIicgJiYgY29tcG9uZW50c1tpXS5zbGljZSgtMSkgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldID0gY29tcG9uZW50c1tpXS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufVxuZXhwb3J0cy5QbHVnZ2FibGVBdXRoSGFuZGxlciA9IFBsdWdnYWJsZUF1dGhIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2dhYmxlLWF1dGgtaGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/refreshclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nexports.USER_REFRESH_ACCOUNT_TYPE = 'authorized_user';\nclass UserRefreshClient extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : {\n                clientId: optionsOrClientId,\n                clientSecret,\n                refreshToken,\n                eagerRefreshThresholdMillis,\n                forceRefreshOnFailure,\n            };\n        super({\n            clientId: opts.clientId,\n            clientSecret: opts.clientSecret,\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure,\n        });\n        this._refreshToken = opts.refreshToken;\n        this.credentials.refresh_token = opts.refreshToken;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken An ignored refreshToken..\n     * @param callback Optional callback.\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        return super.refreshTokenNoCache(this._refreshToken);\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the user refresh token');\n        }\n        if (json.type !== 'authorized_user') {\n            throw new Error('The incoming JSON object does not have the \"authorized_user\" type');\n        }\n        if (!json.client_id) {\n            throw new Error('The incoming JSON object does not contain a client_id field');\n        }\n        if (!json.client_secret) {\n            throw new Error('The incoming JSON object does not contain a client_secret field');\n        }\n        if (!json.refresh_token) {\n            throw new Error('The incoming JSON object does not contain a refresh_token field');\n        }\n        this._clientId = json.client_id;\n        this._clientSecret = json.client_secret;\n        this._refreshToken = json.refresh_token;\n        this.credentials.refresh_token = json.refresh_token;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    async fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                return reject(new Error('Must pass in a stream containing the user refresh token.'));\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    return resolve();\n                }\n                catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n}\nexports.UserRefreshClient = UserRefreshClient;\n//# sourceMappingURL=refreshclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9yZWZyZXNoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsaUNBQWlDO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvcmVmcmVzaGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE1IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IGV4cG9ydHMuVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuZXhwb3J0cy5VU0VSX1JFRlJFU0hfQUNDT1VOVF9UWVBFID0gJ2F1dGhvcml6ZWRfdXNlcic7XG5jbGFzcyBVc2VyUmVmcmVzaENsaWVudCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9uc09yQ2xpZW50SWQsIGNsaWVudFNlY3JldCwgcmVmcmVzaFRva2VuLCBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSkge1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc09yQ2xpZW50SWQgJiYgdHlwZW9mIG9wdGlvbnNPckNsaWVudElkID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBvcHRpb25zT3JDbGllbnRJZFxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnNPckNsaWVudElkLFxuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICAgICAgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzLFxuICAgICAgICAgICAgICAgIGZvcmNlUmVmcmVzaE9uRmFpbHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNsaWVudElkOiBvcHRzLmNsaWVudElkLFxuICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBvcHRzLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpczogb3B0cy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsXG4gICAgICAgICAgICBmb3JjZVJlZnJlc2hPbkZhaWx1cmU6IG9wdHMuZm9yY2VSZWZyZXNoT25GYWlsdXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFRva2VuID0gb3B0cy5yZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiA9IG9wdHMucmVmcmVzaFRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEFuIGlnbm9yZWQgcmVmcmVzaFRva2VuLi5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZWZyZXNoVG9rZW5Ob0NhY2hlKHRoaXMuX3JlZnJlc2hUb2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFVzZXJSZWZyZXNoQ2xpZW50IGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBpbnB1dFxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VyIHJlZnJlc2ggdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlICE9PSAnYXV0aG9yaXplZF91c2VyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgaGF2ZSB0aGUgXCJhdXRob3JpemVkX3VzZXJcIiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLmNsaWVudF9pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIGNsaWVudF9pZCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5jbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X3NlY3JldCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcmVmcmVzaF90b2tlbiBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsaWVudElkID0ganNvbi5jbGllbnRfaWQ7XG4gICAgICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IGpzb24uY2xpZW50X3NlY3JldDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFRva2VuID0ganNvbi5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gPSBqc29uLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBqc29uLnF1b3RhX3Byb2plY3RfaWQ7XG4gICAgfVxuICAgIGZyb21TdHJlYW0oaW5wdXRTdHJlYW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pLnRoZW4oKCkgPT4gY2FsbGJhY2soKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHVzZXIgcmVmcmVzaCB0b2tlbi4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IFVzZXJSZWZyZXNoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmcmVzaGNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/stscredentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StsCredentials = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\n/**\n * Implements the OAuth 2.0 token exchange based on\n * https://tools.ietf.org/html/rfc8693\n */\nclass StsCredentials extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an STS credentials instance.\n     * @param tokenExchangeEndpoint The token exchange endpoint.\n     * @param clientAuthentication The client authentication credentials if\n     *   available.\n     */\n    constructor(tokenExchangeEndpoint, clientAuthentication) {\n        super(clientAuthentication);\n        this.tokenExchangeEndpoint = tokenExchangeEndpoint;\n        this.transporter = new transporters_1.DefaultTransporter();\n    }\n    /**\n     * Exchanges the provided token for another type of token based on the\n     * rfc8693 spec.\n     * @param stsCredentialsOptions The token exchange options used to populate\n     *   the token exchange request.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @param options Optional additional GCP-specific non-spec defined options\n     *   to send with the request.\n     *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`\n     * @return A promise that resolves with the token exchange response containing\n     *   the requested token and its expiration time.\n     */\n    async exchangeToken(stsCredentialsOptions, additionalHeaders, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options) {\n        var _a, _b, _c;\n        const values = {\n            grant_type: stsCredentialsOptions.grantType,\n            resource: stsCredentialsOptions.resource,\n            audience: stsCredentialsOptions.audience,\n            scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(' '),\n            requested_token_type: stsCredentialsOptions.requestedTokenType,\n            subject_token: stsCredentialsOptions.subjectToken,\n            subject_token_type: stsCredentialsOptions.subjectTokenType,\n            actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,\n            actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,\n            // Non-standard GCP-specific options.\n            options: options && JSON.stringify(options),\n        };\n        // Remove undefined fields.\n        Object.keys(values).forEach(key => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof values[key] === 'undefined') {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                delete values[key];\n            }\n        });\n        const headers = {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        };\n        // Inject additional STS headers if available.\n        Object.assign(headers, additionalHeaders || {});\n        const opts = {\n            url: this.tokenExchangeEndpoint,\n            method: 'POST',\n            headers,\n            data: querystring.stringify(values),\n            responseType: 'json',\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const stsSuccessfulResponse = response.data;\n            stsSuccessfulResponse.res = response;\n            return stsSuccessfulResponse;\n        }\n        catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, \n                // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\nexports.StsCredentials = StsCredentials;\n//# sourceMappingURL=stscredentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixpQkFBaUIsbUJBQU8sQ0FBQyw4REFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBaUI7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvc3RzY3JlZGVudGlhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RzQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydGVyc1wiKTtcbmNvbnN0IG9hdXRoMmNvbW1vbl8xID0gcmVxdWlyZShcIi4vb2F1dGgyY29tbW9uXCIpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBPQXV0aCAyLjAgdG9rZW4gZXhjaGFuZ2UgYmFzZWQgb25cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4NjkzXG4gKi9cbmNsYXNzIFN0c0NyZWRlbnRpYWxzIGV4dGVuZHMgb2F1dGgyY29tbW9uXzEuT0F1dGhDbGllbnRBdXRoSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gU1RTIGNyZWRlbnRpYWxzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB0b2tlbkV4Y2hhbmdlRW5kcG9pbnQgVGhlIHRva2VuIGV4Y2hhbmdlIGVuZHBvaW50LlxuICAgICAqIEBwYXJhbSBjbGllbnRBdXRoZW50aWNhdGlvbiBUaGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGlmXG4gICAgICogICBhdmFpbGFibGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW5FeGNoYW5nZUVuZHBvaW50LCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBzdXBlcihjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgICAgIHRoaXMudG9rZW5FeGNoYW5nZUVuZHBvaW50ID0gdG9rZW5FeGNoYW5nZUVuZHBvaW50O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gbmV3IHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNoYW5nZXMgdGhlIHByb3ZpZGVkIHRva2VuIGZvciBhbm90aGVyIHR5cGUgb2YgdG9rZW4gYmFzZWQgb24gdGhlXG4gICAgICogcmZjODY5MyBzcGVjLlxuICAgICAqIEBwYXJhbSBzdHNDcmVkZW50aWFsc09wdGlvbnMgVGhlIHRva2VuIGV4Y2hhbmdlIG9wdGlvbnMgdXNlZCB0byBwb3B1bGF0ZVxuICAgICAqICAgdGhlIHRva2VuIGV4Y2hhbmdlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIE9wdGlvbmFsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBwYXNzIGFsb25nIHRoZVxuICAgICAqICAgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBhZGRpdGlvbmFsIEdDUC1zcGVjaWZpYyBub24tc3BlYyBkZWZpbmVkIG9wdGlvbnNcbiAgICAgKiAgIHRvIHNlbmQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKiAgIEV4YW1wbGU6IGAmb3B0aW9ucz0ke2VuY29kZVVyaUNvbXBvbmVudChKU09OLnN0cmluZ2lmaWVkKG9wdGlvbnMpKX1gXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0b2tlbiBleGNoYW5nZSByZXNwb25zZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcmVxdWVzdGVkIHRva2VuIGFuZCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAqL1xuICAgIGFzeW5jIGV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCBhZGRpdGlvbmFsSGVhZGVycywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICBncmFudF90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuZ3JhbnRUeXBlLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5yZXNvdXJjZSxcbiAgICAgICAgICAgIGF1ZGllbmNlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuYXVkaWVuY2UsXG4gICAgICAgICAgICBzY29wZTogKF9hID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLnNjb3BlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignICcpLFxuICAgICAgICAgICAgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5yZXF1ZXN0ZWRUb2tlblR5cGUsXG4gICAgICAgICAgICBzdWJqZWN0X3Rva2VuOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuc3ViamVjdFRva2VuLFxuICAgICAgICAgICAgc3ViamVjdF90b2tlbl90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMuc3ViamVjdFRva2VuVHlwZSxcbiAgICAgICAgICAgIGFjdG9yX3Rva2VuOiAoX2IgPSBzdHNDcmVkZW50aWFsc09wdGlvbnMuYWN0aW5nUGFydHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3RvclRva2VuLFxuICAgICAgICAgICAgYWN0b3JfdG9rZW5fdHlwZTogKF9jID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLmFjdGluZ1BhcnR5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWN0b3JUb2tlblR5cGUsXG4gICAgICAgICAgICAvLyBOb24tc3RhbmRhcmQgR0NQLXNwZWNpZmljIG9wdGlvbnMuXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zICYmIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIGZpZWxkcy5cbiAgICAgICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEluamVjdCBhZGRpdGlvbmFsIFNUUyBoZWFkZXJzIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBhZGRpdGlvbmFsSGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmw6IHRoaXMudG9rZW5FeGNoYW5nZUVuZHBvaW50LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHZhbHVlcyksXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXBwbHkgT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICB0aGlzLmFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zKG9wdHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICAvLyBTdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3Qgc3RzU3VjY2Vzc2Z1bFJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHN0c1N1Y2Nlc3NmdWxSZXNwb25zZS5yZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBzdHNTdWNjZXNzZnVsUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgZXJyb3IgdG8gT0F1dGhFcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIG9hdXRoMmNvbW1vbl8xLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSkoZXJyb3IucmVzcG9uc2UuZGF0YSwgXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgb3RoZXIgZmllbGRzIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY291bGQgZmFpbCBiZWZvcmUgdGhlIHNlcnZlciByZXNwb25kcy5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdHNDcmVkZW50aWFscyA9IFN0c0NyZWRlbnRpYWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RzY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/browser/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserCrypto = void 0;\n// This file implements crypto functions we need using in-browser\n// SubtleCrypto interface `window.crypto.subtle`.\nconst base64js = __webpack_require__(/*! base64-js */ \"(rsc)/./node_modules/base64-js/index.js\");\n// Not all browsers support `TextEncoder`. The following `require` will\n// provide a fast UTF8-only replacement for those browsers that don't support\n// text encoding natively.\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nif (typeof process === 'undefined' && typeof TextEncoder === 'undefined') {\n    __webpack_require__(/*! fast-text-encoding */ \"(rsc)/./node_modules/fast-text-encoding/text.min.js\");\n}\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nclass BrowserCrypto {\n    constructor() {\n        if (typeof window === 'undefined' ||\n            window.crypto === undefined ||\n            window.crypto.subtle === undefined) {\n            throw new Error(\"SubtleCrypto not found. Make sure it's an https:// website.\");\n        }\n    }\n    async sha256DigestBase64(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest('SHA-256', inputBuffer);\n        return base64js.fromByteArray(new Uint8Array(outputBuffer));\n    }\n    randomBytesBase64(count) {\n        const array = new Uint8Array(count);\n        window.crypto.getRandomValues(array);\n        return base64js.fromByteArray(array);\n    }\n    static padBase64(base64) {\n        // base64js requires padding, so let's add some '='\n        while (base64.length % 4 !== 0) {\n            base64 += '=';\n        }\n        return base64;\n    }\n    async verify(pubkey, data, signature) {\n        const algo = {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: { name: 'SHA-256' },\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));\n        const cryptoKey = await window.crypto.subtle.importKey('jwk', pubkey, algo, true, ['verify']);\n        // SubtleCrypto's verify method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);\n        return result;\n    }\n    async sign(privateKey, data) {\n        const algo = {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: { name: 'SHA-256' },\n        };\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const dataArray = new TextEncoder().encode(data);\n        const cryptoKey = await window.crypto.subtle.importKey('jwk', privateKey, algo, true, ['sign']);\n        // SubtleCrypto's sign method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);\n        return base64js.fromByteArray(new Uint8Array(result));\n    }\n    decodeBase64StringUtf8(base64) {\n        const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const result = new TextDecoder().decode(uint8array);\n        return result;\n    }\n    encodeBase64StringUtf8(text) {\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const uint8array = new TextEncoder().encode(text);\n        const result = base64js.fromByteArray(uint8array);\n        return result;\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */\n    async sha256DigestHex(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest('SHA-256', inputBuffer);\n        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */\n    async signWithHmacSha256(key, msg) {\n        // Convert key, if provided in ArrayBuffer format, to string.\n        const rawKey = typeof key === 'string'\n            ? key\n            : String.fromCharCode(...new Uint16Array(key));\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        const enc = new TextEncoder();\n        const cryptoKey = await window.crypto.subtle.importKey('raw', enc.encode(rawKey), {\n            name: 'HMAC',\n            hash: {\n                name: 'SHA-256',\n            },\n        }, false, ['sign']);\n        return window.crypto.subtle.sign('HMAC', cryptoKey, enc.encode(msg));\n    }\n}\nexports.BrowserCrypto = BrowserCrypto;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2Jyb3dzZXIvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFPLENBQUMsK0VBQW9CO0FBQ2hDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0ZBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2Jyb3dzZXIvY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBnbG9iYWwgd2luZG93ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJDcnlwdG8gPSB2b2lkIDA7XG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBjcnlwdG8gZnVuY3Rpb25zIHdlIG5lZWQgdXNpbmcgaW4tYnJvd3NlclxuLy8gU3VidGxlQ3J5cHRvIGludGVyZmFjZSBgd2luZG93LmNyeXB0by5zdWJ0bGVgLlxuY29uc3QgYmFzZTY0anMgPSByZXF1aXJlKFwiYmFzZTY0LWpzXCIpO1xuLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IGBUZXh0RW5jb2RlcmAuIFRoZSBmb2xsb3dpbmcgYHJlcXVpcmVgIHdpbGxcbi8vIHByb3ZpZGUgYSBmYXN0IFVURjgtb25seSByZXBsYWNlbWVudCBmb3IgdGhvc2UgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0XG4vLyB0ZXh0IGVuY29kaW5nIG5hdGl2ZWx5LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVxdWlyZSgnZmFzdC10ZXh0LWVuY29kaW5nJyk7XG59XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG9cIik7XG5jbGFzcyBCcm93c2VyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB3aW5kb3cuY3J5cHRvID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHdpbmRvdy5jcnlwdG8uc3VidGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1YnRsZUNyeXB0byBub3QgZm91bmQuIE1ha2Ugc3VyZSBpdCdzIGFuIGh0dHBzOi8vIHdlYnNpdGUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEJhc2U2NChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gYmFzZTY0anMuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShvdXRwdXRCdWZmZXIpKTtcbiAgICB9XG4gICAgcmFuZG9tQnl0ZXNCYXNlNjQoY291bnQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICAvLyBiYXNlNjRqcyByZXF1aXJlcyBwYWRkaW5nLCBzbyBsZXQncyBhZGQgc29tZSAnPSdcbiAgICAgICAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBhbGdvID0ge1xuICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVBcnJheSA9IGJhc2U2NGpzLnRvQnl0ZUFycmF5KEJyb3dzZXJDcnlwdG8ucGFkQmFzZTY0KHNpZ25hdHVyZSkpO1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHB1YmtleSwgYWxnbywgdHJ1ZSwgWyd2ZXJpZnknXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHZlcmlmeSBtZXRob2QgaXMgYXN5bmMgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvLCBjcnlwdG9LZXksIHNpZ25hdHVyZUFycmF5LCBkYXRhQXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaWduKHByaXZhdGVLZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgYWxnbyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBwcml2YXRlS2V5LCBhbGdvLCB0cnVlLCBbJ3NpZ24nXSk7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0bydzIHNpZ24gbWV0aG9kIGlzIGFzeW5jIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5zaWduKGFsZ28sIGNyeXB0b0tleSwgZGF0YUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBiYXNlNjRqcy50b0J5dGVBcnJheShCcm93c2VyQ3J5cHRvLnBhZEJhc2U2NChiYXNlNjQpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZUJhc2U2NFN0cmluZ1V0ZjgodGV4dCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGNvbnN0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJhc2U2NGpzLmZyb21CeXRlQXJyYXkodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvIGRpZ2VzdCgpIG1ldGhvZCBpcyBhc3luYywgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBTSEEyNTYgZGlnZXN0IHVzaW5nIFN1YnRsZUNyeXB0bywgd2UgZmlyc3RcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IGFuIGlucHV0IHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlcjpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gKDAsIGNyeXB0b18xLmZyb21BcnJheUJ1ZmZlclRvSGV4KShvdXRwdXRCdWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgLy8gQ29udmVydCBrZXksIGlmIHByb3ZpZGVkIGluIEFycmF5QnVmZmVyIGZvcm1hdCwgdG8gc3RyaW5nLlxuICAgICAgICBjb25zdCByYXdLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDE2QXJyYXkoa2V5KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShyYXdLZXkpLCB7XG4gICAgICAgICAgICBuYW1lOiAnSE1BQycsXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLnNpZ24oJ0hNQUMnLCBjcnlwdG9LZXksIGVuYy5lbmNvZGUobXNnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gQnJvd3NlckNyeXB0bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js":
/*!*********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/crypto.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromArrayBufferToHex = exports.hasBrowserCrypto = exports.createCrypto = void 0;\nconst crypto_1 = __webpack_require__(/*! ./browser/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\");\nconst crypto_2 = __webpack_require__(/*! ./node/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\");\nfunction createCrypto() {\n    if (hasBrowserCrypto()) {\n        return new crypto_1.BrowserCrypto();\n    }\n    return new crypto_2.NodeCrypto();\n}\nexports.createCrypto = createCrypto;\nfunction hasBrowserCrypto() {\n    return (typeof window !== 'undefined' &&\n        typeof window.crypto !== 'undefined' &&\n        typeof window.crypto.subtle !== 'undefined');\n}\nexports.hasBrowserCrypto = hasBrowserCrypto;\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.\n * @return The hexadecimal encoding of the ArrayBuffer.\n */\nfunction fromArrayBufferToHex(arrayBuffer) {\n    // Convert buffer to byte array.\n    const byteArray = Array.from(new Uint8Array(arrayBuffer));\n    // Convert bytes to hex string.\n    return byteArray\n        .map(byte => {\n        return byte.toString(16).padStart(2, '0');\n    })\n        .join('');\n}\nexports.fromArrayBufferToHex = fromArrayBufferToHex;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CO0FBQzlFLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFrQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQywrRkFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGV4cG9ydHMuaGFzQnJvd3NlckNyeXB0byA9IGV4cG9ydHMuY3JlYXRlQ3J5cHRvID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi9icm93c2VyL2NyeXB0b1wiKTtcbmNvbnN0IGNyeXB0b18yID0gcmVxdWlyZShcIi4vbm9kZS9jcnlwdG9cIik7XG5mdW5jdGlvbiBjcmVhdGVDcnlwdG8oKSB7XG4gICAgaWYgKGhhc0Jyb3dzZXJDcnlwdG8oKSkge1xuICAgICAgICByZXR1cm4gbmV3IGNyeXB0b18xLkJyb3dzZXJDcnlwdG8oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjcnlwdG9fMi5Ob2RlQ3J5cHRvKCk7XG59XG5leHBvcnRzLmNyZWF0ZUNyeXB0byA9IGNyZWF0ZUNyeXB0bztcbmZ1bmN0aW9uIGhhc0Jyb3dzZXJDcnlwdG8oKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5jcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyk7XG59XG5leHBvcnRzLmhhc0Jyb3dzZXJDcnlwdG8gPSBoYXNCcm93c2VyQ3J5cHRvO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSBhcnJheUJ1ZmZlciBUaGUgQXJyYXlCdWZmZXIgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJuIFRoZSBoZXhhZGVjaW1hbCBlbmNvZGluZyBvZiB0aGUgQXJyYXlCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlclRvSGV4KGFycmF5QnVmZmVyKSB7XG4gICAgLy8gQ29udmVydCBidWZmZXIgdG8gYnl0ZSBhcnJheS5cbiAgICBjb25zdCBieXRlQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgLy8gQ29udmVydCBieXRlcyB0byBoZXggc3RyaW5nLlxuICAgIHJldHVybiBieXRlQXJyYXlcbiAgICAgICAgLm1hcChieXRlID0+IHtcbiAgICAgICAgcmV0dXJuIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0cy5mcm9tQXJyYXlCdWZmZXJUb0hleCA9IGZyb21BcnJheUJ1ZmZlclRvSGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/node/crypto.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodeCrypto = void 0;\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nclass NodeCrypto {\n    async sha256DigestBase64(str) {\n        return crypto.createHash('sha256').update(str).digest('base64');\n    }\n    randomBytesBase64(count) {\n        return crypto.randomBytes(count).toString('base64');\n    }\n    async verify(pubkey, data, signature) {\n        const verifier = crypto.createVerify('sha256');\n        verifier.update(data);\n        verifier.end();\n        return verifier.verify(pubkey, signature, 'base64');\n    }\n    async sign(privateKey, data) {\n        const signer = crypto.createSign('RSA-SHA256');\n        signer.update(data);\n        signer.end();\n        return signer.sign(privateKey, 'base64');\n    }\n    decodeBase64StringUtf8(base64) {\n        return Buffer.from(base64, 'base64').toString('utf-8');\n    }\n    encodeBase64StringUtf8(text) {\n        return Buffer.from(text, 'utf-8').toString('base64');\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */\n    async sha256DigestHex(str) {\n        return crypto.createHash('sha256').update(str).digest('hex');\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */\n    async signWithHmacSha256(key, msg) {\n        const cryptoKey = typeof key === 'string' ? key : toBuffer(key);\n        return toArrayBuffer(crypto.createHmac('sha256', cryptoKey).update(msg).digest());\n    }\n}\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */\nfunction toArrayBuffer(buffer) {\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */\nfunction toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n}\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL25vZGUvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL25vZGUvY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vZGVDcnlwdG8gPSB2b2lkIDA7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY2xhc3MgTm9kZUNyeXB0byB7XG4gICAgYXN5bmMgc2hhMjU2RGlnZXN0QmFzZTY0KHN0cikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzQmFzZTY0KGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KHB1YmtleSwgZGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeSgnc2hhMjU2Jyk7XG4gICAgICAgIHZlcmlmaWVyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgdmVyaWZpZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnkocHVia2V5LCBzaWduYXR1cmUsICdiYXNlNjQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbihwcml2YXRlS2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVTaWduKCdSU0EtU0hBMjU2Jyk7XG4gICAgICAgIHNpZ25lci51cGRhdGUoZGF0YSk7XG4gICAgICAgIHNpZ25lci5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHNpZ25lci5zaWduKHByaXZhdGVLZXksICdiYXNlNjQnKTtcbiAgICB9XG4gICAgZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICBlbmNvZGVCYXNlNjRTdHJpbmdVdGY4KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRleHQsICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIFNIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzdHIgVGhlIHBsYWluIHRleHQgc3RyaW5nIHRvIGhhc2guXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkXG4gICAgICogICBzdHJpbmcgaW4gaGV4YWRlY2ltYWwgZW5jb2RpbmcuXG4gICAgICovXG4gICAgYXN5bmMgc2hhMjU2RGlnZXN0SGV4KHN0cikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBITUFDIGhhc2ggb2YgYSBtZXNzYWdlIHVzaW5nIHRoZSBwcm92aWRlZCBjcnlwdG8ga2V5IGFuZCB0aGVcbiAgICAgKiBTSEEtMjU2IGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBzZWNyZXQgY3J5cHRvIGtleSBpbiB1dGYtOCBvciBBcnJheUJ1ZmZlciBmb3JtYXQuXG4gICAgICogQHBhcmFtIG1zZyBUaGUgcGxhaW4gdGV4dCBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgSE1BQy1TSEEyNTYgaGFzaCBpbiBBcnJheUJ1ZmZlclxuICAgICAqICAgZm9ybWF0LlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25XaXRoSG1hY1NoYTI1NihrZXksIG1zZykge1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IGtleSA6IHRvQnVmZmVyKGtleSk7XG4gICAgICAgIHJldHVybiB0b0FycmF5QnVmZmVyKGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBjcnlwdG9LZXkpLnVwZGF0ZShtc2cpLmRpZ2VzdCgpKTtcbiAgICB9XG59XG5leHBvcnRzLk5vZGVDcnlwdG8gPSBOb2RlQ3J5cHRvO1xuLyoqXG4gKiBDb252ZXJ0cyBhIE5vZGUuanMgQnVmZmVyIHRvIGFuIEFycmF5QnVmZmVyLlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODYwOTI4OS9jb252ZXJ0LWEtYmluYXJ5LW5vZGVqcy1idWZmZXItdG8tamF2YXNjcmlwdC1hcnJheWJ1ZmZlclxuICogQHBhcmFtIGJ1ZmZlciBUaGUgQnVmZmVyIGlucHV0IHRvIGNvdmVydC5cbiAqIEByZXR1cm4gVGhlIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlci5zbGljZShidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIEFycmF5QnVmZmVyIHRvIGEgTm9kZS5qcyBCdWZmZXIuXG4gKiBAcGFyYW0gYXJyYXlCdWZmZXIgVGhlIEFycmF5QnVmZmVyIGlucHV0IHRvIGNvdmVydC5cbiAqIEByZXR1cm4gVGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.AuthClient = void 0;\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst googleauth_1 = __webpack_require__(/*! ./auth/googleauth */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\");\nObject.defineProperty(exports, \"GoogleAuth\", ({ enumerable: true, get: function () { return googleauth_1.GoogleAuth; } }));\nvar authclient_1 = __webpack_require__(/*! ./auth/authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"AuthClient\", ({ enumerable: true, get: function () { return authclient_1.AuthClient; } }));\nvar computeclient_1 = __webpack_require__(/*! ./auth/computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nObject.defineProperty(exports, \"Compute\", ({ enumerable: true, get: function () { return computeclient_1.Compute; } }));\nvar envDetect_1 = __webpack_require__(/*! ./auth/envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nObject.defineProperty(exports, \"GCPEnv\", ({ enumerable: true, get: function () { return envDetect_1.GCPEnv; } }));\nvar iam_1 = __webpack_require__(/*! ./auth/iam */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\");\nObject.defineProperty(exports, \"IAMAuth\", ({ enumerable: true, get: function () { return iam_1.IAMAuth; } }));\nvar idtokenclient_1 = __webpack_require__(/*! ./auth/idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nObject.defineProperty(exports, \"IdTokenClient\", ({ enumerable: true, get: function () { return idtokenclient_1.IdTokenClient; } }));\nvar jwtaccess_1 = __webpack_require__(/*! ./auth/jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nObject.defineProperty(exports, \"JWTAccess\", ({ enumerable: true, get: function () { return jwtaccess_1.JWTAccess; } }));\nvar jwtclient_1 = __webpack_require__(/*! ./auth/jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nObject.defineProperty(exports, \"JWT\", ({ enumerable: true, get: function () { return jwtclient_1.JWT; } }));\nvar impersonated_1 = __webpack_require__(/*! ./auth/impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nObject.defineProperty(exports, \"Impersonated\", ({ enumerable: true, get: function () { return impersonated_1.Impersonated; } }));\nvar oauth2client_1 = __webpack_require__(/*! ./auth/oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nObject.defineProperty(exports, \"CodeChallengeMethod\", ({ enumerable: true, get: function () { return oauth2client_1.CodeChallengeMethod; } }));\nObject.defineProperty(exports, \"OAuth2Client\", ({ enumerable: true, get: function () { return oauth2client_1.OAuth2Client; } }));\nvar loginticket_1 = __webpack_require__(/*! ./auth/loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nObject.defineProperty(exports, \"LoginTicket\", ({ enumerable: true, get: function () { return loginticket_1.LoginTicket; } }));\nvar refreshclient_1 = __webpack_require__(/*! ./auth/refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nObject.defineProperty(exports, \"UserRefreshClient\", ({ enumerable: true, get: function () { return refreshclient_1.UserRefreshClient; } }));\nvar awsclient_1 = __webpack_require__(/*! ./auth/awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nObject.defineProperty(exports, \"AwsClient\", ({ enumerable: true, get: function () { return awsclient_1.AwsClient; } }));\nvar identitypoolclient_1 = __webpack_require__(/*! ./auth/identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nObject.defineProperty(exports, \"IdentityPoolClient\", ({ enumerable: true, get: function () { return identitypoolclient_1.IdentityPoolClient; } }));\nvar externalclient_1 = __webpack_require__(/*! ./auth/externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nObject.defineProperty(exports, \"ExternalAccountClient\", ({ enumerable: true, get: function () { return externalclient_1.ExternalAccountClient; } }));\nvar baseexternalclient_1 = __webpack_require__(/*! ./auth/baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nObject.defineProperty(exports, \"BaseExternalAccountClient\", ({ enumerable: true, get: function () { return baseexternalclient_1.BaseExternalAccountClient; } }));\nvar downscopedclient_1 = __webpack_require__(/*! ./auth/downscopedclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\");\nObject.defineProperty(exports, \"DownscopedClient\", ({ enumerable: true, get: function () { return downscopedclient_1.DownscopedClient; } }));\nvar pluggable_auth_client_1 = __webpack_require__(/*! ./auth/pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nObject.defineProperty(exports, \"PluggableAuthClient\", ({ enumerable: true, get: function () { return pluggable_auth_client_1.PluggableAuthClient; } }));\nvar transporters_1 = __webpack_require__(/*! ./transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nObject.defineProperty(exports, \"DefaultTransporter\", ({ enumerable: true, get: function () { return transporters_1.DefaultTransporter; } }));\nconst auth = new googleauth_1.GoogleAuth();\nexports.auth = auth;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QixHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxrQkFBa0I7QUFDOWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDaEQsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILG1CQUFtQixtQkFBTyxDQUFDLGdHQUFtQjtBQUM5Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsc0JBQXNCLG1CQUFPLENBQUMsc0dBQXNCO0FBQ3BELDJDQUEwQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUNySCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBa0I7QUFDNUMsMENBQXlDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQy9HLFlBQVksbUJBQU8sQ0FBQyxrRkFBWTtBQUNoQywyQ0FBMEMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDM0csc0JBQXNCLG1CQUFPLENBQUMsc0dBQXNCO0FBQ3BELGlEQUFnRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNqSSxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBa0I7QUFDNUMsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGtCQUFrQixtQkFBTyxDQUFDLDhGQUFrQjtBQUM1Qyx1Q0FBc0MsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDekcscUJBQXFCLG1CQUFPLENBQUMsb0dBQXFCO0FBQ2xELGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBcUI7QUFDbEQsdURBQXNELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQzVJLGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDaEQsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILHNCQUFzQixtQkFBTyxDQUFDLHNHQUFzQjtBQUNwRCxxREFBb0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDekksa0JBQWtCLG1CQUFPLENBQUMsOEZBQWtCO0FBQzVDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCwyQkFBMkIsbUJBQU8sQ0FBQyxnSEFBMkI7QUFDOUQsc0RBQXFELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQ2hKLHVCQUF1QixtQkFBTyxDQUFDLHdHQUF1QjtBQUN0RCx5REFBd0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDbEosMkJBQTJCLG1CQUFPLENBQUMsZ0hBQTJCO0FBQzlELDZEQUE0RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUM5Six5QkFBeUIsbUJBQU8sQ0FBQyw0R0FBeUI7QUFDMUQsb0RBQW1ELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQzFJLDhCQUE4QixtQkFBTyxDQUFDLHNIQUE4QjtBQUNwRSx1REFBc0QsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDckoscUJBQXFCLG1CQUFPLENBQUMsMEZBQWdCO0FBQzdDLHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSTtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBleHBvcnRzLmF1dGggPSBleHBvcnRzLkRlZmF1bHRUcmFuc3BvcnRlciA9IGV4cG9ydHMuUGx1Z2dhYmxlQXV0aENsaWVudCA9IGV4cG9ydHMuRG93bnNjb3BlZENsaWVudCA9IGV4cG9ydHMuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCA9IGV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5JZGVudGl0eVBvb2xDbGllbnQgPSBleHBvcnRzLkF3c0NsaWVudCA9IGV4cG9ydHMuVXNlclJlZnJlc2hDbGllbnQgPSBleHBvcnRzLkxvZ2luVGlja2V0ID0gZXhwb3J0cy5PQXV0aDJDbGllbnQgPSBleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSBleHBvcnRzLkltcGVyc29uYXRlZCA9IGV4cG9ydHMuSldUID0gZXhwb3J0cy5KV1RBY2Nlc3MgPSBleHBvcnRzLklkVG9rZW5DbGllbnQgPSBleHBvcnRzLklBTUF1dGggPSBleHBvcnRzLkdDUEVudiA9IGV4cG9ydHMuQ29tcHV0ZSA9IGV4cG9ydHMuQXV0aENsaWVudCA9IHZvaWQgMDtcbi8vIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgZ29vZ2xlYXV0aF8xID0gcmVxdWlyZShcIi4vYXV0aC9nb29nbGVhdXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR29vZ2xlQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ29vZ2xlYXV0aF8xLkdvb2dsZUF1dGg7IH0gfSk7XG52YXIgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9hdXRoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXV0aENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aGNsaWVudF8xLkF1dGhDbGllbnQ7IH0gfSk7XG52YXIgY29tcHV0ZWNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9jb21wdXRlY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tcHV0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHV0ZWNsaWVudF8xLkNvbXB1dGU7IH0gfSk7XG52YXIgZW52RGV0ZWN0XzEgPSByZXF1aXJlKFwiLi9hdXRoL2VudkRldGVjdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdDUEVudlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW52RGV0ZWN0XzEuR0NQRW52OyB9IH0pO1xudmFyIGlhbV8xID0gcmVxdWlyZShcIi4vYXV0aC9pYW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJQU1BdXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpYW1fMS5JQU1BdXRoOyB9IH0pO1xudmFyIGlkdG9rZW5jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvaWR0b2tlbmNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkVG9rZW5DbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkdG9rZW5jbGllbnRfMS5JZFRva2VuQ2xpZW50OyB9IH0pO1xudmFyIGp3dGFjY2Vzc18xID0gcmVxdWlyZShcIi4vYXV0aC9qd3RhY2Nlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKV1RBY2Nlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGp3dGFjY2Vzc18xLkpXVEFjY2VzczsgfSB9KTtcbnZhciBqd3RjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvand0Y2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSldUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqd3RjbGllbnRfMS5KV1Q7IH0gfSk7XG52YXIgaW1wZXJzb25hdGVkXzEgPSByZXF1aXJlKFwiLi9hdXRoL2ltcGVyc29uYXRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcGVyc29uYXRlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW1wZXJzb25hdGVkXzEuSW1wZXJzb25hdGVkOyB9IH0pO1xudmFyIG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9vYXV0aDJjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlQ2hhbGxlbmdlTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYXV0aDJjbGllbnRfMS5Db2RlQ2hhbGxlbmdlTWV0aG9kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT0F1dGgyQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQ7IH0gfSk7XG52YXIgbG9naW50aWNrZXRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvbG9naW50aWNrZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dpblRpY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9naW50aWNrZXRfMS5Mb2dpblRpY2tldDsgfSB9KTtcbnZhciByZWZyZXNoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL3JlZnJlc2hjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVc2VyUmVmcmVzaENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVmcmVzaGNsaWVudF8xLlVzZXJSZWZyZXNoQ2xpZW50OyB9IH0pO1xudmFyIGF3c2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9hd3NjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBd3NDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF3c2NsaWVudF8xLkF3c0NsaWVudDsgfSB9KTtcbnZhciBpZGVudGl0eXBvb2xjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvaWRlbnRpdHlwb29sY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWRlbnRpdHlQb29sQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZGVudGl0eXBvb2xjbGllbnRfMS5JZGVudGl0eVBvb2xDbGllbnQ7IH0gfSk7XG52YXIgZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvZXh0ZXJuYWxjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeHRlcm5hbEFjY291bnRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4dGVybmFsY2xpZW50XzEuRXh0ZXJuYWxBY2NvdW50Q2xpZW50OyB9IH0pO1xudmFyIGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50OyB9IH0pO1xudmFyIGRvd25zY29wZWRjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvZG93bnNjb3BlZGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvd25zY29wZWRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvd25zY29wZWRjbGllbnRfMS5Eb3duc2NvcGVkQ2xpZW50OyB9IH0pO1xudmFyIHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQbHVnZ2FibGVBdXRoQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMS5QbHVnZ2FibGVBdXRoQ2xpZW50OyB9IH0pO1xudmFyIHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0ZXJzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdFRyYW5zcG9ydGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXI7IH0gfSk7XG5jb25zdCBhdXRoID0gbmV3IGdvb2dsZWF1dGhfMS5Hb29nbGVBdXRoKCk7XG5leHBvcnRzLmF1dGggPSBhdXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/options.js":
/*!***************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/options.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validate = void 0;\n// Accepts an options object passed from the user to the API.  In the\n// previous version of the API, it referred to a `Request` options object.\n// Now it refers to an Axiox Request Config object.  This is here to help\n// ensure users don't pass invalid options when they upgrade from 0.x to 1.x.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validate(options) {\n    const vpairs = [\n        { invalid: 'uri', expected: 'url' },\n        { invalid: 'json', expected: 'data' },\n        { invalid: 'qs', expected: 'params' },\n    ];\n    for (const pair of vpairs) {\n        if (options[pair.invalid]) {\n            const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;\n            throw new Error(e);\n        }\n    }\n}\nexports.validate = validate;\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDLFVBQVUsbUNBQW1DO0FBQzdDLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLHFEQUFxRCxjQUFjO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9vcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlID0gdm9pZCAwO1xuLy8gQWNjZXB0cyBhbiBvcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgdXNlciB0byB0aGUgQVBJLiAgSW4gdGhlXG4vLyBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSBBUEksIGl0IHJlZmVycmVkIHRvIGEgYFJlcXVlc3RgIG9wdGlvbnMgb2JqZWN0LlxuLy8gTm93IGl0IHJlZmVycyB0byBhbiBBeGlveCBSZXF1ZXN0IENvbmZpZyBvYmplY3QuICBUaGlzIGlzIGhlcmUgdG8gaGVscFxuLy8gZW5zdXJlIHVzZXJzIGRvbid0IHBhc3MgaW52YWxpZCBvcHRpb25zIHdoZW4gdGhleSB1cGdyYWRlIGZyb20gMC54IHRvIDEueC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgdnBhaXJzID0gW1xuICAgICAgICB7IGludmFsaWQ6ICd1cmknLCBleHBlY3RlZDogJ3VybCcgfSxcbiAgICAgICAgeyBpbnZhbGlkOiAnanNvbicsIGV4cGVjdGVkOiAnZGF0YScgfSxcbiAgICAgICAgeyBpbnZhbGlkOiAncXMnLCBleHBlY3RlZDogJ3BhcmFtcycgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB2cGFpcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbcGFpci5pbnZhbGlkXSkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGAnJHtwYWlyLmludmFsaWR9JyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uIG9wdGlvbi4gUGxlYXNlIHVzZSAnJHtwYWlyLmV4cGVjdGVkfScgaW5zdGVhZC4gVGhpcyBsaWJyYXJ5IGlzIHVzaW5nIEF4aW9zIGZvciByZXF1ZXN0cy4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MgdG8gbGVhcm4gbW9yZSBhYm91dCB0aGUgdmFsaWQgcmVxdWVzdCBvcHRpb25zLmA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/transporters.js":
/*!********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/transporters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DefaultTransporter = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/google-auth-library/build/src/options.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/google-auth-library/package.json\");\nconst PRODUCT_NAME = 'google-api-nodejs-client';\nclass DefaultTransporter {\n    /**\n     * Configures request options before making a request.\n     * @param opts GaxiosOptions options.\n     * @return Configured options.\n     */\n    configure(opts = {}) {\n        opts.headers = opts.headers || {};\n        if (typeof window === 'undefined') {\n            // set transporter user agent if not in browser\n            const uaValue = opts.headers['User-Agent'];\n            if (!uaValue) {\n                opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n            }\n            else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n                opts.headers['User-Agent'] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n            }\n            // track google-auth-library-nodejs version:\n            if (!opts.headers['x-goog-api-client']) {\n                const nodeVersion = process.version.replace(/^v/, '');\n                opts.headers['x-goog-api-client'] = `gl-node/${nodeVersion}`;\n            }\n        }\n        return opts;\n    }\n    request(opts, callback) {\n        // ensure the user isn't passing in request-style options\n        opts = this.configure(opts);\n        try {\n            (0, options_1.validate)(opts);\n        }\n        catch (e) {\n            if (callback) {\n                return callback(e);\n            }\n            else {\n                throw e;\n            }\n        }\n        if (callback) {\n            (0, gaxios_1.request)(opts).then(r => {\n                callback(null, r);\n            }, e => {\n                callback(this.processError(e));\n            });\n        }\n        else {\n            return (0, gaxios_1.request)(opts).catch(e => {\n                throw this.processError(e);\n            });\n        }\n    }\n    /**\n     * Changes the error to include details from the body.\n     */\n    processError(e) {\n        const res = e.response;\n        const err = e;\n        const body = res ? res.data : null;\n        if (res && body && body.error && res.status !== 200) {\n            if (typeof body.error === 'string') {\n                err.message = body.error;\n                err.code = res.status.toString();\n            }\n            else if (Array.isArray(body.error.errors)) {\n                err.message = body.error.errors\n                    .map((err2) => err2.message)\n                    .join('\\n');\n                err.code = body.error.code;\n                err.errors = body.error.errors;\n            }\n            else {\n                err.message = body.error.message;\n                err.code = body.error.code || res.status;\n            }\n        }\n        else if (res && res.status >= 400) {\n            // Consider all 4xx and 5xx responses errors.\n            err.message = body;\n            err.code = res.status.toString();\n        }\n        return err;\n    }\n}\nexports.DefaultTransporter = DefaultTransporter;\n/**\n * Default user agent.\n */\nDefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n//# sourceMappingURL=transporters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLDhEQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFXO0FBQ3JDO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGlGQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZELGdEQUFnRCxTQUFTLEVBQUUsOEJBQThCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhLEdBQUcsWUFBWTtBQUMvRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRUcmFuc3BvcnRlciA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBQUk9EVUNUX05BTUUgPSAnZ29vZ2xlLWFwaS1ub2RlanMtY2xpZW50JztcbmNsYXNzIERlZmF1bHRUcmFuc3BvcnRlciB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyByZXF1ZXN0IG9wdGlvbnMgYmVmb3JlIG1ha2luZyBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMgR2F4aW9zT3B0aW9ucyBvcHRpb25zLlxuICAgICAqIEByZXR1cm4gQ29uZmlndXJlZCBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRzID0ge30pIHtcbiAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHNldCB0cmFuc3BvcnRlciB1c2VyIGFnZW50IGlmIG5vdCBpbiBicm93c2VyXG4gICAgICAgICAgICBjb25zdCB1YVZhbHVlID0gb3B0cy5oZWFkZXJzWydVc2VyLUFnZW50J107XG4gICAgICAgICAgICBpZiAoIXVhVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IERlZmF1bHRUcmFuc3BvcnRlci5VU0VSX0FHRU5UO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXVhVmFsdWUuaW5jbHVkZXMoYCR7UFJPRFVDVF9OQU1FfS9gKSkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1snVXNlci1BZ2VudCddID0gYCR7dWFWYWx1ZX0gJHtEZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJhY2sgZ29vZ2xlLWF1dGgtbGlicmFyeS1ub2RlanMgdmVyc2lvbjpcbiAgICAgICAgICAgIGlmICghb3B0cy5oZWFkZXJzWyd4LWdvb2ctYXBpLWNsaWVudCddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb24ucmVwbGFjZSgvXnYvLCAnJyk7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctYXBpLWNsaWVudCddID0gYGdsLW5vZGUvJHtub2RlVmVyc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGUgdXNlciBpc24ndCBwYXNzaW5nIGluIHJlcXVlc3Qtc3R5bGUgb3B0aW9uc1xuICAgICAgICBvcHRzID0gdGhpcy5jb25maWd1cmUob3B0cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoMCwgb3B0aW9uc18xLnZhbGlkYXRlKShvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShvcHRzKS50aGVuKHIgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHIpO1xuICAgICAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5wcm9jZXNzRXJyb3IoZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdheGlvc18xLnJlcXVlc3QpKG9wdHMpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZXJyb3IgdG8gaW5jbHVkZSBkZXRhaWxzIGZyb20gdGhlIGJvZHkuXG4gICAgICovXG4gICAgcHJvY2Vzc0Vycm9yKGUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgY29uc3QgZXJyID0gZTtcbiAgICAgICAgY29uc3QgYm9keSA9IHJlcyA/IHJlcy5kYXRhIDogbnVsbDtcbiAgICAgICAgaWYgKHJlcyAmJiBib2R5ICYmIGJvZHkuZXJyb3IgJiYgcmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5LmVycm9yO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gcmVzLnN0YXR1cy50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShib2R5LmVycm9yLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHkuZXJyb3IuZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVycjIpID0+IGVycjIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gYm9keS5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgIGVyci5lcnJvcnMgPSBib2R5LmVycm9yLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keS5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gYm9keS5lcnJvci5jb2RlIHx8IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzICYmIHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBhbGwgNHh4IGFuZCA1eHggcmVzcG9uc2VzIGVycm9ycy5cbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gcmVzLnN0YXR1cy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0VHJhbnNwb3J0ZXIgPSBEZWZhdWx0VHJhbnNwb3J0ZXI7XG4vKipcbiAqIERlZmF1bHQgdXNlciBhZ2VudC5cbiAqL1xuRGVmYXVsdFRyYW5zcG9ydGVyLlVTRVJfQUdFTlQgPSBgJHtQUk9EVUNUX05BTUV9LyR7cGtnLnZlcnNpb259YDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/transporters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/node_modules/lru-cache/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/node_modules/lru-cache/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"(rsc)/./node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsa0JBQWtCO0FBQ2xCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG5jb25zdCBNQVggPSBTeW1ib2woJ21heCcpXG5jb25zdCBMRU5HVEggPSBTeW1ib2woJ2xlbmd0aCcpXG5jb25zdCBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG5jb25zdCBBTExPV19TVEFMRSA9IFN5bWJvbCgnYWxsb3dTdGFsZScpXG5jb25zdCBNQVhfQUdFID0gU3ltYm9sKCdtYXhBZ2UnKVxuY29uc3QgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpXG5jb25zdCBOT19ESVNQT1NFX09OX1NFVCA9IFN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxuY29uc3QgTFJVX0xJU1QgPSBTeW1ib2woJ2xydUxpc3QnKVxuY29uc3QgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJylcbmNvbnN0IFVQREFURV9BR0VfT05fR0VUID0gU3ltYm9sKCd1cGRhdGVBZ2VPbkdldCcpXG5cbmNvbnN0IG5haXZlTGVuZ3RoID0gKCkgPT4gMVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fVxuXG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgICBjb25zdCBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heCB8fCBJbmZpbml0eVxuXG4gICAgY29uc3QgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykgPyBuYWl2ZUxlbmd0aCA6IGxjXG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMubWF4QWdlICYmIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gICAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gICAgdGhpc1tVUERBVEVfQUdFX09OX0dFVF0gPSBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0IHx8IGZhbHNlXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuICBzZXQgbWF4IChtTCkge1xuICAgIGlmICh0eXBlb2YgbUwgIT09ICdudW1iZXInIHx8IG1MIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF0gPSBtTCB8fCBJbmZpbml0eVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4ICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH1cblxuICBzZXQgYWxsb3dTdGFsZSAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH1cbiAgZ2V0IGFsbG93U3RhbGUgKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9XG5cbiAgc2V0IG1heEFnZSAobUEpIHtcbiAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG5cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IG1heEFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuICBzZXQgbGVuZ3RoQ2FsY3VsYXRvciAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKVxuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuXG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4ge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSlcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBsZW5ndGhDYWxjdWxhdG9yICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH1cblxuICBnZXQgbGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9XG4gIGdldCBpdGVtQ291bnQgKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH1cblxuICByZm9yRWFjaCAoZm4sIHRoaXNwKSB7XG4gICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgY29uc3QgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cblxuICBmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gbmV4dFxuICAgIH1cbiAgfVxuXG4gIGtleXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay5rZXkpXG4gIH1cblxuICB2YWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGsgPT4gay52YWx1ZSlcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKSlcbiAgICB9XG5cbiAgICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICAgIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gICAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgfVxuXG4gIGR1bXAgKCkge1xuICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoaGl0ID0+XG4gICAgICBpc1N0YWxlKHRoaXMsIGhpdCkgPyBmYWxzZSA6IHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pLnRvQXJyYXkoKS5maWx0ZXIoaCA9PiBoKVxuICB9XG5cbiAgZHVtcExydSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG4gIH1cblxuICBzZXQgKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgICBpZiAobWF4QWdlICYmIHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKVxuXG4gICAgY29uc3Qgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgICBjb25zdCBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgICAgY29uc3QgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pXG4gICAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGl0ZW0ubm93ID0gbm93XG4gICAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgICB0aGlzLmdldChrZXkpXG4gICAgICB0cmltKHRoaXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gICAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pXG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaGFzIChrZXkpIHtcbiAgICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICAgIHJldHVybiAhaXNTdGFsZSh0aGlzLCBoaXQpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxuICB9XG5cbiAgcGVlayAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxuICB9XG5cbiAgcG9wICgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBkZWwodGhpcywgbm9kZSlcbiAgICByZXR1cm4gbm9kZS52YWx1ZVxuICB9XG5cbiAgZGVsIChrZXkpIHtcbiAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gIH1cblxuICBsb2FkIChhcnIpIHtcbiAgICAvLyByZXNldCB0aGUgY2FjaGVcbiAgICB0aGlzLnJlc2V0KClcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICAgIGZvciAobGV0IGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgIGNvbnN0IGhpdCA9IGFycltsXVxuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgICAgaWYgKGV4cGlyZXNBdCA9PT0gMClcbiAgICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBydW5lICgpIHtcbiAgICB0aGlzW0NBQ0hFXS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBnZXQodGhpcywga2V5LCBmYWxzZSkpXG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKHNlbGYsIGtleSwgZG9Vc2UpID0+IHtcbiAgY29uc3Qgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgaWYgKHNlbGZbVVBEQVRFX0FHRV9PTl9HRVRdKVxuICAgICAgICAgIG5vZGUudmFsdWUubm93ID0gRGF0ZS5ub3coKVxuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGl0LnZhbHVlXG4gIH1cbn1cblxuY29uc3QgaXNTdGFsZSA9IChzZWxmLCBoaXQpID0+IHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSlcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgcmV0dXJuIGhpdC5tYXhBZ2UgPyBkaWZmID4gaGl0Lm1heEFnZVxuICAgIDogc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG59XG5cbmNvbnN0IHRyaW0gPSBzZWxmID0+IHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGRlbCA9IChzZWxmLCBub2RlKSA9PiB7XG4gIGlmIChub2RlKSB7XG4gICAgY29uc3QgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKVxuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG5cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG5jbGFzcyBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMubm93ID0gbm93XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxuICB9XG59XG5cbmNvbnN0IGZvckVhY2hTdGVwID0gKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkgPT4ge1xuICBsZXQgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSlcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICB9XG4gIGlmIChoaXQpXG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/node_modules/lru-cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/package.json":
/*!*******************************************************!*\
  !*** ./node_modules/google-auth-library/package.json ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"google-auth-library","version":"8.9.0","author":"Google Inc.","description":"Google APIs Authentication Client Library for Node.js","engines":{"node":">=12"},"main":"./build/src/index.js","types":"./build/src/index.d.ts","repository":"googleapis/google-auth-library-nodejs.git","keywords":["google","api","google apis","client","client library"],"dependencies":{"arrify":"^2.0.0","base64-js":"^1.3.0","ecdsa-sig-formatter":"^1.0.11","fast-text-encoding":"^1.0.0","gaxios":"^5.0.0","gcp-metadata":"^5.3.0","gtoken":"^6.1.0","jws":"^4.0.0","lru-cache":"^6.0.0"},"devDependencies":{"@compodoc/compodoc":"^1.1.7","@types/base64-js":"^1.2.5","@types/chai":"^4.1.7","@types/jws":"^3.1.0","@types/lru-cache":"^5.0.0","@types/mocha":"^9.0.0","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^16.0.0","@types/sinon":"^10.0.0","assert-rejects":"^1.0.0","c8":"^8.0.0","chai":"^4.2.0","codecov":"^3.0.2","execa":"^5.0.0","gts":"^3.1.0","is-docker":"^2.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-sourcemap-loader":"^0.4.0","karma-webpack":"^5.0.0","keypair":"^1.0.4","linkinator":"^4.0.0","mocha":"^9.2.2","mv":"^2.1.1","ncp":"^2.0.0","nock":"^13.0.0","null-loader":"^4.0.0","puppeteer":"^20.0.0","sinon":"^15.0.0","ts-loader":"^8.0.0","typescript":"^4.6.3","webpack":"^5.21.2","webpack-cli":"^4.0.0"},"files":["build/src","!build/src/**/*.map"],"scripts":{"test":"c8 mocha build/test","clean":"gts clean","prepare":"npm run compile","lint":"gts check","compile":"tsc -p .","fix":"gts fix","pretest":"npm run compile","docs":"compodoc src/","samples-setup":"cd samples/ && npm link ../ && npm run setup && cd ../","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","system-test":"mocha build/system-test --timeout 60000","presystem-test":"npm run compile","webpack":"webpack","browser-test":"karma start","docs-test":"linkinator docs","predocs-test":"npm run docs","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"license":"Apache-2.0"}');

/***/ })

};
;