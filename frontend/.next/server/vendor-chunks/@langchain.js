/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@langchain";
exports.ids = ["vendor-chunks/@langchain"];
exports.modules = {

/***/ "(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/chat_models.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatBedrockConverse = void 0;\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst chat_models_1 = __webpack_require__(/*! @langchain/core/language_models/chat_models */ \"(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\");\nconst client_bedrock_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-runtime/dist-es/index.js\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst credential_provider_node_1 = __webpack_require__(/*! @aws-sdk/credential-provider-node */ \"(rsc)/./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js\");\nconst runnables_1 = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.cjs\");\nconst types_1 = __webpack_require__(/*! @langchain/core/utils/types */ \"(rsc)/./node_modules/@langchain/core/utils/types.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @langchain/core/utils/json_schema */ \"(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./common.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/common.cjs\");\n/**\n * AWS Bedrock Converse chat model integration.\n *\n * Setup:\n * Install `@langchain/aws` and set the following environment variables:\n *\n * ```bash\n * npm install @langchain/aws\n * export BEDROCK_AWS_REGION=\"your-aws-region\"\n * export BEDROCK_AWS_SECRET_ACCESS_KEY=\"your-aws-secret-access-key\"\n * export BEDROCK_AWS_ACCESS_KEY_ID=\"your-aws-access-key-id\"\n * ```\n *\n * ## [Constructor args](https://api.js.langchain.com/classes/langchain_aws.ChatBedrockConverse.html#constructor)\n *\n * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_aws.ChatBedrockConverseCallOptions.html)\n *\n * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n * They can also be passed via `.withConfig`, or the second arg in `.bindTools`, like shown in the examples below:\n *\n * ```typescript\n * // When calling `.withConfig`, call options should be passed via the first argument\n * const llmWithArgsBound = llm.withConfig({\n *   stop: [\"\\n\"],\n *   tools: [...],\n * });\n *\n * // When calling `.bindTools`, call options should be passed via the second argument\n * const llmWithTools = llm.bindTools(\n *   [...],\n *   {\n *     stop: [\"\\n\"],\n *   }\n * );\n * ```\n *\n * ## Examples\n *\n * <details open>\n * <summary><strong>Instantiate</strong></summary>\n *\n * ```typescript\n * import { ChatBedrockConverse } from '@langchain/aws';\n *\n * const llm = new ChatBedrockConverse({\n *   model: \"anthropic.claude-3-5-sonnet-20240620-v1:0\",\n *   temperature: 0,\n *   maxTokens: undefined,\n *   timeout: undefined,\n *   maxRetries: 2,\n *   region: process.env.BEDROCK_AWS_REGION,\n *   credentials: {\n *     secretAccessKey: process.env.BEDROCK_AWS_SECRET_ACCESS_KEY!,\n *     accessKeyId: process.env.BEDROCK_AWS_ACCESS_KEY_ID!,\n *   },\n *   // Configure client options (e.g., custom request handler)\n *   // clientOptions: {\n *   //   requestHandler: myCustomRequestHandler,\n *   // },\n *   // other params...\n * });\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Invoking</strong></summary>\n *\n * ```typescript\n * const input = `Translate \"I love programming\" into French.`;\n *\n * // Models also accept a list of chat messages or a formatted prompt\n * const result = await llm.invoke(input);\n * console.log(result);\n * ```\n *\n * ```txt\n * AIMessage {\n *   \"id\": \"81a27f7a-550c-473d-8307-c2fbb9c74956\",\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"response_metadata\": {\n *     \"$metadata\": {\n *       \"httpStatusCode\": 200,\n *       \"requestId\": \"81a27f7a-550c-473d-8307-c2fbb9c74956\",\n *       \"attempts\": 1,\n *       \"totalRetryDelay\": 0\n *     },\n *     \"metrics\": {\n *       \"latencyMs\": 1109\n *     },\n *     \"stopReason\": \"end_turn\",\n *     \"usage\": {\n *       \"inputTokens\": 25,\n *       \"outputTokens\": 19,\n *       \"totalTokens\": 44\n *     }\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Streaming Chunks</strong></summary>\n *\n * ```typescript\n * for await (const chunk of await llm.stream(input)) {\n *   console.log(chunk);\n * }\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"messageStart\": {\n *       \"p\": \"abcdefghijk\",\n *       \"role\": \"assistant\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"Here\"\n * }\n * AIMessageChunk {\n *   \"content\": \"'s\"\n * }\n * AIMessageChunk {\n *   \"content\": \" the translation\"\n * }\n * AIMessageChunk {\n *   \"content\": \" to\"\n * }\n * AIMessageChunk {\n *   \"content\": \" French:\\n\\nJ\"\n * }\n * AIMessageChunk {\n *   \"content\": \"'adore la\"\n * }\n * AIMessageChunk {\n *   \"content\": \" programmation.\"\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"contentBlockStop\": {\n *       \"contentBlockIndex\": 0,\n *       \"p\": \"abcdefghijk\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"messageStop\": {\n *       \"stopReason\": \"end_turn\"\n *     }\n *   }\n * }\n * AIMessageChunk {\n *   \"content\": \"\"\n *   \"response_metadata\": {\n *     \"metadata\": {\n *       \"metrics\": {\n *         \"latencyMs\": 838\n *       },\n *       \"p\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123\",\n *       \"usage\": {\n *         \"inputTokens\": 25,\n *         \"outputTokens\": 19,\n *         \"totalTokens\": 44\n *       }\n *     }\n *   }\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n *\n * ```typescript\n * import { AIMessageChunk } from '@langchain/core/messages';\n * import { concat } from '@langchain/core/utils/stream';\n *\n * const stream = await llm.stream(input);\n * let full: AIMessageChunk | undefined;\n * for await (const chunk of stream) {\n *   full = !full ? chunk : concat(full, chunk);\n * }\n * console.log(full);\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"Here's the translation to French:\\n\\nJ'adore la programmation.\",\n *   \"response_metadata\": {\n *     \"messageStart\": {\n *       \"p\": \"ab\",\n *       \"role\": \"assistant\"\n *     },\n *     \"contentBlockStop\": {\n *       \"contentBlockIndex\": 0,\n *       \"p\": \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJK\"\n *     },\n *     \"messageStop\": {\n *       \"stopReason\": \"end_turn\"\n *     },\n *     \"metadata\": {\n *       \"metrics\": {\n *         \"latencyMs\": 838\n *       },\n *       \"p\": \"abcdefghijklmnopqrstuvwxyz\",\n *       \"usage\": {\n *         \"inputTokens\": 25,\n *         \"outputTokens\": 19,\n *         \"totalTokens\": 44\n *       }\n *     }\n *   },\n *   \"usage_metadata\": {\n *     \"input_tokens\": 25,\n *     \"output_tokens\": 19,\n *     \"total_tokens\": 44\n *   }\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Bind tools</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const GetWeather = {\n *   name: \"GetWeather\",\n *   description: \"Get the current weather in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const GetPopulation = {\n *   name: \"GetPopulation\",\n *   description: \"Get the current population in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const llmWithTools = llm.bindTools(\n *   [GetWeather, GetPopulation],\n *   {\n *     // strict: true  // enforce tool args schema is respected\n *   }\n * );\n * const aiMsg = await llmWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\"\n * );\n * console.log(aiMsg.tool_calls);\n * ```\n *\n * ```txt\n * [\n *   {\n *     id: 'tooluse_hIaiqfweRtSiJyi6J4naJA',\n *     name: 'GetWeather',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_nOS8B0UlTd2FdpH4MSHw9w',\n *     name: 'GetWeather',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_XxMpZiETQ5aVS5opVDyIaw',\n *     name: 'GetPopulation',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call'\n *   },\n *   {\n *     id: 'tooluse_GpYvAfldT2aR8VQfH-p4PQ',\n *     name: 'GetPopulation',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call'\n *   }\n * ]\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Structured Output</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const Joke = z.object({\n *   setup: z.string().describe(\"The setup of the joke\"),\n *   punchline: z.string().describe(\"The punchline to the joke\"),\n *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n * }).describe('Joke to tell user.');\n *\n * const structuredLlm = llm.withStructuredOutput(Joke, { name: \"Joke\" });\n * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n * console.log(jokeResult);\n * ```\n *\n * ```txt\n * {\n *   setup: \"Why don't cats play poker in the jungle?\",\n *   punchline: 'Too many cheetahs!',\n *   rating: 7\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Multimodal</strong></summary>\n *\n * ```typescript\n * import { HumanMessage } from '@langchain/core/messages';\n *\n * const imageUrl = \"https://example.com/image.jpg\";\n * const imageData = await fetch(imageUrl).then(res => res.arrayBuffer());\n * const base64Image = Buffer.from(imageData).toString('base64');\n *\n * const message = new HumanMessage({\n *   content: [\n *     { type: \"text\", text: \"describe the weather in this image\" },\n *     {\n *       type: \"image_url\",\n *       image_url: { url: `data:image/jpeg;base64,${base64Image}` },\n *     },\n *   ]\n * });\n *\n * const imageDescriptionAiMsg = await llm.invoke([message]);\n * console.log(imageDescriptionAiMsg.content);\n * ```\n *\n * ```txt\n * The weather in this image appears to be clear and pleasant. The sky is a vibrant blue with scattered white clouds, suggesting a sunny day with good visibility. The clouds are light and wispy, indicating fair weather conditions. There's no sign of rain, storm, or any adverse weather patterns. The lush green grass on the rolling hills looks well-watered and healthy, which could indicate recent rainfall or generally favorable weather conditions. Overall, the image depicts a beautiful, calm day with blue skies and sunshine - perfect weather for enjoying the outdoors.\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Usage Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForMetadata = await llm.invoke(input);\n * console.log(aiMsgForMetadata.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 19, total_tokens: 44 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Stream Usage Metadata</strong></summary>\n *\n * ```typescript\n * const streamForMetadata = await llm.stream(input);\n * let fullForMetadata: AIMessageChunk | undefined;\n * for await (const chunk of streamForMetadata) {\n *   fullForMetadata = !fullForMetadata ? chunk : concat(fullForMetadata, chunk);\n * }\n * console.log(fullForMetadata?.usage_metadata);\n * ```\n *\n * ```txt\n * { input_tokens: 25, output_tokens: 19, total_tokens: 44 }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Response Metadata</strong></summary>\n *\n * ```typescript\n * const aiMsgForResponseMetadata = await llm.invoke(input);\n * console.log(aiMsgForResponseMetadata.response_metadata);\n * ```\n *\n * ```txt\n * {\n *   '$metadata': {\n *     httpStatusCode: 200,\n *     requestId: '5de2a2e5-d1dc-4dff-bb02-31361f4107bc',\n *     extendedRequestId: undefined,\n *     cfId: undefined,\n *     attempts: 1,\n *     totalRetryDelay: 0\n *   },\n *   metrics: { latencyMs: 1163 },\n *   stopReason: 'end_turn',\n *   usage: { inputTokens: 25, outputTokens: 19, totalTokens: 44 }\n * }\n * ```\n * </details>\n *\n * <br />\n */\nclass ChatBedrockConverse extends chat_models_1.BaseChatModel {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatBedrockConverse\";\n    }\n    /**\n     * Replace with any secrets this class passes to `super`.\n     * See {@link ../../langchain-cohere/src/chat_model.ts} for\n     * an example.\n     */\n    get lc_secrets() {\n        return {\n            apiKey: \"API_KEY_NAME\",\n        };\n    }\n    get lc_aliases() {\n        return {\n            apiKey: \"API_KEY_NAME\",\n        };\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"anthropic.claude-3-haiku-20240307-v1:0\"\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"region\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        Object.defineProperty(this, \"maxTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        Object.defineProperty(this, \"endpointHost\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"additionalModelRequestFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamUsage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"guardrailConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"performanceConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Which types of `tool_choice` values the model supports.\n         *\n         * Inferred if not specified. Inferred as ['auto', 'any', 'tool'] if a 'claude-3'\n         * model is used, ['auto', 'any'] if a 'mistral-large' model is used, empty otherwise.\n         */\n        Object.defineProperty(this, \"supportsToolChoiceValues\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { profile, filepath, configFilepath, ignoreCache, mfaCodeProvider, roleAssumer, roleArn, webIdentityTokenFile, roleAssumerWithWebIdentity, ...rest } = fields ?? {};\n        const credentials = rest?.credentials ??\n            (0, credential_provider_node_1.defaultProvider)({\n                profile,\n                filepath,\n                configFilepath,\n                ignoreCache,\n                mfaCodeProvider,\n                roleAssumer,\n                roleArn,\n                webIdentityTokenFile,\n                roleAssumerWithWebIdentity,\n            });\n        const region = rest?.region ?? (0, env_1.getEnvironmentVariable)(\"AWS_DEFAULT_REGION\");\n        if (!region) {\n            throw new Error(\"Please set the AWS_DEFAULT_REGION environment variable or pass it to the constructor as the region field.\");\n        }\n        this.client =\n            fields?.client ??\n                new client_bedrock_runtime_1.BedrockRuntimeClient({\n                    ...fields?.clientOptions,\n                    region,\n                    credentials,\n                    endpoint: rest.endpointHost\n                        ? `https://${rest.endpointHost}`\n                        : undefined,\n                });\n        this.region = region;\n        this.model = rest?.model ?? this.model;\n        this.streaming = rest?.streaming ?? this.streaming;\n        this.temperature = rest?.temperature;\n        this.maxTokens = rest?.maxTokens;\n        this.endpointHost = rest?.endpointHost;\n        this.topP = rest?.topP;\n        this.additionalModelRequestFields = rest?.additionalModelRequestFields;\n        this.streamUsage = rest?.streamUsage ?? this.streamUsage;\n        this.guardrailConfig = rest?.guardrailConfig;\n        this.performanceConfig = rest?.performanceConfig;\n        this.clientOptions = rest?.clientOptions;\n        if (rest?.supportsToolChoiceValues === undefined) {\n            this.supportsToolChoiceValues = (0, common_js_1.supportedToolChoiceValuesForModel)(this.model);\n        }\n        else {\n            this.supportsToolChoiceValues = rest.supportsToolChoiceValues;\n        }\n    }\n    getLsParams(options) {\n        const params = this.invocationParams(options);\n        return {\n            ls_provider: \"amazon_bedrock\",\n            ls_model_name: this.model,\n            ls_model_type: \"chat\",\n            ls_temperature: params.inferenceConfig?.temperature ?? this.temperature,\n            ls_max_tokens: params.inferenceConfig?.maxTokens ?? undefined,\n            ls_stop: options.stop,\n        };\n    }\n    bindTools(tools, kwargs) {\n        return this.withConfig({\n            tools: (0, common_js_1.convertToConverseTools)(tools),\n            ...kwargs,\n        });\n    }\n    // Replace\n    _llmType() {\n        return \"chat_bedrock_converse\";\n    }\n    invocationParams(options) {\n        let toolConfig;\n        if (options?.tools && options.tools.length) {\n            const tools = (0, common_js_1.convertToConverseTools)(options.tools);\n            toolConfig = {\n                tools,\n                toolChoice: options.tool_choice\n                    ? (0, common_js_1.convertToBedrockToolChoice)(options.tool_choice, tools, {\n                        model: this.model,\n                        supportsToolChoiceValues: this.supportsToolChoiceValues,\n                    })\n                    : undefined,\n            };\n        }\n        return {\n            inferenceConfig: {\n                maxTokens: this.maxTokens,\n                temperature: this.temperature,\n                topP: this.topP,\n                stopSequences: options?.stop,\n            },\n            toolConfig,\n            additionalModelRequestFields: this.additionalModelRequestFields ??\n                options?.additionalModelRequestFields,\n            guardrailConfig: this.guardrailConfig ?? options?.guardrailConfig,\n            performanceConfig: options?.performanceConfig,\n        };\n    }\n    async _generate(messages, options, runManager) {\n        if (this.streaming) {\n            const stream = this._streamResponseChunks(messages, options, runManager);\n            let finalResult;\n            for await (const chunk of stream) {\n                if (finalResult === undefined) {\n                    finalResult = chunk;\n                }\n                else {\n                    finalResult = finalResult.concat(chunk);\n                }\n            }\n            if (finalResult === undefined) {\n                throw new Error(\"Could not parse final output from Bedrock streaming call.\");\n            }\n            return {\n                generations: [finalResult],\n                llmOutput: finalResult.generationInfo,\n            };\n        }\n        return this._generateNonStreaming(messages, options, runManager);\n    }\n    async _generateNonStreaming(messages, options, _runManager) {\n        const { converseMessages, converseSystem } = (0, common_js_1.convertToConverseMessages)(messages);\n        const params = this.invocationParams(options);\n        const command = new client_bedrock_runtime_1.ConverseCommand({\n            modelId: this.model,\n            messages: converseMessages,\n            system: converseSystem,\n            requestMetadata: options.requestMetadata,\n            ...params,\n        });\n        const response = await this.client.send(command, {\n            abortSignal: options.signal,\n        });\n        const { output, ...responseMetadata } = response;\n        if (!output?.message) {\n            throw new Error(\"No message found in Bedrock response.\");\n        }\n        const message = (0, common_js_1.convertConverseMessageToLangChainMessage)(output.message, responseMetadata);\n        return {\n            generations: [\n                {\n                    text: typeof message.content === \"string\" ? message.content : \"\",\n                    message,\n                },\n            ],\n        };\n    }\n    async *_streamResponseChunks(messages, options, runManager) {\n        const { converseMessages, converseSystem } = (0, common_js_1.convertToConverseMessages)(messages);\n        const params = this.invocationParams(options);\n        let { streamUsage } = this;\n        if (options.streamUsage !== undefined) {\n            streamUsage = options.streamUsage;\n        }\n        const command = new client_bedrock_runtime_1.ConverseStreamCommand({\n            modelId: this.model,\n            messages: converseMessages,\n            system: converseSystem,\n            requestMetadata: options.requestMetadata,\n            ...params,\n        });\n        const response = await this.client.send(command, {\n            abortSignal: options.signal,\n        });\n        if (response.stream) {\n            for await (const chunk of response.stream) {\n                if (chunk.contentBlockStart) {\n                    yield (0, common_js_1.handleConverseStreamContentBlockStart)(chunk.contentBlockStart);\n                }\n                else if (chunk.contentBlockDelta) {\n                    const textChatGeneration = (0, common_js_1.handleConverseStreamContentBlockDelta)(chunk.contentBlockDelta);\n                    yield textChatGeneration;\n                    await runManager?.handleLLMNewToken(textChatGeneration.text, undefined, undefined, undefined, undefined, {\n                        chunk: textChatGeneration,\n                    });\n                }\n                else if (chunk.metadata) {\n                    yield (0, common_js_1.handleConverseStreamMetadata)(chunk.metadata, {\n                        streamUsage,\n                    });\n                }\n                else {\n                    yield new outputs_1.ChatGenerationChunk({\n                        text: \"\",\n                        message: new messages_1.AIMessageChunk({\n                            content: \"\",\n                            response_metadata: chunk,\n                        }),\n                    });\n                }\n            }\n        }\n    }\n    withStructuredOutput(outputSchema, config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = (0, types_1.getSchemaDescription)(schema) ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`ChatBedrockConverse does not support 'jsonMode'.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0, types_1.isInteropZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0, json_schema_1.toJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const supportsToolChoiceValues = this.supportsToolChoiceValues ?? [];\n        let toolChoiceObj;\n        if (supportsToolChoiceValues.includes(\"tool\")) {\n            toolChoiceObj = {\n                tool_choice: tools[0].function.name,\n            };\n        }\n        else if (supportsToolChoiceValues.includes(\"any\")) {\n            toolChoiceObj = {\n                tool_choice: \"any\",\n            };\n        }\n        const llm = this.bindTools(tools, toolChoiceObj);\n        const outputParser = runnables_1.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = runnables_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = runnables_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return runnables_1.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.ChatBedrockConverse = ChatBedrockConverse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyx5SEFBNkM7QUFDM0UsaUNBQWlDLG1CQUFPLENBQUMsOEdBQWlDO0FBQzFFLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELG1DQUFtQyxtQkFBTyxDQUFDLGtIQUFtQztBQUM5RSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMseUZBQTZCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHFHQUFtQztBQUNqRSxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwREFBMEQsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQTBEO0FBQ25FO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCLFNBQVMsWUFBWSxHQUFHO0FBQ3BFLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLG1KQUFtSjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jaGF0X21vZGVscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRCZWRyb2NrQ29udmVyc2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmNvbnN0IGNoYXRfbW9kZWxzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVsc1wiKTtcbmNvbnN0IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJAYXdzLXNkay9jbGllbnQtYmVkcm9jay1ydW50aW1lXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IGNyZWRlbnRpYWxfcHJvdmlkZXJfbm9kZV8xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2NyZWRlbnRpYWwtcHJvdmlkZXItbm9kZVwiKTtcbmNvbnN0IHJ1bm5hYmxlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy90eXBlc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2pzb25fc2NoZW1hXCIpO1xuY29uc3QgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb24uY2pzXCIpO1xuLyoqXG4gKiBBV1MgQmVkcm9jayBDb252ZXJzZSBjaGF0IG1vZGVsIGludGVncmF0aW9uLlxuICpcbiAqIFNldHVwOlxuICogSW5zdGFsbCBgQGxhbmdjaGFpbi9hd3NgIGFuZCBzZXQgdGhlIGZvbGxvd2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4gKlxuICogYGBgYmFzaFxuICogbnBtIGluc3RhbGwgQGxhbmdjaGFpbi9hd3NcbiAqIGV4cG9ydCBCRURST0NLX0FXU19SRUdJT049XCJ5b3VyLWF3cy1yZWdpb25cIlxuICogZXhwb3J0IEJFRFJPQ0tfQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZPVwieW91ci1hd3Mtc2VjcmV0LWFjY2Vzcy1rZXlcIlxuICogZXhwb3J0IEJFRFJPQ0tfQVdTX0FDQ0VTU19LRVlfSUQ9XCJ5b3VyLWF3cy1hY2Nlc3Mta2V5LWlkXCJcbiAqIGBgYFxuICpcbiAqICMjIFtDb25zdHJ1Y3RvciBhcmdzXShodHRwczovL2FwaS5qcy5sYW5nY2hhaW4uY29tL2NsYXNzZXMvbGFuZ2NoYWluX2F3cy5DaGF0QmVkcm9ja0NvbnZlcnNlLmh0bWwjY29uc3RydWN0b3IpXG4gKlxuICogIyMgW1J1bnRpbWUgYXJnc10oaHR0cHM6Ly9hcGkuanMubGFuZ2NoYWluLmNvbS9pbnRlcmZhY2VzL2xhbmdjaGFpbl9hd3MuQ2hhdEJlZHJvY2tDb252ZXJzZUNhbGxPcHRpb25zLmh0bWwpXG4gKlxuICogUnVudGltZSBhcmdzIGNhbiBiZSBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBhbnkgb2YgdGhlIGJhc2UgcnVubmFibGUgbWV0aG9kcyBgLmludm9rZWAuIGAuc3RyZWFtYCwgYC5iYXRjaGAsIGV0Yy5cbiAqIFRoZXkgY2FuIGFsc28gYmUgcGFzc2VkIHZpYSBgLndpdGhDb25maWdgLCBvciB0aGUgc2Vjb25kIGFyZyBpbiBgLmJpbmRUb29sc2AsIGxpa2Ugc2hvd24gaW4gdGhlIGV4YW1wbGVzIGJlbG93OlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFdoZW4gY2FsbGluZyBgLndpdGhDb25maWdgLCBjYWxsIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBjb25zdCBsbG1XaXRoQXJnc0JvdW5kID0gbGxtLndpdGhDb25maWcoe1xuICogICBzdG9wOiBbXCJcXG5cIl0sXG4gKiAgIHRvb2xzOiBbLi4uXSxcbiAqIH0pO1xuICpcbiAqIC8vIFdoZW4gY2FsbGluZyBgLmJpbmRUb29sc2AsIGNhbGwgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB0aGUgc2Vjb25kIGFyZ3VtZW50XG4gKiBjb25zdCBsbG1XaXRoVG9vbHMgPSBsbG0uYmluZFRvb2xzKFxuICogICBbLi4uXSxcbiAqICAge1xuICogICAgIHN0b3A6IFtcIlxcblwiXSxcbiAqICAgfVxuICogKTtcbiAqIGBgYFxuICpcbiAqICMjIEV4YW1wbGVzXG4gKlxuICogPGRldGFpbHMgb3Blbj5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+SW5zdGFudGlhdGU8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQ2hhdEJlZHJvY2tDb252ZXJzZSB9IGZyb20gJ0BsYW5nY2hhaW4vYXdzJztcbiAqXG4gKiBjb25zdCBsbG0gPSBuZXcgQ2hhdEJlZHJvY2tDb252ZXJzZSh7XG4gKiAgIG1vZGVsOiBcImFudGhyb3BpYy5jbGF1ZGUtMy01LXNvbm5ldC0yMDI0MDYyMC12MTowXCIsXG4gKiAgIHRlbXBlcmF0dXJlOiAwLFxuICogICBtYXhUb2tlbnM6IHVuZGVmaW5lZCxcbiAqICAgdGltZW91dDogdW5kZWZpbmVkLFxuICogICBtYXhSZXRyaWVzOiAyLFxuICogICByZWdpb246IHByb2Nlc3MuZW52LkJFRFJPQ0tfQVdTX1JFR0lPTixcbiAqICAgY3JlZGVudGlhbHM6IHtcbiAqICAgICBzZWNyZXRBY2Nlc3NLZXk6IHByb2Nlc3MuZW52LkJFRFJPQ0tfQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZISxcbiAqICAgICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnYuQkVEUk9DS19BV1NfQUNDRVNTX0tFWV9JRCEsXG4gKiAgIH0sXG4gKiAgIC8vIENvbmZpZ3VyZSBjbGllbnQgb3B0aW9ucyAoZS5nLiwgY3VzdG9tIHJlcXVlc3QgaGFuZGxlcilcbiAqICAgLy8gY2xpZW50T3B0aW9uczoge1xuICogICAvLyAgIHJlcXVlc3RIYW5kbGVyOiBteUN1c3RvbVJlcXVlc3RIYW5kbGVyLFxuICogICAvLyB9LFxuICogICAvLyBvdGhlciBwYXJhbXMuLi5cbiAqIH0pO1xuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPkludm9raW5nPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGlucHV0ID0gYFRyYW5zbGF0ZSBcIkkgbG92ZSBwcm9ncmFtbWluZ1wiIGludG8gRnJlbmNoLmA7XG4gKlxuICogLy8gTW9kZWxzIGFsc28gYWNjZXB0IGEgbGlzdCBvZiBjaGF0IG1lc3NhZ2VzIG9yIGEgZm9ybWF0dGVkIHByb21wdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbGxtLmludm9rZShpbnB1dCk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBBSU1lc3NhZ2Uge1xuICogICBcImlkXCI6IFwiODFhMjdmN2EtNTUwYy00NzNkLTgzMDctYzJmYmI5Yzc0OTU2XCIsXG4gKiAgIFwiY29udGVudFwiOiBcIkhlcmUncyB0aGUgdHJhbnNsYXRpb24gdG8gRnJlbmNoOlxcblxcbkonYWRvcmUgbGEgcHJvZ3JhbW1hdGlvbi5cIixcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCIkbWV0YWRhdGFcIjoge1xuICogICAgICAgXCJodHRwU3RhdHVzQ29kZVwiOiAyMDAsXG4gKiAgICAgICBcInJlcXVlc3RJZFwiOiBcIjgxYTI3ZjdhLTU1MGMtNDczZC04MzA3LWMyZmJiOWM3NDk1NlwiLFxuICogICAgICAgXCJhdHRlbXB0c1wiOiAxLFxuICogICAgICAgXCJ0b3RhbFJldHJ5RGVsYXlcIjogMFxuICogICAgIH0sXG4gKiAgICAgXCJtZXRyaWNzXCI6IHtcbiAqICAgICAgIFwibGF0ZW5jeU1zXCI6IDExMDlcbiAqICAgICB9LFxuICogICAgIFwic3RvcFJlYXNvblwiOiBcImVuZF90dXJuXCIsXG4gKiAgICAgXCJ1c2FnZVwiOiB7XG4gKiAgICAgICBcImlucHV0VG9rZW5zXCI6IDI1LFxuICogICAgICAgXCJvdXRwdXRUb2tlbnNcIjogMTksXG4gKiAgICAgICBcInRvdGFsVG9rZW5zXCI6IDQ0XG4gKiAgICAgfVxuICogICB9LFxuICogICBcInVzYWdlX21ldGFkYXRhXCI6IHtcbiAqICAgICBcImlucHV0X3Rva2Vuc1wiOiAyNSxcbiAqICAgICBcIm91dHB1dF90b2tlbnNcIjogMTksXG4gKiAgICAgXCJ0b3RhbF90b2tlbnNcIjogNDRcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPlN0cmVhbWluZyBDaHVua3M8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBhd2FpdCBsbG0uc3RyZWFtKGlucHV0KSkge1xuICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiXCJcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJtZXNzYWdlU3RhcnRcIjoge1xuICogICAgICAgXCJwXCI6IFwiYWJjZGVmZ2hpamtcIixcbiAqICAgICAgIFwicm9sZVwiOiBcImFzc2lzdGFudFwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIkhlcmVcIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCInc1wiXG4gKiB9XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIiB0aGUgdHJhbnNsYXRpb25cIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCIgdG9cIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCIgRnJlbmNoOlxcblxcbkpcIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCInYWRvcmUgbGFcIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCIgcHJvZ3JhbW1hdGlvbi5cIlxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCJcIlxuICogICBcInJlc3BvbnNlX21ldGFkYXRhXCI6IHtcbiAqICAgICBcImNvbnRlbnRCbG9ja1N0b3BcIjoge1xuICogICAgICAgXCJjb250ZW50QmxvY2tJbmRleFwiOiAwLFxuICogICAgICAgXCJwXCI6IFwiYWJjZGVmZ2hpamtcIlxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCJcIlxuICogICBcInJlc3BvbnNlX21ldGFkYXRhXCI6IHtcbiAqICAgICBcIm1lc3NhZ2VTdG9wXCI6IHtcbiAqICAgICAgIFwic3RvcFJlYXNvblwiOiBcImVuZF90dXJuXCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiXCJcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJtZXRhZGF0YVwiOiB7XG4gKiAgICAgICBcIm1ldHJpY3NcIjoge1xuICogICAgICAgICBcImxhdGVuY3lNc1wiOiA4MzhcbiAqICAgICAgIH0sXG4gKiAgICAgICBcInBcIjogXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyM1wiLFxuICogICAgICAgXCJ1c2FnZVwiOiB7XG4gKiAgICAgICAgIFwiaW5wdXRUb2tlbnNcIjogMjUsXG4gKiAgICAgICAgIFwib3V0cHV0VG9rZW5zXCI6IDE5LFxuICogICAgICAgICBcInRvdGFsVG9rZW5zXCI6IDQ0XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiAgIFwidXNhZ2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwiaW5wdXRfdG9rZW5zXCI6IDI1LFxuICogICAgIFwib3V0cHV0X3Rva2Vuc1wiOiAxOSxcbiAqICAgICBcInRvdGFsX3Rva2Vuc1wiOiA0NFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+QWdncmVnYXRlIFN0cmVhbWVkIENodW5rczwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBBSU1lc3NhZ2VDaHVuayB9IGZyb20gJ0BsYW5nY2hhaW4vY29yZS9tZXNzYWdlcyc7XG4gKiBpbXBvcnQgeyBjb25jYXQgfSBmcm9tICdAbGFuZ2NoYWluL2NvcmUvdXRpbHMvc3RyZWFtJztcbiAqXG4gKiBjb25zdCBzdHJlYW0gPSBhd2FpdCBsbG0uc3RyZWFtKGlucHV0KTtcbiAqIGxldCBmdWxsOiBBSU1lc3NhZ2VDaHVuayB8IHVuZGVmaW5lZDtcbiAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gKiAgIGZ1bGwgPSAhZnVsbCA/IGNodW5rIDogY29uY2F0KGZ1bGwsIGNodW5rKTtcbiAqIH1cbiAqIGNvbnNvbGUubG9nKGZ1bGwpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIkhlcmUncyB0aGUgdHJhbnNsYXRpb24gdG8gRnJlbmNoOlxcblxcbkonYWRvcmUgbGEgcHJvZ3JhbW1hdGlvbi5cIixcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJtZXNzYWdlU3RhcnRcIjoge1xuICogICAgICAgXCJwXCI6IFwiYWJcIixcbiAqICAgICAgIFwicm9sZVwiOiBcImFzc2lzdGFudFwiXG4gKiAgICAgfSxcbiAqICAgICBcImNvbnRlbnRCbG9ja1N0b3BcIjoge1xuICogICAgICAgXCJjb250ZW50QmxvY2tJbmRleFwiOiAwLFxuICogICAgICAgXCJwXCI6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS1wiXG4gKiAgICAgfSxcbiAqICAgICBcIm1lc3NhZ2VTdG9wXCI6IHtcbiAqICAgICAgIFwic3RvcFJlYXNvblwiOiBcImVuZF90dXJuXCJcbiAqICAgICB9LFxuICogICAgIFwibWV0YWRhdGFcIjoge1xuICogICAgICAgXCJtZXRyaWNzXCI6IHtcbiAqICAgICAgICAgXCJsYXRlbmN5TXNcIjogODM4XG4gKiAgICAgICB9LFxuICogICAgICAgXCJwXCI6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAqICAgICAgIFwidXNhZ2VcIjoge1xuICogICAgICAgICBcImlucHV0VG9rZW5zXCI6IDI1LFxuICogICAgICAgICBcIm91dHB1dFRva2Vuc1wiOiAxOSxcbiAqICAgICAgICAgXCJ0b3RhbFRva2Vuc1wiOiA0NFxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfSxcbiAqICAgXCJ1c2FnZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJpbnB1dF90b2tlbnNcIjogMjUsXG4gKiAgICAgXCJvdXRwdXRfdG9rZW5zXCI6IDE5LFxuICogICAgIFwidG90YWxfdG9rZW5zXCI6IDQ0XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5CaW5kIHRvb2xzPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuICpcbiAqIGNvbnN0IEdldFdlYXRoZXIgPSB7XG4gKiAgIG5hbWU6IFwiR2V0V2VhdGhlclwiLFxuICogICBkZXNjcmlwdGlvbjogXCJHZXQgdGhlIGN1cnJlbnQgd2VhdGhlciBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXG4gKiAgIHNjaGVtYTogei5vYmplY3Qoe1xuICogICAgIGxvY2F0aW9uOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGNpdHkgYW5kIHN0YXRlLCBlLmcuIFNhbiBGcmFuY2lzY28sIENBXCIpXG4gKiAgIH0pLFxuICogfVxuICpcbiAqIGNvbnN0IEdldFBvcHVsYXRpb24gPSB7XG4gKiAgIG5hbWU6IFwiR2V0UG9wdWxhdGlvblwiLFxuICogICBkZXNjcmlwdGlvbjogXCJHZXQgdGhlIGN1cnJlbnQgcG9wdWxhdGlvbiBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXG4gKiAgIHNjaGVtYTogei5vYmplY3Qoe1xuICogICAgIGxvY2F0aW9uOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGNpdHkgYW5kIHN0YXRlLCBlLmcuIFNhbiBGcmFuY2lzY28sIENBXCIpXG4gKiAgIH0pLFxuICogfVxuICpcbiAqIGNvbnN0IGxsbVdpdGhUb29scyA9IGxsbS5iaW5kVG9vbHMoXG4gKiAgIFtHZXRXZWF0aGVyLCBHZXRQb3B1bGF0aW9uXSxcbiAqICAge1xuICogICAgIC8vIHN0cmljdDogdHJ1ZSAgLy8gZW5mb3JjZSB0b29sIGFyZ3Mgc2NoZW1hIGlzIHJlc3BlY3RlZFxuICogICB9XG4gKiApO1xuICogY29uc3QgYWlNc2cgPSBhd2FpdCBsbG1XaXRoVG9vbHMuaW52b2tlKFxuICogICBcIldoaWNoIGNpdHkgaXMgaG90dGVyIHRvZGF5IGFuZCB3aGljaCBpcyBiaWdnZXI6IExBIG9yIE5ZP1wiXG4gKiApO1xuICogY29uc29sZS5sb2coYWlNc2cudG9vbF9jYWxscyk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIFtcbiAqICAge1xuICogICAgIGlkOiAndG9vbHVzZV9oSWFpcWZ3ZVJ0U2lKeWk2SjRuYUpBJyxcbiAqICAgICBuYW1lOiAnR2V0V2VhdGhlcicsXG4gKiAgICAgYXJnczogeyBsb2NhdGlvbjogJ0xvcyBBbmdlbGVzLCBDQScgfSxcbiAqICAgICB0eXBlOiAndG9vbF9jYWxsJ1xuICogICB9LFxuICogICB7XG4gKiAgICAgaWQ6ICd0b29sdXNlX25PUzhCMFVsVGQyRmRwSDRNU0h3OXcnLFxuICogICAgIG5hbWU6ICdHZXRXZWF0aGVyJyxcbiAqICAgICBhcmdzOiB7IGxvY2F0aW9uOiAnTmV3IFlvcmssIE5ZJyB9LFxuICogICAgIHR5cGU6ICd0b29sX2NhbGwnXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBpZDogJ3Rvb2x1c2VfWHhNcFppRVRRNWFWUzVvcFZEeUlhdycsXG4gKiAgICAgbmFtZTogJ0dldFBvcHVsYXRpb24nLFxuICogICAgIGFyZ3M6IHsgbG9jYXRpb246ICdMb3MgQW5nZWxlcywgQ0EnIH0sXG4gKiAgICAgdHlwZTogJ3Rvb2xfY2FsbCdcbiAqICAgfSxcbiAqICAge1xuICogICAgIGlkOiAndG9vbHVzZV9HcFl2QWZsZFQyYVI4VlFmSC1wNFBRJyxcbiAqICAgICBuYW1lOiAnR2V0UG9wdWxhdGlvbicsXG4gKiAgICAgYXJnczogeyBsb2NhdGlvbjogJ05ldyBZb3JrLCBOWScgfSxcbiAqICAgICB0eXBlOiAndG9vbF9jYWxsJ1xuICogICB9XG4gKiBdXG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+U3RydWN0dXJlZCBPdXRwdXQ8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG4gKlxuICogY29uc3QgSm9rZSA9IHoub2JqZWN0KHtcbiAqICAgc2V0dXA6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc2V0dXAgb2YgdGhlIGpva2VcIiksXG4gKiAgIHB1bmNobGluZTogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBwdW5jaGxpbmUgdG8gdGhlIGpva2VcIiksXG4gKiAgIHJhdGluZzogei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiSG93IGZ1bm55IHRoZSBqb2tlIGlzLCBmcm9tIDEgdG8gMTBcIilcbiAqIH0pLmRlc2NyaWJlKCdKb2tlIHRvIHRlbGwgdXNlci4nKTtcbiAqXG4gKiBjb25zdCBzdHJ1Y3R1cmVkTGxtID0gbGxtLndpdGhTdHJ1Y3R1cmVkT3V0cHV0KEpva2UsIHsgbmFtZTogXCJKb2tlXCIgfSk7XG4gKiBjb25zdCBqb2tlUmVzdWx0ID0gYXdhaXQgc3RydWN0dXJlZExsbS5pbnZva2UoXCJUZWxsIG1lIGEgam9rZSBhYm91dCBjYXRzXCIpO1xuICogY29uc29sZS5sb2coam9rZVJlc3VsdCk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIHtcbiAqICAgc2V0dXA6IFwiV2h5IGRvbid0IGNhdHMgcGxheSBwb2tlciBpbiB0aGUganVuZ2xlP1wiLFxuICogICBwdW5jaGxpbmU6ICdUb28gbWFueSBjaGVldGFocyEnLFxuICogICByYXRpbmc6IDdcbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5NdWx0aW1vZGFsPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IEh1bWFuTWVzc2FnZSB9IGZyb20gJ0BsYW5nY2hhaW4vY29yZS9tZXNzYWdlcyc7XG4gKlxuICogY29uc3QgaW1hZ2VVcmwgPSBcImh0dHBzOi8vZXhhbXBsZS5jb20vaW1hZ2UuanBnXCI7XG4gKiBjb25zdCBpbWFnZURhdGEgPSBhd2FpdCBmZXRjaChpbWFnZVVybCkudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpO1xuICogY29uc3QgYmFzZTY0SW1hZ2UgPSBCdWZmZXIuZnJvbShpbWFnZURhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAqXG4gKiBjb25zdCBtZXNzYWdlID0gbmV3IEh1bWFuTWVzc2FnZSh7XG4gKiAgIGNvbnRlbnQ6IFtcbiAqICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBcImRlc2NyaWJlIHRoZSB3ZWF0aGVyIGluIHRoaXMgaW1hZ2VcIiB9LFxuICogICAgIHtcbiAqICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gKiAgICAgICBpbWFnZV91cmw6IHsgdXJsOiBgZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwke2Jhc2U2NEltYWdlfWAgfSxcbiAqICAgICB9LFxuICogICBdXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBpbWFnZURlc2NyaXB0aW9uQWlNc2cgPSBhd2FpdCBsbG0uaW52b2tlKFttZXNzYWdlXSk7XG4gKiBjb25zb2xlLmxvZyhpbWFnZURlc2NyaXB0aW9uQWlNc2cuY29udGVudCk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIFRoZSB3ZWF0aGVyIGluIHRoaXMgaW1hZ2UgYXBwZWFycyB0byBiZSBjbGVhciBhbmQgcGxlYXNhbnQuIFRoZSBza3kgaXMgYSB2aWJyYW50IGJsdWUgd2l0aCBzY2F0dGVyZWQgd2hpdGUgY2xvdWRzLCBzdWdnZXN0aW5nIGEgc3VubnkgZGF5IHdpdGggZ29vZCB2aXNpYmlsaXR5LiBUaGUgY2xvdWRzIGFyZSBsaWdodCBhbmQgd2lzcHksIGluZGljYXRpbmcgZmFpciB3ZWF0aGVyIGNvbmRpdGlvbnMuIFRoZXJlJ3Mgbm8gc2lnbiBvZiByYWluLCBzdG9ybSwgb3IgYW55IGFkdmVyc2Ugd2VhdGhlciBwYXR0ZXJucy4gVGhlIGx1c2ggZ3JlZW4gZ3Jhc3Mgb24gdGhlIHJvbGxpbmcgaGlsbHMgbG9va3Mgd2VsbC13YXRlcmVkIGFuZCBoZWFsdGh5LCB3aGljaCBjb3VsZCBpbmRpY2F0ZSByZWNlbnQgcmFpbmZhbGwgb3IgZ2VuZXJhbGx5IGZhdm9yYWJsZSB3ZWF0aGVyIGNvbmRpdGlvbnMuIE92ZXJhbGwsIHRoZSBpbWFnZSBkZXBpY3RzIGEgYmVhdXRpZnVsLCBjYWxtIGRheSB3aXRoIGJsdWUgc2tpZXMgYW5kIHN1bnNoaW5lIC0gcGVyZmVjdCB3ZWF0aGVyIGZvciBlbmpveWluZyB0aGUgb3V0ZG9vcnMuXG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+VXNhZ2UgTWV0YWRhdGE8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYWlNc2dGb3JNZXRhZGF0YSA9IGF3YWl0IGxsbS5pbnZva2UoaW5wdXQpO1xuICogY29uc29sZS5sb2coYWlNc2dGb3JNZXRhZGF0YS51c2FnZV9tZXRhZGF0YSk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIHsgaW5wdXRfdG9rZW5zOiAyNSwgb3V0cHV0X3Rva2VuczogMTksIHRvdGFsX3Rva2VuczogNDQgfVxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPlN0cmVhbSBVc2FnZSBNZXRhZGF0YTwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBzdHJlYW1Gb3JNZXRhZGF0YSA9IGF3YWl0IGxsbS5zdHJlYW0oaW5wdXQpO1xuICogbGV0IGZ1bGxGb3JNZXRhZGF0YTogQUlNZXNzYWdlQ2h1bmsgfCB1bmRlZmluZWQ7XG4gKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbUZvck1ldGFkYXRhKSB7XG4gKiAgIGZ1bGxGb3JNZXRhZGF0YSA9ICFmdWxsRm9yTWV0YWRhdGEgPyBjaHVuayA6IGNvbmNhdChmdWxsRm9yTWV0YWRhdGEsIGNodW5rKTtcbiAqIH1cbiAqIGNvbnNvbGUubG9nKGZ1bGxGb3JNZXRhZGF0YT8udXNhZ2VfbWV0YWRhdGEpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiB7IGlucHV0X3Rva2VuczogMjUsIG91dHB1dF90b2tlbnM6IDE5LCB0b3RhbF90b2tlbnM6IDQ0IH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5SZXNwb25zZSBNZXRhZGF0YTwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBhaU1zZ0ZvclJlc3BvbnNlTWV0YWRhdGEgPSBhd2FpdCBsbG0uaW52b2tlKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnRm9yUmVzcG9uc2VNZXRhZGF0YS5yZXNwb25zZV9tZXRhZGF0YSk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIHtcbiAqICAgJyRtZXRhZGF0YSc6IHtcbiAqICAgICBodHRwU3RhdHVzQ29kZTogMjAwLFxuICogICAgIHJlcXVlc3RJZDogJzVkZTJhMmU1LWQxZGMtNGRmZi1iYjAyLTMxMzYxZjQxMDdiYycsXG4gKiAgICAgZXh0ZW5kZWRSZXF1ZXN0SWQ6IHVuZGVmaW5lZCxcbiAqICAgICBjZklkOiB1bmRlZmluZWQsXG4gKiAgICAgYXR0ZW1wdHM6IDEsXG4gKiAgICAgdG90YWxSZXRyeURlbGF5OiAwXG4gKiAgIH0sXG4gKiAgIG1ldHJpY3M6IHsgbGF0ZW5jeU1zOiAxMTYzIH0sXG4gKiAgIHN0b3BSZWFzb246ICdlbmRfdHVybicsXG4gKiAgIHVzYWdlOiB7IGlucHV0VG9rZW5zOiAyNSwgb3V0cHV0VG9rZW5zOiAxOSwgdG90YWxUb2tlbnM6IDQ0IH1cbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICovXG5jbGFzcyBDaGF0QmVkcm9ja0NvbnZlcnNlIGV4dGVuZHMgY2hhdF9tb2RlbHNfMS5CYXNlQ2hhdE1vZGVsIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRCZWRyb2NrQ29udmVyc2VcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB3aXRoIGFueSBzZWNyZXRzIHRoaXMgY2xhc3MgcGFzc2VzIHRvIGBzdXBlcmAuXG4gICAgICogU2VlIHtAbGluayAuLi8uLi9sYW5nY2hhaW4tY29oZXJlL3NyYy9jaGF0X21vZGVsLnRzfSBmb3JcbiAgICAgKiBhbiBleGFtcGxlLlxuICAgICAqL1xuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpS2V5OiBcIkFQSV9LRVlfTkFNRVwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaUtleTogXCJBUElfS0VZX05BTUVcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyA/PyB7fSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImFudGhyb3BpYy5jbGF1ZGUtMy1oYWlrdS0yMDI0MDMwNy12MTowXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wZXJhdHVyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhUb2tlbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kcG9pbnRIb3N0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcFBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbE1vZGVsUmVxdWVzdEZpZWxkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1Vc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3VhcmRyYWlsQ29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBlcmZvcm1hbmNlQ29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRPcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGljaCB0eXBlcyBvZiBgdG9vbF9jaG9pY2VgIHZhbHVlcyB0aGUgbW9kZWwgc3VwcG9ydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluZmVycmVkIGlmIG5vdCBzcGVjaWZpZWQuIEluZmVycmVkIGFzIFsnYXV0bycsICdhbnknLCAndG9vbCddIGlmIGEgJ2NsYXVkZS0zJ1xuICAgICAgICAgKiBtb2RlbCBpcyB1c2VkLCBbJ2F1dG8nLCAnYW55J10gaWYgYSAnbWlzdHJhbC1sYXJnZScgbW9kZWwgaXMgdXNlZCwgZW1wdHkgb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgcHJvZmlsZSwgZmlsZXBhdGgsIGNvbmZpZ0ZpbGVwYXRoLCBpZ25vcmVDYWNoZSwgbWZhQ29kZVByb3ZpZGVyLCByb2xlQXNzdW1lciwgcm9sZUFybiwgd2ViSWRlbnRpdHlUb2tlbkZpbGUsIHJvbGVBc3N1bWVyV2l0aFdlYklkZW50aXR5LCAuLi5yZXN0IH0gPSBmaWVsZHMgPz8ge307XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gcmVzdD8uY3JlZGVudGlhbHMgPz9cbiAgICAgICAgICAgICgwLCBjcmVkZW50aWFsX3Byb3ZpZGVyX25vZGVfMS5kZWZhdWx0UHJvdmlkZXIpKHtcbiAgICAgICAgICAgICAgICBwcm9maWxlLFxuICAgICAgICAgICAgICAgIGZpbGVwYXRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ0ZpbGVwYXRoLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNhY2hlLFxuICAgICAgICAgICAgICAgIG1mYUNvZGVQcm92aWRlcixcbiAgICAgICAgICAgICAgICByb2xlQXNzdW1lcixcbiAgICAgICAgICAgICAgICByb2xlQXJuLFxuICAgICAgICAgICAgICAgIHdlYklkZW50aXR5VG9rZW5GaWxlLFxuICAgICAgICAgICAgICAgIHJvbGVBc3N1bWVyV2l0aFdlYklkZW50aXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IHJlc3Q/LnJlZ2lvbiA/PyAoMCwgZW52XzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJBV1NfREVGQVVMVF9SRUdJT05cIik7XG4gICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc2V0IHRoZSBBV1NfREVGQVVMVF9SRUdJT04gZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgcGFzcyBpdCB0byB0aGUgY29uc3RydWN0b3IgYXMgdGhlIHJlZ2lvbiBmaWVsZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPVxuICAgICAgICAgICAgZmllbGRzPy5jbGllbnQgPz9cbiAgICAgICAgICAgICAgICBuZXcgY2xpZW50X2JlZHJvY2tfcnVudGltZV8xLkJlZHJvY2tSdW50aW1lQ2xpZW50KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmllbGRzPy5jbGllbnRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZWdpb24sXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogcmVzdC5lbmRwb2ludEhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGh0dHBzOi8vJHtyZXN0LmVuZHBvaW50SG9zdH1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN0Py5tb2RlbCA/PyB0aGlzLm1vZGVsO1xuICAgICAgICB0aGlzLnN0cmVhbWluZyA9IHJlc3Q/LnN0cmVhbWluZyA/PyB0aGlzLnN0cmVhbWluZztcbiAgICAgICAgdGhpcy50ZW1wZXJhdHVyZSA9IHJlc3Q/LnRlbXBlcmF0dXJlO1xuICAgICAgICB0aGlzLm1heFRva2VucyA9IHJlc3Q/Lm1heFRva2VucztcbiAgICAgICAgdGhpcy5lbmRwb2ludEhvc3QgPSByZXN0Py5lbmRwb2ludEhvc3Q7XG4gICAgICAgIHRoaXMudG9wUCA9IHJlc3Q/LnRvcFA7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbE1vZGVsUmVxdWVzdEZpZWxkcyA9IHJlc3Q/LmFkZGl0aW9uYWxNb2RlbFJlcXVlc3RGaWVsZHM7XG4gICAgICAgIHRoaXMuc3RyZWFtVXNhZ2UgPSByZXN0Py5zdHJlYW1Vc2FnZSA/PyB0aGlzLnN0cmVhbVVzYWdlO1xuICAgICAgICB0aGlzLmd1YXJkcmFpbENvbmZpZyA9IHJlc3Q/Lmd1YXJkcmFpbENvbmZpZztcbiAgICAgICAgdGhpcy5wZXJmb3JtYW5jZUNvbmZpZyA9IHJlc3Q/LnBlcmZvcm1hbmNlQ29uZmlnO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSByZXN0Py5jbGllbnRPcHRpb25zO1xuICAgICAgICBpZiAocmVzdD8uc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzID0gKDAsIGNvbW1vbl9qc18xLnN1cHBvcnRlZFRvb2xDaG9pY2VWYWx1ZXNGb3JNb2RlbCkodGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyA9IHJlc3Quc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExzUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbHNfcHJvdmlkZXI6IFwiYW1hem9uX2JlZHJvY2tcIixcbiAgICAgICAgICAgIGxzX21vZGVsX25hbWU6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBsc19tb2RlbF90eXBlOiBcImNoYXRcIixcbiAgICAgICAgICAgIGxzX3RlbXBlcmF0dXJlOiBwYXJhbXMuaW5mZXJlbmNlQ29uZmlnPy50ZW1wZXJhdHVyZSA/PyB0aGlzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgbHNfbWF4X3Rva2VuczogcGFyYW1zLmluZmVyZW5jZUNvbmZpZz8ubWF4VG9rZW5zID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxzX3N0b3A6IG9wdGlvbnMuc3RvcCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYmluZFRvb2xzKHRvb2xzLCBrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbmZpZyh7XG4gICAgICAgICAgICB0b29sczogKDAsIGNvbW1vbl9qc18xLmNvbnZlcnRUb0NvbnZlcnNlVG9vbHMpKHRvb2xzKSxcbiAgICAgICAgICAgIC4uLmt3YXJncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VcbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiY2hhdF9iZWRyb2NrX2NvbnZlcnNlXCI7XG4gICAgfVxuICAgIGludm9jYXRpb25QYXJhbXMob3B0aW9ucykge1xuICAgICAgICBsZXQgdG9vbENvbmZpZztcbiAgICAgICAgaWYgKG9wdGlvbnM/LnRvb2xzICYmIG9wdGlvbnMudG9vbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0b29scyA9ICgwLCBjb21tb25fanNfMS5jb252ZXJ0VG9Db252ZXJzZVRvb2xzKShvcHRpb25zLnRvb2xzKTtcbiAgICAgICAgICAgIHRvb2xDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgICAgdG9vbENob2ljZTogb3B0aW9ucy50b29sX2Nob2ljZVxuICAgICAgICAgICAgICAgICAgICA/ICgwLCBjb21tb25fanNfMS5jb252ZXJ0VG9CZWRyb2NrVG9vbENob2ljZSkob3B0aW9ucy50b29sX2Nob2ljZSwgdG9vbHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzOiB0aGlzLnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmZlcmVuY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICBtYXhUb2tlbnM6IHRoaXMubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiB0aGlzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIHRvcFA6IHRoaXMudG9wUCxcbiAgICAgICAgICAgICAgICBzdG9wU2VxdWVuY2VzOiBvcHRpb25zPy5zdG9wLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2xDb25maWcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsTW9kZWxSZXF1ZXN0RmllbGRzOiB0aGlzLmFkZGl0aW9uYWxNb2RlbFJlcXVlc3RGaWVsZHMgPz9cbiAgICAgICAgICAgICAgICBvcHRpb25zPy5hZGRpdGlvbmFsTW9kZWxSZXF1ZXN0RmllbGRzLFxuICAgICAgICAgICAgZ3VhcmRyYWlsQ29uZmlnOiB0aGlzLmd1YXJkcmFpbENvbmZpZyA/PyBvcHRpb25zPy5ndWFyZHJhaWxDb25maWcsXG4gICAgICAgICAgICBwZXJmb3JtYW5jZUNvbmZpZzogb3B0aW9ucz8ucGVyZm9ybWFuY2VDb25maWcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKTtcbiAgICAgICAgICAgIGxldCBmaW5hbFJlc3VsdDtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxSZXN1bHQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0ID0gZmluYWxSZXN1bHQuY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBmaW5hbCBvdXRwdXQgZnJvbSBCZWRyb2NrIHN0cmVhbWluZyBjYWxsLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtmaW5hbFJlc3VsdF0sXG4gICAgICAgICAgICAgICAgbGxtT3V0cHV0OiBmaW5hbFJlc3VsdC5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlTm9uU3RyZWFtaW5nKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKTtcbiAgICB9XG4gICAgYXN5bmMgX2dlbmVyYXRlTm9uU3RyZWFtaW5nKG1lc3NhZ2VzLCBvcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB7IGNvbnZlcnNlTWVzc2FnZXMsIGNvbnZlcnNlU3lzdGVtIH0gPSAoMCwgY29tbW9uX2pzXzEuY29udmVydFRvQ29udmVyc2VNZXNzYWdlcykobWVzc2FnZXMpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmludm9jYXRpb25QYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgY2xpZW50X2JlZHJvY2tfcnVudGltZV8xLkNvbnZlcnNlQ29tbWFuZCh7XG4gICAgICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgbWVzc2FnZXM6IGNvbnZlcnNlTWVzc2FnZXMsXG4gICAgICAgICAgICBzeXN0ZW06IGNvbnZlcnNlU3lzdGVtLFxuICAgICAgICAgICAgcmVxdWVzdE1ldGFkYXRhOiBvcHRpb25zLnJlcXVlc3RNZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuc2VuZChjb21tYW5kLCB7XG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IG91dHB1dCwgLi4ucmVzcG9uc2VNZXRhZGF0YSB9ID0gcmVzcG9uc2U7XG4gICAgICAgIGlmICghb3V0cHV0Py5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtZXNzYWdlIGZvdW5kIGluIEJlZHJvY2sgcmVzcG9uc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAoMCwgY29tbW9uX2pzXzEuY29udmVydENvbnZlcnNlTWVzc2FnZVRvTGFuZ0NoYWluTWVzc2FnZSkob3V0cHV0Lm1lc3NhZ2UsIHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlLmNvbnRlbnQgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY29udmVyc2VNZXNzYWdlcywgY29udmVyc2VTeXN0ZW0gfSA9ICgwLCBjb21tb25fanNfMS5jb252ZXJ0VG9Db252ZXJzZU1lc3NhZ2VzKShtZXNzYWdlcyk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgbGV0IHsgc3RyZWFtVXNhZ2UgfSA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmVhbVVzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbVVzYWdlID0gb3B0aW9ucy5zdHJlYW1Vc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21tYW5kID0gbmV3IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMS5Db252ZXJzZVN0cmVhbUNvbW1hbmQoe1xuICAgICAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBjb252ZXJzZU1lc3NhZ2VzLFxuICAgICAgICAgICAgc3lzdGVtOiBjb252ZXJzZVN5c3RlbSxcbiAgICAgICAgICAgIHJlcXVlc3RNZXRhZGF0YTogb3B0aW9ucy5yZXF1ZXN0TWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmQoY29tbWFuZCwge1xuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0cmVhbSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZS5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsuY29udGVudEJsb2NrU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgKDAsIGNvbW1vbl9qc18xLmhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrU3RhcnQpKGNodW5rLmNvbnRlbnRCbG9ja1N0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudEJsb2NrRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXRHZW5lcmF0aW9uID0gKDAsIGNvbW1vbl9qc18xLmhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrRGVsdGEpKGNodW5rLmNvbnRlbnRCbG9ja0RlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGV4dENoYXRHZW5lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbih0ZXh0Q2hhdEdlbmVyYXRpb24udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogdGV4dENoYXRHZW5lcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgKDAsIGNvbW1vbl9qc18xLmhhbmRsZUNvbnZlcnNlU3RyZWFtTWV0YWRhdGEpKGNodW5rLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1Vc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnPy5uYW1lO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9ICgwLCB0eXBlc18xLmdldFNjaGVtYURlc2NyaXB0aW9uKShzY2hlbWEpID8/IFwiQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5cIjtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY29uZmlnPy5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVSYXcgPSBjb25maWc/LmluY2x1ZGVSYXc7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwianNvbk1vZGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGF0QmVkcm9ja0NvbnZlcnNlIGRvZXMgbm90IHN1cHBvcnQgJ2pzb25Nb2RlJy5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gbmFtZSA/PyBcImV4dHJhY3RcIjtcbiAgICAgICAgbGV0IHRvb2xzO1xuICAgICAgICBpZiAoKDAsIHR5cGVzXzEuaXNJbnRlcm9wWm9kU2NoZW1hKShzY2hlbWEpKSB7XG4gICAgICAgICAgICB0b29scyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogKDAsIGpzb25fc2NoZW1hXzEudG9Kc29uU2NoZW1hKShzY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFwibmFtZVwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9IHNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMgPSB0aGlzLnN1cHBvcnRzVG9vbENob2ljZVZhbHVlcyA/PyBbXTtcbiAgICAgICAgbGV0IHRvb2xDaG9pY2VPYmo7XG4gICAgICAgIGlmIChzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMuaW5jbHVkZXMoXCJ0b29sXCIpKSB7XG4gICAgICAgICAgICB0b29sQ2hvaWNlT2JqID0ge1xuICAgICAgICAgICAgICAgIHRvb2xfY2hvaWNlOiB0b29sc1swXS5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMuaW5jbHVkZXMoXCJhbnlcIikpIHtcbiAgICAgICAgICAgIHRvb2xDaG9pY2VPYmogPSB7XG4gICAgICAgICAgICAgICAgdG9vbF9jaG9pY2U6IFwiYW55XCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxsbSA9IHRoaXMuYmluZFRvb2xzKHRvb2xzLCB0b29sQ2hvaWNlT2JqKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0UGFyc2VyID0gcnVubmFibGVzXzEuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXQudG9vbF9jYWxscyB8fCBpbnB1dC50b29sX2NhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgY2FsbHMgZm91bmQgaW4gdGhlIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gaW5wdXQudG9vbF9jYWxscy5maW5kKCh0YykgPT4gdGMubmFtZSA9PT0gZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGlmICghdG9vbENhbGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHRvb2wgY2FsbCBmb3VuZCB3aXRoIG5hbWUgJHtmdW5jdGlvbk5hbWV9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxsLmFyZ3M7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWluY2x1ZGVSYXcpIHtcbiAgICAgICAgICAgIHJldHVybiBsbG0ucGlwZShvdXRwdXRQYXJzZXIpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyQXNzaWduID0gcnVubmFibGVzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHBhcnNlZDogKGlucHV0LCBjb25maWcpID0+IG91dHB1dFBhcnNlci5pbnZva2UoaW5wdXQucmF3LCBjb25maWcpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VyTm9uZSA9IHJ1bm5hYmxlc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgIHBhcnNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFdpdGhGYWxsYmFjayA9IHBhcnNlckFzc2lnbi53aXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIGZhbGxiYWNrczogW3BhcnNlck5vbmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlc18xLlJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmF3OiBsbG0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VkV2l0aEZhbGxiYWNrLFxuICAgICAgICBdKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFJ1bm5hYmxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdEJlZHJvY2tDb252ZXJzZSA9IENoYXRCZWRyb2NrQ29udmVyc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/common.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/common.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractImageInfo = extractImageInfo;\nexports.convertToConverseMessages = convertToConverseMessages;\nexports.isBedrockTool = isBedrockTool;\nexports.convertToConverseTools = convertToConverseTools;\nexports.convertToBedrockToolChoice = convertToBedrockToolChoice;\nexports.convertConverseMessageToLangChainMessage = convertConverseMessageToLangChainMessage;\nexports.handleConverseStreamContentBlockDelta = handleConverseStreamContentBlockDelta;\nexports.handleConverseStreamContentBlockStart = handleConverseStreamContentBlockStart;\nexports.handleConverseStreamMetadata = handleConverseStreamMetadata;\nexports.bedrockReasoningDeltaToLangchainPartialReasoningBlock = bedrockReasoningDeltaToLangchainPartialReasoningBlock;\nexports.bedrockReasoningBlockToLangchainReasoningBlock = bedrockReasoningBlockToLangchainReasoningBlock;\nexports.langchainReasoningBlockToBedrockReasoningBlock = langchainReasoningBlockToBedrockReasoningBlock;\nexports.concatenateLangchainReasoningBlocks = concatenateLangchainReasoningBlocks;\nexports.supportedToolChoiceValuesForModel = supportedToolChoiceValuesForModel;\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst base_1 = __webpack_require__(/*! @langchain/core/language_models/base */ \"(rsc)/./node_modules/@langchain/core/language_models/base.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst types_1 = __webpack_require__(/*! @langchain/core/utils/types */ \"(rsc)/./node_modules/@langchain/core/utils/types.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @langchain/core/utils/json_schema */ \"(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\");\nfunction isDefaultCachePoint(block) {\n    return Boolean(typeof block === \"object\" &&\n        block !== null &&\n        \"cachePoint\" in block &&\n        block.cachePoint &&\n        typeof block.cachePoint === \"object\" &&\n        block.cachePoint !== null &&\n        \"type\" in block.cachePoint &&\n        block.cachePoint.type === \"default\");\n}\nconst standardContentBlockConverter = {\n    providerName: \"ChatBedrockConverse\",\n    fromStandardTextBlock(block) {\n        return {\n            text: block.text,\n        };\n    },\n    fromStandardImageBlock(block) {\n        let format;\n        if (block.source_type === \"url\") {\n            const parsedData = (0, messages_1.parseBase64DataUrl)({\n                dataUrl: block.url,\n                asTypedArray: true,\n            });\n            if (parsedData) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(parsedData.mime_type);\n                format = parsedMimeType.type;\n                return {\n                    image: {\n                        format,\n                        source: {\n                            bytes: parsedData.data,\n                        },\n                    },\n                };\n            }\n            else {\n                throw new Error(\"Only base64 data URLs are supported for image blocks with source type 'url' with ChatBedrockConverse.\");\n            }\n        }\n        else if (block.source_type === \"base64\") {\n            if (block.mime_type) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(block.mime_type);\n                format = parsedMimeType.subtype;\n            }\n            if (format && ![\"gif\", \"jpeg\", \"png\", \"webp\"].includes(format)) {\n                throw new Error(`Unsupported image mime type: \"${block.mime_type}\" ChatBedrockConverse only supports \"image/gif\", \"image/jpeg\", \"image/png\", and \"image/webp\" formats.`);\n            }\n            return {\n                image: {\n                    format,\n                    source: {\n                        bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n                    },\n                },\n            };\n        }\n        else if (block.source_type === \"id\") {\n            throw new Error(\"Image source type 'id' not supported with ChatBedrockConverse.\");\n        }\n        else {\n            throw new Error(`Unsupported image source type: \"${block.source_type}\" with ChatBedrockConverse.`);\n        }\n    },\n    fromStandardFileBlock(block) {\n        const mimeTypeToDocumentFormat = {\n            \"text/csv\": \"csv\",\n            \"application/msword\": \"doc\",\n            \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": \"docx\",\n            \"text/html\": \"html\",\n            \"text/markdown\": \"md\",\n            \"application/pdf\": \"pdf\",\n            \"text/plain\": \"txt\",\n            \"application/vnd.ms-excel\": \"xls\",\n            \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": \"xlsx\",\n        };\n        const name = (block.metadata?.name ??\n            block.metadata?.filename ??\n            block.metadata?.title);\n        if (block.source_type === \"text\") {\n            return {\n                document: {\n                    name,\n                    format: \"txt\",\n                    source: {\n                        bytes: new TextEncoder().encode(block.text),\n                    },\n                },\n            };\n        }\n        if (block.source_type === \"url\") {\n            const parsedData = (0, messages_1.parseBase64DataUrl)({\n                dataUrl: block.url,\n                asTypedArray: true,\n            });\n            if (parsedData) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(parsedData.mime_type ?? block.mime_type);\n                const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n                const format = mimeTypeToDocumentFormat[mimeType];\n                return {\n                    document: {\n                        name,\n                        format,\n                        source: {\n                            bytes: parsedData.data,\n                        },\n                    },\n                };\n            }\n            throw new Error(\"Only base64 data URLs are supported for file blocks with source type 'url' with ChatBedrockConverse.\");\n        }\n        if (block.source_type === \"base64\") {\n            let format;\n            if (block.mime_type) {\n                const parsedMimeType = (0, messages_1.parseMimeType)(block.mime_type);\n                const mimeType = `${parsedMimeType.type}/${parsedMimeType.subtype}`;\n                format = mimeTypeToDocumentFormat[mimeType];\n                if (format === undefined) {\n                    throw new Error(`Unsupported file mime type: \"${block.mime_type}\" ChatBedrockConverse only supports ${Object.keys(mimeTypeToDocumentFormat).join(\", \")} formats.`);\n                }\n            }\n            return {\n                document: {\n                    name,\n                    format,\n                    source: {\n                        bytes: Uint8Array.from(atob(block.data), (c) => c.charCodeAt(0)),\n                    },\n                },\n            };\n        }\n        if (block.source_type === \"id\") {\n            throw new Error(\"File source type 'id' not supported with ChatBedrockConverse.\");\n        }\n        throw new Error(`Unsupported file source type: \"${block.source_type}\" with ChatBedrockConverse.`);\n    },\n};\nfunction extractImageInfo(base64) {\n    // Extract the format from the base64 string\n    const formatMatch = base64.match(/^data:image\\/(\\w+);base64,/);\n    let format;\n    if (formatMatch) {\n        const extractedFormat = formatMatch[1].toLowerCase();\n        if ([\"gif\", \"jpeg\", \"png\", \"webp\"].includes(extractedFormat)) {\n            format = extractedFormat;\n        }\n    }\n    // Remove the data URL prefix if present\n    const base64Data = base64.replace(/^data:image\\/\\w+;base64,/, \"\");\n    // Convert base64 to Uint8Array\n    const binaryString = atob(base64Data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i += 1) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return {\n        image: {\n            format,\n            source: {\n                bytes,\n            },\n        },\n    };\n}\nfunction convertLangChainContentBlockToConverseContentBlock({ block, onUnknown = \"throw\", }) {\n    if (typeof block === \"string\") {\n        return { text: block };\n    }\n    if ((0, messages_1.isDataContentBlock)(block)) {\n        return (0, messages_1.convertToProviderContentBlock)(block, standardContentBlockConverter);\n    }\n    if (block.type === \"text\") {\n        return { text: block.text };\n    }\n    if (block.type === \"image_url\") {\n        return extractImageInfo(typeof block.image_url === \"string\"\n            ? block.image_url\n            : block.image_url.url);\n    }\n    if (block.type === \"document\" && block.document !== undefined) {\n        return {\n            document: block.document,\n        };\n    }\n    if (block.type === \"image\" && block.image !== undefined) {\n        return {\n            image: block.image,\n        };\n    }\n    if (isDefaultCachePoint(block)) {\n        return {\n            cachePoint: {\n                type: \"default\",\n            },\n        };\n    }\n    if (onUnknown === \"throw\") {\n        throw new Error(`Unsupported content block type: ${block.type}`);\n    }\n    else {\n        return block;\n    }\n}\nfunction convertSystemMessageToConverseMessage(msg) {\n    if (typeof msg.content === \"string\") {\n        return [{ text: msg.content }];\n    }\n    else if (Array.isArray(msg.content) && msg.content.length > 0) {\n        const contentBlocks = [];\n        for (const block of msg.content) {\n            if (block.type === \"text\" && typeof block.text === \"string\") {\n                contentBlocks.push({\n                    text: block.text,\n                });\n            }\n            else if (isDefaultCachePoint(block)) {\n                contentBlocks.push({\n                    cachePoint: {\n                        type: \"default\",\n                    },\n                });\n            }\n            else\n                break;\n        }\n        if (msg.content.length === contentBlocks.length)\n            return contentBlocks;\n    }\n    throw new Error(\"System message content must be either a string, or an array of text blocks, optionally including a cache point.\");\n}\nfunction convertAIMessageToConverseMessage(msg) {\n    const assistantMsg = {\n        role: \"assistant\",\n        content: [],\n    };\n    if (typeof msg.content === \"string\" && msg.content !== \"\") {\n        assistantMsg.content?.push({\n            text: msg.content,\n        });\n    }\n    else if (Array.isArray(msg.content)) {\n        const concatenatedBlocks = concatenateLangchainReasoningBlocks(msg.content);\n        const contentBlocks = [];\n        concatenatedBlocks.forEach((block) => {\n            if (block.type === \"text\" && block.text !== \"\") {\n                // Merge whitespace/newlines with previous text blocks to avoid validation errors.\n                const cleanedText = block.text?.replace(/\\n/g, \"\").trim();\n                if (cleanedText === \"\") {\n                    if (contentBlocks.length > 0) {\n                        const mergedTextContent = `${contentBlocks[contentBlocks.length - 1].text}${block.text}`;\n                        contentBlocks[contentBlocks.length - 1].text = mergedTextContent;\n                    }\n                }\n                else {\n                    contentBlocks.push({\n                        text: block.text,\n                    });\n                }\n            }\n            else if (block.type === \"reasoning_content\") {\n                contentBlocks.push({\n                    reasoningContent: langchainReasoningBlockToBedrockReasoningBlock(block),\n                });\n            }\n            else if (isDefaultCachePoint(block)) {\n                contentBlocks.push({\n                    cachePoint: {\n                        type: \"default\",\n                    },\n                });\n            }\n            else {\n                const blockValues = Object.fromEntries(Object.entries(block).filter(([key]) => key !== \"type\"));\n                throw new Error(`Unsupported content block type: ${block.type} with content of ${JSON.stringify(blockValues, null, 2)}`);\n            }\n        });\n        assistantMsg.content = [\n            ...(assistantMsg.content ? assistantMsg.content : []),\n            ...contentBlocks,\n        ];\n    }\n    // Important: this must be placed after any reasoning content blocks, else claude models will return an error.\n    if (msg.tool_calls && msg.tool_calls.length) {\n        assistantMsg.content = [\n            ...(assistantMsg.content ? assistantMsg.content : []),\n            ...msg.tool_calls.map((tc) => ({\n                toolUse: {\n                    toolUseId: tc.id,\n                    name: tc.name,\n                    input: tc.args,\n                },\n            })),\n        ];\n    }\n    return assistantMsg;\n}\nfunction convertHumanMessageToConverseMessage(msg) {\n    if (msg.content === \"\") {\n        throw new Error(`Invalid message content: empty string. '${msg.getType()}' must contain non-empty content.`);\n    }\n    const content = Array.isArray(msg.content)\n        ? msg.content.map((c) => convertLangChainContentBlockToConverseContentBlock({\n            block: c,\n            onUnknown: \"throw\",\n        }))\n        : [\n            convertLangChainContentBlockToConverseContentBlock({\n                block: msg.content,\n                onUnknown: \"throw\",\n            }),\n        ];\n    return {\n        role: \"user\",\n        content,\n    };\n}\nfunction convertToolMessageToConverseMessage(msg) {\n    const castMsg = msg;\n    if (typeof castMsg.content === \"string\") {\n        return {\n            // Tool use messages are always from the user\n            role: \"user\",\n            content: [\n                {\n                    toolResult: {\n                        toolUseId: castMsg.tool_call_id,\n                        content: [\n                            {\n                                text: castMsg.content,\n                            },\n                        ],\n                    },\n                },\n            ],\n        };\n    }\n    else {\n        return {\n            // Tool use messages are always from the user\n            role: \"user\",\n            content: [\n                {\n                    toolResult: {\n                        toolUseId: castMsg.tool_call_id,\n                        content: msg.content.map((c) => {\n                            const converted = convertLangChainContentBlockToConverseContentBlock({\n                                block: c,\n                                onUnknown: \"returnUnmodified\",\n                            });\n                            if (converted !== c) {\n                                return converted;\n                            }\n                            return { json: c };\n                        }),\n                    },\n                },\n            ],\n        };\n    }\n}\nfunction convertToConverseMessages(messages) {\n    const converseSystem = messages\n        .filter((msg) => msg.getType() === \"system\")\n        .flatMap((msg) => convertSystemMessageToConverseMessage(msg));\n    const converseMessages = messages\n        .filter((msg) => msg.getType() !== \"system\")\n        .map((msg) => {\n        if (msg.getType() === \"ai\") {\n            return convertAIMessageToConverseMessage(msg);\n        }\n        else if (msg.getType() === \"human\" || msg.getType() === \"generic\") {\n            return convertHumanMessageToConverseMessage(msg);\n        }\n        else if (msg.getType() === \"tool\") {\n            return convertToolMessageToConverseMessage(msg);\n        }\n        else {\n            throw new Error(`Unsupported message type: ${msg.getType()}`);\n        }\n    });\n    // Combine consecutive user tool result messages into a single message\n    const combinedConverseMessages = converseMessages.reduce((acc, curr) => {\n        const lastMessage = acc[acc.length - 1];\n        if (lastMessage &&\n            lastMessage.role === \"user\" &&\n            lastMessage.content?.some((c) => \"toolResult\" in c) &&\n            curr.role === \"user\" &&\n            curr.content?.some((c) => \"toolResult\" in c)) {\n            lastMessage.content = lastMessage.content.concat(curr.content);\n        }\n        else {\n            acc.push(curr);\n        }\n        return acc;\n    }, []);\n    return { converseMessages: combinedConverseMessages, converseSystem };\n}\nfunction isBedrockTool(tool) {\n    if (typeof tool === \"object\" && tool && \"toolSpec\" in tool) {\n        return true;\n    }\n    return false;\n}\nfunction convertToConverseTools(tools) {\n    if (tools.every(base_1.isOpenAITool)) {\n        return tools.map((tool) => ({\n            toolSpec: {\n                name: tool.function.name,\n                description: tool.function.description,\n                inputSchema: {\n                    json: tool.function.parameters,\n                },\n            },\n        }));\n    }\n    else if (tools.every(function_calling_1.isLangChainTool)) {\n        return tools.map((tool) => ({\n            toolSpec: {\n                name: tool.name,\n                description: tool.description,\n                inputSchema: {\n                    json: ((0, types_1.isInteropZodSchema)(tool.schema)\n                        ? (0, json_schema_1.toJsonSchema)(tool.schema)\n                        : tool.schema),\n                },\n            },\n        }));\n    }\n    else if (tools.every(isBedrockTool)) {\n        return tools;\n    }\n    throw new Error(\"Invalid tools passed. Must be an array of StructuredToolInterface, ToolDefinition, or BedrockTool.\");\n}\nfunction convertToBedrockToolChoice(toolChoice, tools, fields) {\n    const supportsToolChoiceValues = fields.supportsToolChoiceValues ?? [];\n    let bedrockToolChoice;\n    if (typeof toolChoice === \"string\") {\n        switch (toolChoice) {\n            case \"any\":\n                bedrockToolChoice = {\n                    any: {},\n                };\n                break;\n            case \"auto\":\n                bedrockToolChoice = {\n                    auto: {},\n                };\n                break;\n            default: {\n                const foundTool = tools.find((tool) => tool.toolSpec?.name === toolChoice);\n                if (!foundTool) {\n                    throw new Error(`Tool with name ${toolChoice} not found in tools list.`);\n                }\n                bedrockToolChoice = {\n                    tool: {\n                        name: toolChoice,\n                    },\n                };\n            }\n        }\n    }\n    else {\n        bedrockToolChoice = toolChoice;\n    }\n    const toolChoiceType = Object.keys(bedrockToolChoice)[0];\n    if (!supportsToolChoiceValues.includes(toolChoiceType)) {\n        let supportedTxt = \"\";\n        if (supportsToolChoiceValues.length) {\n            supportedTxt =\n                `Model ${fields.model} does not currently support 'tool_choice' ` +\n                    `of type ${toolChoiceType}. The following 'tool_choice' types ` +\n                    `are supported: ${supportsToolChoiceValues.join(\", \")}.`;\n        }\n        else {\n            supportedTxt = `Model ${fields.model} does not currently support 'tool_choice'.`;\n        }\n        throw new Error(`${supportedTxt} Please see` +\n            \"https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ToolChoice.html\" +\n            \"for the latest documentation on models that support tool choice.\");\n    }\n    return bedrockToolChoice;\n}\nfunction convertConverseMessageToLangChainMessage(message, responseMetadata) {\n    if (!message.content) {\n        throw new Error(\"No message content found in response.\");\n    }\n    if (message.role !== \"assistant\") {\n        throw new Error(`Unsupported message role received in ChatBedrockConverse response: ${message.role}`);\n    }\n    let requestId;\n    if (\"$metadata\" in responseMetadata &&\n        responseMetadata.$metadata &&\n        typeof responseMetadata.$metadata === \"object\" &&\n        \"requestId\" in responseMetadata.$metadata) {\n        requestId = responseMetadata.$metadata.requestId;\n    }\n    let tokenUsage;\n    if (responseMetadata.usage) {\n        const input_tokens = responseMetadata.usage.inputTokens ?? 0;\n        const output_tokens = responseMetadata.usage.outputTokens ?? 0;\n        tokenUsage = {\n            input_tokens,\n            output_tokens,\n            total_tokens: responseMetadata.usage.totalTokens ?? input_tokens + output_tokens,\n        };\n    }\n    if (message.content?.length === 1 &&\n        \"text\" in message.content[0] &&\n        typeof message.content[0].text === \"string\") {\n        return new messages_1.AIMessage({\n            content: message.content[0].text,\n            response_metadata: responseMetadata,\n            usage_metadata: tokenUsage,\n            id: requestId,\n        });\n    }\n    else {\n        const toolCalls = [];\n        const content = [];\n        message.content.forEach((c) => {\n            if (\"toolUse\" in c &&\n                c.toolUse &&\n                c.toolUse.name &&\n                c.toolUse.input &&\n                typeof c.toolUse.input === \"object\") {\n                toolCalls.push({\n                    id: c.toolUse.toolUseId,\n                    name: c.toolUse.name,\n                    args: c.toolUse.input,\n                    type: \"tool_call\",\n                });\n            }\n            else if (\"text\" in c && typeof c.text === \"string\") {\n                content.push({ type: \"text\", text: c.text });\n            }\n            else if (\"reasoningContent\" in c) {\n                content.push(bedrockReasoningBlockToLangchainReasoningBlock(c.reasoningContent));\n            }\n            else {\n                content.push(c);\n            }\n        });\n        return new messages_1.AIMessage({\n            content: content.length ? content : \"\",\n            tool_calls: toolCalls.length ? toolCalls : undefined,\n            response_metadata: responseMetadata,\n            usage_metadata: tokenUsage,\n            id: requestId,\n        });\n    }\n}\nfunction handleConverseStreamContentBlockDelta(contentBlockDelta) {\n    if (!contentBlockDelta.delta) {\n        throw new Error(\"No delta found in content block.\");\n    }\n    if (typeof contentBlockDelta.delta.text === \"string\") {\n        return new outputs_1.ChatGenerationChunk({\n            text: contentBlockDelta.delta.text,\n            message: new messages_1.AIMessageChunk({\n                content: contentBlockDelta.delta.text,\n            }),\n        });\n    }\n    else if (contentBlockDelta.delta.toolUse) {\n        const index = contentBlockDelta.contentBlockIndex;\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: \"\",\n                tool_call_chunks: [\n                    {\n                        args: contentBlockDelta.delta.toolUse.input,\n                        index,\n                        type: \"tool_call_chunk\",\n                    },\n                ],\n            }),\n        });\n    }\n    else if (contentBlockDelta.delta.reasoningContent) {\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: [\n                    bedrockReasoningDeltaToLangchainPartialReasoningBlock(contentBlockDelta.delta.reasoningContent),\n                ],\n            }),\n        });\n    }\n    else {\n        throw new Error(`Unsupported content block type(s): ${JSON.stringify(contentBlockDelta.delta, null, 2)}`);\n    }\n}\nfunction handleConverseStreamContentBlockStart(contentBlockStart) {\n    const index = contentBlockStart.contentBlockIndex;\n    if (contentBlockStart.start?.toolUse) {\n        return new outputs_1.ChatGenerationChunk({\n            text: \"\",\n            message: new messages_1.AIMessageChunk({\n                content: \"\",\n                tool_call_chunks: [\n                    {\n                        name: contentBlockStart.start.toolUse.name,\n                        id: contentBlockStart.start.toolUse.toolUseId,\n                        index,\n                        type: \"tool_call_chunk\",\n                    },\n                ],\n            }),\n        });\n    }\n    throw new Error(\"Unsupported content block start event.\");\n}\nfunction handleConverseStreamMetadata(metadata, extra) {\n    const inputTokens = metadata.usage?.inputTokens ?? 0;\n    const outputTokens = metadata.usage?.outputTokens ?? 0;\n    const usage_metadata = {\n        input_tokens: inputTokens,\n        output_tokens: outputTokens,\n        total_tokens: metadata.usage?.totalTokens ?? inputTokens + outputTokens,\n    };\n    return new outputs_1.ChatGenerationChunk({\n        text: \"\",\n        message: new messages_1.AIMessageChunk({\n            content: \"\",\n            usage_metadata: extra.streamUsage ? usage_metadata : undefined,\n            response_metadata: {\n                // Use the same key as returned from the Converse API\n                metadata,\n            },\n        }),\n    });\n}\nfunction bedrockReasoningDeltaToLangchainPartialReasoningBlock(reasoningContent) {\n    const { text, redactedContent, signature } = reasoningContent;\n    if (typeof text === \"string\") {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: { text },\n        };\n    }\n    if (signature) {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: { signature },\n        };\n    }\n    if (redactedContent) {\n        return {\n            type: \"reasoning_content\",\n            redactedContent: Buffer.from(redactedContent).toString(\"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction bedrockReasoningBlockToLangchainReasoningBlock(reasoningContent) {\n    const { reasoningText, redactedContent } = reasoningContent;\n    if (reasoningText) {\n        return {\n            type: \"reasoning_content\",\n            reasoningText: reasoningText,\n        };\n    }\n    if (redactedContent) {\n        return {\n            type: \"reasoning_content\",\n            redactedContent: Buffer.from(redactedContent).toString(\"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction langchainReasoningBlockToBedrockReasoningBlock(content) {\n    if (content.type !== \"reasoning_content\") {\n        throw new Error(\"Invalid reasoning content\");\n    }\n    if (\"reasoningText\" in content) {\n        return {\n            reasoningText: content.reasoningText,\n        };\n    }\n    if (\"redactedContent\" in content) {\n        return {\n            redactedContent: Buffer.from(content.redactedContent, \"base64\"),\n        };\n    }\n    throw new Error(\"Invalid reasoning content\");\n}\nfunction concatenateLangchainReasoningBlocks(content) {\n    const concatenatedBlocks = [];\n    let concatenatedBlock = {};\n    for (const block of content) {\n        if (block.type !== \"reasoning_content\") {\n            // if it's some other block type, end the current block, but keep it so we preserve order\n            if (Object.keys(concatenatedBlock).length > 0) {\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            concatenatedBlocks.push(block);\n            continue;\n        }\n        // non-redacted block\n        if (\"reasoningText\" in block && typeof block.reasoningText === \"object\") {\n            if (\"redactedContent\" in concatenatedBlock) {\n                // new type of block, so end the previous one\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            const { text, signature } = block.reasoningText;\n            const { text: prevText, signature: prevSignature } = (\"reasoningText\" in concatenatedBlock\n                ? concatenatedBlock.reasoningText\n                : {});\n            concatenatedBlock = {\n                type: \"reasoning_content\",\n                reasoningText: {\n                    ...(concatenatedBlock\n                        .reasoningText ?? {}),\n                    ...(prevText !== undefined || text !== undefined\n                        ? { text: (prevText ?? \"\") + (text ?? \"\") }\n                        : {}),\n                    ...(prevSignature !== undefined || signature !== undefined\n                        ? { signature: (prevSignature ?? \"\") + (signature ?? \"\") }\n                        : {}),\n                },\n            };\n            // if a partial block chunk has a signature, the next one will begin a new reasoning block.\n            // full blocks always have signatures, so we start one now, anyway\n            if (\"signature\" in block.reasoningText) {\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n        }\n        if (\"redactedContent\" in block) {\n            if (\"reasoningText\" in concatenatedBlock) {\n                // New type of block, so end the previous one. We should't really hit\n                // this, as we'll have created a new block upon encountering the\n                // signature above, but better safe than sorry.\n                concatenatedBlocks.push(concatenatedBlock);\n                concatenatedBlock = {};\n            }\n            const { redactedContent } = block;\n            const prevRedactedContent = (\"redactedContent\" in concatenatedBlock\n                ? concatenatedBlock.redactedContent\n                : \"\");\n            concatenatedBlock = {\n                type: \"reasoning_content\",\n                redactedContent: prevRedactedContent + redactedContent,\n            };\n        }\n    }\n    if (Object.keys(concatenatedBlock).length > 0) {\n        concatenatedBlocks.push(concatenatedBlock);\n    }\n    return concatenatedBlocks;\n}\nfunction supportedToolChoiceValuesForModel(model) {\n    if (model.includes(\"claude-3\") ||\n        model.includes(\"claude-4\") ||\n        model.includes(\"claude-opus-4\") ||\n        model.includes(\"claude-sonnet-4\")) {\n        return [\"auto\", \"any\", \"tool\"];\n    }\n    if (model.includes(\"mistral-large\")) {\n        return [\"auto\", \"any\"];\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9jb21tb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QixrQ0FBa0M7QUFDbEMsZ0RBQWdEO0FBQ2hELDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDLDZEQUE2RDtBQUM3RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywyR0FBc0M7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsK0dBQXdDO0FBQzNFLGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBNkI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMscUdBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CLEdBQUcsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQixHQUFHLHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0Esb0VBQW9FLGdCQUFnQixzQ0FBc0Msa0RBQWtEO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOERBQThELDZCQUE2QjtBQUMzRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkNBQTZDLEVBQUUsV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsWUFBWSxrQkFBa0IscUNBQXFDO0FBQ3RJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsK0JBQStCLGVBQWU7QUFDOUMsc0NBQXNDLG9DQUFvQztBQUMxRTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4REFBOEQsaURBQWlEO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0IsMkNBQTJDO0FBQy9EO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L2NvbW1vbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RJbWFnZUluZm8gPSBleHRyYWN0SW1hZ2VJbmZvO1xuZXhwb3J0cy5jb252ZXJ0VG9Db252ZXJzZU1lc3NhZ2VzID0gY29udmVydFRvQ29udmVyc2VNZXNzYWdlcztcbmV4cG9ydHMuaXNCZWRyb2NrVG9vbCA9IGlzQmVkcm9ja1Rvb2w7XG5leHBvcnRzLmNvbnZlcnRUb0NvbnZlcnNlVG9vbHMgPSBjb252ZXJ0VG9Db252ZXJzZVRvb2xzO1xuZXhwb3J0cy5jb252ZXJ0VG9CZWRyb2NrVG9vbENob2ljZSA9IGNvbnZlcnRUb0JlZHJvY2tUb29sQ2hvaWNlO1xuZXhwb3J0cy5jb252ZXJ0Q29udmVyc2VNZXNzYWdlVG9MYW5nQ2hhaW5NZXNzYWdlID0gY29udmVydENvbnZlcnNlTWVzc2FnZVRvTGFuZ0NoYWluTWVzc2FnZTtcbmV4cG9ydHMuaGFuZGxlQ29udmVyc2VTdHJlYW1Db250ZW50QmxvY2tEZWx0YSA9IGhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrRGVsdGE7XG5leHBvcnRzLmhhbmRsZUNvbnZlcnNlU3RyZWFtQ29udGVudEJsb2NrU3RhcnQgPSBoYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja1N0YXJ0O1xuZXhwb3J0cy5oYW5kbGVDb252ZXJzZVN0cmVhbU1ldGFkYXRhID0gaGFuZGxlQ29udmVyc2VTdHJlYW1NZXRhZGF0YTtcbmV4cG9ydHMuYmVkcm9ja1JlYXNvbmluZ0RlbHRhVG9MYW5nY2hhaW5QYXJ0aWFsUmVhc29uaW5nQmxvY2sgPSBiZWRyb2NrUmVhc29uaW5nRGVsdGFUb0xhbmdjaGFpblBhcnRpYWxSZWFzb25pbmdCbG9jaztcbmV4cG9ydHMuYmVkcm9ja1JlYXNvbmluZ0Jsb2NrVG9MYW5nY2hhaW5SZWFzb25pbmdCbG9jayA9IGJlZHJvY2tSZWFzb25pbmdCbG9ja1RvTGFuZ2NoYWluUmVhc29uaW5nQmxvY2s7XG5leHBvcnRzLmxhbmdjaGFpblJlYXNvbmluZ0Jsb2NrVG9CZWRyb2NrUmVhc29uaW5nQmxvY2sgPSBsYW5nY2hhaW5SZWFzb25pbmdCbG9ja1RvQmVkcm9ja1JlYXNvbmluZ0Jsb2NrO1xuZXhwb3J0cy5jb25jYXRlbmF0ZUxhbmdjaGFpblJlYXNvbmluZ0Jsb2NrcyA9IGNvbmNhdGVuYXRlTGFuZ2NoYWluUmVhc29uaW5nQmxvY2tzO1xuZXhwb3J0cy5zdXBwb3J0ZWRUb29sQ2hvaWNlVmFsdWVzRm9yTW9kZWwgPSBzdXBwb3J0ZWRUb29sQ2hvaWNlVmFsdWVzRm9yTW9kZWw7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2VcIik7XG5jb25zdCBmdW5jdGlvbl9jYWxsaW5nXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmdcIik7XG5jb25zdCBvdXRwdXRzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL291dHB1dHNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy90eXBlc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2pzb25fc2NoZW1hXCIpO1xuZnVuY3Rpb24gaXNEZWZhdWx0Q2FjaGVQb2ludChibG9jaykge1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiBibG9jayA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBibG9jayAhPT0gbnVsbCAmJlxuICAgICAgICBcImNhY2hlUG9pbnRcIiBpbiBibG9jayAmJlxuICAgICAgICBibG9jay5jYWNoZVBvaW50ICYmXG4gICAgICAgIHR5cGVvZiBibG9jay5jYWNoZVBvaW50ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGJsb2NrLmNhY2hlUG9pbnQgIT09IG51bGwgJiZcbiAgICAgICAgXCJ0eXBlXCIgaW4gYmxvY2suY2FjaGVQb2ludCAmJlxuICAgICAgICBibG9jay5jYWNoZVBvaW50LnR5cGUgPT09IFwiZGVmYXVsdFwiKTtcbn1cbmNvbnN0IHN0YW5kYXJkQ29udGVudEJsb2NrQ29udmVydGVyID0ge1xuICAgIHByb3ZpZGVyTmFtZTogXCJDaGF0QmVkcm9ja0NvbnZlcnNlXCIsXG4gICAgZnJvbVN0YW5kYXJkVGV4dEJsb2NrKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBibG9jay50ZXh0LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbVN0YW5kYXJkSW1hZ2VCbG9jayhibG9jaykge1xuICAgICAgICBsZXQgZm9ybWF0O1xuICAgICAgICBpZiAoYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSAoMCwgbWVzc2FnZXNfMS5wYXJzZUJhc2U2NERhdGFVcmwpKHtcbiAgICAgICAgICAgICAgICBkYXRhVXJsOiBibG9jay51cmwsXG4gICAgICAgICAgICAgICAgYXNUeXBlZEFycmF5OiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1pbWVUeXBlID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VNaW1lVHlwZSkocGFyc2VkRGF0YS5taW1lX3R5cGUpO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHBhcnNlZE1pbWVUeXBlLnR5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBwYXJzZWREYXRhLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IGJhc2U2NCBkYXRhIFVSTHMgYXJlIHN1cHBvcnRlZCBmb3IgaW1hZ2UgYmxvY2tzIHdpdGggc291cmNlIHR5cGUgJ3VybCcgd2l0aCBDaGF0QmVkcm9ja0NvbnZlcnNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrLm1pbWVfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1pbWVUeXBlID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VNaW1lVHlwZSkoYmxvY2subWltZV90eXBlKTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBwYXJzZWRNaW1lVHlwZS5zdWJ0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCAmJiAhW1wiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcIndlYnBcIl0uaW5jbHVkZXMoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaW1hZ2UgbWltZSB0eXBlOiBcIiR7YmxvY2subWltZV90eXBlfVwiIENoYXRCZWRyb2NrQ29udmVyc2Ugb25seSBzdXBwb3J0cyBcImltYWdlL2dpZlwiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9wbmdcIiwgYW5kIFwiaW1hZ2Uvd2VicFwiIGZvcm1hdHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlczogVWludDhBcnJheS5mcm9tKGF0b2IoYmxvY2suZGF0YSksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLnNvdXJjZV90eXBlID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIHNvdXJjZSB0eXBlICdpZCcgbm90IHN1cHBvcnRlZCB3aXRoIENoYXRCZWRyb2NrQ29udmVyc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpbWFnZSBzb3VyY2UgdHlwZTogXCIke2Jsb2NrLnNvdXJjZV90eXBlfVwiIHdpdGggQ2hhdEJlZHJvY2tDb252ZXJzZS5gKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZnJvbVN0YW5kYXJkRmlsZUJsb2NrKGJsb2NrKSB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlVG9Eb2N1bWVudEZvcm1hdCA9IHtcbiAgICAgICAgICAgIFwidGV4dC9jc3ZcIjogXCJjc3ZcIixcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vbXN3b3JkXCI6IFwiZG9jXCIsXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50XCI6IFwiZG9jeFwiLFxuICAgICAgICAgICAgXCJ0ZXh0L2h0bWxcIjogXCJodG1sXCIsXG4gICAgICAgICAgICBcInRleHQvbWFya2Rvd25cIjogXCJtZFwiLFxuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9wZGZcIjogXCJwZGZcIixcbiAgICAgICAgICAgIFwidGV4dC9wbGFpblwiOiBcInR4dFwiLFxuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIjogXCJ4bHNcIixcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIjogXCJ4bHN4XCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoYmxvY2subWV0YWRhdGE/Lm5hbWUgPz9cbiAgICAgICAgICAgIGJsb2NrLm1ldGFkYXRhPy5maWxlbmFtZSA/P1xuICAgICAgICAgICAgYmxvY2subWV0YWRhdGE/LnRpdGxlKTtcbiAgICAgICAgaWYgKGJsb2NrLnNvdXJjZV90eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwidHh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShibG9jay50ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSAoMCwgbWVzc2FnZXNfMS5wYXJzZUJhc2U2NERhdGFVcmwpKHtcbiAgICAgICAgICAgICAgICBkYXRhVXJsOiBibG9jay51cmwsXG4gICAgICAgICAgICAgICAgYXNUeXBlZEFycmF5OiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1pbWVUeXBlID0gKDAsIG1lc3NhZ2VzXzEucGFyc2VNaW1lVHlwZSkocGFyc2VkRGF0YS5taW1lX3R5cGUgPz8gYmxvY2subWltZV90eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke3BhcnNlZE1pbWVUeXBlLnR5cGV9LyR7cGFyc2VkTWltZVR5cGUuc3VidHlwZX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG1pbWVUeXBlVG9Eb2N1bWVudEZvcm1hdFttaW1lVHlwZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlczogcGFyc2VkRGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBiYXNlNjQgZGF0YSBVUkxzIGFyZSBzdXBwb3J0ZWQgZm9yIGZpbGUgYmxvY2tzIHdpdGggc291cmNlIHR5cGUgJ3VybCcgd2l0aCBDaGF0QmVkcm9ja0NvbnZlcnNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgIGxldCBmb3JtYXQ7XG4gICAgICAgICAgICBpZiAoYmxvY2subWltZV90eXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTWltZVR5cGUgPSAoMCwgbWVzc2FnZXNfMS5wYXJzZU1pbWVUeXBlKShibG9jay5taW1lX3R5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7cGFyc2VkTWltZVR5cGUudHlwZX0vJHtwYXJzZWRNaW1lVHlwZS5zdWJ0eXBlfWA7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gbWltZVR5cGVUb0RvY3VtZW50Rm9ybWF0W21pbWVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmaWxlIG1pbWUgdHlwZTogXCIke2Jsb2NrLm1pbWVfdHlwZX1cIiBDaGF0QmVkcm9ja0NvbnZlcnNlIG9ubHkgc3VwcG9ydHMgJHtPYmplY3Qua2V5cyhtaW1lVHlwZVRvRG9jdW1lbnRGb3JtYXQpLmpvaW4oXCIsIFwiKX0gZm9ybWF0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlczogVWludDhBcnJheS5mcm9tKGF0b2IoYmxvY2suZGF0YSksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIHNvdXJjZSB0eXBlICdpZCcgbm90IHN1cHBvcnRlZCB3aXRoIENoYXRCZWRyb2NrQ29udmVyc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmlsZSBzb3VyY2UgdHlwZTogXCIke2Jsb2NrLnNvdXJjZV90eXBlfVwiIHdpdGggQ2hhdEJlZHJvY2tDb252ZXJzZS5gKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGV4dHJhY3RJbWFnZUluZm8oYmFzZTY0KSB7XG4gICAgLy8gRXh0cmFjdCB0aGUgZm9ybWF0IGZyb20gdGhlIGJhc2U2NCBzdHJpbmdcbiAgICBjb25zdCBmb3JtYXRNYXRjaCA9IGJhc2U2NC5tYXRjaCgvXmRhdGE6aW1hZ2VcXC8oXFx3Kyk7YmFzZTY0LC8pO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGZvcm1hdE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZEZvcm1hdCA9IGZvcm1hdE1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChbXCJnaWZcIiwgXCJqcGVnXCIsIFwicG5nXCIsIFwid2VicFwiXS5pbmNsdWRlcyhleHRyYWN0ZWRGb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBleHRyYWN0ZWRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBkYXRhIFVSTCBwcmVmaXggaWYgcHJlc2VudFxuICAgIGNvbnN0IGJhc2U2NERhdGEgPSBiYXNlNjQucmVwbGFjZSgvXmRhdGE6aW1hZ2VcXC9cXHcrO2Jhc2U2NCwvLCBcIlwiKTtcbiAgICAvLyBDb252ZXJ0IGJhc2U2NCB0byBVaW50OEFycmF5XG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICBieXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5Db250ZW50QmxvY2tUb0NvbnZlcnNlQ29udGVudEJsb2NrKHsgYmxvY2ssIG9uVW5rbm93biA9IFwidGhyb3dcIiwgfSkge1xuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogYmxvY2sgfTtcbiAgICB9XG4gICAgaWYgKCgwLCBtZXNzYWdlc18xLmlzRGF0YUNvbnRlbnRCbG9jaykoYmxvY2spKSB7XG4gICAgICAgIHJldHVybiAoMCwgbWVzc2FnZXNfMS5jb252ZXJ0VG9Qcm92aWRlckNvbnRlbnRCbG9jaykoYmxvY2ssIHN0YW5kYXJkQ29udGVudEJsb2NrQ29udmVydGVyKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IGJsb2NrLnRleHQgfTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwiaW1hZ2VfdXJsXCIpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RJbWFnZUluZm8odHlwZW9mIGJsb2NrLmltYWdlX3VybCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBibG9jay5pbWFnZV91cmxcbiAgICAgICAgICAgIDogYmxvY2suaW1hZ2VfdXJsLnVybCk7XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlID09PSBcImRvY3VtZW50XCIgJiYgYmxvY2suZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGJsb2NrLmRvY3VtZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiICYmIGJsb2NrLmltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBibG9jay5pbWFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRGVmYXVsdENhY2hlUG9pbnQoYmxvY2spKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZVBvaW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob25Vbmtub3duID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb250ZW50IGJsb2NrIHR5cGU6ICR7YmxvY2sudHlwZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U3lzdGVtTWVzc2FnZVRvQ29udmVyc2VNZXNzYWdlKG1zZykge1xuICAgIGlmICh0eXBlb2YgbXNnLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFt7IHRleHQ6IG1zZy5jb250ZW50IH1dO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1zZy5jb250ZW50KSAmJiBtc2cuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRCbG9ja3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBtc2cuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFwidGV4dFwiICYmIHR5cGVvZiBibG9jay50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYmxvY2sudGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmYXVsdENhY2hlUG9pbnQoYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVQb2ludDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy5jb250ZW50Lmxlbmd0aCA9PT0gY29udGVudEJsb2Nrcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gY29udGVudEJsb2NrcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIG1lc3NhZ2UgY29udGVudCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgdGV4dCBibG9ja3MsIG9wdGlvbmFsbHkgaW5jbHVkaW5nIGEgY2FjaGUgcG9pbnQuXCIpO1xufVxuZnVuY3Rpb24gY29udmVydEFJTWVzc2FnZVRvQ29udmVyc2VNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGFzc2lzdGFudE1zZyA9IHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogW10sXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG1zZy5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIG1zZy5jb250ZW50ICE9PSBcIlwiKSB7XG4gICAgICAgIGFzc2lzdGFudE1zZy5jb250ZW50Py5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IG1zZy5jb250ZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtc2cuY29udGVudCkpIHtcbiAgICAgICAgY29uc3QgY29uY2F0ZW5hdGVkQmxvY2tzID0gY29uY2F0ZW5hdGVMYW5nY2hhaW5SZWFzb25pbmdCbG9ja3MobXNnLmNvbnRlbnQpO1xuICAgICAgICBjb25zdCBjb250ZW50QmxvY2tzID0gW107XG4gICAgICAgIGNvbmNhdGVuYXRlZEJsb2Nrcy5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFwidGV4dFwiICYmIGJsb2NrLnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSB3aGl0ZXNwYWNlL25ld2xpbmVzIHdpdGggcHJldmlvdXMgdGV4dCBibG9ja3MgdG8gYXZvaWQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFRleHQgPSBibG9jay50ZXh0Py5yZXBsYWNlKC9cXG4vZywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkVGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRUZXh0Q29udGVudCA9IGAke2NvbnRlbnRCbG9ja3NbY29udGVudEJsb2Nrcy5sZW5ndGggLSAxXS50ZXh0fSR7YmxvY2sudGV4dH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEJsb2Nrc1tjb250ZW50QmxvY2tzLmxlbmd0aCAtIDFdLnRleHQgPSBtZXJnZWRUZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGJsb2NrLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrLnR5cGUgPT09IFwicmVhc29uaW5nX2NvbnRlbnRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRCbG9ja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbmluZ0NvbnRlbnQ6IGxhbmdjaGFpblJlYXNvbmluZ0Jsb2NrVG9CZWRyb2NrUmVhc29uaW5nQmxvY2soYmxvY2spLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWZhdWx0Q2FjaGVQb2ludChibG9jaykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50QmxvY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrVmFsdWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJsb2NrKS5maWx0ZXIoKFtrZXldKSA9PiBrZXkgIT09IFwidHlwZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb250ZW50IGJsb2NrIHR5cGU6ICR7YmxvY2sudHlwZX0gd2l0aCBjb250ZW50IG9mICR7SlNPTi5zdHJpbmdpZnkoYmxvY2tWYWx1ZXMsIG51bGwsIDIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXNzaXN0YW50TXNnLmNvbnRlbnQgPSBbXG4gICAgICAgICAgICAuLi4oYXNzaXN0YW50TXNnLmNvbnRlbnQgPyBhc3Npc3RhbnRNc2cuY29udGVudCA6IFtdKSxcbiAgICAgICAgICAgIC4uLmNvbnRlbnRCbG9ja3MsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIEltcG9ydGFudDogdGhpcyBtdXN0IGJlIHBsYWNlZCBhZnRlciBhbnkgcmVhc29uaW5nIGNvbnRlbnQgYmxvY2tzLCBlbHNlIGNsYXVkZSBtb2RlbHMgd2lsbCByZXR1cm4gYW4gZXJyb3IuXG4gICAgaWYgKG1zZy50b29sX2NhbGxzICYmIG1zZy50b29sX2NhbGxzLmxlbmd0aCkge1xuICAgICAgICBhc3Npc3RhbnRNc2cuY29udGVudCA9IFtcbiAgICAgICAgICAgIC4uLihhc3Npc3RhbnRNc2cuY29udGVudCA/IGFzc2lzdGFudE1zZy5jb250ZW50IDogW10pLFxuICAgICAgICAgICAgLi4ubXNnLnRvb2xfY2FsbHMubWFwKCh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICB0b29sVXNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xVc2VJZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0Yy5hcmdzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBhc3Npc3RhbnRNc2c7XG59XG5mdW5jdGlvbiBjb252ZXJ0SHVtYW5NZXNzYWdlVG9Db252ZXJzZU1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKG1zZy5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlIGNvbnRlbnQ6IGVtcHR5IHN0cmluZy4gJyR7bXNnLmdldFR5cGUoKX0nIG11c3QgY29udGFpbiBub24tZW1wdHkgY29udGVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IEFycmF5LmlzQXJyYXkobXNnLmNvbnRlbnQpXG4gICAgICAgID8gbXNnLmNvbnRlbnQubWFwKChjKSA9PiBjb252ZXJ0TGFuZ0NoYWluQ29udGVudEJsb2NrVG9Db252ZXJzZUNvbnRlbnRCbG9jayh7XG4gICAgICAgICAgICBibG9jazogYyxcbiAgICAgICAgICAgIG9uVW5rbm93bjogXCJ0aHJvd1wiLFxuICAgICAgICB9KSlcbiAgICAgICAgOiBbXG4gICAgICAgICAgICBjb252ZXJ0TGFuZ0NoYWluQ29udGVudEJsb2NrVG9Db252ZXJzZUNvbnRlbnRCbG9jayh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IG1zZy5jb250ZW50LFxuICAgICAgICAgICAgICAgIG9uVW5rbm93bjogXCJ0aHJvd1wiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb29sTWVzc2FnZVRvQ29udmVyc2VNZXNzYWdlKG1zZykge1xuICAgIGNvbnN0IGNhc3RNc2cgPSBtc2c7XG4gICAgaWYgKHR5cGVvZiBjYXN0TXNnLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFRvb2wgdXNlIG1lc3NhZ2VzIGFyZSBhbHdheXMgZnJvbSB0aGUgdXNlclxuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWQ6IGNhc3RNc2cudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2FzdE1zZy5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFRvb2wgdXNlIG1lc3NhZ2VzIGFyZSBhbHdheXMgZnJvbSB0aGUgdXNlclxuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sVXNlSWQ6IGNhc3RNc2cudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbXNnLmNvbnRlbnQubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVkID0gY29udmVydExhbmdDaGFpbkNvbnRlbnRCbG9ja1RvQ29udmVyc2VDb250ZW50QmxvY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jazogYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Vbmtub3duOiBcInJldHVyblVubW9kaWZpZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVkICE9PSBjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGpzb246IGMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbnZlcnNlTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBjb25zdCBjb252ZXJzZVN5c3RlbSA9IG1lc3NhZ2VzXG4gICAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLmdldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIilcbiAgICAgICAgLmZsYXRNYXAoKG1zZykgPT4gY29udmVydFN5c3RlbU1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpKTtcbiAgICBjb25zdCBjb252ZXJzZU1lc3NhZ2VzID0gbWVzc2FnZXNcbiAgICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuZ2V0VHlwZSgpICE9PSBcInN5c3RlbVwiKVxuICAgICAgICAubWFwKChtc2cpID0+IHtcbiAgICAgICAgaWYgKG1zZy5nZXRUeXBlKCkgPT09IFwiYWlcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRBSU1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy5nZXRUeXBlKCkgPT09IFwiaHVtYW5cIiB8fCBtc2cuZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRIdW1hbk1lc3NhZ2VUb0NvbnZlcnNlTWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy5nZXRUeXBlKCkgPT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvb2xNZXNzYWdlVG9Db252ZXJzZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWVzc2FnZSB0eXBlOiAke21zZy5nZXRUeXBlKCl9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDb21iaW5lIGNvbnNlY3V0aXZlIHVzZXIgdG9vbCByZXN1bHQgbWVzc2FnZXMgaW50byBhIHNpbmdsZSBtZXNzYWdlXG4gICAgY29uc3QgY29tYmluZWRDb252ZXJzZU1lc3NhZ2VzID0gY29udmVyc2VNZXNzYWdlcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0TWVzc2FnZSAmJlxuICAgICAgICAgICAgbGFzdE1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIgJiZcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQ/LnNvbWUoKGMpID0+IFwidG9vbFJlc3VsdFwiIGluIGMpICYmXG4gICAgICAgICAgICBjdXJyLnJvbGUgPT09IFwidXNlclwiICYmXG4gICAgICAgICAgICBjdXJyLmNvbnRlbnQ/LnNvbWUoKGMpID0+IFwidG9vbFJlc3VsdFwiIGluIGMpKSB7XG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50ID0gbGFzdE1lc3NhZ2UuY29udGVudC5jb25jYXQoY3Vyci5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7IGNvbnZlcnNlTWVzc2FnZXM6IGNvbWJpbmVkQ29udmVyc2VNZXNzYWdlcywgY29udmVyc2VTeXN0ZW0gfTtcbn1cbmZ1bmN0aW9uIGlzQmVkcm9ja1Rvb2wodG9vbCkge1xuICAgIGlmICh0eXBlb2YgdG9vbCA9PT0gXCJvYmplY3RcIiAmJiB0b29sICYmIFwidG9vbFNwZWNcIiBpbiB0b29sKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db252ZXJzZVRvb2xzKHRvb2xzKSB7XG4gICAgaWYgKHRvb2xzLmV2ZXJ5KGJhc2VfMS5pc09wZW5BSVRvb2wpKSB7XG4gICAgICAgIHJldHVybiB0b29scy5tYXAoKHRvb2wpID0+ICh7XG4gICAgICAgICAgICB0b29sU3BlYzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICBqc29uOiB0b29sLmZ1bmN0aW9uLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9vbHMuZXZlcnkoZnVuY3Rpb25fY2FsbGluZ18xLmlzTGFuZ0NoYWluVG9vbCkpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xzLm1hcCgodG9vbCkgPT4gKHtcbiAgICAgICAgICAgIHRvb2xTcGVjOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIGpzb246ICgoMCwgdHlwZXNfMS5pc0ludGVyb3Bab2RTY2hlbWEpKHRvb2wuc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwganNvbl9zY2hlbWFfMS50b0pzb25TY2hlbWEpKHRvb2wuc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0b29sLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9vbHMuZXZlcnkoaXNCZWRyb2NrVG9vbCkpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRvb2xzIHBhc3NlZC4gTXVzdCBiZSBhbiBhcnJheSBvZiBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSwgVG9vbERlZmluaXRpb24sIG9yIEJlZHJvY2tUb29sLlwiKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0JlZHJvY2tUb29sQ2hvaWNlKHRvb2xDaG9pY2UsIHRvb2xzLCBmaWVsZHMpIHtcbiAgICBjb25zdCBzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMgPSBmaWVsZHMuc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzID8/IFtdO1xuICAgIGxldCBiZWRyb2NrVG9vbENob2ljZTtcbiAgICBpZiAodHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoICh0b29sQ2hvaWNlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgICAgICAgYmVkcm9ja1Rvb2xDaG9pY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFueToge30sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgICAgICAgICAgICAgYmVkcm9ja1Rvb2xDaG9pY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG86IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRUb29sID0gdG9vbHMuZmluZCgodG9vbCkgPT4gdG9vbC50b29sU3BlYz8ubmFtZSA9PT0gdG9vbENob2ljZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZFRvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sIHdpdGggbmFtZSAke3Rvb2xDaG9pY2V9IG5vdCBmb3VuZCBpbiB0b29scyBsaXN0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZWRyb2NrVG9vbENob2ljZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiZWRyb2NrVG9vbENob2ljZSA9IHRvb2xDaG9pY2U7XG4gICAgfVxuICAgIGNvbnN0IHRvb2xDaG9pY2VUeXBlID0gT2JqZWN0LmtleXMoYmVkcm9ja1Rvb2xDaG9pY2UpWzBdO1xuICAgIGlmICghc3VwcG9ydHNUb29sQ2hvaWNlVmFsdWVzLmluY2x1ZGVzKHRvb2xDaG9pY2VUeXBlKSkge1xuICAgICAgICBsZXQgc3VwcG9ydGVkVHh0ID0gXCJcIjtcbiAgICAgICAgaWYgKHN1cHBvcnRzVG9vbENob2ljZVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZFR4dCA9XG4gICAgICAgICAgICAgICAgYE1vZGVsICR7ZmllbGRzLm1vZGVsfSBkb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCAndG9vbF9jaG9pY2UnIGAgK1xuICAgICAgICAgICAgICAgICAgICBgb2YgdHlwZSAke3Rvb2xDaG9pY2VUeXBlfS4gVGhlIGZvbGxvd2luZyAndG9vbF9jaG9pY2UnIHR5cGVzIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYXJlIHN1cHBvcnRlZDogJHtzdXBwb3J0c1Rvb2xDaG9pY2VWYWx1ZXMuam9pbihcIiwgXCIpfS5gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwcG9ydGVkVHh0ID0gYE1vZGVsICR7ZmllbGRzLm1vZGVsfSBkb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCAndG9vbF9jaG9pY2UnLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3N1cHBvcnRlZFR4dH0gUGxlYXNlIHNlZWAgK1xuICAgICAgICAgICAgXCJodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vYmVkcm9jay9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9ydW50aW1lX1Rvb2xDaG9pY2UuaHRtbFwiICtcbiAgICAgICAgICAgIFwiZm9yIHRoZSBsYXRlc3QgZG9jdW1lbnRhdGlvbiBvbiBtb2RlbHMgdGhhdCBzdXBwb3J0IHRvb2wgY2hvaWNlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlZHJvY2tUb29sQ2hvaWNlO1xufVxuZnVuY3Rpb24gY29udmVydENvbnZlcnNlTWVzc2FnZVRvTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlLCByZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgaWYgKCFtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZSBjb250ZW50IGZvdW5kIGluIHJlc3BvbnNlLlwiKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1lc3NhZ2Ugcm9sZSByZWNlaXZlZCBpbiBDaGF0QmVkcm9ja0NvbnZlcnNlIHJlc3BvbnNlOiAke21lc3NhZ2Uucm9sZX1gKTtcbiAgICB9XG4gICAgbGV0IHJlcXVlc3RJZDtcbiAgICBpZiAoXCIkbWV0YWRhdGFcIiBpbiByZXNwb25zZU1ldGFkYXRhICYmXG4gICAgICAgIHJlc3BvbnNlTWV0YWRhdGEuJG1ldGFkYXRhICYmXG4gICAgICAgIHR5cGVvZiByZXNwb25zZU1ldGFkYXRhLiRtZXRhZGF0YSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcInJlcXVlc3RJZFwiIGluIHJlc3BvbnNlTWV0YWRhdGEuJG1ldGFkYXRhKSB7XG4gICAgICAgIHJlcXVlc3RJZCA9IHJlc3BvbnNlTWV0YWRhdGEuJG1ldGFkYXRhLnJlcXVlc3RJZDtcbiAgICB9XG4gICAgbGV0IHRva2VuVXNhZ2U7XG4gICAgaWYgKHJlc3BvbnNlTWV0YWRhdGEudXNhZ2UpIHtcbiAgICAgICAgY29uc3QgaW5wdXRfdG9rZW5zID0gcmVzcG9uc2VNZXRhZGF0YS51c2FnZS5pbnB1dFRva2VucyA/PyAwO1xuICAgICAgICBjb25zdCBvdXRwdXRfdG9rZW5zID0gcmVzcG9uc2VNZXRhZGF0YS51c2FnZS5vdXRwdXRUb2tlbnMgPz8gMDtcbiAgICAgICAgdG9rZW5Vc2FnZSA9IHtcbiAgICAgICAgICAgIGlucHV0X3Rva2VucyxcbiAgICAgICAgICAgIG91dHB1dF90b2tlbnMsXG4gICAgICAgICAgICB0b3RhbF90b2tlbnM6IHJlc3BvbnNlTWV0YWRhdGEudXNhZ2UudG90YWxUb2tlbnMgPz8gaW5wdXRfdG9rZW5zICsgb3V0cHV0X3Rva2VucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuY29udGVudD8ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIFwidGV4dFwiIGluIG1lc3NhZ2UuY29udGVudFswXSAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZS5jb250ZW50WzBdLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZSh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnRbMF0udGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiByZXNwb25zZU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRva2VuVXNhZ2UsXG4gICAgICAgICAgICBpZDogcmVxdWVzdElkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgIG1lc3NhZ2UuY29udGVudC5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJ0b29sVXNlXCIgaW4gYyAmJlxuICAgICAgICAgICAgICAgIGMudG9vbFVzZSAmJlxuICAgICAgICAgICAgICAgIGMudG9vbFVzZS5uYW1lICYmXG4gICAgICAgICAgICAgICAgYy50b29sVXNlLmlucHV0ICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGMudG9vbFVzZS5pbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGMudG9vbFVzZS50b29sVXNlSWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGMudG9vbFVzZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBjLnRvb2xVc2UuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcInRleHRcIiBpbiBjICYmIHR5cGVvZiBjLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goeyB0eXBlOiBcInRleHRcIiwgdGV4dDogYy50ZXh0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJyZWFzb25pbmdDb250ZW50XCIgaW4gYykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChiZWRyb2NrUmVhc29uaW5nQmxvY2tUb0xhbmdjaGFpblJlYXNvbmluZ0Jsb2NrKGMucmVhc29uaW5nQ29udGVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZSh7XG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQgOiBcIlwiLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbENhbGxzLmxlbmd0aCA/IHRvb2xDYWxscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiByZXNwb25zZU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRva2VuVXNhZ2UsXG4gICAgICAgICAgICBpZDogcmVxdWVzdElkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVDb252ZXJzZVN0cmVhbUNvbnRlbnRCbG9ja0RlbHRhKGNvbnRlbnRCbG9ja0RlbHRhKSB7XG4gICAgaWYgKCFjb250ZW50QmxvY2tEZWx0YS5kZWx0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkZWx0YSBmb3VuZCBpbiBjb250ZW50IGJsb2NrLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZW50QmxvY2tEZWx0YS5kZWx0YS50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogY29udGVudEJsb2NrRGVsdGEuZGVsdGEudGV4dCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50QmxvY2tEZWx0YS5kZWx0YS50ZXh0LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50QmxvY2tEZWx0YS5kZWx0YS50b29sVXNlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGVudEJsb2NrRGVsdGEuY29udGVudEJsb2NrSW5kZXg7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY29udGVudEJsb2NrRGVsdGEuZGVsdGEudG9vbFVzZS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50QmxvY2tEZWx0YS5kZWx0YS5yZWFzb25pbmdDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgIGJlZHJvY2tSZWFzb25pbmdEZWx0YVRvTGFuZ2NoYWluUGFydGlhbFJlYXNvbmluZ0Jsb2NrKGNvbnRlbnRCbG9ja0RlbHRhLmRlbHRhLnJlYXNvbmluZ0NvbnRlbnQpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnRlbnQgYmxvY2sgdHlwZShzKTogJHtKU09OLnN0cmluZ2lmeShjb250ZW50QmxvY2tEZWx0YS5kZWx0YSwgbnVsbCwgMil9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ29udmVyc2VTdHJlYW1Db250ZW50QmxvY2tTdGFydChjb250ZW50QmxvY2tTdGFydCkge1xuICAgIGNvbnN0IGluZGV4ID0gY29udGVudEJsb2NrU3RhcnQuY29udGVudEJsb2NrSW5kZXg7XG4gICAgaWYgKGNvbnRlbnRCbG9ja1N0YXJ0LnN0YXJ0Py50b29sVXNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY29udGVudEJsb2NrU3RhcnQuc3RhcnQudG9vbFVzZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnRlbnRCbG9ja1N0YXJ0LnN0YXJ0LnRvb2xVc2UudG9vbFVzZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbnRlbnQgYmxvY2sgc3RhcnQgZXZlbnQuXCIpO1xufVxuZnVuY3Rpb24gaGFuZGxlQ29udmVyc2VTdHJlYW1NZXRhZGF0YShtZXRhZGF0YSwgZXh0cmEpIHtcbiAgICBjb25zdCBpbnB1dFRva2VucyA9IG1ldGFkYXRhLnVzYWdlPy5pbnB1dFRva2VucyA/PyAwO1xuICAgIGNvbnN0IG91dHB1dFRva2VucyA9IG1ldGFkYXRhLnVzYWdlPy5vdXRwdXRUb2tlbnMgPz8gMDtcbiAgICBjb25zdCB1c2FnZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgaW5wdXRfdG9rZW5zOiBpbnB1dFRva2VucyxcbiAgICAgICAgb3V0cHV0X3Rva2Vuczogb3V0cHV0VG9rZW5zLFxuICAgICAgICB0b3RhbF90b2tlbnM6IG1ldGFkYXRhLnVzYWdlPy50b3RhbFRva2VucyA/PyBpbnB1dFRva2VucyArIG91dHB1dFRva2VucyxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtZXNzYWdlOiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGV4dHJhLnN0cmVhbVVzYWdlID8gdXNhZ2VfbWV0YWRhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBrZXkgYXMgcmV0dXJuZWQgZnJvbSB0aGUgQ29udmVyc2UgQVBJXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJlZHJvY2tSZWFzb25pbmdEZWx0YVRvTGFuZ2NoYWluUGFydGlhbFJlYXNvbmluZ0Jsb2NrKHJlYXNvbmluZ0NvbnRlbnQpIHtcbiAgICBjb25zdCB7IHRleHQsIHJlZGFjdGVkQ29udGVudCwgc2lnbmF0dXJlIH0gPSByZWFzb25pbmdDb250ZW50O1xuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdfY29udGVudFwiLFxuICAgICAgICAgICAgcmVhc29uaW5nVGV4dDogeyB0ZXh0IH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nX2NvbnRlbnRcIixcbiAgICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IHsgc2lnbmF0dXJlIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChyZWRhY3RlZENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nX2NvbnRlbnRcIixcbiAgICAgICAgICAgIHJlZGFjdGVkQ29udGVudDogQnVmZmVyLmZyb20ocmVkYWN0ZWRDb250ZW50KS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWFzb25pbmcgY29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGJlZHJvY2tSZWFzb25pbmdCbG9ja1RvTGFuZ2NoYWluUmVhc29uaW5nQmxvY2socmVhc29uaW5nQ29udGVudCkge1xuICAgIGNvbnN0IHsgcmVhc29uaW5nVGV4dCwgcmVkYWN0ZWRDb250ZW50IH0gPSByZWFzb25pbmdDb250ZW50O1xuICAgIGlmIChyZWFzb25pbmdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiByZWFzb25pbmdUZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVkYWN0ZWRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICByZWRhY3RlZENvbnRlbnQ6IEJ1ZmZlci5mcm9tKHJlZGFjdGVkQ29udGVudCkudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVhc29uaW5nIGNvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBsYW5nY2hhaW5SZWFzb25pbmdCbG9ja1RvQmVkcm9ja1JlYXNvbmluZ0Jsb2NrKGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC50eXBlICE9PSBcInJlYXNvbmluZ19jb250ZW50XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWFzb25pbmcgY29udGVudFwiKTtcbiAgICB9XG4gICAgaWYgKFwicmVhc29uaW5nVGV4dFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IGNvbnRlbnQucmVhc29uaW5nVGV4dCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwicmVkYWN0ZWRDb250ZW50XCIgaW4gY29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVkYWN0ZWRDb250ZW50OiBCdWZmZXIuZnJvbShjb250ZW50LnJlZGFjdGVkQ29udGVudCwgXCJiYXNlNjRcIiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVhc29uaW5nIGNvbnRlbnRcIik7XG59XG5mdW5jdGlvbiBjb25jYXRlbmF0ZUxhbmdjaGFpblJlYXNvbmluZ0Jsb2Nrcyhjb250ZW50KSB7XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQmxvY2tzID0gW107XG4gICAgbGV0IGNvbmNhdGVuYXRlZEJsb2NrID0ge307XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChibG9jay50eXBlICE9PSBcInJlYXNvbmluZ19jb250ZW50XCIpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0J3Mgc29tZSBvdGhlciBibG9jayB0eXBlLCBlbmQgdGhlIGN1cnJlbnQgYmxvY2ssIGJ1dCBrZWVwIGl0IHNvIHdlIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29uY2F0ZW5hdGVkQmxvY2spLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MucHVzaChjb25jYXRlbmF0ZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2sgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vbi1yZWRhY3RlZCBibG9ja1xuICAgICAgICBpZiAoXCJyZWFzb25pbmdUZXh0XCIgaW4gYmxvY2sgJiYgdHlwZW9mIGJsb2NrLnJlYXNvbmluZ1RleHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChcInJlZGFjdGVkQ29udGVudFwiIGluIGNvbmNhdGVuYXRlZEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IHR5cGUgb2YgYmxvY2ssIHNvIGVuZCB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2tzLnB1c2goY29uY2F0ZW5hdGVkQmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2NrID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRleHQsIHNpZ25hdHVyZSB9ID0gYmxvY2sucmVhc29uaW5nVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHsgdGV4dDogcHJldlRleHQsIHNpZ25hdHVyZTogcHJldlNpZ25hdHVyZSB9ID0gKFwicmVhc29uaW5nVGV4dFwiIGluIGNvbmNhdGVuYXRlZEJsb2NrXG4gICAgICAgICAgICAgICAgPyBjb25jYXRlbmF0ZWRCbG9jay5yZWFzb25pbmdUZXh0XG4gICAgICAgICAgICAgICAgOiB7fSk7XG4gICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9jayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ19jb250ZW50XCIsXG4gICAgICAgICAgICAgICAgcmVhc29uaW5nVGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAuLi4oY29uY2F0ZW5hdGVkQmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWFzb25pbmdUZXh0ID8/IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByZXZUZXh0ICE9PSB1bmRlZmluZWQgfHwgdGV4dCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgdGV4dDogKHByZXZUZXh0ID8/IFwiXCIpICsgKHRleHQgPz8gXCJcIikgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmV2U2lnbmF0dXJlICE9PSB1bmRlZmluZWQgfHwgc2lnbmF0dXJlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBzaWduYXR1cmU6IChwcmV2U2lnbmF0dXJlID8/IFwiXCIpICsgKHNpZ25hdHVyZSA/PyBcIlwiKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGlmIGEgcGFydGlhbCBibG9jayBjaHVuayBoYXMgYSBzaWduYXR1cmUsIHRoZSBuZXh0IG9uZSB3aWxsIGJlZ2luIGEgbmV3IHJlYXNvbmluZyBibG9jay5cbiAgICAgICAgICAgIC8vIGZ1bGwgYmxvY2tzIGFsd2F5cyBoYXZlIHNpZ25hdHVyZXMsIHNvIHdlIHN0YXJ0IG9uZSBub3csIGFueXdheVxuICAgICAgICAgICAgaWYgKFwic2lnbmF0dXJlXCIgaW4gYmxvY2sucmVhc29uaW5nVGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2Nrcy5wdXNoKGNvbmNhdGVuYXRlZEJsb2NrKTtcbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9jayA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcInJlZGFjdGVkQ29udGVudFwiIGluIGJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoXCJyZWFzb25pbmdUZXh0XCIgaW4gY29uY2F0ZW5hdGVkQmxvY2spIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgdHlwZSBvZiBibG9jaywgc28gZW5kIHRoZSBwcmV2aW91cyBvbmUuIFdlIHNob3VsZCd0IHJlYWxseSBoaXRcbiAgICAgICAgICAgICAgICAvLyB0aGlzLCBhcyB3ZSdsbCBoYXZlIGNyZWF0ZWQgYSBuZXcgYmxvY2sgdXBvbiBlbmNvdW50ZXJpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlIGFib3ZlLCBidXQgYmV0dGVyIHNhZmUgdGhhbiBzb3JyeS5cbiAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MucHVzaChjb25jYXRlbmF0ZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgY29uY2F0ZW5hdGVkQmxvY2sgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcmVkYWN0ZWRDb250ZW50IH0gPSBibG9jaztcbiAgICAgICAgICAgIGNvbnN0IHByZXZSZWRhY3RlZENvbnRlbnQgPSAoXCJyZWRhY3RlZENvbnRlbnRcIiBpbiBjb25jYXRlbmF0ZWRCbG9ja1xuICAgICAgICAgICAgICAgID8gY29uY2F0ZW5hdGVkQmxvY2sucmVkYWN0ZWRDb250ZW50XG4gICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgICAgIGNvbmNhdGVuYXRlZEJsb2NrID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nX2NvbnRlbnRcIixcbiAgICAgICAgICAgICAgICByZWRhY3RlZENvbnRlbnQ6IHByZXZSZWRhY3RlZENvbnRlbnQgKyByZWRhY3RlZENvbnRlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhjb25jYXRlbmF0ZWRCbG9jaykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25jYXRlbmF0ZWRCbG9ja3MucHVzaChjb25jYXRlbmF0ZWRCbG9jayk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRlbmF0ZWRCbG9ja3M7XG59XG5mdW5jdGlvbiBzdXBwb3J0ZWRUb29sQ2hvaWNlVmFsdWVzRm9yTW9kZWwobW9kZWwpIHtcbiAgICBpZiAobW9kZWwuaW5jbHVkZXMoXCJjbGF1ZGUtM1wiKSB8fFxuICAgICAgICBtb2RlbC5pbmNsdWRlcyhcImNsYXVkZS00XCIpIHx8XG4gICAgICAgIG1vZGVsLmluY2x1ZGVzKFwiY2xhdWRlLW9wdXMtNFwiKSB8fFxuICAgICAgICBtb2RlbC5pbmNsdWRlcyhcImNsYXVkZS1zb25uZXQtNFwiKSkge1xuICAgICAgICByZXR1cm4gW1wiYXV0b1wiLCBcImFueVwiLCBcInRvb2xcIl07XG4gICAgfVxuICAgIGlmIChtb2RlbC5pbmNsdWRlcyhcIm1pc3RyYWwtbGFyZ2VcIikpIHtcbiAgICAgICAgcmV0dXJuIFtcImF1dG9cIiwgXCJhbnlcIl07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/common.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/embeddings.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BedrockEmbeddings = void 0;\nconst client_bedrock_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-runtime/dist-es/index.js\");\nconst embeddings_1 = __webpack_require__(/*! @langchain/core/embeddings */ \"(rsc)/./node_modules/@langchain/core/embeddings.cjs\");\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using the Bedrock API.\n * @example\n * ```typescript\n * const embeddings = new BedrockEmbeddings({\n *   region: \"your-aws-region\",\n *   credentials: {\n *     accessKeyId: \"your-access-key-id\",\n *     secretAccessKey: \"your-secret-access-key\",\n *   },\n *   model: \"amazon.titan-embed-text-v1\",\n *   // Configure client options (e.g., custom request handler)\n *   // clientOptions: {\n *   //   requestHandler: myCustomRequestHandler,\n *   // },\n * });\n *\n * // Embed a query and log the result\n * const res = await embeddings.embedQuery(\n *   \"What would be a good company name for a company that makes colorful socks?\"\n * );\n * console.log({ res });\n * ```\n */\nclass BedrockEmbeddings extends embeddings_1.Embeddings {\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clientOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 512\n        });\n        this.model = fields?.model ?? \"amazon.titan-embed-text-v1\";\n        this.clientOptions = fields?.clientOptions;\n        this.client =\n            fields?.client ??\n                new client_bedrock_runtime_1.BedrockRuntimeClient({\n                    ...fields?.clientOptions,\n                    region: fields?.region,\n                    credentials: fields?.credentials,\n                });\n    }\n    /**\n     * Protected method to make a request to the Bedrock API to generate\n     * embeddings. Handles the retry logic and returns the response from the\n     * API.\n     * @param request Request to send to the Bedrock API.\n     * @returns Promise that resolves to the response from the API.\n     */\n    async _embedText(text) {\n        return this.caller.call(async () => {\n            try {\n                // replace newlines, which can negatively affect performance.\n                const cleanedText = text.replace(/\\n/g, \" \");\n                const res = await this.client.send(new client_bedrock_runtime_1.InvokeModelCommand({\n                    modelId: this.model,\n                    body: JSON.stringify({\n                        inputText: cleanedText,\n                    }),\n                    contentType: \"application/json\",\n                    accept: \"application/json\",\n                }));\n                const body = new TextDecoder().decode(res.body);\n                return JSON.parse(body).embedding;\n            }\n            catch (e) {\n                console.error({\n                    error: e,\n                });\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (e instanceof Error) {\n                    throw new Error(`An error occurred while embedding documents with Bedrock: ${e.message}`);\n                }\n                throw new Error(\"An error occurred while embedding documents with Bedrock\");\n            }\n        });\n    }\n    /**\n     * Method that takes a document as input and returns a promise that\n     * resolves to an embedding for the document. It calls the _embedText\n     * method with the document as the input.\n     * @param document Document for which to generate an embedding.\n     * @returns Promise that resolves to an embedding for the input document.\n     */\n    embedQuery(document) {\n        return this.caller.callWithOptions({}, this._embedText.bind(this), document);\n    }\n    /**\n     * Method to generate embeddings for an array of texts. Calls _embedText\n     * method which batches and handles retry logic when calling the AWS Bedrock API.\n     * @param documents Array of texts for which to generate embeddings.\n     * @returns Promise that resolves to a 2D array of embeddings for each input document.\n     */\n    async embedDocuments(documents) {\n        return Promise.all(documents.map((document) => this._embedText(document)));\n    }\n}\nexports.BedrockEmbeddings = BedrockEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9lbWJlZGRpbmdzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsaUNBQWlDLG1CQUFPLENBQUMsOEdBQWlDO0FBQzFFLHFCQUFxQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpR0FBaUcsVUFBVTtBQUMzRztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2Rpc3QvZW1iZWRkaW5ncy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJlZHJvY2tFbWJlZGRpbmdzID0gdm9pZCAwO1xuY29uc3QgY2xpZW50X2JlZHJvY2tfcnVudGltZV8xID0gcmVxdWlyZShcIkBhd3Mtc2RrL2NsaWVudC1iZWRyb2NrLXJ1bnRpbWVcIik7XG5jb25zdCBlbWJlZGRpbmdzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3NcIik7XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgRW1iZWRkaW5ncyBjbGFzcyBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3JcbiAqIGdlbmVyYXRpbmcgZW1iZWRkaW5ncyB1c2luZyB0aGUgQmVkcm9jayBBUEkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZW1iZWRkaW5ncyA9IG5ldyBCZWRyb2NrRW1iZWRkaW5ncyh7XG4gKiAgIHJlZ2lvbjogXCJ5b3VyLWF3cy1yZWdpb25cIixcbiAqICAgY3JlZGVudGlhbHM6IHtcbiAqICAgICBhY2Nlc3NLZXlJZDogXCJ5b3VyLWFjY2Vzcy1rZXktaWRcIixcbiAqICAgICBzZWNyZXRBY2Nlc3NLZXk6IFwieW91ci1zZWNyZXQtYWNjZXNzLWtleVwiLFxuICogICB9LFxuICogICBtb2RlbDogXCJhbWF6b24udGl0YW4tZW1iZWQtdGV4dC12MVwiLFxuICogICAvLyBDb25maWd1cmUgY2xpZW50IG9wdGlvbnMgKGUuZy4sIGN1c3RvbSByZXF1ZXN0IGhhbmRsZXIpXG4gKiAgIC8vIGNsaWVudE9wdGlvbnM6IHtcbiAqICAgLy8gICByZXF1ZXN0SGFuZGxlcjogbXlDdXN0b21SZXF1ZXN0SGFuZGxlcixcbiAqICAgLy8gfSxcbiAqIH0pO1xuICpcbiAqIC8vIEVtYmVkIGEgcXVlcnkgYW5kIGxvZyB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXMgPSBhd2FpdCBlbWJlZGRpbmdzLmVtYmVkUXVlcnkoXG4gKiAgIFwiV2hhdCB3b3VsZCBiZSBhIGdvb2QgY29tcGFueSBuYW1lIGZvciBhIGNvbXBhbnkgdGhhdCBtYWtlcyBjb2xvcmZ1bCBzb2Nrcz9cIlxuICogKTtcbiAqIGNvbnNvbGUubG9nKHsgcmVzIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIEJlZHJvY2tFbWJlZGRpbmdzIGV4dGVuZHMgZW1iZWRkaW5nc18xLkVtYmVkZGluZ3Mge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMgPz8ge30pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50T3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUxMlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZpZWxkcz8ubW9kZWwgPz8gXCJhbWF6b24udGl0YW4tZW1iZWQtdGV4dC12MVwiO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMgPSBmaWVsZHM/LmNsaWVudE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2xpZW50ID1cbiAgICAgICAgICAgIGZpZWxkcz8uY2xpZW50ID8/XG4gICAgICAgICAgICAgICAgbmV3IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMS5CZWRyb2NrUnVudGltZUNsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcz8uY2xpZW50T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiBmaWVsZHM/LnJlZ2lvbixcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IGZpZWxkcz8uY3JlZGVudGlhbHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3RlY3RlZCBtZXRob2QgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIEJlZHJvY2sgQVBJIHRvIGdlbmVyYXRlXG4gICAgICogZW1iZWRkaW5ncy4gSGFuZGxlcyB0aGUgcmV0cnkgbG9naWMgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGZyb20gdGhlXG4gICAgICogQVBJLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFJlcXVlc3QgdG8gc2VuZCB0byB0aGUgQmVkcm9jayBBUEkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgYXN5bmMgX2VtYmVkVGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBuZXdsaW5lcywgd2hpY2ggY2FuIG5lZ2F0aXZlbHkgYWZmZWN0IHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LnNlbmQobmV3IGNsaWVudF9iZWRyb2NrX3J1bnRpbWVfMS5JbnZva2VNb2RlbENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFRleHQ6IGNsZWFuZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHJlcy5ib2R5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KS5lbWJlZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGVtYmVkZGluZyBkb2N1bWVudHMgd2l0aCBCZWRyb2NrOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZW1iZWRkaW5nIGRvY3VtZW50cyB3aXRoIEJlZHJvY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCB0YWtlcyBhIGRvY3VtZW50IGFzIGlucHV0IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgdG8gYW4gZW1iZWRkaW5nIGZvciB0aGUgZG9jdW1lbnQuIEl0IGNhbGxzIHRoZSBfZW1iZWRUZXh0XG4gICAgICogbWV0aG9kIHdpdGggdGhlIGRvY3VtZW50IGFzIHRoZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgRG9jdW1lbnQgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIGFuIGVtYmVkZGluZy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gZW1iZWRkaW5nIGZvciB0aGUgaW5wdXQgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZW1iZWRRdWVyeShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsZXIuY2FsbFdpdGhPcHRpb25zKHt9LCB0aGlzLl9lbWJlZFRleHQuYmluZCh0aGlzKSwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgYW4gYXJyYXkgb2YgdGV4dHMuIENhbGxzIF9lbWJlZFRleHRcbiAgICAgKiBtZXRob2Qgd2hpY2ggYmF0Y2hlcyBhbmQgaGFuZGxlcyByZXRyeSBsb2dpYyB3aGVuIGNhbGxpbmcgdGhlIEFXUyBCZWRyb2NrIEFQSS5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIEFycmF5IG9mIHRleHRzIGZvciB3aGljaCB0byBnZW5lcmF0ZSBlbWJlZGRpbmdzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIDJEIGFycmF5IG9mIGVtYmVkZGluZ3MgZm9yIGVhY2ggaW5wdXQgZG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWREb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChkb2N1bWVudHMubWFwKChkb2N1bWVudCkgPT4gdGhpcy5fZW1iZWRUZXh0KGRvY3VtZW50KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmVkcm9ja0VtYmVkZGluZ3MgPSBCZWRyb2NrRW1iZWRkaW5ncztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/index.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/index.cjs ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./retrievers/index.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/embeddings.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1GQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsdUVBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDZGQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsaUZBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoYXRfbW9kZWxzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2luZGV4LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW1iZWRkaW5ncy5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmazonKnowledgeBaseRetriever = void 0;\nconst client_bedrock_agent_runtime_1 = __webpack_require__(/*! @aws-sdk/client-bedrock-agent-runtime */ \"(rsc)/./node_modules/@aws-sdk/client-bedrock-agent-runtime/dist-es/index.js\");\nconst retrievers_1 = __webpack_require__(/*! @langchain/core/retrievers */ \"(rsc)/./node_modules/@langchain/core/retrievers.cjs\");\n/**\n * Class for interacting with Amazon Bedrock Knowledge Bases, a RAG workflow oriented service\n * provided by AWS. Extends the BaseRetriever class.\n * @example\n * ```typescript\n * const retriever = new AmazonKnowledgeBaseRetriever({\n *   topK: 10,\n *   knowledgeBaseId: \"YOUR_KNOWLEDGE_BASE_ID\",\n *   region: \"us-east-2\",\n *   clientOptions: {\n *     credentials: {\n *       accessKeyId: \"YOUR_ACCESS_KEY_ID\",\n *       secretAccessKey: \"YOUR_SECRET_ACCESS_KEY\",\n *     },\n *   },\n * });\n *\n * const docs = await retriever.getRelevantDocuments(\"How are clouds formed?\");\n * ```\n */\nclass AmazonKnowledgeBaseRetriever extends retrievers_1.BaseRetriever {\n    static lc_name() {\n        return \"AmazonKnowledgeBaseRetriever\";\n    }\n    constructor({ knowledgeBaseId, topK = 10, clientOptions, region, filter, overrideSearchType, }) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"retrievers\", \"amazon_bedrock_knowledge_base\"]\n        });\n        Object.defineProperty(this, \"knowledgeBaseId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"bedrockAgentRuntimeClient\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"overrideSearchType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.topK = topK;\n        this.filter = filter;\n        this.overrideSearchType = overrideSearchType;\n        this.bedrockAgentRuntimeClient = new client_bedrock_agent_runtime_1.BedrockAgentRuntimeClient({\n            region,\n            ...clientOptions,\n        });\n        this.knowledgeBaseId = knowledgeBaseId;\n    }\n    /**\n     * Cleans the result text by replacing sequences of whitespace with a\n     * single space and removing ellipses.\n     * @param resText The result text to clean.\n     * @returns The cleaned result text.\n     */\n    cleanResult(resText) {\n        const res = resText.replace(/\\s+/g, \" \").replace(/\\.\\.\\./g, \"\");\n        return res;\n    }\n    async queryKnowledgeBase(query, topK, filter, overrideSearchType) {\n        const retrieveCommand = new client_bedrock_agent_runtime_1.RetrieveCommand({\n            knowledgeBaseId: this.knowledgeBaseId,\n            retrievalQuery: {\n                text: query,\n            },\n            retrievalConfiguration: {\n                vectorSearchConfiguration: {\n                    numberOfResults: topK,\n                    overrideSearchType,\n                    filter,\n                },\n            },\n        });\n        const retrieveResponse = await this.bedrockAgentRuntimeClient.send(retrieveCommand);\n        return (retrieveResponse.retrievalResults?.map((result) => {\n            let source;\n            switch (result.location?.type) {\n                case \"CONFLUENCE\":\n                    source = result.location?.confluenceLocation?.url;\n                    break;\n                case \"S3\":\n                    source = result.location?.s3Location?.uri;\n                    break;\n                case \"SALESFORCE\":\n                    source = result.location?.salesforceLocation?.url;\n                    break;\n                case \"SHAREPOINT\":\n                    source = result.location?.sharePointLocation?.url;\n                    break;\n                case \"WEB\":\n                    source = result.location?.webLocation?.url;\n                    break;\n                default:\n                    source = result.location?.s3Location?.uri;\n                    break;\n            }\n            return {\n                pageContent: this.cleanResult(result.content?.text || \"\"),\n                metadata: {\n                    source,\n                    score: result.score,\n                    ...result.metadata,\n                },\n            };\n        }) ?? []);\n    }\n    async _getRelevantDocuments(query) {\n        const docs = await this.queryKnowledgeBase(query, this.topK, this.filter, this.overrideSearchType);\n        return docs;\n    }\n}\nexports.AmazonKnowledgeBaseRetriever = AmazonKnowledgeBaseRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2JlZHJvY2suY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQztBQUNwQyx1Q0FBdUMsbUJBQU8sQ0FBQywwSEFBdUM7QUFDdEYscUJBQXFCLG1CQUFPLENBQUMsdUZBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRkFBZ0Y7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2Rpc3QvcmV0cmlldmVycy9iZWRyb2NrLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1hem9uS25vd2xlZGdlQmFzZVJldHJpZXZlciA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF9iZWRyb2NrX2FnZW50X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJAYXdzLXNkay9jbGllbnQtYmVkcm9jay1hZ2VudC1ydW50aW1lXCIpO1xuY29uc3QgcmV0cmlldmVyc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9yZXRyaWV2ZXJzXCIpO1xuLyoqXG4gKiBDbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBBbWF6b24gQmVkcm9jayBLbm93bGVkZ2UgQmFzZXMsIGEgUkFHIHdvcmtmbG93IG9yaWVudGVkIHNlcnZpY2VcbiAqIHByb3ZpZGVkIGJ5IEFXUy4gRXh0ZW5kcyB0aGUgQmFzZVJldHJpZXZlciBjbGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCByZXRyaWV2ZXIgPSBuZXcgQW1hem9uS25vd2xlZGdlQmFzZVJldHJpZXZlcih7XG4gKiAgIHRvcEs6IDEwLFxuICogICBrbm93bGVkZ2VCYXNlSWQ6IFwiWU9VUl9LTk9XTEVER0VfQkFTRV9JRFwiLFxuICogICByZWdpb246IFwidXMtZWFzdC0yXCIsXG4gKiAgIGNsaWVudE9wdGlvbnM6IHtcbiAqICAgICBjcmVkZW50aWFsczoge1xuICogICAgICAgYWNjZXNzS2V5SWQ6IFwiWU9VUl9BQ0NFU1NfS0VZX0lEXCIsXG4gKiAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IFwiWU9VUl9TRUNSRVRfQUNDRVNTX0tFWVwiLFxuICogICAgIH0sXG4gKiAgIH0sXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBkb2NzID0gYXdhaXQgcmV0cmlldmVyLmdldFJlbGV2YW50RG9jdW1lbnRzKFwiSG93IGFyZSBjbG91ZHMgZm9ybWVkP1wiKTtcbiAqIGBgYFxuICovXG5jbGFzcyBBbWF6b25Lbm93bGVkZ2VCYXNlUmV0cmlldmVyIGV4dGVuZHMgcmV0cmlldmVyc18xLkJhc2VSZXRyaWV2ZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJBbWF6b25Lbm93bGVkZ2VCYXNlUmV0cmlldmVyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsga25vd2xlZGdlQmFzZUlkLCB0b3BLID0gMTAsIGNsaWVudE9wdGlvbnMsIHJlZ2lvbiwgZmlsdGVyLCBvdmVycmlkZVNlYXJjaFR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJyZXRyaWV2ZXJzXCIsIFwiYW1hem9uX2JlZHJvY2tfa25vd2xlZGdlX2Jhc2VcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtub3dsZWRnZUJhc2VJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BLXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJlZHJvY2tBZ2VudFJ1bnRpbWVDbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm92ZXJyaWRlU2VhcmNoVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvcEsgPSB0b3BLO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5vdmVycmlkZVNlYXJjaFR5cGUgPSBvdmVycmlkZVNlYXJjaFR5cGU7XG4gICAgICAgIHRoaXMuYmVkcm9ja0FnZW50UnVudGltZUNsaWVudCA9IG5ldyBjbGllbnRfYmVkcm9ja19hZ2VudF9ydW50aW1lXzEuQmVkcm9ja0FnZW50UnVudGltZUNsaWVudCh7XG4gICAgICAgICAgICByZWdpb24sXG4gICAgICAgICAgICAuLi5jbGllbnRPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rbm93bGVkZ2VCYXNlSWQgPSBrbm93bGVkZ2VCYXNlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB0aGUgcmVzdWx0IHRleHQgYnkgcmVwbGFjaW5nIHNlcXVlbmNlcyBvZiB3aGl0ZXNwYWNlIHdpdGggYVxuICAgICAqIHNpbmdsZSBzcGFjZSBhbmQgcmVtb3ZpbmcgZWxsaXBzZXMuXG4gICAgICogQHBhcmFtIHJlc1RleHQgVGhlIHJlc3VsdCB0ZXh0IHRvIGNsZWFuLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGVhbmVkIHJlc3VsdCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuUmVzdWx0KHJlc1RleHQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVzVGV4dC5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKS5yZXBsYWNlKC9cXC5cXC5cXC4vZywgXCJcIik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGFzeW5jIHF1ZXJ5S25vd2xlZGdlQmFzZShxdWVyeSwgdG9wSywgZmlsdGVyLCBvdmVycmlkZVNlYXJjaFR5cGUpIHtcbiAgICAgICAgY29uc3QgcmV0cmlldmVDb21tYW5kID0gbmV3IGNsaWVudF9iZWRyb2NrX2FnZW50X3J1bnRpbWVfMS5SZXRyaWV2ZUNvbW1hbmQoe1xuICAgICAgICAgICAga25vd2xlZGdlQmFzZUlkOiB0aGlzLmtub3dsZWRnZUJhc2VJZCxcbiAgICAgICAgICAgIHJldHJpZXZhbFF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgdGV4dDogcXVlcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cmlldmFsQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIHZlY3RvclNlYXJjaENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZSZXN1bHRzOiB0b3BLLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZVNlYXJjaFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldHJpZXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJlZHJvY2tBZ2VudFJ1bnRpbWVDbGllbnQuc2VuZChyZXRyaWV2ZUNvbW1hbmQpO1xuICAgICAgICByZXR1cm4gKHJldHJpZXZlUmVzcG9uc2UucmV0cmlldmFsUmVzdWx0cz8ubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5sb2NhdGlvbj8udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDT05GTFVFTkNFXCI6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdC5sb2NhdGlvbj8uY29uZmx1ZW5jZUxvY2F0aW9uPy51cmw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTM1wiOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQubG9jYXRpb24/LnMzTG9jYXRpb24/LnVyaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNBTEVTRk9SQ0VcIjpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0LmxvY2F0aW9uPy5zYWxlc2ZvcmNlTG9jYXRpb24/LnVybDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlNIQVJFUE9JTlRcIjpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0LmxvY2F0aW9uPy5zaGFyZVBvaW50TG9jYXRpb24/LnVybDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIldFQlwiOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQubG9jYXRpb24/LndlYkxvY2F0aW9uPy51cmw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdC5sb2NhdGlvbj8uczNMb2NhdGlvbj8udXJpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQ6IHRoaXMuY2xlYW5SZXN1bHQocmVzdWx0LmNvbnRlbnQ/LnRleHQgfHwgXCJcIiksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzY29yZTogcmVzdWx0LnNjb3JlLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pID8/IFtdKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlbGV2YW50RG9jdW1lbnRzKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBhd2FpdCB0aGlzLnF1ZXJ5S25vd2xlZGdlQmFzZShxdWVyeSwgdGhpcy50b3BLLCB0aGlzLmZpbHRlciwgdGhpcy5vdmVycmlkZVNlYXJjaFR5cGUpO1xuICAgICAgICByZXR1cm4gZG9jcztcbiAgICB9XG59XG5leHBvcnRzLkFtYXpvbktub3dsZWRnZUJhc2VSZXRyaWV2ZXIgPSBBbWF6b25Lbm93bGVkZ2VCYXNlUmV0cmlldmVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./bedrock.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/bedrock.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./kendra.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsc0ZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLG9GQUFjIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2F3cy9kaXN0L3JldHJpZXZlcnMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmVkcm9jay5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tlbmRyYS5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/retrievers/kendra.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmazonKendraRetriever = void 0;\nconst client_kendra_1 = __webpack_require__(/*! @aws-sdk/client-kendra */ \"(rsc)/./node_modules/@aws-sdk/client-kendra/dist-es/index.js\");\nconst retrievers_1 = __webpack_require__(/*! @langchain/core/retrievers */ \"(rsc)/./node_modules/@langchain/core/retrievers.cjs\");\nconst documents_1 = __webpack_require__(/*! @langchain/core/documents */ \"(rsc)/./node_modules/@langchain/core/documents.cjs\");\n/**\n * Class for interacting with Amazon Kendra, an intelligent search service\n * provided by AWS. Extends the BaseRetriever class.\n * @example\n * ```typescript\n * const retriever = new AmazonKendraRetriever({\n *   topK: 10,\n *   indexId: \"YOUR_INDEX_ID\",\n *   region: \"us-east-2\",\n *   clientOptions: {\n *     credentials: {\n *       accessKeyId: \"YOUR_ACCESS_KEY_ID\",\n *       secretAccessKey: \"YOUR_SECRET_ACCESS_KEY\",\n *     },\n *   },\n * });\n *\n * const docs = await retriever.getRelevantDocuments(\"How are clouds formed?\");\n * ```\n */\nclass AmazonKendraRetriever extends retrievers_1.BaseRetriever {\n    static lc_name() {\n        return \"AmazonKendraRetriever\";\n    }\n    constructor({ indexId, topK = 10, clientOptions, attributeFilter, region, }) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"retrievers\", \"amazon_kendra\"]\n        });\n        Object.defineProperty(this, \"indexId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kendraClient\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"attributeFilter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!region) {\n            throw new Error(\"Please pass regionName field to the constructor!\");\n        }\n        if (!indexId) {\n            throw new Error(\"Please pass Kendra Index Id to the constructor\");\n        }\n        this.topK = topK;\n        this.kendraClient = new client_kendra_1.KendraClient({\n            region,\n            ...clientOptions,\n        });\n        this.attributeFilter = attributeFilter;\n        this.indexId = indexId;\n    }\n    // A method to combine title and excerpt into a single string.\n    /**\n     * Combines title and excerpt into a single string.\n     * @param title The title of the document.\n     * @param excerpt An excerpt from the document.\n     * @returns A single string combining the title and excerpt.\n     */\n    combineText(title, excerpt) {\n        let text = \"\";\n        if (title) {\n            text += `Document Title: ${title}\\n`;\n        }\n        if (excerpt) {\n            text += `Document Excerpt: \\n${excerpt}\\n`;\n        }\n        return text;\n    }\n    // A method to clean the result text by replacing sequences of whitespace with a single space and removing ellipses.\n    /**\n     * Cleans the result text by replacing sequences of whitespace with a\n     * single space and removing ellipses.\n     * @param resText The result text to clean.\n     * @returns The cleaned result text.\n     */\n    cleanResult(resText) {\n        const res = resText.replace(/\\s+/g, \" \").replace(/\\.\\.\\./g, \"\");\n        return res;\n    }\n    // A method to extract the attribute value from a DocumentAttributeValue object.\n    /**\n     * Extracts the attribute value from a DocumentAttributeValue object.\n     * @param value The DocumentAttributeValue object to extract the value from.\n     * @returns The extracted attribute value.\n     */\n    getDocAttributeValue(value) {\n        if (value.DateValue) {\n            return value.DateValue;\n        }\n        if (value.LongValue) {\n            return value.LongValue;\n        }\n        if (value.StringListValue) {\n            return value.StringListValue;\n        }\n        if (value.StringValue) {\n            return value.StringValue;\n        }\n        return \"\";\n    }\n    // A method to extract the attribute key-value pairs from an array of DocumentAttribute objects.\n    /**\n     * Extracts the attribute key-value pairs from an array of\n     * DocumentAttribute objects.\n     * @param documentAttributes The array of DocumentAttribute objects to extract the key-value pairs from.\n     * @returns An object containing the extracted attribute key-value pairs.\n     */\n    getDocAttributes(documentAttributes) {\n        const attributes = {};\n        if (documentAttributes) {\n            for (const attr of documentAttributes) {\n                if (attr.Key && attr.Value) {\n                    attributes[attr.Key] = this.getDocAttributeValue(attr.Value);\n                }\n            }\n        }\n        return attributes;\n    }\n    // A method to convert a RetrieveResultItem object into a Document object.\n    /**\n     * Converts a RetrieveResultItem object into a Document object.\n     * @param item The RetrieveResultItem object to convert.\n     * @returns A Document object.\n     */\n    convertRetrieverItem(item) {\n        const title = item.DocumentTitle || \"\";\n        const excerpt = item.Content ? this.cleanResult(item.Content) : \"\";\n        const pageContent = this.combineText(title, excerpt);\n        const source = item.DocumentURI;\n        const attributes = this.getDocAttributes(item.DocumentAttributes);\n        const metadata = {\n            source,\n            title,\n            excerpt,\n            document_attributes: attributes,\n        };\n        return new documents_1.Document({ pageContent, metadata });\n    }\n    // A method to extract the top-k documents from a RetrieveCommandOutput object.\n    /**\n     * Extracts the top-k documents from a RetrieveCommandOutput object.\n     * @param response The RetrieveCommandOutput object to extract the documents from.\n     * @param pageSize The number of documents to extract.\n     * @returns An array of Document objects.\n     */\n    getRetrieverDocs(response, pageSize) {\n        if (!response.ResultItems)\n            return [];\n        const { length } = response.ResultItems;\n        const count = length < pageSize ? length : pageSize;\n        return response.ResultItems.slice(0, count).map((item) => this.convertRetrieverItem(item));\n    }\n    // A method to extract the excerpt text from a QueryResultItem object.\n    /**\n     * Extracts the excerpt text from a QueryResultItem object.\n     * @param item The QueryResultItem object to extract the excerpt text from.\n     * @returns The extracted excerpt text.\n     */\n    getQueryItemExcerpt(item) {\n        if (item.AdditionalAttributes &&\n            item.AdditionalAttributes.length &&\n            item.AdditionalAttributes[0].Key === \"AnswerText\") {\n            if (!item.AdditionalAttributes) {\n                return \"\";\n            }\n            if (!item.AdditionalAttributes[0]) {\n                return \"\";\n            }\n            return this.cleanResult(item.AdditionalAttributes[0].Value?.TextWithHighlightsValue?.Text || \"\");\n        }\n        else if (item.DocumentExcerpt) {\n            return this.cleanResult(item.DocumentExcerpt.Text || \"\");\n        }\n        else {\n            return \"\";\n        }\n    }\n    // A method to convert a QueryResultItem object into a Document object.\n    /**\n     * Converts a QueryResultItem object into a Document object.\n     * @param item The QueryResultItem object to convert.\n     * @returns A Document object.\n     */\n    convertQueryItem(item) {\n        const title = item.DocumentTitle?.Text || \"\";\n        const excerpt = this.getQueryItemExcerpt(item);\n        const pageContent = this.combineText(title, excerpt);\n        const source = item.DocumentURI;\n        const attributes = this.getDocAttributes(item.DocumentAttributes);\n        const metadata = {\n            source,\n            title,\n            excerpt,\n            document_attributes: attributes,\n        };\n        return new documents_1.Document({ pageContent, metadata });\n    }\n    // A method to extract the top-k documents from a QueryCommandOutput object.\n    /**\n     * Extracts the top-k documents from a QueryCommandOutput object.\n     * @param response The QueryCommandOutput object to extract the documents from.\n     * @param pageSize The number of documents to extract.\n     * @returns An array of Document objects.\n     */\n    getQueryDocs(response, pageSize) {\n        if (!response.ResultItems)\n            return [];\n        const { length } = response.ResultItems;\n        const count = length < pageSize ? length : pageSize;\n        return response.ResultItems.slice(0, count).map((item) => this.convertQueryItem(item));\n    }\n    // A method to send a retrieve or query request to Kendra and return the top-k documents.\n    /**\n     * Sends a retrieve or query request to Kendra and returns the top-k\n     * documents.\n     * @param query The query to send to Kendra.\n     * @param topK The number of top documents to return.\n     * @param attributeFilter Optional filter to apply when retrieving documents.\n     * @returns A Promise that resolves to an array of Document objects.\n     */\n    async queryKendra(query, topK, attributeFilter) {\n        const retrieveCommand = new client_kendra_1.RetrieveCommand({\n            IndexId: this.indexId,\n            QueryText: query,\n            PageSize: topK,\n            AttributeFilter: attributeFilter,\n        });\n        const retrieveResponse = await this.kendraClient.send(retrieveCommand);\n        const retriveLength = retrieveResponse.ResultItems?.length;\n        if (retriveLength === 0) {\n            // Retrieve API returned 0 results, call query API\n            const queryCommand = new client_kendra_1.QueryCommand({\n                IndexId: this.indexId,\n                QueryText: query,\n                PageSize: topK,\n                AttributeFilter: attributeFilter,\n            });\n            const queryResponse = await this.kendraClient.send(queryCommand);\n            return this.getQueryDocs(queryResponse, this.topK);\n        }\n        else {\n            return this.getRetrieverDocs(retrieveResponse, this.topK);\n        }\n    }\n    async _getRelevantDocuments(query) {\n        const docs = await this.queryKendra(query, this.topK, this.attributeFilter);\n        return docs;\n    }\n}\nexports.AmazonKendraRetriever = AmazonKendraRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC9yZXRyaWV2ZXJzL2tlbmRyYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLHdCQUF3QixtQkFBTyxDQUFDLDRGQUF3QjtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBNEI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMscUZBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBNkQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2Rpc3QvcmV0cmlldmVycy9rZW5kcmEuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbWF6b25LZW5kcmFSZXRyaWV2ZXIgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfa2VuZHJhXzEgPSByZXF1aXJlKFwiQGF3cy1zZGsvY2xpZW50LWtlbmRyYVwiKTtcbmNvbnN0IHJldHJpZXZlcnNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvcmV0cmlldmVyc1wiKTtcbmNvbnN0IGRvY3VtZW50c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9kb2N1bWVudHNcIik7XG4vKipcbiAqIENsYXNzIGZvciBpbnRlcmFjdGluZyB3aXRoIEFtYXpvbiBLZW5kcmEsIGFuIGludGVsbGlnZW50IHNlYXJjaCBzZXJ2aWNlXG4gKiBwcm92aWRlZCBieSBBV1MuIEV4dGVuZHMgdGhlIEJhc2VSZXRyaWV2ZXIgY2xhc3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcmV0cmlldmVyID0gbmV3IEFtYXpvbktlbmRyYVJldHJpZXZlcih7XG4gKiAgIHRvcEs6IDEwLFxuICogICBpbmRleElkOiBcIllPVVJfSU5ERVhfSURcIixcbiAqICAgcmVnaW9uOiBcInVzLWVhc3QtMlwiLFxuICogICBjbGllbnRPcHRpb25zOiB7XG4gKiAgICAgY3JlZGVudGlhbHM6IHtcbiAqICAgICAgIGFjY2Vzc0tleUlkOiBcIllPVVJfQUNDRVNTX0tFWV9JRFwiLFxuICogICAgICAgc2VjcmV0QWNjZXNzS2V5OiBcIllPVVJfU0VDUkVUX0FDQ0VTU19LRVlcIixcbiAqICAgICB9LFxuICogICB9LFxuICogfSk7XG4gKlxuICogY29uc3QgZG9jcyA9IGF3YWl0IHJldHJpZXZlci5nZXRSZWxldmFudERvY3VtZW50cyhcIkhvdyBhcmUgY2xvdWRzIGZvcm1lZD9cIik7XG4gKiBgYGBcbiAqL1xuY2xhc3MgQW1hem9uS2VuZHJhUmV0cmlldmVyIGV4dGVuZHMgcmV0cmlldmVyc18xLkJhc2VSZXRyaWV2ZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJBbWF6b25LZW5kcmFSZXRyaWV2ZXJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBpbmRleElkLCB0b3BLID0gMTAsIGNsaWVudE9wdGlvbnMsIGF0dHJpYnV0ZUZpbHRlciwgcmVnaW9uLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwicmV0cmlldmVyc1wiLCBcImFtYXpvbl9rZW5kcmFcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZGV4SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wS1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZW5kcmFDbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXR0cmlidXRlRmlsdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcGFzcyByZWdpb25OYW1lIGZpZWxkIHRvIHRoZSBjb25zdHJ1Y3RvciFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmRleElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcGFzcyBLZW5kcmEgSW5kZXggSWQgdG8gdGhlIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wSyA9IHRvcEs7XG4gICAgICAgIHRoaXMua2VuZHJhQ2xpZW50ID0gbmV3IGNsaWVudF9rZW5kcmFfMS5LZW5kcmFDbGllbnQoe1xuICAgICAgICAgICAgcmVnaW9uLFxuICAgICAgICAgICAgLi4uY2xpZW50T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlRmlsdGVyID0gYXR0cmlidXRlRmlsdGVyO1xuICAgICAgICB0aGlzLmluZGV4SWQgPSBpbmRleElkO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBjb21iaW5lIHRpdGxlIGFuZCBleGNlcnB0IGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHRpdGxlIGFuZCBleGNlcnB0IGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgdGl0bGUgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBleGNlcnB0IEFuIGV4Y2VycHQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgQSBzaW5nbGUgc3RyaW5nIGNvbWJpbmluZyB0aGUgdGl0bGUgYW5kIGV4Y2VycHQuXG4gICAgICovXG4gICAgY29tYmluZVRleHQodGl0bGUsIGV4Y2VycHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgIHRleHQgKz0gYERvY3VtZW50IFRpdGxlOiAke3RpdGxlfVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2VycHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gYERvY3VtZW50IEV4Y2VycHQ6IFxcbiR7ZXhjZXJwdH1cXG5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBjbGVhbiB0aGUgcmVzdWx0IHRleHQgYnkgcmVwbGFjaW5nIHNlcXVlbmNlcyBvZiB3aGl0ZXNwYWNlIHdpdGggYSBzaW5nbGUgc3BhY2UgYW5kIHJlbW92aW5nIGVsbGlwc2VzLlxuICAgIC8qKlxuICAgICAqIENsZWFucyB0aGUgcmVzdWx0IHRleHQgYnkgcmVwbGFjaW5nIHNlcXVlbmNlcyBvZiB3aGl0ZXNwYWNlIHdpdGggYVxuICAgICAqIHNpbmdsZSBzcGFjZSBhbmQgcmVtb3ZpbmcgZWxsaXBzZXMuXG4gICAgICogQHBhcmFtIHJlc1RleHQgVGhlIHJlc3VsdCB0ZXh0IHRvIGNsZWFuLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGVhbmVkIHJlc3VsdCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFuUmVzdWx0KHJlc1RleHQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVzVGV4dC5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKS5yZXBsYWNlKC9cXC5cXC5cXC4vZywgXCJcIik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vIEEgbWV0aG9kIHRvIGV4dHJhY3QgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGEgRG9jdW1lbnRBdHRyaWJ1dGVWYWx1ZSBvYmplY3QuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGEgRG9jdW1lbnRBdHRyaWJ1dGVWYWx1ZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBEb2N1bWVudEF0dHJpYnV0ZVZhbHVlIG9iamVjdCB0byBleHRyYWN0IHRoZSB2YWx1ZSBmcm9tLlxuICAgICAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldERvY0F0dHJpYnV0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5EYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5EYXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLkxvbmdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLkxvbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuU3RyaW5nTGlzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuU3RyaW5nTGlzdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLlN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBleHRyYWN0IHRoZSBhdHRyaWJ1dGUga2V5LXZhbHVlIHBhaXJzIGZyb20gYW4gYXJyYXkgb2YgRG9jdW1lbnRBdHRyaWJ1dGUgb2JqZWN0cy5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgYXR0cmlidXRlIGtleS12YWx1ZSBwYWlycyBmcm9tIGFuIGFycmF5IG9mXG4gICAgICogRG9jdW1lbnRBdHRyaWJ1dGUgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRBdHRyaWJ1dGVzIFRoZSBhcnJheSBvZiBEb2N1bWVudEF0dHJpYnV0ZSBvYmplY3RzIHRvIGV4dHJhY3QgdGhlIGtleS12YWx1ZSBwYWlycyBmcm9tLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBleHRyYWN0ZWQgYXR0cmlidXRlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKi9cbiAgICBnZXREb2NBdHRyaWJ1dGVzKGRvY3VtZW50QXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChkb2N1bWVudEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBkb2N1bWVudEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5LZXkgJiYgYXR0ci5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHIuS2V5XSA9IHRoaXMuZ2V0RG9jQXR0cmlidXRlVmFsdWUoYXR0ci5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBjb252ZXJ0IGEgUmV0cmlldmVSZXN1bHRJdGVtIG9iamVjdCBpbnRvIGEgRG9jdW1lbnQgb2JqZWN0LlxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUmV0cmlldmVSZXN1bHRJdGVtIG9iamVjdCBpbnRvIGEgRG9jdW1lbnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBSZXRyaWV2ZVJlc3VsdEl0ZW0gb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMgQSBEb2N1bWVudCBvYmplY3QuXG4gICAgICovXG4gICAgY29udmVydFJldHJpZXZlckl0ZW0oaXRlbSkge1xuICAgICAgICBjb25zdCB0aXRsZSA9IGl0ZW0uRG9jdW1lbnRUaXRsZSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBleGNlcnB0ID0gaXRlbS5Db250ZW50ID8gdGhpcy5jbGVhblJlc3VsdChpdGVtLkNvbnRlbnQpIDogXCJcIjtcbiAgICAgICAgY29uc3QgcGFnZUNvbnRlbnQgPSB0aGlzLmNvbWJpbmVUZXh0KHRpdGxlLCBleGNlcnB0KTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gaXRlbS5Eb2N1bWVudFVSSTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuZ2V0RG9jQXR0cmlidXRlcyhpdGVtLkRvY3VtZW50QXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBleGNlcnB0LFxuICAgICAgICAgICAgZG9jdW1lbnRfYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBkb2N1bWVudHNfMS5Eb2N1bWVudCh7IHBhZ2VDb250ZW50LCBtZXRhZGF0YSB9KTtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gZXh0cmFjdCB0aGUgdG9wLWsgZG9jdW1lbnRzIGZyb20gYSBSZXRyaWV2ZUNvbW1hbmRPdXRwdXQgb2JqZWN0LlxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB0b3AtayBkb2N1bWVudHMgZnJvbSBhIFJldHJpZXZlQ29tbWFuZE91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIFRoZSBSZXRyaWV2ZUNvbW1hbmRPdXRwdXQgb2JqZWN0IHRvIGV4dHJhY3QgdGhlIGRvY3VtZW50cyBmcm9tLlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0byBleHRyYWN0LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIERvY3VtZW50IG9iamVjdHMuXG4gICAgICovXG4gICAgZ2V0UmV0cmlldmVyRG9jcyhyZXNwb25zZSwgcGFnZVNpemUpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5SZXN1bHRJdGVtcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHJlc3BvbnNlLlJlc3VsdEl0ZW1zO1xuICAgICAgICBjb25zdCBjb3VudCA9IGxlbmd0aCA8IHBhZ2VTaXplID8gbGVuZ3RoIDogcGFnZVNpemU7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5SZXN1bHRJdGVtcy5zbGljZSgwLCBjb3VudCkubWFwKChpdGVtKSA9PiB0aGlzLmNvbnZlcnRSZXRyaWV2ZXJJdGVtKGl0ZW0pKTtcbiAgICB9XG4gICAgLy8gQSBtZXRob2QgdG8gZXh0cmFjdCB0aGUgZXhjZXJwdCB0ZXh0IGZyb20gYSBRdWVyeVJlc3VsdEl0ZW0gb2JqZWN0LlxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBleGNlcnB0IHRleHQgZnJvbSBhIFF1ZXJ5UmVzdWx0SXRlbSBvYmplY3QuXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIFF1ZXJ5UmVzdWx0SXRlbSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgZXhjZXJwdCB0ZXh0IGZyb20uXG4gICAgICogQHJldHVybnMgVGhlIGV4dHJhY3RlZCBleGNlcnB0IHRleHQuXG4gICAgICovXG4gICAgZ2V0UXVlcnlJdGVtRXhjZXJwdChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLkFkZGl0aW9uYWxBdHRyaWJ1dGVzICYmXG4gICAgICAgICAgICBpdGVtLkFkZGl0aW9uYWxBdHRyaWJ1dGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgaXRlbS5BZGRpdGlvbmFsQXR0cmlidXRlc1swXS5LZXkgPT09IFwiQW5zd2VyVGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uQWRkaXRpb25hbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXRlbS5BZGRpdGlvbmFsQXR0cmlidXRlc1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW5SZXN1bHQoaXRlbS5BZGRpdGlvbmFsQXR0cmlidXRlc1swXS5WYWx1ZT8uVGV4dFdpdGhIaWdobGlnaHRzVmFsdWU/LlRleHQgfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbS5Eb2N1bWVudEV4Y2VycHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFuUmVzdWx0KGl0ZW0uRG9jdW1lbnRFeGNlcnB0LlRleHQgfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBjb252ZXJ0IGEgUXVlcnlSZXN1bHRJdGVtIG9iamVjdCBpbnRvIGEgRG9jdW1lbnQgb2JqZWN0LlxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUXVlcnlSZXN1bHRJdGVtIG9iamVjdCBpbnRvIGEgRG9jdW1lbnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBRdWVyeVJlc3VsdEl0ZW0gb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMgQSBEb2N1bWVudCBvYmplY3QuXG4gICAgICovXG4gICAgY29udmVydFF1ZXJ5SXRlbShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gaXRlbS5Eb2N1bWVudFRpdGxlPy5UZXh0IHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGV4Y2VycHQgPSB0aGlzLmdldFF1ZXJ5SXRlbUV4Y2VycHQoaXRlbSk7XG4gICAgICAgIGNvbnN0IHBhZ2VDb250ZW50ID0gdGhpcy5jb21iaW5lVGV4dCh0aXRsZSwgZXhjZXJwdCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGl0ZW0uRG9jdW1lbnRVUkk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldERvY0F0dHJpYnV0ZXMoaXRlbS5Eb2N1bWVudEF0dHJpYnV0ZXMpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgZXhjZXJwdCxcbiAgICAgICAgICAgIGRvY3VtZW50X2F0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgZG9jdW1lbnRzXzEuRG9jdW1lbnQoeyBwYWdlQ29udGVudCwgbWV0YWRhdGEgfSk7XG4gICAgfVxuICAgIC8vIEEgbWV0aG9kIHRvIGV4dHJhY3QgdGhlIHRvcC1rIGRvY3VtZW50cyBmcm9tIGEgUXVlcnlDb21tYW5kT3V0cHV0IG9iamVjdC5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdG9wLWsgZG9jdW1lbnRzIGZyb20gYSBRdWVyeUNvbW1hbmRPdXRwdXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByZXNwb25zZSBUaGUgUXVlcnlDb21tYW5kT3V0cHV0IG9iamVjdCB0byBleHRyYWN0IHRoZSBkb2N1bWVudHMgZnJvbS5cbiAgICAgKiBAcGFyYW0gcGFnZVNpemUgVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gZXh0cmFjdC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBEb2N1bWVudCBvYmplY3RzLlxuICAgICAqL1xuICAgIGdldFF1ZXJ5RG9jcyhyZXNwb25zZSwgcGFnZVNpemUpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5SZXN1bHRJdGVtcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHJlc3BvbnNlLlJlc3VsdEl0ZW1zO1xuICAgICAgICBjb25zdCBjb3VudCA9IGxlbmd0aCA8IHBhZ2VTaXplID8gbGVuZ3RoIDogcGFnZVNpemU7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5SZXN1bHRJdGVtcy5zbGljZSgwLCBjb3VudCkubWFwKChpdGVtKSA9PiB0aGlzLmNvbnZlcnRRdWVyeUl0ZW0oaXRlbSkpO1xuICAgIH1cbiAgICAvLyBBIG1ldGhvZCB0byBzZW5kIGEgcmV0cmlldmUgb3IgcXVlcnkgcmVxdWVzdCB0byBLZW5kcmEgYW5kIHJldHVybiB0aGUgdG9wLWsgZG9jdW1lbnRzLlxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmV0cmlldmUgb3IgcXVlcnkgcmVxdWVzdCB0byBLZW5kcmEgYW5kIHJldHVybnMgdGhlIHRvcC1rXG4gICAgICogZG9jdW1lbnRzLlxuICAgICAqIEBwYXJhbSBxdWVyeSBUaGUgcXVlcnkgdG8gc2VuZCB0byBLZW5kcmEuXG4gICAgICogQHBhcmFtIHRvcEsgVGhlIG51bWJlciBvZiB0b3AgZG9jdW1lbnRzIHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlRmlsdGVyIE9wdGlvbmFsIGZpbHRlciB0byBhcHBseSB3aGVuIHJldHJpZXZpbmcgZG9jdW1lbnRzLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIERvY3VtZW50IG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlLZW5kcmEocXVlcnksIHRvcEssIGF0dHJpYnV0ZUZpbHRlcikge1xuICAgICAgICBjb25zdCByZXRyaWV2ZUNvbW1hbmQgPSBuZXcgY2xpZW50X2tlbmRyYV8xLlJldHJpZXZlQ29tbWFuZCh7XG4gICAgICAgICAgICBJbmRleElkOiB0aGlzLmluZGV4SWQsXG4gICAgICAgICAgICBRdWVyeVRleHQ6IHF1ZXJ5LFxuICAgICAgICAgICAgUGFnZVNpemU6IHRvcEssXG4gICAgICAgICAgICBBdHRyaWJ1dGVGaWx0ZXI6IGF0dHJpYnV0ZUZpbHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldHJpZXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmtlbmRyYUNsaWVudC5zZW5kKHJldHJpZXZlQ29tbWFuZCk7XG4gICAgICAgIGNvbnN0IHJldHJpdmVMZW5ndGggPSByZXRyaWV2ZVJlc3BvbnNlLlJlc3VsdEl0ZW1zPy5sZW5ndGg7XG4gICAgICAgIGlmIChyZXRyaXZlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBBUEkgcmV0dXJuZWQgMCByZXN1bHRzLCBjYWxsIHF1ZXJ5IEFQSVxuICAgICAgICAgICAgY29uc3QgcXVlcnlDb21tYW5kID0gbmV3IGNsaWVudF9rZW5kcmFfMS5RdWVyeUNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIEluZGV4SWQ6IHRoaXMuaW5kZXhJZCxcbiAgICAgICAgICAgICAgICBRdWVyeVRleHQ6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIFBhZ2VTaXplOiB0b3BLLFxuICAgICAgICAgICAgICAgIEF0dHJpYnV0ZUZpbHRlcjogYXR0cmlidXRlRmlsdGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVJlc3BvbnNlID0gYXdhaXQgdGhpcy5rZW5kcmFDbGllbnQuc2VuZChxdWVyeUNvbW1hbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnlEb2NzKHF1ZXJ5UmVzcG9uc2UsIHRoaXMudG9wSyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXRyaWV2ZXJEb2NzKHJldHJpZXZlUmVzcG9uc2UsIHRoaXMudG9wSyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2dldFJlbGV2YW50RG9jdW1lbnRzKHF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBhd2FpdCB0aGlzLnF1ZXJ5S2VuZHJhKHF1ZXJ5LCB0aGlzLnRvcEssIHRoaXMuYXR0cmlidXRlRmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIGRvY3M7XG4gICAgfVxufVxuZXhwb3J0cy5BbWF6b25LZW5kcmFSZXRyaWV2ZXIgPSBBbWF6b25LZW5kcmFSZXRyaWV2ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/retrievers/kendra.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/dist/types.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/aws/dist/types.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvZGlzdC90eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vYXdzL2Rpc3QvdHlwZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/dist/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/aws/index.cjs":
/*!***********************************************!*\
  !*** ./node_modules/@langchain/aws/index.cjs ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/aws/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLGtIQUE0QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9hd3MvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/aws/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/base.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/base.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxzSUFBc0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9jYWxsYmFja3MvYmFzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2NhbGxiYWNrcy9iYXNlLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/manager.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9tYW5hZ2VyLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9jYWxsYmFja3MvbWFuYWdlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2NhbGxiYWNrcy9tYW5hZ2VyLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/callbacks/promises.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/callbacks/promises.cjs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/callbacks/promises.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2NhbGxiYWNrcy9wcm9taXNlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEsOElBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL3Byb21pc2VzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/callbacks/promises.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/caches/base.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryCache = exports.BaseCache = exports.getCacheKey = void 0;\nexports.deserializeStoredGeneration = deserializeStoredGeneration;\nexports.serializeGeneration = serializeGeneration;\nconst hash_js_1 = __webpack_require__(/*! ../utils/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * This cache key should be consistent across all versions of LangChain.\n * It is currently NOT consistent across versions of LangChain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * separate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of LangChain.\n *\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst getCacheKey = (...strings) => (0, hash_js_1.insecureHash)(strings.join(\"_\"));\nexports.getCacheKey = getCacheKey;\nfunction deserializeStoredGeneration(storedGeneration) {\n    if (storedGeneration.message !== undefined) {\n        return {\n            text: storedGeneration.text,\n            message: (0, utils_js_1.mapStoredMessageToChatMessage)(storedGeneration.message),\n        };\n    }\n    else {\n        return { text: storedGeneration.text };\n    }\n}\nfunction serializeGeneration(generation) {\n    const serializedValue = {\n        text: generation.text,\n    };\n    if (generation.message !== undefined) {\n        serializedValue.message = generation.message.toDict();\n    }\n    return serializedValue;\n}\n/**\n * Base class for all caches. All caches should extend this class.\n */\nclass BaseCache {\n    constructor() {\n        // For backwards compatibility, we use a default key encoder\n        // that uses SHA-1 to hash the prompt and LLM key. This will also print a warning\n        // about the security implications of using SHA-1 as a cache key.\n        Object.defineProperty(this, \"keyEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: exports.getCacheKey\n        });\n    }\n    /**\n     * Sets a custom key encoder function for the cache.\n     * This function should take a prompt and an LLM key and return a string\n     * that will be used as the cache key.\n     * @param keyEncoderFn The custom key encoder function.\n     */\n    makeDefaultKeyEncoder(keyEncoderFn) {\n        this.keyEncoder = keyEncoderFn;\n    }\n}\nexports.BaseCache = BaseCache;\nconst GLOBAL_MAP = new Map();\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nclass InMemoryCache extends BaseCache {\n    constructor(map) {\n        super();\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cache = map ?? new Map();\n    }\n    /**\n     * Retrieves data from the cache using a prompt and an LLM key. If the\n     * data is not found, it returns null.\n     * @param prompt The prompt used to find the data.\n     * @param llmKey The LLM key used to find the data.\n     * @returns The data corresponding to the prompt and LLM key, or null if not found.\n     */\n    lookup(prompt, llmKey) {\n        return Promise.resolve(this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null);\n    }\n    /**\n     * Updates the cache with new data using a prompt and an LLM key.\n     * @param prompt The prompt used to store the data.\n     * @param llmKey The LLM key used to store the data.\n     * @param value The data to be stored.\n     */\n    async update(prompt, llmKey, value) {\n        this.cache.set(this.keyEncoder(prompt, llmKey), value);\n    }\n    /**\n     * Returns a global instance of InMemoryCache using a predefined global\n     * map as the initial cache.\n     * @returns A global instance of InMemoryCache.\n     */\n    static global() {\n        return new InMemoryCache(GLOBAL_MAP);\n    }\n}\nexports.InMemoryCache = InMemoryCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FjaGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQjtBQUMvRCxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFtQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhY2hlcy9iYXNlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5NZW1vcnlDYWNoZSA9IGV4cG9ydHMuQmFzZUNhY2hlID0gZXhwb3J0cy5nZXRDYWNoZUtleSA9IHZvaWQgMDtcbmV4cG9ydHMuZGVzZXJpYWxpemVTdG9yZWRHZW5lcmF0aW9uID0gZGVzZXJpYWxpemVTdG9yZWRHZW5lcmF0aW9uO1xuZXhwb3J0cy5zZXJpYWxpemVHZW5lcmF0aW9uID0gc2VyaWFsaXplR2VuZXJhdGlvbjtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9oYXNoLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHMuY2pzXCIpO1xuLyoqXG4gKiBUaGlzIGNhY2hlIGtleSBzaG91bGQgYmUgY29uc2lzdGVudCBhY3Jvc3MgYWxsIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqIEl0IGlzIGN1cnJlbnRseSBOT1QgY29uc2lzdGVudCBhY3Jvc3MgdmVyc2lvbnMgb2YgTGFuZ0NoYWluLlxuICpcbiAqIEEgaHVnZSBiZW5lZml0IG9mIGhhdmluZyBhIHJlbW90ZSBjYWNoZSAobGlrZSByZWRpcykgaXMgdGhhdCB5b3UgY2FuXG4gKiBhY2Nlc3MgdGhlIGNhY2hlIGZyb20gZGlmZmVyZW50IHByb2Nlc3Nlcy9tYWNoaW5lcy4gVGhlIGFsbG93cyB5b3UgdG9cbiAqIHNlcGFyYXRlIGNvbmNlcm5zIGFuZCBzY2FsZSBob3Jpem9udGFsbHkuXG4gKlxuICogVE9ETzogTWFrZSBjYWNoZSBrZXkgY29uc2lzdGVudCBhY3Jvc3MgdmVyc2lvbnMgb2YgTGFuZ0NoYWluLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgbWFrZURlZmF1bHRLZXlFbmNvZGVyKClgIHRvIGNyZWF0ZSBhIGN1c3RvbSBrZXkgZW5jb2Rlci5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbmNvbnN0IGdldENhY2hlS2V5ID0gKC4uLnN0cmluZ3MpID0+ICgwLCBoYXNoX2pzXzEuaW5zZWN1cmVIYXNoKShzdHJpbmdzLmpvaW4oXCJfXCIpKTtcbmV4cG9ydHMuZ2V0Q2FjaGVLZXkgPSBnZXRDYWNoZUtleTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RvcmVkR2VuZXJhdGlvbihzdG9yZWRHZW5lcmF0aW9uKSB7XG4gICAgaWYgKHN0b3JlZEdlbmVyYXRpb24ubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBzdG9yZWRHZW5lcmF0aW9uLnRleHQsXG4gICAgICAgICAgICBtZXNzYWdlOiAoMCwgdXRpbHNfanNfMS5tYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZSkoc3RvcmVkR2VuZXJhdGlvbi5tZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHN0b3JlZEdlbmVyYXRpb24udGV4dCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUdlbmVyYXRpb24oZ2VuZXJhdGlvbikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IHtcbiAgICAgICAgdGV4dDogZ2VuZXJhdGlvbi50ZXh0LFxuICAgIH07XG4gICAgaWYgKGdlbmVyYXRpb24ubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5tZXNzYWdlID0gZ2VuZXJhdGlvbi5tZXNzYWdlLnRvRGljdCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZFZhbHVlO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgY2FjaGVzLiBBbGwgY2FjaGVzIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQmFzZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSB1c2UgYSBkZWZhdWx0IGtleSBlbmNvZGVyXG4gICAgICAgIC8vIHRoYXQgdXNlcyBTSEEtMSB0byBoYXNoIHRoZSBwcm9tcHQgYW5kIExMTSBrZXkuIFRoaXMgd2lsbCBhbHNvIHByaW50IGEgd2FybmluZ1xuICAgICAgICAvLyBhYm91dCB0aGUgc2VjdXJpdHkgaW1wbGljYXRpb25zIG9mIHVzaW5nIFNIQS0xIGFzIGEgY2FjaGUga2V5LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlFbmNvZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBleHBvcnRzLmdldENhY2hlS2V5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGtleSBlbmNvZGVyIGZ1bmN0aW9uIGZvciB0aGUgY2FjaGUuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgdGFrZSBhIHByb21wdCBhbmQgYW4gTExNIGtleSBhbmQgcmV0dXJuIGEgc3RyaW5nXG4gICAgICogdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5RW5jb2RlckZuIFRoZSBjdXN0b20ga2V5IGVuY29kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWFrZURlZmF1bHRLZXlFbmNvZGVyKGtleUVuY29kZXJGbikge1xuICAgICAgICB0aGlzLmtleUVuY29kZXIgPSBrZXlFbmNvZGVyRm47XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ2FjaGUgPSBCYXNlQ2FjaGU7XG5jb25zdCBHTE9CQUxfTUFQID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBBIGNhY2hlIGZvciBzdG9yaW5nIExMTSBnZW5lcmF0aW9ucyB0aGF0IHN0b3JlcyBkYXRhIGluIG1lbW9yeS5cbiAqL1xuY2xhc3MgSW5NZW1vcnlDYWNoZSBleHRlbmRzIEJhc2VDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobWFwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBtYXAgPz8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGF0YSBmcm9tIHRoZSBjYWNoZSB1c2luZyBhIHByb21wdCBhbmQgYW4gTExNIGtleS4gSWYgdGhlXG4gICAgICogZGF0YSBpcyBub3QgZm91bmQsIGl0IHJldHVybnMgbnVsbC5cbiAgICAgKiBAcGFyYW0gcHJvbXB0IFRoZSBwcm9tcHQgdXNlZCB0byBmaW5kIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBsbG1LZXkgVGhlIExMTSBrZXkgdXNlZCB0byBmaW5kIHRoZSBkYXRhLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb21wdCBhbmQgTExNIGtleSwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbG9va3VwKHByb21wdCwgbGxtS2V5KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jYWNoZS5nZXQodGhpcy5rZXlFbmNvZGVyKHByb21wdCwgbGxtS2V5KSkgPz8gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhY2hlIHdpdGggbmV3IGRhdGEgdXNpbmcgYSBwcm9tcHQgYW5kIGFuIExMTSBrZXkuXG4gICAgICogQHBhcmFtIHByb21wdCBUaGUgcHJvbXB0IHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGxsbUtleSBUaGUgTExNIGtleSB1c2VkIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgZGF0YSB0byBiZSBzdG9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHByb21wdCwgbGxtS2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhY2hlLnNldCh0aGlzLmtleUVuY29kZXIocHJvbXB0LCBsbG1LZXkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBnbG9iYWwgaW5zdGFuY2Ugb2YgSW5NZW1vcnlDYWNoZSB1c2luZyBhIHByZWRlZmluZWQgZ2xvYmFsXG4gICAgICogbWFwIGFzIHRoZSBpbml0aWFsIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIEEgZ2xvYmFsIGluc3RhbmNlIG9mIEluTWVtb3J5Q2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGdsb2JhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbk1lbW9yeUNhY2hlKEdMT0JBTF9NQVApO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5NZW1vcnlDYWNoZSA9IEluTWVtb3J5Q2FjaGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBaseCallbackHandler = exports.BaseCallbackHandler = void 0;\nexports.callbackHandlerPrefersStreaming = callbackHandlerPrefersStreaming;\nconst uuid = __importStar(__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\"));\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nclass BaseCallbackHandlerMethodsClass {\n}\nfunction callbackHandlerPrefersStreaming(x) {\n    return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nclass BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {\n    get lc_namespace() {\n        return [\"langchain_core\", \"callbacks\", this.name];\n    }\n    get lc_secrets() {\n        return undefined;\n    }\n    get lc_attributes() {\n        return undefined;\n    }\n    get lc_aliases() {\n        return undefined;\n    }\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            (0, serializable_js_1.get_lc_unique_name)(this.constructor),\n        ];\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"ignoreLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreAgent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreRetriever\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"ignoreCustomEvent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"raiseError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"awaitHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        });\n        this.lc_kwargs = input || {};\n        if (input) {\n            this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n            this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n            this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n            this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n            this.ignoreCustomEvent =\n                input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n            this.raiseError = input.raiseError ?? this.raiseError;\n            this.awaitHandlers =\n                this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n        }\n    }\n    copy() {\n        return new this.constructor(this);\n    }\n    toJSON() {\n        return serializable_js_1.Serializable.prototype.toJSON.call(this);\n    }\n    toJSONNotImplemented() {\n        return serializable_js_1.Serializable.prototype.toJSONNotImplemented.call(this);\n    }\n    static fromMethods(methods) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuid.v4()\n                });\n                Object.assign(this, methods);\n            }\n        }\n        return new Handler();\n    }\n}\nexports.BaseCallbackHandler = BaseCallbackHandler;\nconst isBaseCallbackHandler = (x) => {\n    const callbackHandler = x;\n    return (callbackHandler !== undefined &&\n        typeof callbackHandler.copy === \"function\" &&\n        typeof callbackHandler.name === \"string\" &&\n        typeof callbackHandler.awaitHandlers === \"boolean\");\n};\nexports.isBaseCallbackHandler = isBaseCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDJCQUEyQjtBQUMzRCx1Q0FBdUM7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMsMkZBQU07QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLGlGQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQmFzZUNhbGxiYWNrSGFuZGxlciA9IGV4cG9ydHMuQmFzZUNhbGxiYWNrSGFuZGxlciA9IHZvaWQgMDtcbmV4cG9ydHMuY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyA9IGNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmc7XG5jb25zdCB1dWlkID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ1dWlkXCIpKTtcbmNvbnN0IHNlcmlhbGl6YWJsZV9qc18xID0gcmVxdWlyZShcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmNqc1wiKTtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2Vudi5janNcIik7XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBzZXQgb2Ygb3B0aW9uYWwgbWV0aG9kcyB0aGF0IGNhbiBiZVxuICogb3ZlcnJpZGRlbiBpbiBkZXJpdmVkIGNsYXNzZXMgdG8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzIGR1cmluZyB0aGVcbiAqIGV4ZWN1dGlvbiBvZiBhIExhbmdDaGFpbiBhcHBsaWNhdGlvbi5cbiAqL1xuY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlck1ldGhvZHNDbGFzcyB7XG59XG5mdW5jdGlvbiBjYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nKHgpIHtcbiAgICByZXR1cm4gXCJsY19wcmVmZXJfc3RyZWFtaW5nXCIgaW4geCAmJiB4LmxjX3ByZWZlcl9zdHJlYW1pbmc7XG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGNhbGxiYWNrIGhhbmRsZXJzIGluIHRoZSBMYW5nQ2hhaW5cbiAqIGZyYW1ld29yay4gSXQgcHJvdmlkZXMgYSBzZXQgb2Ygb3B0aW9uYWwgbWV0aG9kcyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuXG4gKiBpbiBkZXJpdmVkIGNsYXNzZXMgdG8gaGFuZGxlIHZhcmlvdXMgZXZlbnRzIGR1cmluZyB0aGUgZXhlY3V0aW9uIG9mIGFcbiAqIExhbmdDaGFpbiBhcHBsaWNhdGlvbi5cbiAqL1xuY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xuICAgIGdldCBsY19uYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImNhbGxiYWNrc1wiLCB0aGlzLm5hbWVdO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfc2VyaWFsaXphYmxlX2tleXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemFibGUuIE92ZXJyaWRlIHRvIHByb3ZpZGUgYW4gYWxpYXMgb3JcbiAgICAgKiB0byBwcmVzZXJ2ZSB0aGUgc2VyaWFsaXplZCBtb2R1bGUgbmFtZSBpbiBtaW5pZmllZCBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBhIHN0YXRpYyBtZXRob2QgdG8gc3VwcG9ydCBsb2FkaW5nIGxvZ2ljLlxuICAgICAqL1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmluYWwgc2VyaWFsaXplZCBpZGVudGlmaWVyIGZvciB0aGUgbW9kdWxlLlxuICAgICAqL1xuICAgIGdldCBsY19pZCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMubGNfbmFtZXNwYWNlLFxuICAgICAgICAgICAgKDAsIHNlcmlhbGl6YWJsZV9qc18xLmdldF9sY191bmlxdWVfbmFtZSkodGhpcy5jb25zdHJ1Y3RvciksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVMTE1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVDaGFpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUFnZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlUmV0cmlldmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQ3VzdG9tRXZlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWlzZUVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXdhaXRIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKDAsIGVudl9qc18xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiTEFOR0NIQUlOX0NBTExCQUNLU19CQUNLR1JPVU5EXCIpID09PSBcImZhbHNlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0gaW5wdXQgfHwge307XG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVMTE0gPSBpbnB1dC5pZ25vcmVMTE0gPz8gdGhpcy5pZ25vcmVMTE07XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUNoYWluID0gaW5wdXQuaWdub3JlQ2hhaW4gPz8gdGhpcy5pZ25vcmVDaGFpbjtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQWdlbnQgPSBpbnB1dC5pZ25vcmVBZ2VudCA/PyB0aGlzLmlnbm9yZUFnZW50O1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVSZXRyaWV2ZXIgPSBpbnB1dC5pZ25vcmVSZXRyaWV2ZXIgPz8gdGhpcy5pZ25vcmVSZXRyaWV2ZXI7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50ID1cbiAgICAgICAgICAgICAgICBpbnB1dC5pZ25vcmVDdXN0b21FdmVudCA/PyB0aGlzLmlnbm9yZUN1c3RvbUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yID0gaW5wdXQucmFpc2VFcnJvciA/PyB0aGlzLnJhaXNlRXJyb3I7XG4gICAgICAgICAgICB0aGlzLmF3YWl0SGFuZGxlcnMgPVxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvciB8fCAoaW5wdXQuX2F3YWl0SGFuZGxlciA/PyB0aGlzLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVfanNfMS5TZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTk5vdEltcGxlbWVudGVkLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkLnY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGFuZGxlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNhbGxiYWNrSGFuZGxlciA9IEJhc2VDYWxsYmFja0hhbmRsZXI7XG5jb25zdCBpc0Jhc2VDYWxsYmFja0hhbmRsZXIgPSAoeCkgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrSGFuZGxlciA9IHg7XG4gICAgcmV0dXJuIChjYWxsYmFja0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tIYW5kbGVyLmNvcHkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tIYW5kbGVyLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrSGFuZGxlci5hd2FpdEhhbmRsZXJzID09PSBcImJvb2xlYW5cIik7XG59O1xuZXhwb3J0cy5pc0Jhc2VDYWxsYmFja0hhbmRsZXIgPSBpc0Jhc2VDYWxsYmFja0hhbmRsZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/manager.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TraceGroup = exports.CallbackManager = exports.CallbackManagerForToolRun = exports.CallbackManagerForChainRun = exports.CallbackManagerForLLMRun = exports.CallbackManagerForRetrieverRun = exports.BaseRunManager = exports.BaseCallbackManager = void 0;\nexports.parseCallbackConfigArg = parseCallbackConfigArg;\nexports.ensureHandler = ensureHandler;\nexports.traceAsGroup = traceAsGroup;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst console_js_1 = __webpack_require__(/*! ../tracers/console.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst tracer_langchain_js_1 = __webpack_require__(/*! ../tracers/tracer_langchain.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\");\nconst promises_js_1 = __webpack_require__(/*! ./promises.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\");\nconst callbacks_js_1 = __webpack_require__(/*! ../utils/callbacks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../tracers/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst context_js_1 = __webpack_require__(/*! ../singletons/async_local_storage/context.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs\");\nfunction parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nclass BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\nexports.BaseCallbackManager = BaseCallbackManager;\n/**\n * Base class for run manager in LangChain.\n */\nclass BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.BaseRunManager = BaseRunManager;\n/**\n * Manages callbacks for retriever runs.\n */\nclass CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForRetrieverRun = CallbackManagerForRetrieverRun;\nclass CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForLLMRun = CallbackManagerForLLMRun;\nclass CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForChainRun = CallbackManagerForChainRun;\nclass CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexports.CallbackManagerForToolRun = CallbackManagerForToolRun;\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nclass CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : (0, uuid_1.v4)();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if ((0, base_js_2.isBaseTracer)(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return (0, promises_js_1.consumeCallback)(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = (0, utils_js_1.getBufferString)(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = (0, uuid_1.v4)(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = (0, uuid_1.v4)(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if ((0, base_js_2.isBaseTracer)(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return (0, promises_js_1.consumeCallback)(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => (0, promises_js_1.consumeCallback)(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends base_js_1.BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: (0, uuid_1.v4)()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            (0, callbacks_js_1.isTracingEnabled)();\n        const tracingEnabled = tracingV2Enabled ||\n            ((0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === console_js_1.ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new console_js_1.ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new tracer_langchain_js_1.LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                }\n            }\n            if (tracingV2Enabled) {\n                // handoff between langchain and langsmith/traceable\n                // override the parent run ID\n                const implicitRunTree = tracer_langchain_js_1.LangChainTracer.getTraceableRunTree();\n                if (implicitRunTree && callbackManager._parentRunId === undefined) {\n                    callbackManager._parentRunId = implicitRunTree.id;\n                    const tracerV2 = callbackManager.handlers.find((handler) => handler.name === \"langchain_tracer\");\n                    tracerV2?.updateFromRunTree(implicitRunTree);\n                }\n            }\n        }\n        for (const { contextVar, inheritable = true, handlerClass, envVar, } of (0, context_js_1._getConfigureHooks)()) {\n            const createIfNotInContext = envVar && (0, env_js_1.getEnvironmentVariable)(envVar) === \"true\" && handlerClass;\n            let handler;\n            const contextVarValue = contextVar !== undefined ? (0, context_js_1.getContextVariable)(contextVar) : undefined;\n            if (contextVarValue && (0, base_js_1.isBaseCallbackHandler)(contextVarValue)) {\n                handler = contextVarValue;\n            }\n            else if (createIfNotInContext) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                handler = new handlerClass({});\n            }\n            if (handler !== undefined) {\n                if (!callbackManager) {\n                    callbackManager = new CallbackManager();\n                }\n                if (!callbackManager.handlers.some((h) => h.name === handler.name)) {\n                    callbackManager.addHandler(handler, inheritable);\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nexports.CallbackManager = CallbackManager;\nfunction ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return base_js_1.BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)\n * from \"langsmith\" instead.\n */\nclass TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new tracer_langchain_js_1.LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\nexports.TraceGroup = TraceGroup;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLHNDQUFzQyxHQUFHLHNCQUFzQixHQUFHLDJCQUEyQjtBQUN4UCw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixlQUFlLG1CQUFPLENBQUMsMkZBQU07QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3ZFLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFnQjtBQUM5Qyx1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsdUZBQXFCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDJJQUErQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLGdCQUFnQixJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsMEJBQTBCLE1BQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMEJBQTBCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixrQkFBa0IsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHNCQUFzQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5Qix1QkFBdUIsSUFBSTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUIscUJBQXFCLElBQUk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLG1CQUFtQixJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUIsb0JBQW9CLElBQUk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCLG9CQUFvQixJQUFJO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixzQkFBc0IsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QixxQkFBcUIsSUFBSTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QiwwQkFBMEIsSUFBSTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCLHVCQUF1QixJQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFjZUdyb3VwID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXIgPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuID0gZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JMTE1SdW4gPSBleHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biA9IGV4cG9ydHMuQmFzZVJ1bk1hbmFnZXIgPSBleHBvcnRzLkJhc2VDYWxsYmFja01hbmFnZXIgPSB2b2lkIDA7XG5leHBvcnRzLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcgPSBwYXJzZUNhbGxiYWNrQ29uZmlnQXJnO1xuZXhwb3J0cy5lbnN1cmVIYW5kbGVyID0gZW5zdXJlSGFuZGxlcjtcbmV4cG9ydHMudHJhY2VBc0dyb3VwID0gdHJhY2VBc0dyb3VwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbnNvbGVfanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2NvbnNvbGUuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy91dGlscy5janNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xuY29uc3QgdHJhY2VyX2xhbmdjaGFpbl9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvdHJhY2VyX2xhbmdjaGFpbi5janNcIik7XG5jb25zdCBwcm9taXNlc19qc18xID0gcmVxdWlyZShcIi4vcHJvbWlzZXMuY2pzXCIpO1xuY29uc3QgY2FsbGJhY2tzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY2FsbGJhY2tzLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMiA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29udGV4dF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvYXN5bmNfbG9jYWxfc3RvcmFnZS9jb250ZXh0LmNqc1wiKTtcbmZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoYXJnKSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgXCJuYW1lXCIgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB7IGNhbGxiYWNrczogYXJnIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlIGNhbGxiYWNrcyBmcm9tIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIExhbmdDaGFpbi5cbiAqL1xuY2xhc3MgQmFzZUNhbGxiYWNrTWFuYWdlciB7XG4gICAgc2V0SGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEhhbmRsZXJzKFtoYW5kbGVyXSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ2FsbGJhY2tNYW5hZ2VyID0gQmFzZUNhbGxiYWNrTWFuYWdlcjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVuIG1hbmFnZXIgaW4gTGFuZ0NoYWluLlxuICovXG5jbGFzcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocnVuSWQsIGhhbmRsZXJzLCBpbmhlcml0YWJsZUhhbmRsZXJzLCB0YWdzLCBpbmhlcml0YWJsZVRhZ3MsIG1ldGFkYXRhLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBfcGFyZW50UnVuSWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJ1bklkXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlSGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlSGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRhZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVUYWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3BhcmVudFJ1bklkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0KSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUZXh0Py4odGV4dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVGV4dDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBfcnVuSWQsIF90YWdzLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9tZXRhZGF0YSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ3VzdG9tRXZlbnQ/LihldmVudE5hbWUsIGRhdGEsIHRoaXMucnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ3VzdG9tRXZlbnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVJ1bk1hbmFnZXIgPSBCYXNlUnVuTWFuYWdlcjtcbi8qKlxuICogTWFuYWdlcyBjYWxsYmFja3MgZm9yIHJldHJpZXZlciBydW5zLlxuICovXG5jbGFzcyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRW5kKGRvY3VtZW50cykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFbmQ/Lihkb2N1bWVudHMsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlcmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlckVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1biA9IENhbGxiYWNrTWFuYWdlckZvclJldHJpZXZlclJ1bjtcbmNsYXNzIENhbGxiYWNrTWFuYWdlckZvckxMTVJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1OZXdUb2tlbj8uKHRva2VuLCBpZHggPz8geyBwcm9tcHQ6IDAsIGNvbXBsZXRpb246IDAgfSwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1OZXdUb2tlbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnIsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZXh0cmFQYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGV4dHJhUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FbmQob3V0cHV0LCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuID0gQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuO1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yQ2hhaW5SdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FcnJvcihlcnIsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+ICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUFnZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVBZ2VudEFjdGlvbj8uKGFjdGlvbiwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQWdlbnRBY3Rpb246ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQWdlbnRFbmQoYWN0aW9uKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRFbmQ/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUFnZW50RW5kOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biA9IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuO1xuY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbEVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBoYW5kbGVUb29sRW5kKG91dHB1dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gPSBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuO1xuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0ID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiV2hhdCBpcyB0aGUgYW5zd2VyIHRvIHtxdWVzdGlvbn0/XCIpO1xuICpcbiAqIC8vIEV4YW1wbGUgb2YgdXNpbmcgTExNQ2hhaW4gd2l0aCBPcGVuQUkgYW5kIGEgc2ltcGxlIHByb21wdFxuICogY29uc3QgY2hhaW4gPSBuZXcgTExNQ2hhaW4oe1xuICogICBsbG06IG5ldyBDaGF0T3BlbkFJKHsgbW9kZWw6IFwiZ3B0LTRvLW1pbmlcIiwgdGVtcGVyYXR1cmU6IDAuOSB9KSxcbiAqICAgcHJvbXB0LFxuICogfSk7XG4gKlxuICogLy8gUnVubmluZyB0aGUgY2hhaW4gd2l0aCBhIHNpbmdsZSBxdWVzdGlvblxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uY2FsbCh7XG4gKiAgIHF1ZXN0aW9uOiBcIldoYXQgaXMgdGhlIGFpcnNwZWVkIHZlbG9jaXR5IG9mIGFuIHVubGFkZW4gc3dhbGxvdz9cIixcbiAqIH0pO1xuICogY29uc29sZS5sb2coXCJUaGUgYW5zd2VyIGlzOlwiLCByZXN1bHQpO1xuICogYGBgXG4gKi9cbmNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlVHJhY2VyKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yTExNU3RhcnQobGxtLCBbcHJvbXB0XSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFtwcm9tcHRdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgW21lc3NhZ2VHcm91cF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuaGFuZGxlTExNU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gKDAsIHV0aWxzX2pzXzEuZ2V0QnVmZmVyU3RyaW5nKShtZXNzYWdlR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFttZXNzYWdlU3RyaW5nXSwgcnVuSWRfLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckxMTVJ1bihydW5JZF8sIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCA9ICgwLCB1dWlkXzEudjQpKCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBiYXNlX2pzXzIuaXNCYXNlVHJhY2VyKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZXNfanNfMS5jb25zdW1lQ2FsbGJhY2spKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluU3RhcnQ/LihjaGFpbiwgaW5wdXRzLCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuVHlwZSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCA9ICgwLCB1dWlkXzEudjQpKCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VUcmFjZXIpKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbFN0YXJ0Py4odG9vbCwgaW5wdXQsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQgPSAoMCwgdXVpZF8xLnY0KSgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYmFzZV9qc18yLmlzQmFzZVRyYWNlcikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLmNvbnN1bWVDYWxsYmFjaykoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyU3RhcnQ/LihyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDdXN0b21FdmVudChldmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZGF0YSwgcnVuSWQsIF90YWdzLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9tZXRhZGF0YSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gKDAsIHByb21pc2VzX2pzXzEuY29uc3VtZUNhbGxiYWNrKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUN1c3RvbUV2ZW50Py4oZXZlbnROYW1lLCBkYXRhLCBydW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDdXN0b21FdmVudDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gdGhpcy5oYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5maWx0ZXIoKF9oYW5kbGVyKSA9PiBfaGFuZGxlciAhPT0gaGFuZGxlcik7XG4gICAgfVxuICAgIHNldEhhbmRsZXJzKGhhbmRsZXJzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYWdzKHRhZ3MsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGFncyh0YWdzKTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgdGhpcy50YWdzLnB1c2goLi4udGFncyk7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVRhZ3ModGFncykge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdzLmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IHRoaXMuaW5oZXJpdGFibGVUYWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICB9XG4gICAgYWRkTWV0YWRhdGEobWV0YWRhdGEsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB7IC4uLnRoaXMubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEgPSB7IC4uLnRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1ldGFkYXRhW2tleV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weShhZGRpdGlvbmFsSGFuZGxlcnMgPSBbXSwgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5fcGFyZW50UnVuSWQpO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuaW5jbHVkZXMoaGFuZGxlcik7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5pbmNsdWRlcyh0YWcpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBpbmhlcml0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gT2JqZWN0LmtleXModGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKS5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh7IFtrZXldOiB0aGlzLm1ldGFkYXRhW2tleV0gfSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBhZGRpdGlvbmFsSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgY29waWVzIG9mIGNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclxuICAgICAgICAgICAgbWFuYWdlci5oYW5kbGVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGgpID0+IGgubmFtZSA9PT0gXCJjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcIilcbiAgICAgICAgICAgICAgICAuc29tZSgoaCkgPT4gaC5uYW1lID09PSBoYW5kbGVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgY2xhc3MgSGFuZGxlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgdXVpZF8xLnY0KSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBoYW5kbGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihuZXcgSGFuZGxlcigpKTtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjb25maWd1cmUoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgYXN5bmMgbWV0aG9kIGluIGZhdm9yIG9mIHRoaXMgb25lLlxuICAgIHN0YXRpYyBfY29uZmlndXJlU3luYyhpbmhlcml0YWJsZUhhbmRsZXJzLCBsb2NhbEhhbmRsZXJzLCBpbmhlcml0YWJsZVRhZ3MsIGxvY2FsVGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgbG9jYWxNZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgY2FsbGJhY2tNYW5hZ2VyO1xuICAgICAgICBpZiAoaW5oZXJpdGFibGVIYW5kbGVycyB8fCBsb2NhbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmhlcml0YWJsZUhhbmRsZXJzKSB8fCAhaW5oZXJpdGFibGVIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuc2V0SGFuZGxlcnMoaW5oZXJpdGFibGVIYW5kbGVycz8ubWFwKGVuc3VyZUhhbmRsZXIpID8/IFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IGluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBjYWxsYmFja01hbmFnZXIuY29weShBcnJheS5pc0FycmF5KGxvY2FsSGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgPyBsb2NhbEhhbmRsZXJzLm1hcChlbnN1cmVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIDogbG9jYWxIYW5kbGVycz8uaGFuZGxlcnMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlRW5hYmxlZCA9ICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9WRVJCT1NFXCIpID09PSBcInRydWVcIiB8fFxuICAgICAgICAgICAgb3B0aW9ucz8udmVyYm9zZTtcbiAgICAgICAgY29uc3QgdHJhY2luZ1YyRW5hYmxlZCA9IHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpPy50cmFjaW5nRW5hYmxlZCB8fFxuICAgICAgICAgICAgKDAsIGNhbGxiYWNrc19qc18xLmlzVHJhY2luZ0VuYWJsZWQpKCk7XG4gICAgICAgIGNvbnN0IHRyYWNpbmdFbmFibGVkID0gdHJhY2luZ1YyRW5hYmxlZCB8fFxuICAgICAgICAgICAgKCgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBjb25zb2xlX2pzXzEuQ29uc29sZUNhbGxiYWNrSGFuZGxlci5wcm90b3R5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zb2xlSGFuZGxlciA9IG5ldyBjb25zb2xlX2pzXzEuQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKGNvbnNvbGVIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2luZ1YyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFjZXJWMiA9IG5ldyB0cmFjZXJfbGFuZ2NoYWluX2pzXzEuTGFuZ0NoYWluVHJhY2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKHRyYWNlclYyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ1YyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRvZmYgYmV0d2VlbiBsYW5nY2hhaW4gYW5kIGxhbmdzbWl0aC90cmFjZWFibGVcbiAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgcGFyZW50IHJ1biBJRFxuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0UnVuVHJlZSA9IHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpbXBsaWNpdFJ1blRyZWUgJiYgY2FsbGJhY2tNYW5hZ2VyLl9wYXJlbnRSdW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5fcGFyZW50UnVuSWQgPSBpbXBsaWNpdFJ1blRyZWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlclYyID0gY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjZXJWMj8udXBkYXRlRnJvbVJ1blRyZWUoaW1wbGljaXRSdW5UcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB7IGNvbnRleHRWYXIsIGluaGVyaXRhYmxlID0gdHJ1ZSwgaGFuZGxlckNsYXNzLCBlbnZWYXIsIH0gb2YgKDAsIGNvbnRleHRfanNfMS5fZ2V0Q29uZmlndXJlSG9va3MpKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUlmTm90SW5Db250ZXh0ID0gZW52VmFyICYmICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShlbnZWYXIpID09PSBcInRydWVcIiAmJiBoYW5kbGVyQ2xhc3M7XG4gICAgICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRWYXJWYWx1ZSA9IGNvbnRleHRWYXIgIT09IHVuZGVmaW5lZCA/ICgwLCBjb250ZXh0X2pzXzEuZ2V0Q29udGV4dFZhcmlhYmxlKShjb250ZXh0VmFyKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb250ZXh0VmFyVmFsdWUgJiYgKDAsIGJhc2VfanNfMS5pc0Jhc2VDYWxsYmFja0hhbmRsZXIpKGNvbnRleHRWYXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gY29udGV4dFZhclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSWZOb3RJbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBuZXcgaGFuZGxlckNsYXNzKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZVRhZ3MgfHwgbG9jYWxUYWdzKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MoaW5oZXJpdGFibGVUYWdzID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhsb2NhbFRhZ3MgPz8gW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVNZXRhZGF0YSB8fCBsb2NhbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGluaGVyaXRhYmxlTWV0YWRhdGEgPz8ge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShsb2NhbE1ldGFkYXRhID8/IHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrTWFuYWdlcjtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxiYWNrTWFuYWdlciA9IENhbGxiYWNrTWFuYWdlcjtcbmZ1bmN0aW9uIGVuc3VyZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmIChcIm5hbWVcIiBpbiBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZV9qc18xLkJhc2VDYWxsYmFja0hhbmRsZXIuZnJvbU1ldGhvZHMoaGFuZGxlcik7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBbYHRyYWNlYWJsZWBdKGh0dHBzOi8vZG9jcy5zbWl0aC5sYW5nY2hhaW4uY29tL29ic2VydmFiaWxpdHkvaG93X3RvX2d1aWRlcy90cmFjaW5nL2Fubm90YXRlX2NvZGUpXG4gKiBmcm9tIFwibGFuZ3NtaXRoXCIgaW5zdGVhZC5cbiAqL1xuY2xhc3MgVHJhY2VHcm91cCB7XG4gICAgY29uc3RydWN0b3IoZ3JvdXBOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyb3VwTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ3JvdXBOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYW5hZ2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIoZ3JvdXBfbmFtZSwgaW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNiID0gbmV3IHRyYWNlcl9sYW5nY2hhaW5fanNfMS5MYW5nQ2hhaW5UcmFjZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNtID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShbY2JdKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNtPy5oYW5kbGVDaGFpblN0YXJ0KHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiBbXCJsYW5nY2hhaW5cIiwgXCJjYWxsYmFja3NcIiwgXCJncm91cHNcIiwgZ3JvdXBfbmFtZV0sXG4gICAgICAgIH0sIGlucHV0cyA/PyB7fSk7XG4gICAgICAgIGlmICghcnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBydW4gZ3JvdXAgY2FsbGJhY2sgbWFuYWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KGlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRUcmFjZUdyb3VwQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuZ3JvdXBOYW1lLCBpbnB1dHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVuTWFuYWdlci5nZXRDaGlsZCgpO1xuICAgIH1cbiAgICBhc3luYyBlcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmQob3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVuZChvdXRwdXQgPz8ge30pO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UcmFjZUdyb3VwID0gVHJhY2VHcm91cDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIHRyYWNlQXNHcm91cChncm91cE9wdGlvbnMsIGVuY2xvc2VkQ29kZSwgLi4uYXJncykge1xuICAgIGNvbnN0IHRyYWNlR3JvdXAgPSBuZXcgVHJhY2VHcm91cChncm91cE9wdGlvbnMubmFtZSwgZ3JvdXBPcHRpb25zKTtcbiAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBhd2FpdCB0cmFjZUdyb3VwLnN0YXJ0KHsgLi4uYXJncyB9KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmNsb3NlZENvZGUoY2FsbGJhY2tNYW5hZ2VyLCAuLi5hcmdzKTtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lbmQoX2NvZXJjZVRvRGljdChyZXN1bHQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVycm9yKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/callbacks/promises.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.consumeCallback = exports.awaitAllCallbacks = void 0;\nconst callbacks_js_1 = __webpack_require__(/*! ../singletons/callbacks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs\");\nObject.defineProperty(exports, \"awaitAllCallbacks\", ({ enumerable: true, get: function () { return callbacks_js_1.awaitAllCallbacks; } }));\nObject.defineProperty(exports, \"consumeCallback\", ({ enumerable: true, get: function () { return callbacks_js_1.consumeCallback; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL3Byb21pc2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx5QkFBeUI7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsdUdBQTZCO0FBQzVELHFEQUFvRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUN4SSxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9wcm9taXNlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN1bWVDYWxsYmFjayA9IGV4cG9ydHMuYXdhaXRBbGxDYWxsYmFja3MgPSB2b2lkIDA7XG5jb25zdCBjYWxsYmFja3NfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL2NhbGxiYWNrcy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhd2FpdEFsbENhbGxiYWNrc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2tzX2pzXzEuYXdhaXRBbGxDYWxsYmFja3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdW1lQ2FsbGJhY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrc19qc18xLmNvbnN1bWVDYWxsYmFjazsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/callbacks/promises.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/document.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Document = void 0;\n/**\n * Interface for interacting with a document.\n */\nclass Document {\n    constructor(fields) {\n        Object.defineProperty(this, \"pageContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The ID field is optional at the moment.\n        // It will likely become required in a future major release after\n        // it has been adopted by enough vectorstore implementations.\n        /**\n         * An optional identifier for the document.\n         *\n         * Ideally this should be unique across the document collection and formatted\n         * as a UUID, but this will not be enforced.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pageContent =\n            fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n        this.metadata = fields.metadata ?? {};\n        this.id = fields.id;\n    }\n}\nexports.Document = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2RvY3VtZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2RvY3VtZW50LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRG9jdW1lbnQgPSB2b2lkIDA7XG4vKipcbiAqIEludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIGRvY3VtZW50LlxuICovXG5jbGFzcyBEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhZ2VDb250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBJRCBmaWVsZCBpcyBvcHRpb25hbCBhdCB0aGUgbW9tZW50LlxuICAgICAgICAvLyBJdCB3aWxsIGxpa2VseSBiZWNvbWUgcmVxdWlyZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZSBhZnRlclxuICAgICAgICAvLyBpdCBoYXMgYmVlbiBhZG9wdGVkIGJ5IGVub3VnaCB2ZWN0b3JzdG9yZSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcHRpb25hbCBpZGVudGlmaWVyIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElkZWFsbHkgdGhpcyBzaG91bGQgYmUgdW5pcXVlIGFjcm9zcyB0aGUgZG9jdW1lbnQgY29sbGVjdGlvbiBhbmQgZm9ybWF0dGVkXG4gICAgICAgICAqIGFzIGEgVVVJRCwgYnV0IHRoaXMgd2lsbCBub3QgYmUgZW5mb3JjZWQuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhZ2VDb250ZW50ID1cbiAgICAgICAgICAgIGZpZWxkcy5wYWdlQ29udGVudCAhPT0gdW5kZWZpbmVkID8gZmllbGRzLnBhZ2VDb250ZW50LnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gZmllbGRzLm1ldGFkYXRhID8/IHt9O1xuICAgICAgICB0aGlzLmlkID0gZmllbGRzLmlkO1xuICAgIH1cbn1cbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/index.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./document.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/document.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsd0ZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kb2N1bWVudC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybWVycy5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/documents/transformers.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MappingDocumentTransformer = exports.BaseDocumentTransformer = void 0;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nclass BaseDocumentTransformer extends base_js_1.Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"documents\", \"transformers\"]\n        });\n    }\n    /**\n     * Method to invoke the document transformation. This method calls the\n     * transformDocuments method with the provided input.\n     * @param input The input documents to be transformed.\n     * @param _options Optional configuration object to customize the behavior of callbacks.\n     * @returns A Promise that resolves to the transformed documents.\n     */\n    invoke(input, _options) {\n        return this.transformDocuments(input);\n    }\n}\nexports.BaseDocumentTransformer = BaseDocumentTransformer;\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nclass MappingDocumentTransformer extends BaseDocumentTransformer {\n    async transformDocuments(documents) {\n        const newDocuments = [];\n        for (const document of documents) {\n            const transformedDocument = await this._transformDocument(document);\n            newDocuments.push(transformedDocument);\n        }\n        return newDocuments;\n    }\n}\nexports.MappingDocumentTransformer = MappingDocumentTransformer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZG9jdW1lbnRzL3RyYW5zZm9ybWVycy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsK0JBQStCO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2RvY3VtZW50cy90cmFuc2Zvcm1lcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXBwaW5nRG9jdW1lbnRUcmFuc2Zvcm1lciA9IGV4cG9ydHMuQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbiBzeXN0ZW1zLlxuICpcbiAqIEEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24gc3lzdGVtIHRha2VzIGFuIGFycmF5IG9mIERvY3VtZW50cyBhbmQgcmV0dXJucyBhblxuICogYXJyYXkgb2YgdHJhbnNmb3JtZWQgRG9jdW1lbnRzLiBUaGVzZSBhcnJheXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaGF2ZVxuICogdGhlIHNhbWUgbGVuZ3RoLlxuICpcbiAqIE9uZSBleGFtcGxlIG9mIHRoaXMgaXMgYSB0ZXh0IHNwbGl0dGVyIHRoYXQgc3BsaXRzIGEgbGFyZ2UgZG9jdW1lbnQgaW50b1xuICogbWFueSBzbWFsbGVyIGRvY3VtZW50cy5cbiAqL1xuY2xhc3MgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwiZG9jdW1lbnRzXCIsIFwidHJhbnNmb3JtZXJzXCJdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gaW52b2tlIHRoZSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi4gVGhpcyBtZXRob2QgY2FsbHMgdGhlXG4gICAgICogdHJhbnNmb3JtRG9jdW1lbnRzIG1ldGhvZCB3aXRoIHRoZSBwcm92aWRlZCBpbnB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGRvY3VtZW50cyB0byBiZSB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0gX29wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiBjYWxsYmFja3MuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50cy5cbiAgICAgKi9cbiAgICBpbnZva2UoaW5wdXQsIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybURvY3VtZW50cyhpbnB1dCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRG9jdW1lbnRUcmFuc2Zvcm1lciA9IEJhc2VEb2N1bWVudFRyYW5zZm9ybWVyO1xuLyoqXG4gKiBDbGFzcyBmb3IgZG9jdW1lbnQgdHJhbnNmb3JtZXJzIHRoYXQgcmV0dXJuIGV4YWN0bHkgb25lIHRyYW5zZm9ybWVkIGRvY3VtZW50XG4gKiBmb3IgZWFjaCBpbnB1dCBkb2N1bWVudC5cbiAqL1xuY2xhc3MgTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXIgZXh0ZW5kcyBCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lciB7XG4gICAgYXN5bmMgdHJhbnNmb3JtRG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICBjb25zdCBuZXdEb2N1bWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRG9jdW1lbnQgPSBhd2FpdCB0aGlzLl90cmFuc2Zvcm1Eb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICBuZXdEb2N1bWVudHMucHVzaCh0cmFuc2Zvcm1lZERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RG9jdW1lbnRzO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFwcGluZ0RvY3VtZW50VHJhbnNmb3JtZXIgPSBNYXBwaW5nRG9jdW1lbnRUcmFuc2Zvcm1lcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/documents/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/embeddings.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Embeddings = void 0;\nconst async_caller_js_1 = __webpack_require__(/*! ./utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nclass Embeddings {\n    constructor(params) {\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n}\nexports.Embeddings = Embeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDBCQUEwQixtQkFBTyxDQUFDLGtHQUEwQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2VtYmVkZGluZ3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWJlZGRpbmdzID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfY2FsbGVyX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9hc3luY19jYWxsZXIuY2pzXCIpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtYmVkZGluZyBkb2N1bWVudHMgYW5kXG4gKiBxdWVyaWVzIHVzaW5nIExhbmdDaGFpbi5cbiAqL1xuY2xhc3MgRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXN5bmMgY2FsbGVyIHNob3VsZCBiZSB1c2VkIGJ5IHN1YmNsYXNzZXMgdG8gbWFrZSBhbnkgYXN5bmMgY2FsbHMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgdGh1cyBiZW5lZml0IGZyb20gdGhlIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBhc3luY19jYWxsZXJfanNfMS5Bc3luY0NhbGxlcihwYXJhbXMgPz8ge30pO1xuICAgIH1cbn1cbmV4cG9ydHMuRW1iZWRkaW5ncyA9IEVtYmVkZGluZ3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/errors/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-param-reassign */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addLangChainErrorFields = addLangChainErrorFields;\nfunction addLangChainErrorFields(error, lc_error_code) {\n    error.lc_error_code = lc_error_code;\n    error.message = `${error.message}\\n\\nTroubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/\\n`;\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvZXJyb3JzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxnRkFBZ0YsY0FBYztBQUNuSTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9lcnJvcnMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMgPSBhZGRMYW5nQ2hhaW5FcnJvckZpZWxkcztcbmZ1bmN0aW9uIGFkZExhbmdDaGFpbkVycm9yRmllbGRzKGVycm9yLCBsY19lcnJvcl9jb2RlKSB7XG4gICAgZXJyb3IubGNfZXJyb3JfY29kZSA9IGxjX2Vycm9yX2NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGAke2Vycm9yLm1lc3NhZ2V9XFxuXFxuVHJvdWJsZXNob290aW5nIFVSTDogaHR0cHM6Ly9qcy5sYW5nY2hhaW4uY29tL2RvY3MvdHJvdWJsZXNob290aW5nL2Vycm9ycy8ke2xjX2Vycm9yX2NvZGV9L1xcbmA7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/base.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseLanguageModel = exports.BaseLangChain = exports.calculateMaxTokens = exports.getModelContextSize = exports.getEmbeddingContextSize = exports.getModelNameForTiktoken = void 0;\nexports.isOpenAITool = isOpenAITool;\nconst base_js_1 = __webpack_require__(/*! ../caches/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/caches/base.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst tiktoken_js_1 = __webpack_require__(/*! ../utils/tiktoken.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\n// https://www.npmjs.com/package/js-tiktoken\nconst getModelNameForTiktoken = (modelName) => {\n    if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n        return \"gpt-3.5-turbo-16k\";\n    }\n    if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n        return \"gpt-3.5-turbo\";\n    }\n    if (modelName.startsWith(\"gpt-4-32k\")) {\n        return \"gpt-4-32k\";\n    }\n    if (modelName.startsWith(\"gpt-4-\")) {\n        return \"gpt-4\";\n    }\n    if (modelName.startsWith(\"gpt-4o\")) {\n        return \"gpt-4o\";\n    }\n    return modelName;\n};\nexports.getModelNameForTiktoken = getModelNameForTiktoken;\nconst getEmbeddingContextSize = (modelName) => {\n    switch (modelName) {\n        case \"text-embedding-ada-002\":\n            return 8191;\n        default:\n            return 2046;\n    }\n};\nexports.getEmbeddingContextSize = getEmbeddingContextSize;\nconst getModelContextSize = (modelName) => {\n    switch ((0, exports.getModelNameForTiktoken)(modelName)) {\n        case \"gpt-3.5-turbo-16k\":\n            return 16384;\n        case \"gpt-3.5-turbo\":\n            return 4096;\n        case \"gpt-4-32k\":\n            return 32768;\n        case \"gpt-4\":\n            return 8192;\n        case \"text-davinci-003\":\n            return 4097;\n        case \"text-curie-001\":\n            return 2048;\n        case \"text-babbage-001\":\n            return 2048;\n        case \"text-ada-001\":\n            return 2048;\n        case \"code-davinci-002\":\n            return 8000;\n        case \"code-cushman-001\":\n            return 2048;\n        default:\n            return 4097;\n    }\n};\nexports.getModelContextSize = getModelContextSize;\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nfunction isOpenAITool(tool) {\n    if (typeof tool !== \"object\" || !tool)\n        return false;\n    if (\"type\" in tool &&\n        tool.type === \"function\" &&\n        \"function\" in tool &&\n        typeof tool.function === \"object\" &&\n        tool.function &&\n        \"name\" in tool.function &&\n        \"parameters\" in tool.function) {\n        return true;\n    }\n    return false;\n}\nconst calculateMaxTokens = async ({ prompt, modelName, }) => {\n    let numTokens;\n    try {\n        numTokens = (await (0, tiktoken_js_1.encodingForModel)((0, exports.getModelNameForTiktoken)(modelName))).encode(prompt).length;\n    }\n    catch (error) {\n        console.warn(\"Failed to calculate number of tokens, falling back to approximate count\");\n        // fallback to approximate calculation if tiktoken is not available\n        // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n        numTokens = Math.ceil(prompt.length / 4);\n    }\n    const maxTokens = (0, exports.getModelContextSize)(modelName);\n    return maxTokens - numTokens;\n};\nexports.calculateMaxTokens = calculateMaxTokens;\nconst getVerbosity = () => false;\n/**\n * Base class for language models, chains, tools.\n */\nclass BaseLangChain extends base_js_2.Runnable {\n    get lc_attributes() {\n        return {\n            callbacks: undefined,\n            verbose: undefined,\n        };\n    }\n    constructor(params) {\n        super(params);\n        /**\n         * Whether to print out response text.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verbose = params.verbose ?? getVerbosity();\n        this.callbacks = params.callbacks;\n        this.tags = params.tags ?? [];\n        this.metadata = params.metadata ?? {};\n    }\n}\nexports.BaseLangChain = BaseLangChain;\n/**\n * Base class for language models.\n */\nclass BaseLanguageModel extends BaseLangChain {\n    /**\n     * Keys that the language model accepts as call options.\n     */\n    get callKeys() {\n        return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n    }\n    constructor({ callbacks, callbackManager, ...params }) {\n        const { cache, ...rest } = params;\n        super({\n            callbacks: callbacks ?? callbackManager,\n            ...rest,\n        });\n        /**\n         * The async caller should be used by subclasses to make any async calls,\n         * which will thus benefit from the concurrency and retry logic.\n         */\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_encoding\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof cache === \"object\") {\n            this.cache = cache;\n        }\n        else if (cache) {\n            this.cache = base_js_1.InMemoryCache.global();\n        }\n        else {\n            this.cache = undefined;\n        }\n        this.caller = new async_caller_js_1.AsyncCaller(params ?? {});\n    }\n    /**\n     * Get the number of tokens in the content.\n     * @param content The content to get the number of tokens for.\n     * @returns The number of tokens in the content.\n     */\n    async getNumTokens(content) {\n        // Extract text content from MessageContent\n        let textContent;\n        if (typeof content === \"string\") {\n            textContent = content;\n        }\n        else {\n            /**\n             * Content is an array of MessageContentComplex\n             *\n             * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n             * We need to find a better way to do this.\n             * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n             */\n            textContent = content\n                .map((item) => {\n                if (typeof item === \"string\")\n                    return item;\n                if (item.type === \"text\" && \"text\" in item)\n                    return item.text;\n                return \"\";\n            })\n                .join(\"\");\n        }\n        // fallback to approximate calculation if tiktoken is not available\n        let numTokens = Math.ceil(textContent.length / 4);\n        if (!this._encoding) {\n            try {\n                this._encoding = await (0, tiktoken_js_1.encodingForModel)(\"modelName\" in this\n                    ? (0, exports.getModelNameForTiktoken)(this.modelName)\n                    : \"gpt2\");\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        if (this._encoding) {\n            try {\n                numTokens = this._encoding.encode(textContent).length;\n            }\n            catch (error) {\n                console.warn(\"Failed to calculate number of tokens, falling back to approximate count\", error);\n            }\n        }\n        return numTokens;\n    }\n    static _convertInputToPromptValue(input) {\n        if (typeof input === \"string\") {\n            return new prompt_values_js_1.StringPromptValue(input);\n        }\n        else if (Array.isArray(input)) {\n            return new prompt_values_js_1.ChatPromptValue(input.map(utils_js_1.coerceMessageLikeToMessage));\n        }\n        else {\n            return input;\n        }\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * Create a unique cache key for a specific call to a specific language model.\n     * @param callOptions Call options for the model\n     * @returns A unique cache key.\n     */\n    _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const params = {\n            ...this._identifyingParams(),\n            ...callOptions,\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n        const filteredEntries = Object.entries(params).filter(([_, value]) => value !== undefined);\n        const serializedEntries = filteredEntries\n            .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n            .sort()\n            .join(\",\");\n        return serializedEntries;\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * @deprecated\n     * Load an LLM from a json-like object describing it.\n     */\n    static async deserialize(_data) {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n}\nexports.BaseLanguageModel = BaseLanguageModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLCtCQUErQjtBQUNoTCxvQkFBb0I7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMscUZBQW9CO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLHlGQUFzQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1Q0FBdUM7QUFDekQsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUksR0FBRyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlTGFuZ3VhZ2VNb2RlbCA9IGV4cG9ydHMuQmFzZUxhbmdDaGFpbiA9IGV4cG9ydHMuY2FsY3VsYXRlTWF4VG9rZW5zID0gZXhwb3J0cy5nZXRNb2RlbENvbnRleHRTaXplID0gZXhwb3J0cy5nZXRFbWJlZGRpbmdDb250ZXh0U2l6ZSA9IGV4cG9ydHMuZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4gPSB2b2lkIDA7XG5leHBvcnRzLmlzT3BlbkFJVG9vbCA9IGlzT3BlbkFJVG9vbDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWNoZXMvYmFzZS5janNcIik7XG5jb25zdCBwcm9tcHRfdmFsdWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vcHJvbXB0X3ZhbHVlcy5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL3V0aWxzLmNqc1wiKTtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5janNcIik7XG5jb25zdCB0aWt0b2tlbl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3Rpa3Rva2VuLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMiA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvYmFzZS5janNcIik7XG4vLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qcy10aWt0b2tlblxuY29uc3QgZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4gPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTMuNS10dXJiby0xNmtcIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTMuNS10dXJiby0xNmtcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTMuNS10dXJiby1cIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTMuNS10dXJib1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtNC0zMmtcIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTQtMzJrXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00LVwiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNFwiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtNG9cIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTRvXCI7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbE5hbWU7XG59O1xuZXhwb3J0cy5nZXRNb2RlbE5hbWVGb3JUaWt0b2tlbiA9IGdldE1vZGVsTmFtZUZvclRpa3Rva2VuO1xuY29uc3QgZ2V0RW1iZWRkaW5nQ29udGV4dFNpemUgPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgc3dpdGNoIChtb2RlbE5hbWUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIjpcbiAgICAgICAgICAgIHJldHVybiA4MTkxO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDIwNDY7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0RW1iZWRkaW5nQ29udGV4dFNpemUgPSBnZXRFbWJlZGRpbmdDb250ZXh0U2l6ZTtcbmNvbnN0IGdldE1vZGVsQ29udGV4dFNpemUgPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgc3dpdGNoICgoMCwgZXhwb3J0cy5nZXRNb2RlbE5hbWVGb3JUaWt0b2tlbikobW9kZWxOYW1lKSkge1xuICAgICAgICBjYXNlIFwiZ3B0LTMuNS10dXJiby0xNmtcIjpcbiAgICAgICAgICAgIHJldHVybiAxNjM4NDtcbiAgICAgICAgY2FzZSBcImdwdC0zLjUtdHVyYm9cIjpcbiAgICAgICAgICAgIHJldHVybiA0MDk2O1xuICAgICAgICBjYXNlIFwiZ3B0LTQtMzJrXCI6XG4gICAgICAgICAgICByZXR1cm4gMzI3Njg7XG4gICAgICAgIGNhc2UgXCJncHQtNFwiOlxuICAgICAgICAgICAgcmV0dXJuIDgxOTI7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAzXCI6XG4gICAgICAgICAgICByZXR1cm4gNDA5NztcbiAgICAgICAgY2FzZSBcInRleHQtY3VyaWUtMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgY2FzZSBcInRleHQtYmFiYmFnZS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwidGV4dC1hZGEtMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgY2FzZSBcImNvZGUtZGF2aW5jaS0wMDJcIjpcbiAgICAgICAgICAgIHJldHVybiA4MDAwO1xuICAgICAgICBjYXNlIFwiY29kZS1jdXNobWFuLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gNDA5NztcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRNb2RlbENvbnRleHRTaXplID0gZ2V0TW9kZWxDb250ZXh0U2l6ZTtcbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGlucHV0IG1hdGNoZXMgdGhlIE9wZW5BSSB0b29sIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge3Vua25vd259IHRvb2wgVGhlIGlucHV0IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGlucHV0IGlzIGFuIE9wZW5BSSB0b29sIGRlZmluaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGlzT3BlbkFJVG9vbCh0b29sKSB7XG4gICAgaWYgKHR5cGVvZiB0b29sICE9PSBcIm9iamVjdFwiIHx8ICF0b29sKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFwidHlwZVwiIGluIHRvb2wgJiZcbiAgICAgICAgdG9vbC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiIGluIHRvb2wgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wuZnVuY3Rpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdG9vbC5mdW5jdGlvbiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sLmZ1bmN0aW9uICYmXG4gICAgICAgIFwicGFyYW1ldGVyc1wiIGluIHRvb2wuZnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGNhbGN1bGF0ZU1heFRva2VucyA9IGFzeW5jICh7IHByb21wdCwgbW9kZWxOYW1lLCB9KSA9PiB7XG4gICAgbGV0IG51bVRva2VucztcbiAgICB0cnkge1xuICAgICAgICBudW1Ub2tlbnMgPSAoYXdhaXQgKDAsIHRpa3Rva2VuX2pzXzEuZW5jb2RpbmdGb3JNb2RlbCkoKDAsIGV4cG9ydHMuZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4pKG1vZGVsTmFtZSkpKS5lbmNvZGUocHJvbXB0KS5sZW5ndGg7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiKTtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwcm94aW1hdGUgY2FsY3VsYXRpb24gaWYgdGlrdG9rZW4gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAvLyBlYWNoIHRva2VuIGlzIH40IGNoYXJhY3RlcnM6IGh0dHBzOi8vaGVscC5vcGVuYWkuY29tL2VuL2FydGljbGVzLzQ5MzY4NTYtd2hhdC1hcmUtdG9rZW5zLWFuZC1ob3ctdG8tY291bnQtdGhlbSNcbiAgICAgICAgbnVtVG9rZW5zID0gTWF0aC5jZWlsKHByb21wdC5sZW5ndGggLyA0KTtcbiAgICB9XG4gICAgY29uc3QgbWF4VG9rZW5zID0gKDAsIGV4cG9ydHMuZ2V0TW9kZWxDb250ZXh0U2l6ZSkobW9kZWxOYW1lKTtcbiAgICByZXR1cm4gbWF4VG9rZW5zIC0gbnVtVG9rZW5zO1xufTtcbmV4cG9ydHMuY2FsY3VsYXRlTWF4VG9rZW5zID0gY2FsY3VsYXRlTWF4VG9rZW5zO1xuY29uc3QgZ2V0VmVyYm9zaXR5ID0gKCkgPT4gZmFsc2U7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxhbmd1YWdlIG1vZGVscywgY2hhaW5zLCB0b29scy5cbiAqL1xuY2xhc3MgQmFzZUxhbmdDaGFpbiBleHRlbmRzIGJhc2VfanNfMi5SdW5uYWJsZSB7XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZlcmJvc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIHByaW50IG91dCByZXNwb25zZSB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBwYXJhbXMudmVyYm9zZSA/PyBnZXRWZXJib3NpdHkoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBwYXJhbXMudGFncyA/PyBbXTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHBhcmFtcy5tZXRhZGF0YSA/PyB7fTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VMYW5nQ2hhaW4gPSBCYXNlTGFuZ0NoYWluO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYW5ndWFnZSBtb2RlbHMuXG4gKi9cbmNsYXNzIEJhc2VMYW5ndWFnZU1vZGVsIGV4dGVuZHMgQmFzZUxhbmdDaGFpbiB7XG4gICAgLyoqXG4gICAgICogS2V5cyB0aGF0IHRoZSBsYW5ndWFnZSBtb2RlbCBhY2NlcHRzIGFzIGNhbGwgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgY2FsbEtleXMoKSB7XG4gICAgICAgIHJldHVybiBbXCJzdG9wXCIsIFwidGltZW91dFwiLCBcInNpZ25hbFwiLCBcInRhZ3NcIiwgXCJtZXRhZGF0YVwiLCBcImNhbGxiYWNrc1wiXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBjYWxsYmFja3MsIGNhbGxiYWNrTWFuYWdlciwgLi4ucGFyYW1zIH0pIHtcbiAgICAgICAgY29uc3QgeyBjYWNoZSwgLi4ucmVzdCB9ID0gcGFyYW1zO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBjYWxsYmFja3M6IGNhbGxiYWNrcyA/PyBjYWxsYmFja01hbmFnZXIsXG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhc3luYyBjYWxsZXIgc2hvdWxkIGJlIHVzZWQgYnkgc3ViY2xhc3NlcyB0byBtYWtlIGFueSBhc3luYyBjYWxscyxcbiAgICAgICAgICogd2hpY2ggd2lsbCB0aHVzIGJlbmVmaXQgZnJvbSB0aGUgY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbmNvZGluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGNhY2hlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBiYXNlX2pzXzEuSW5NZW1vcnlDYWNoZS5nbG9iYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyX2pzXzEuQXN5bmNDYWxsZXIocGFyYW1zID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IHRvIGdldCB0aGUgbnVtYmVyIG9mIHRva2VucyBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TnVtVG9rZW5zKGNvbnRlbnQpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IGNvbnRlbnQgZnJvbSBNZXNzYWdlQ29udGVudFxuICAgICAgICBsZXQgdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb250ZW50IGlzIGFuIGFycmF5IG9mIE1lc3NhZ2VDb250ZW50Q29tcGxleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRvRG8oQGNocmlzdGlhbi1icm9tYW5uKTogVGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggdG8gZ2V0IHRoZSBudW1iZXIgb2YgdG9rZW5zIGZvciB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9wdWxsLzgzNDEjcHVsbHJlcXVlc3RyZXZpZXctMjkzMzcxMzExNlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0ZXh0Q29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHByb3hpbWF0ZSBjYWxjdWxhdGlvbiBpZiB0aWt0b2tlbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGxldCBudW1Ub2tlbnMgPSBNYXRoLmNlaWwodGV4dENvbnRlbnQubGVuZ3RoIC8gNCk7XG4gICAgICAgIGlmICghdGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBhd2FpdCAoMCwgdGlrdG9rZW5fanNfMS5lbmNvZGluZ0Zvck1vZGVsKShcIm1vZGVsTmFtZVwiIGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgZXhwb3J0cy5nZXRNb2RlbE5hbWVGb3JUaWt0b2tlbikodGhpcy5tb2RlbE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogXCJncHQyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbmNvZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBudW1Ub2tlbnMgPSB0aGlzLl9lbmNvZGluZy5lbmNvZGUodGV4dENvbnRlbnQpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtVG9rZW5zO1xuICAgIH1cbiAgICBzdGF0aWMgX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9tcHRfdmFsdWVzX2pzXzEuU3RyaW5nUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb21wdF92YWx1ZXNfanNfMS5DaGF0UHJvbXB0VmFsdWUoaW5wdXQubWFwKHV0aWxzX2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aWZ5aW5nIHBhcmFtZXRlcnMgb2YgdGhlIExMTS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9pZGVudGlmeWluZ1BhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB1bmlxdWUgY2FjaGUga2V5IGZvciBhIHNwZWNpZmljIGNhbGwgdG8gYSBzcGVjaWZpYyBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0gY2FsbE9wdGlvbnMgQ2FsbCBvcHRpb25zIGZvciB0aGUgbW9kZWxcbiAgICAgKiBAcmV0dXJucyBBIHVuaXF1ZSBjYWNoZSBrZXkuXG4gICAgICovXG4gICAgX2dldFNlcmlhbGl6ZWRDYWNoZUtleVBhcmFtZXRlcnNGb3JDYWxsKFxuICAgIC8vIFRPRE86IEZpeCB3aGVuIHdlIHJlbW92ZSB0aGUgUnVubmFibGVMYW1iZGEgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgc2hpbS5cbiAgICB7IGNvbmZpZywgLi4uY2FsbE9wdGlvbnMgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLl9pZGVudGlmeWluZ1BhcmFtcygpLFxuICAgICAgICAgICAgLi4uY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fbGxtVHlwZSgpLFxuICAgICAgICAgICAgX21vZGVsOiB0aGlzLl9tb2RlbFR5cGUoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkRW50cmllcyA9IGZpbHRlcmVkRW50cmllc1xuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApXG4gICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkRW50cmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm4gYSBqc29uLWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIExMTS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLl9pZGVudGlmeWluZ1BhcmFtcygpLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogTG9hZCBhbiBMTE0gZnJvbSBhIGpzb24tbGlrZSBvYmplY3QgZGVzY3JpYmluZyBpdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoX2RhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIC50b0pTT04oKSBpbnN0ZWFkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUxhbmd1YWdlTW9kZWwgPSBCYXNlTGFuZ3VhZ2VNb2RlbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/chat_models.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleChatModel = exports.BaseChatModel = void 0;\nexports.createChatMessageChunkEncoderStream = createChatMessageChunkEncoderStream;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ../runnables/passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst base_js_3 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nfunction createChatMessageChunkEncoderStream() {\n    const textEncoder = new TextEncoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                ? chunk.content\n                : JSON.stringify(chunk.content)));\n        },\n    });\n}\nfunction _formatForTracing(messages) {\n    const messagesToTrace = [];\n    for (const message of messages) {\n        let messageToTrace = message;\n        if (Array.isArray(message.content)) {\n            for (let idx = 0; idx < message.content.length; idx++) {\n                const block = message.content[idx];\n                if ((0, index_js_1.isURLContentBlock)(block) || (0, index_js_1.isBase64ContentBlock)(block)) {\n                    if (messageToTrace === message) {\n                        // Also shallow-copy content\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        messageToTrace = new message.constructor({\n                            ...messageToTrace,\n                            content: [\n                                ...message.content.slice(0, idx),\n                                (0, index_js_1.convertToOpenAIImageBlock)(block),\n                                ...message.content.slice(idx + 1),\n                            ],\n                        });\n                    }\n                }\n            }\n        }\n        messagesToTrace.push(messageToTrace);\n    }\n    return messagesToTrace;\n}\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nclass BaseChatModel extends base_js_1.BaseLanguageModel {\n    constructor(fields) {\n        super(fields);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"chat_models\", this._llmType()]\n        });\n        Object.defineProperty(this, \"disableStreaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    /**\n     * Invokes the chat model with a single input.\n     * @param input The input for the language model.\n     * @param options The call options.\n     * @returns A Promise that resolves to a BaseMessageChunk.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseChatModel._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        const chatGeneration = result.generations[0][0];\n        // TODO: Remove cast after figuring out inheritance\n        return chatGeneration.message;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_messages, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks ===\n            BaseChatModel.prototype._streamResponseChunks ||\n            this.disableStreaming) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseChatModel._convertInputToPromptValue(input);\n            const messages = prompt.toChatMessages();\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const inheritableMetadata = {\n                ...runnableConfig.metadata,\n                ...this.getLsParams(callOptions),\n            };\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generationChunk;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let llmOutput;\n            try {\n                for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    chunk.message.response_metadata = {\n                        ...chunk.generationInfo,\n                        ...chunk.message.response_metadata,\n                    };\n                    yield chunk.message;\n                    if (!generationChunk) {\n                        generationChunk = chunk;\n                    }\n                    else {\n                        generationChunk = generationChunk.concat(chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                // TODO: Remove cast after figuring out inheritance\n                generations: [[generationChunk]],\n                llmOutput,\n            })));\n        }\n    }\n    getLsParams(options) {\n        const providerName = this.getName().startsWith(\"Chat\")\n            ? this.getName().replace(\"Chat\", \"\")\n            : this.getName();\n        return {\n            ls_model_type: \"chat\",\n            ls_stop: options.stop,\n            ls_provider: providerName,\n        };\n    }\n    /** @ignore */\n    async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === baseMessages.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const inheritableMetadata = {\n                ...handledOptions.metadata,\n                ...this.getLsParams(parsedOptions),\n            };\n            // create callback manager and start run\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: 1,\n            };\n            runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        }\n        const generations = [];\n        const llmOutputs = [];\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(base_js_3.callbackHandlerPrefersStreaming);\n        if (hasStreamingHandler &&\n            !this.disableStreaming &&\n            baseMessages.length === 1 &&\n            this._streamResponseChunks !==\n                BaseChatModel.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let llmOutput;\n                for await (const chunk of stream) {\n                    if (chunk.message.id == null) {\n                        const runId = runManagers?.at(0)?.runId;\n                        if (runId != null)\n                            chunk.message._updateId(`run-${runId}`);\n                    }\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                    if ((0, index_js_1.isAIMessageChunk)(chunk.message) &&\n                        chunk.message.usage_metadata !== undefined) {\n                        llmOutput = {\n                            tokenUsage: {\n                                promptTokens: chunk.message.usage_metadata.input_tokens,\n                                completionTokens: chunk.message.usage_metadata.output_tokens,\n                                totalTokens: chunk.message.usage_metadata.total_tokens,\n                            },\n                        };\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                generations.push([aggregated]);\n                await runManagers?.[0].handleLLMEnd({\n                    generations,\n                    llmOutput,\n                });\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            // generate results\n            const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n            // handle results\n            await Promise.all(results.map(async (pResult, i) => {\n                if (pResult.status === \"fulfilled\") {\n                    const result = pResult.value;\n                    for (const generation of result.generations) {\n                        if (generation.message.id == null) {\n                            const runId = runManagers?.at(0)?.runId;\n                            if (runId != null)\n                                generation.message._updateId(`run-${runId}`);\n                        }\n                        generation.message.response_metadata = {\n                            ...generation.generationInfo,\n                            ...generation.message.response_metadata,\n                        };\n                    }\n                    if (result.generations.length === 1) {\n                        result.generations[0].message.response_metadata = {\n                            ...result.llmOutput,\n                            ...result.generations[0].message.response_metadata,\n                        };\n                    }\n                    generations[i] = result.generations;\n                    llmOutputs[i] = result.llmOutput;\n                    return runManagers?.[i]?.handleLLMEnd({\n                        generations: [result.generations],\n                        llmOutput: result.llmOutput,\n                    });\n                }\n                else {\n                    // status === \"rejected\"\n                    await runManagers?.[i]?.handleLLMError(pResult.reason);\n                    return Promise.reject(pResult.reason);\n                }\n            }));\n        }\n        // create combined output\n        const output = {\n            generations,\n            llmOutput: llmOutputs.length\n                ? this._combineLLMOutput?.(...llmOutputs)\n                : undefined,\n        };\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const inheritableMetadata = {\n            ...handledOptions.metadata,\n            ...this.getLsParams(parsedOptions),\n        };\n        // create callback manager and start run\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n            // Join all content into one string for the prompt index\n            const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    if (\"message\" in result &&\n                        (0, index_js_1.isBaseMessage)(result.message) &&\n                        (0, index_js_1.isAIMessage)(result.message)) {\n                        // eslint-disable-next-line no-param-reassign\n                        result.message.usage_metadata = {\n                            input_tokens: 0,\n                            output_tokens: 0,\n                            total_tokens: 0,\n                        };\n                    }\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Generates chat based on the input messages.\n     * @param messages An array of arrays of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generate(messages, options, callbacks) {\n        // parse call options\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const baseMessages = messages.map((messageList) => messageList.map(index_js_1.coerceMessageLikeToMessage));\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(baseMessages, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            messages: baseMessages,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                // Join all content into one string for the prompt index\n                const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                return cache.update(prompt, llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _modelType() {\n        return \"base_chat_model\";\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this.invocationParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * Generates a prompt based on the input prompt values.\n     * @param promptValues An array of BasePromptValue instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n        return this.generate(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async call(messages, options, callbacks) {\n        const result = await this.generate([messages.map(index_js_1.coerceMessageLikeToMessage)], options, callbacks);\n        const generations = result.generations;\n        return generations[0][0].message;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model with a prompt value.\n     * @param promptValue The value of the prompt.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async callPrompt(promptValue, options, callbacks) {\n        const promptMessages = promptValue.toChatMessages();\n        return this.call(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on the input messages.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async predictMessages(messages, options, callbacks) {\n        return this.call(messages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on a text input.\n     * @param text The text input.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a string.\n     */\n    async predict(text, options, callbacks) {\n        const message = new index_js_1.HumanMessage(text);\n        const result = await this.call([message], options, callbacks);\n        if (typeof result.content !== \"string\") {\n            throw new Error(\"Cannot use predict when output is not a string.\");\n        }\n        return result.content;\n    }\n    withStructuredOutput(outputSchema, config) {\n        if (typeof this.bindTools !== \"function\") {\n            throw new Error(`Chat model must implement \".bindTools()\" to use withStructuredOutput.`);\n        }\n        if (config?.strict) {\n            throw new Error(`\"strict\" mode is not supported for this model by default.`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const description = (0, zod_js_1.getSchemaDescription)(schema) ?? \"A function available to call.\";\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let tools;\n        if ((0, zod_js_1.isInteropZodSchema)(schema)) {\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: (0, json_schema_js_1.toJsonSchema)(schema),\n                    },\n                },\n            ];\n        }\n        else {\n            if (\"name\" in schema) {\n                functionName = schema.name;\n            }\n            tools = [\n                {\n                    type: \"function\",\n                    function: {\n                        name: functionName,\n                        description,\n                        parameters: schema,\n                    },\n                },\n            ];\n        }\n        const llm = this.bindTools(tools);\n        const outputParser = base_js_2.RunnableLambda.from((input) => {\n            if (!input.tool_calls || input.tool_calls.length === 0) {\n                throw new Error(\"No tool calls found in the response.\");\n            }\n            const toolCall = input.tool_calls.find((tc) => tc.name === functionName);\n            if (!toolCall) {\n                throw new Error(`No tool call found with name ${functionName}.`);\n            }\n            return toolCall.args;\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"StructuredOutput\",\n            });\n        }\n        const parserAssign = passthrough_js_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = passthrough_js_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return base_js_2.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.BaseChatModel = BaseChatModel;\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nclass SimpleChatModel extends BaseChatModel {\n    async _generate(messages, options, runManager) {\n        const text = await this._call(messages, options, runManager);\n        const message = new index_js_1.AIMessage(text);\n        if (typeof message.content !== \"string\") {\n            throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n        }\n        return {\n            generations: [\n                {\n                    text: message.content,\n                    message,\n                },\n            ],\n        };\n    }\n}\nexports.SimpleChatModel = SimpleChatModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUI7QUFDL0MsMkNBQTJDO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsc0ZBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMseUdBQThCO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzNEO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa01BQWtNLHVCQUF1QjtBQUN6TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrTUFBa00sdUJBQXVCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxrQ0FBa0M7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLHVCQUF1QjtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxtQ0FBbUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0Isd0RBQXdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlQ2hhdE1vZGVsID0gZXhwb3J0cy5CYXNlQ2hhdE1vZGVsID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVDaGF0TWVzc2FnZUNodW5rRW5jb2RlclN0cmVhbSA9IGNyZWF0ZUNoYXRNZXNzYWdlQ2h1bmtFbmNvZGVyU3RyZWFtO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9pbmRleC5janNcIik7XG5jb25zdCBvdXRwdXRzX2pzXzEgPSByZXF1aXJlKFwiLi4vb3V0cHV0cy5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2Jhc2UuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNvbnN0IHBhc3N0aHJvdWdoX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL3Bhc3N0aHJvdWdoLmNqc1wiKTtcbmNvbnN0IHpvZF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3R5cGVzL3pvZC5janNcIik7XG5jb25zdCBiYXNlX2pzXzMgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL2Jhc2UuY2pzXCIpO1xuY29uc3QganNvbl9zY2hlbWFfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uX3NjaGVtYS5janNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIGZvciBlbmNvZGluZyBjaGF0IG1lc3NhZ2UgY2h1bmtzLlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBCeXRlc091dHB1dFBhcnNlcn0gaW5zdGVhZFxuICogQHJldHVybnMgQSBUcmFuc2Zvcm1TdHJlYW0gaW5zdGFuY2UgdGhhdCBlbmNvZGVzIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYXRNZXNzYWdlQ2h1bmtFbmNvZGVyU3RyZWFtKCkge1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUodHlwZW9mIGNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGNodW5rLmNvbnRlbnRcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGNodW5rLmNvbnRlbnQpKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZm9ybWF0Rm9yVHJhY2luZyhtZXNzYWdlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VzVG9UcmFjZSA9IFtdO1xuICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgbWVzc2FnZVRvVHJhY2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBtZXNzYWdlLmNvbnRlbnQubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gbWVzc2FnZS5jb250ZW50W2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18xLmlzVVJMQ29udGVudEJsb2NrKShibG9jaykgfHwgKDAsIGluZGV4X2pzXzEuaXNCYXNlNjRDb250ZW50QmxvY2spKGJsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVRvVHJhY2UgPT09IG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gc2hhbGxvdy1jb3B5IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVG9UcmFjZSA9IG5ldyBtZXNzYWdlLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlVG9UcmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2UuY29udGVudC5zbGljZSgwLCBpZHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5jb252ZXJ0VG9PcGVuQUlJbWFnZUJsb2NrKShibG9jayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2UuY29udGVudC5zbGljZShpZHggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZXNUb1RyYWNlLnB1c2gobWVzc2FnZVRvVHJhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXNUb1RyYWNlO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjaGF0IG1vZGVscy4gSXQgZXh0ZW5kcyB0aGUgQmFzZUxhbmd1YWdlTW9kZWwgY2xhc3MgYW5kXG4gKiBwcm92aWRlcyBtZXRob2RzIGZvciBnZW5lcmF0aW5nIGNoYXQgYmFzZWQgb24gaW5wdXQgbWVzc2FnZXMuXG4gKi9cbmNsYXNzIEJhc2VDaGF0TW9kZWwgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZUxhbmd1YWdlTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICAvLyBPbmx5IGV2ZXIgaW5zdGFudGlhdGVkIGluIG1haW4gTGFuZ0NoYWluXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwiY2hhdF9tb2RlbHNcIiwgdGhpcy5fbGxtVHlwZSgpXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzYWJsZVN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQsIGtlZXAgYHNpZ25hbGAgaW4gYm90aCBydW5uYWJsZUNvbmZpZyBhbmQgY2FsbE9wdGlvbnNcbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSBzdXBlci5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY2FsbE9wdGlvbnMuc2lnbmFsID0gcnVubmFibGVDb25maWcuc2lnbmFsO1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGNoYXQgbW9kZWwgd2l0aCBhIHNpbmdsZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlQ2h1bmsuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb21wdFZhbHVlID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVQcm9tcHQoW3Byb21wdFZhbHVlXSwgb3B0aW9ucywgb3B0aW9ucz8uY2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgY2hhdEdlbmVyYXRpb24gPSByZXN1bHQuZ2VuZXJhdGlvbnNbMF1bMF07XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0IGFmdGVyIGZpZ3VyaW5nIG91dCBpbmhlcml0YW5jZVxuICAgICAgICByZXR1cm4gY2hhdEdlbmVyYXRpb24ubWVzc2FnZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUteWllbGRcbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKF9tZXNzYWdlcywgX29wdGlvbnMsIF9ydW5NYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gU3ViY2xhc3MgY2hlY2sgcmVxdWlyZWQgdG8gYXZvaWQgZG91YmxlIGNhbGxiYWNrcyB3aXRoIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzID09PVxuICAgICAgICAgICAgQmFzZUNoYXRNb2RlbC5wcm90b3R5cGUuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzIHx8XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBwcm9tcHQudG9DaGF0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4ucnVubmFibGVDb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRMc1BhcmFtcyhjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIHJ1bm5hYmxlQ29uZmlnLnRhZ3MsIHRoaXMudGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBjYWxsT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYXRNb2RlbFN0YXJ0KHRoaXMudG9KU09OKCksIFtfZm9ybWF0Rm9yVHJhY2luZyhtZXNzYWdlcyldLCBydW5uYWJsZUNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJ1bm5hYmxlQ29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICAgICAgbGV0IGdlbmVyYXRpb25DaHVuaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgbGxtT3V0cHV0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBjYWxsT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2UuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuSWQgPSBydW5NYW5hZ2Vycz8uYXQoMCk/LnJ1bklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bklkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS5fdXBkYXRlSWQoYHJ1bi0ke3J1bklkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuay5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2VuZXJhdGlvbkNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25DaHVuayA9IGdlbmVyYXRpb25DaHVuay5jb25jYXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0FJTWVzc2FnZUNodW5rKShjaHVuay5tZXNzYWdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEuaW5wdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLm91dHB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLnRvdGFsX3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0IGFmdGVyIGZpZ3VyaW5nIG91dCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbW2dlbmVyYXRpb25DaHVua11dLFxuICAgICAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0THNQYXJhbXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlck5hbWUgPSB0aGlzLmdldE5hbWUoKS5zdGFydHNXaXRoKFwiQ2hhdFwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE5hbWUoKS5yZXBsYWNlKFwiQ2hhdFwiLCBcIlwiKVxuICAgICAgICAgICAgOiB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX21vZGVsX3R5cGU6IFwiY2hhdFwiLFxuICAgICAgICAgICAgbHNfc3RvcDogb3B0aW9ucy5zdG9wLFxuICAgICAgICAgICAgbHNfcHJvdmlkZXI6IHByb3ZpZGVyTmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfZ2VuZXJhdGVVbmNhY2hlZChtZXNzYWdlcywgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMsIHN0YXJ0ZWRSdW5NYW5hZ2Vycykge1xuICAgICAgICBjb25zdCBiYXNlTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0KSA9PiBtZXNzYWdlTGlzdC5tYXAoaW5kZXhfanNfMS5jb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSkpO1xuICAgICAgICBsZXQgcnVuTWFuYWdlcnM7XG4gICAgICAgIGlmIChzdGFydGVkUnVuTWFuYWdlcnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhcnRlZFJ1bk1hbmFnZXJzLmxlbmd0aCA9PT0gYmFzZU1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBzdGFydGVkUnVuTWFuYWdlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIC4uLmhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0THNQYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY3JlYXRlIGNhbGxiYWNrIG1hbmFnZXIgYW5kIHN0YXJ0IHJ1blxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBiYXNlTWVzc2FnZXMubWFwKF9mb3JtYXRGb3JUcmFjaW5nKSwgaGFuZGxlZE9wdGlvbnMucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucy5ydW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBsbG1PdXRwdXRzID0gW107XG4gICAgICAgIC8vIEV2ZW4gaWYgc3RyZWFtIGlzIG5vdCBleHBsaWNpdGx5IGNhbGxlZCwgY2hlY2sgaWYgbW9kZWwgaXMgaW1wbGljaXRseVxuICAgICAgICAvLyBjYWxsZWQgZnJvbSBzdHJlYW1FdmVudHMoKSBvciBzdHJlYW1Mb2coKSB0byBnZXQgYWxsIHN0cmVhbWVkIGV2ZW50cy5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgX3N0cmVhbVJlc3BvbnNlQ2h1bmtzIG5vdCBvdmVycmlkZGVuXG4gICAgICAgIGNvbnN0IGhhc1N0cmVhbWluZ0hhbmRsZXIgPSAhIXJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlcnMuZmluZChiYXNlX2pzXzMuY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyk7XG4gICAgICAgIGlmIChoYXNTdHJlYW1pbmdIYW5kbGVyICYmXG4gICAgICAgICAgICAhdGhpcy5kaXNhYmxlU3RyZWFtaW5nICYmXG4gICAgICAgICAgICBiYXNlTWVzc2FnZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyAhPT1cbiAgICAgICAgICAgICAgICBCYXNlQ2hhdE1vZGVsLnByb3RvdHlwZS5fc3RyZWFtUmVzcG9uc2VDaHVua3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MoYmFzZU1lc3NhZ2VzWzBdLCBwYXJzZWRPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKTtcbiAgICAgICAgICAgICAgICBsZXQgYWdncmVnYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGxldCBsbG1PdXRwdXQ7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2UuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuSWQgPSBydW5NYW5hZ2Vycz8uYXQoMCk/LnJ1bklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bklkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS5fdXBkYXRlSWQoYHJ1bi0ke3J1bklkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShhZ2dyZWdhdGVkLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc18xLmlzQUlNZXNzYWdlQ2h1bmspKGNodW5rLm1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5pbnB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEub3V0cHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEudG90YWxfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgZW1wdHkgcmVzcG9uc2UgZnJvbSBjaGF0IG1vZGVsIGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9ucy5wdXNoKFthZ2dyZWdhdGVkXSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcnM/LlswXS5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSByZXN1bHRzXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGJhc2VNZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0LCBpKSA9PiB0aGlzLl9nZW5lcmF0ZShtZXNzYWdlTGlzdCwgeyAuLi5wYXJzZWRPcHRpb25zLCBwcm9tcHRJbmRleDogaSB9LCBydW5NYW5hZ2Vycz8uW2ldKSkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHJlc3VsdHNcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKGFzeW5jIChwUmVzdWx0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBSZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGlvbiBvZiByZXN1bHQuZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlLl91cGRhdGVJZChgcnVuLSR7cnVuSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2VuZXJhdGlvbi5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZW5lcmF0aW9uLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZ2VuZXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2VuZXJhdGlvbnNbMF0ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5nZW5lcmF0aW9uc1swXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uc1tpXSA9IHJlc3VsdC5nZW5lcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0c1tpXSA9IHJlc3VsdC5sbG1PdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2Vycz8uW2ldPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtyZXN1bHQuZ2VuZXJhdGlvbnNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0OiByZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5baV0/LmhhbmRsZUxMTUVycm9yKHBSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGNvbWJpbmVkIG91dHB1dFxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIGxsbU91dHB1dDogbGxtT3V0cHV0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2NvbWJpbmVMTE1PdXRwdXQ/LiguLi5sbG1PdXRwdXRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBvdXRwdXRzX2pzXzEuUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bk1hbmFnZXJzXG4gICAgICAgICAgICAgICAgPyB7IHJ1bklkczogcnVuTWFuYWdlcnM/Lm1hcCgobWFuYWdlcikgPT4gbWFuYWdlci5ydW5JZCkgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgX2dlbmVyYXRlQ2FjaGVkKHsgbWVzc2FnZXMsIGNhY2hlLCBsbG1TdHJpbmdLZXksIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCB9KSB7XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QpID0+IG1lc3NhZ2VMaXN0Lm1hcChpbmRleF9qc18xLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IGluaGVyaXRhYmxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5oYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0THNQYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSBjYWxsYmFjayBtYW5hZ2VyIGFuZCBzdGFydCBydW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgYmF0Y2hfc2l6ZTogMSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBiYXNlTWVzc2FnZXMubWFwKF9mb3JtYXRGb3JUcmFjaW5nKSwgaGFuZGxlZE9wdGlvbnMucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucy5ydW5OYW1lKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgcmVzdWx0c1xuICAgICAgICBjb25zdCBtaXNzaW5nUHJvbXB0SW5kaWNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGJhc2VNZXNzYWdlcy5tYXAoYXN5bmMgKGJhc2VNZXNzYWdlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gSm9pbiBhbGwgY29udGVudCBpbnRvIG9uZSBzdHJpbmcgZm9yIHRoZSBwcm9tcHQgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoYmFzZU1lc3NhZ2UpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5sb29rdXAocHJvbXB0LCBsbG1TdHJpbmdLZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIE1hcCBydW4gbWFuYWdlcnMgdG8gdGhlIHJlc3VsdHMgYmVmb3JlIGZpbHRlcmluZyBvdXQgbnVsbCByZXN1bHRzXG4gICAgICAgIC8vIE51bGwgcmVzdWx0cyBhcmUganVzdCBhYnNlbnQgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdHMgPSByZXN1bHRzXG4gICAgICAgICAgICAubWFwKChyZXN1bHQsIGluZGV4KSA9PiAoeyByZXN1bHQsIHJ1bk1hbmFnZXI6IHJ1bk1hbmFnZXJzPy5baW5kZXhdIH0pKVxuICAgICAgICAgICAgLmZpbHRlcigoeyByZXN1bHQgfSkgPT4gKHJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgJiYgcmVzdWx0LnZhbHVlICE9IG51bGwpIHx8XG4gICAgICAgICAgICByZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIpO1xuICAgICAgICAvLyBIYW5kbGUgcmVzdWx0cyBhbmQgY2FsbCBydW4gbWFuYWdlcnNcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVkUmVzdWx0cy5tYXAoYXN5bmMgKHsgcmVzdWx0OiBwcm9taXNlUmVzdWx0LCBydW5NYW5hZ2VyIH0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlUmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb21pc2VSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbaV0gPSByZXN1bHQubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIHJlc3VsdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkocmVzdWx0Lm1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5pc0FJTWVzc2FnZSkocmVzdWx0Lm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlLnVzYWdlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZW5lcmF0aW9uSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHJlc3VsdFswXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbcmVzdWx0XSxcbiAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IocHJvbWlzZVJlc3VsdC5yZWFzb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcyxcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2VyczogcnVuTWFuYWdlcnMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZGVmaW5lcyBSVU5fS0VZIGFzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG91dHB1dCBvYmplY3RcbiAgICAgICAgLy8gc28gdGhhdCBpdCBpcyBub3Qgc2VyaWFsaXplZCB3aGVuIHRoZSBvdXRwdXQgaXMgc3RyaW5naWZpZWQsIGFuZCBzbyB0aGF0XG4gICAgICAgIC8vIGl0IGlzbnQgaW5jbHVkZWQgd2hlbiBsaXN0aW5nIHRoZSBrZXlzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3V0cHV0LCBvdXRwdXRzX2pzXzEuUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bk1hbmFnZXJzXG4gICAgICAgICAgICAgICAgPyB7IHJ1bklkczogcnVuTWFuYWdlcnM/Lm1hcCgobWFuYWdlcikgPT4gbWFuYWdlci5ydW5JZCkgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGNoYXQgYmFzZWQgb24gdGhlIGlucHV0IG1lc3NhZ2VzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBBbiBhcnJheSBvZiBhcnJheXMgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gTExNUmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gcGFyc2UgY2FsbCBvcHRpb25zXG4gICAgICAgIGxldCBwYXJzZWRPcHRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucyA9IHsgc3RvcDogb3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZU1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlTGlzdCkgPT4gbWVzc2FnZUxpc3QubWFwKGluZGV4X2pzXzEuY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KHBhcnNlZE9wdGlvbnMpO1xuICAgICAgICBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPSBydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MgPz8gY2FsbGJhY2tzO1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuY2FjaGVkKGJhc2VNZXNzYWdlcywgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsbG1TdHJpbmdLZXkgPSB0aGlzLl9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChjYWxsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMsIG1pc3NpbmdQcm9tcHRJbmRpY2VzLCBzdGFydGVkUnVuTWFuYWdlcnMgfSA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ2FjaGVkKHtcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBiYXNlTWVzc2FnZXMsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGxsbVN0cmluZ0tleSxcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaGFuZGxlZE9wdGlvbnM6IHJ1bm5hYmxlQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxsbU91dHB1dCA9IHt9O1xuICAgICAgICBpZiAobWlzc2luZ1Byb21wdEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQobWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBiYXNlTWVzc2FnZXNbaV0pLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcsIHN0YXJ0ZWRSdW5NYW5hZ2VycyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IHN0YXJ0ZWRSdW5NYW5hZ2Vycz8uW2ldKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMuZ2VuZXJhdGlvbnMubWFwKGFzeW5jIChnZW5lcmF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdEluZGV4ID0gbWlzc2luZ1Byb21wdEluZGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW3Byb21wdEluZGV4XSA9IGdlbmVyYXRpb247XG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgY29udGVudCBpbnRvIG9uZSBzdHJpbmcgZm9yIHRoZSBwcm9tcHQgaW5kZXhcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGJhc2VNZXNzYWdlc1twcm9tcHRJbmRleF0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVwZGF0ZShwcm9tcHQsIGxsbVN0cmluZ0tleSwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsbG1PdXRwdXQgPSByZXN1bHRzLmxsbU91dHB1dCA/PyB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBnZW5lcmF0aW9ucywgbGxtT3V0cHV0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGludm9rZSB0aGUgbW9kZWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGludm9jYXRpb25QYXJhbXMoX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfbW9kZWxUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJiYXNlX2NoYXRfbW9kZWxcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBSZXR1cm4gYSBqc29uLWxpa2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIExMTS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLmludm9jYXRpb25QYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBwcm9tcHQgYmFzZWQgb24gdGhlIGlucHV0IHByb21wdCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHByb21wdFZhbHVlcyBBbiBhcnJheSBvZiBCYXNlUHJvbXB0VmFsdWUgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gTExNUmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlUHJvbXB0KHByb21wdFZhbHVlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gcHJvbXB0VmFsdWVzLm1hcCgocHJvbXB0VmFsdWUpID0+IHByb21wdFZhbHVlLnRvQ2hhdE1lc3NhZ2VzKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZShwcm9tcHRNZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBNYWtlcyBhIHNpbmdsZSBjYWxsIHRvIHRoZSBjaGF0IG1vZGVsLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBBbiBhcnJheSBvZiBCYXNlTWVzc2FnZSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJhc2VNZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGNhbGwobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlKFttZXNzYWdlcy5tYXAoaW5kZXhfanNfMS5jb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSldLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IHJlc3VsdC5nZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25zWzBdWzBdLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogTWFrZXMgYSBzaW5nbGUgY2FsbCB0byB0aGUgY2hhdCBtb2RlbCB3aXRoIGEgcHJvbXB0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb21wdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbFByb21wdChwcm9tcHRWYWx1ZSwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gcHJvbXB0VmFsdWUudG9DaGF0TWVzc2FnZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChwcm9tcHRNZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBQcmVkaWN0cyB0aGUgbmV4dCBtZXNzYWdlIGJhc2VkIG9uIHRoZSBpbnB1dCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0TWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFByZWRpY3RzIHRoZSBuZXh0IG1lc3NhZ2UgYmFzZWQgb24gYSB0ZXh0IGlucHV0LlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IGlucHV0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBpbmRleF9qc18xLkh1bWFuTWVzc2FnZSh0ZXh0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsKFttZXNzYWdlXSwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBwcmVkaWN0IHdoZW4gb3V0cHV0IGlzIG5vdCBhIHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50O1xuICAgIH1cbiAgICB3aXRoU3RydWN0dXJlZE91dHB1dChvdXRwdXRTY2hlbWEsIGNvbmZpZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYmluZFRvb2xzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhdCBtb2RlbCBtdXN0IGltcGxlbWVudCBcIi5iaW5kVG9vbHMoKVwiIHRvIHVzZSB3aXRoU3RydWN0dXJlZE91dHB1dC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnPy5zdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJzdHJpY3RcIiBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgbW9kZWwgYnkgZGVmYXVsdC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBvdXRwdXRTY2hlbWE7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb25maWc/Lm5hbWU7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKDAsIHpvZF9qc18xLmdldFNjaGVtYURlc2NyaXB0aW9uKShzY2hlbWEpID8/IFwiQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5cIjtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY29uZmlnPy5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVSYXcgPSBjb25maWc/LmluY2x1ZGVSYXc7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwianNvbk1vZGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYXNlIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0IGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgXCJmdW5jdGlvbkNhbGxpbmdcIiBhcyBhIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY3Rpb25OYW1lID0gbmFtZSA/PyBcImV4dHJhY3RcIjtcbiAgICAgICAgbGV0IHRvb2xzO1xuICAgICAgICBpZiAoKDAsIHpvZF9qc18xLmlzSW50ZXJvcFpvZFNjaGVtYSkoc2NoZW1hKSkge1xuICAgICAgICAgICAgdG9vbHMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6ICgwLCBqc29uX3NjaGVtYV9qc18xLnRvSnNvblNjaGVtYSkoc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBzY2hlbWEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGxtID0gdGhpcy5iaW5kVG9vbHModG9vbHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRQYXJzZXIgPSBiYXNlX2pzXzIuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXQudG9vbF9jYWxscyB8fCBpbnB1dC50b29sX2NhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgY2FsbHMgZm91bmQgaW4gdGhlIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gaW5wdXQudG9vbF9jYWxscy5maW5kKCh0YykgPT4gdGMubmFtZSA9PT0gZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIGlmICghdG9vbENhbGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHRvb2wgY2FsbCBmb3VuZCB3aXRoIG5hbWUgJHtmdW5jdGlvbk5hbWV9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxsLmFyZ3M7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWluY2x1ZGVSYXcpIHtcbiAgICAgICAgICAgIHJldHVybiBsbG0ucGlwZShvdXRwdXRQYXJzZXIpLndpdGhDb25maWcoe1xuICAgICAgICAgICAgICAgIHJ1bk5hbWU6IFwiU3RydWN0dXJlZE91dHB1dFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VyQXNzaWduID0gcGFzc3Rocm91Z2hfanNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcGFyc2VkOiAoaW5wdXQsIGNvbmZpZykgPT4gb3V0cHV0UGFyc2VyLmludm9rZShpbnB1dC5yYXcsIGNvbmZpZyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZXJOb25lID0gcGFzc3Rocm91Z2hfanNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICBwYXJzZWQ6ICgpID0+IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZWRXaXRoRmFsbGJhY2sgPSBwYXJzZXJBc3NpZ24ud2l0aEZhbGxiYWNrcyh7XG4gICAgICAgICAgICBmYWxsYmFja3M6IFtwYXJzZXJOb25lXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiYXNlX2pzXzIuUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByYXc6IGxsbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZWRXaXRoRmFsbGJhY2ssXG4gICAgICAgIF0pLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0UnVubmFibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ2hhdE1vZGVsID0gQmFzZUNoYXRNb2RlbDtcbi8qKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBleHRlbmRzIEJhc2VDaGF0TW9kZWwgYW5kIHByb3ZpZGVzIGEgc2ltcGxlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBfZ2VuZXJhdGUuXG4gKi9cbmNsYXNzIFNpbXBsZUNoYXRNb2RlbCBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5fY2FsbChtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgaW5kZXhfanNfMS5BSU1lc3NhZ2UodGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2VuZXJhdGUgd2l0aCBhIHNpbXBsZSBjaGF0IG1vZGVsIHdoZW4gb3V0cHV0IGlzIG5vdCBhIHN0cmluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVDaGF0TW9kZWwgPSBTaW1wbGVDaGF0TW9kZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/language_models/llms.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LLM = exports.BaseLLM = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nclass BaseLLM extends base_js_1.BaseLanguageModel {\n    constructor({ concurrency, ...rest }) {\n        super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"llms\", this._llmType()]\n        });\n    }\n    /**\n     * This method takes an input and options, and returns a string. It\n     * converts the input to a prompt value and generates a result based on\n     * the prompt.\n     * @param input Input for the LLM.\n     * @param options Options for the LLM call.\n     * @returns A string result based on the prompt.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseLLM._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        return result.generations[0][0].text;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_input, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    _separateRunnableConfigFromCallOptionsCompat(options) {\n        // For backwards compat, keep `signal` in both runnableConfig and callOptions\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        callOptions.signal = runnableConfig.signal;\n        return [runnableConfig, callOptions];\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseLLM._convertInputToPromptValue(input);\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], runnableConfig.runId, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generation = new outputs_js_1.GenerationChunk({\n                text: \"\",\n            });\n            try {\n                for await (const chunk of this._streamResponseChunks(prompt.toString(), callOptions, runManagers?.[0])) {\n                    if (!generation) {\n                        generation = chunk;\n                    }\n                    else {\n                        generation = generation.concat(chunk);\n                    }\n                    if (typeof chunk.text === \"string\") {\n                        yield chunk.text;\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                generations: [[generation]],\n            })));\n        }\n    }\n    /**\n     * This method takes prompt values, options, and callbacks, and generates\n     * a result based on the prompts.\n     * @param promptValues Prompt values for the LLM.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns An LLMResult based on the prompts.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const prompts = promptValues.map((promptValue) => promptValue.toString());\n        return this.generate(prompts, options, callbacks);\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _flattenLLMResult(llmResult) {\n        const llmResults = [];\n        for (let i = 0; i < llmResult.generations.length; i += 1) {\n            const genList = llmResult.generations[i];\n            if (i === 0) {\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput: llmResult.llmOutput,\n                });\n            }\n            else {\n                const llmOutput = llmResult.llmOutput\n                    ? { ...llmResult.llmOutput, tokenUsage: {} }\n                    : undefined;\n                llmResults.push({\n                    generations: [genList],\n                    llmOutput,\n                });\n            }\n        }\n        return llmResults;\n    }\n    /** @ignore */\n    async _generateUncached(prompts, parsedOptions, handledOptions, startedRunManagers) {\n        let runManagers;\n        if (startedRunManagers !== undefined &&\n            startedRunManagers.length === prompts.length) {\n            runManagers = startedRunManagers;\n        }\n        else {\n            const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: parsedOptions,\n                invocation_params: this?.invocationParams(parsedOptions),\n                batch_size: prompts.length,\n            };\n            runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, handledOptions.runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        }\n        // Even if stream is not explicitly called, check if model is implicitly\n        // called from streamEvents() or streamLog() to get all streamed events.\n        // Bail out if _streamResponseChunks not overridden\n        const hasStreamingHandler = !!runManagers?.[0].handlers.find(base_js_2.callbackHandlerPrefersStreaming);\n        let output;\n        if (hasStreamingHandler &&\n            prompts.length === 1 &&\n            this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks) {\n            try {\n                const stream = await this._streamResponseChunks(prompts[0], parsedOptions, runManagers?.[0]);\n                let aggregated;\n                for await (const chunk of stream) {\n                    if (aggregated === undefined) {\n                        aggregated = chunk;\n                    }\n                    else {\n                        aggregated = (0, stream_js_1.concat)(aggregated, chunk);\n                    }\n                }\n                if (aggregated === undefined) {\n                    throw new Error(\"Received empty response from chat model call.\");\n                }\n                output = { generations: [[aggregated]], llmOutput: {} };\n                await runManagers?.[0].handleLLMEnd(output);\n            }\n            catch (e) {\n                await runManagers?.[0].handleLLMError(e);\n                throw e;\n            }\n        }\n        else {\n            try {\n                output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            const flattenedOutputs = this._flattenLLMResult(output);\n            await Promise.all((runManagers ?? []).map((runManager, i) => runManager?.handleLLMEnd(flattenedOutputs[i])));\n        }\n        const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runIds ? { runIds } : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ prompts, cache, llmStringKey, parsedOptions, handledOptions, runId, }) {\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: prompts.length,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), prompts, runId, undefined, extra, undefined, undefined, handledOptions?.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(prompts.map(async (prompt, index) => {\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result.map((result) => {\n                    // eslint-disable-next-line no-param-reassign\n                    result.generationInfo = {\n                        ...result.generationInfo,\n                        tokenUsage: {},\n                    };\n                    return result;\n                });\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                }, undefined, undefined, undefined, {\n                    cached: true,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason, undefined, undefined, undefined, {\n                    cached: true,\n                });\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n            startedRunManagers: runManagers,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, outputs_js_1.RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Run the LLM on the given prompts and input, handling caching.\n     */\n    async generate(prompts, options, callbacks) {\n        if (!Array.isArray(prompts)) {\n            throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n        }\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(prompts, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({\n            prompts,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n            runId: runnableConfig.runId,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig, startedRunManagers !== undefined\n                ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n                : undefined);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                return cache.update(prompts[promptIndex], llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.\n     */\n    async call(prompt, options, callbacks) {\n        const { generations } = await this.generate([prompt], options, callbacks);\n        return generations[0][0].text;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method is similar to `call`, but it's used for making predictions\n     * based on the input text.\n     * @param text Input text for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A prediction based on the input text.\n     */\n    async predict(text, options, callbacks) {\n        return this.call(text, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * This method takes a list of messages, options, and callbacks, and\n     * returns a predicted message.\n     * @param messages A list of messages for the prediction.\n     * @param options Options for the LLM call.\n     * @param callbacks Callbacks for the LLM call.\n     * @returns A predicted message based on the list of messages.\n     */\n    async predictMessages(messages, options, callbacks) {\n        const text = (0, index_js_1.getBufferString)(messages);\n        const prediction = await this.call(text, options, callbacks);\n        return new index_js_1.AIMessage(prediction);\n    }\n    /**\n     * Get the identifying parameters of the LLM.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _identifyingParams() {\n        return {};\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this._identifyingParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    _modelType() {\n        return \"base_llm\";\n    }\n}\nexports.BaseLLM = BaseLLM;\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nclass LLM extends BaseLLM {\n    async _generate(prompts, options, runManager) {\n        const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text) => [{ text }])));\n        return { generations };\n    }\n}\nexports.LLM = LLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxlQUFlO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTUFBc00sdUJBQXVCO0FBQzdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLHVCQUF1QjtBQUM3TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCLHFFQUFxRTtBQUNqRyxrTUFBa00sdUJBQXVCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGdCQUFnQix3REFBd0Q7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQSx5Q0FBeUMsYUFBYSxtQkFBbUIsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0cseUJBQXlCLGdDQUFnQyxNQUFNO0FBQ3ZLLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2xsbXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MTE0gPSBleHBvcnRzLkJhc2VMTE0gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzL2luZGV4LmNqc1wiKTtcbmNvbnN0IG91dHB1dHNfanNfMSA9IHJlcXVpcmUoXCIuLi9vdXRwdXRzLmNqc1wiKTtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3N0cmVhbS5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi4vY2FsbGJhY2tzL2Jhc2UuY2pzXCIpO1xuLyoqXG4gKiBMTE0gV3JhcHBlci4gVGFrZXMgaW4gYSBwcm9tcHQgKG9yIHByb21wdHMpIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICovXG5jbGFzcyBCYXNlTExNIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VMYW5ndWFnZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmN1cnJlbmN5LCAuLi5yZXN0IH0pIHtcbiAgICAgICAgc3VwZXIoY29uY3VycmVuY3kgPyB7IG1heENvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSwgLi4ucmVzdCB9IDogcmVzdCk7XG4gICAgICAgIC8vIE9ubHkgZXZlciBpbnN0YW50aWF0ZWQgaW4gbWFpbiBMYW5nQ2hhaW5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJsbG1zXCIsIHRoaXMuX2xsbVR5cGUoKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGlucHV0IGFuZCBvcHRpb25zLCBhbmQgcmV0dXJucyBhIHN0cmluZy4gSXRcbiAgICAgKiBjb252ZXJ0cyB0aGUgaW5wdXQgdG8gYSBwcm9tcHQgdmFsdWUgYW5kIGdlbmVyYXRlcyBhIHJlc3VsdCBiYXNlZCBvblxuICAgICAqIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IGZvciB0aGUgTExNLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0VmFsdWUgPSBCYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVByb21wdChbcHJvbXB0VmFsdWVdLCBvcHRpb25zLCBvcHRpb25zPy5jYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdlbmVyYXRpb25zWzBdWzBdLnRleHQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfaW5wdXQsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBfc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0LCBrZWVwIGBzaWduYWxgIGluIGJvdGggcnVubmFibGVDb25maWcgYW5kIGNhbGxPcHRpb25zXG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gc3VwZXIuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNhbGxPcHRpb25zLnNpZ25hbCA9IHJ1bm5hYmxlQ29uZmlnLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFN1YmNsYXNzIGNoZWNrIHJlcXVpcmVkIHRvIGF2b2lkIGRvdWJsZSBjYWxsYmFja3Mgd2l0aCBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyA9PT0gQmFzZUxMTS5wcm90b3R5cGUuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHJ1bm5hYmxlQ29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlTExNU3RhcnQodGhpcy50b0pTT04oKSwgW3Byb21wdC50b1N0cmluZygpXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uID0gbmV3IG91dHB1dHNfanNfMS5HZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhwcm9tcHQudG9TdHJpbmcoKSwgY2FsbE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb24uY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uXV0sXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIHByb21wdCB2YWx1ZXMsIG9wdGlvbnMsIGFuZCBjYWxsYmFja3MsIGFuZCBnZW5lcmF0ZXNcbiAgICAgKiBhIHJlc3VsdCBiYXNlZCBvbiB0aGUgcHJvbXB0cy5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWVzIFByb21wdCB2YWx1ZXMgZm9yIHRoZSBMTE0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHJldHVybnMgQW4gTExNUmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlUHJvbXB0KHByb21wdFZhbHVlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdHMgPSBwcm9tcHRWYWx1ZXMubWFwKChwcm9tcHRWYWx1ZSkgPT4gcHJvbXB0VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKHByb21wdHMsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVycyB1c2VkIHRvIGludm9rZSB0aGUgbW9kZWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGludm9jYXRpb25QYXJhbXMoX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBfZmxhdHRlbkxMTVJlc3VsdChsbG1SZXN1bHQpIHtcbiAgICAgICAgY29uc3QgbGxtUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxsbVJlc3VsdC5nZW5lcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgZ2VuTGlzdCA9IGxsbVJlc3VsdC5nZW5lcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGxtUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtnZW5MaXN0XSxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0OiBsbG1SZXN1bHQubGxtT3V0cHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGxtT3V0cHV0ID0gbGxtUmVzdWx0LmxsbU91dHB1dFxuICAgICAgICAgICAgICAgICAgICA/IHsgLi4ubGxtUmVzdWx0LmxsbU91dHB1dCwgdG9rZW5Vc2FnZToge30gfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsbG1SZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW2dlbkxpc3RdLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxsbVJlc3VsdHM7XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2dlbmVyYXRlVW5jYWNoZWQocHJvbXB0cywgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMsIHN0YXJ0ZWRSdW5NYW5hZ2Vycykge1xuICAgICAgICBsZXQgcnVuTWFuYWdlcnM7XG4gICAgICAgIGlmIChzdGFydGVkUnVuTWFuYWdlcnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgc3RhcnRlZFJ1bk1hbmFnZXJzLmxlbmd0aCA9PT0gcHJvbXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXJzID0gc3RhcnRlZFJ1bk1hbmFnZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaGFuZGxlZE9wdGlvbnMubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiBwcm9tcHRzLmxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIHByb21wdHMsIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW4gaWYgc3RyZWFtIGlzIG5vdCBleHBsaWNpdGx5IGNhbGxlZCwgY2hlY2sgaWYgbW9kZWwgaXMgaW1wbGljaXRseVxuICAgICAgICAvLyBjYWxsZWQgZnJvbSBzdHJlYW1FdmVudHMoKSBvciBzdHJlYW1Mb2coKSB0byBnZXQgYWxsIHN0cmVhbWVkIGV2ZW50cy5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgX3N0cmVhbVJlc3BvbnNlQ2h1bmtzIG5vdCBvdmVycmlkZGVuXG4gICAgICAgIGNvbnN0IGhhc1N0cmVhbWluZ0hhbmRsZXIgPSAhIXJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlcnMuZmluZChiYXNlX2pzXzIuY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyk7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGlmIChoYXNTdHJlYW1pbmdIYW5kbGVyICYmXG4gICAgICAgICAgICBwcm9tcHRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgIT09IEJhc2VMTE0ucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhwcm9tcHRzWzBdLCBwYXJzZWRPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKTtcbiAgICAgICAgICAgICAgICBsZXQgYWdncmVnYXRlZDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoYWdncmVnYXRlZCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgZW1wdHkgcmVzcG9uc2UgZnJvbSBjaGF0IG1vZGVsIGNhbGwuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IGdlbmVyYXRpb25zOiBbW2FnZ3JlZ2F0ZWRdXSwgbGxtT3V0cHV0OiB7fSB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlTExNRW5kKG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlTExNRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGUocHJvbXB0cywgcGFyc2VkT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKGVycikpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbGF0dGVuZWRPdXRwdXRzID0gdGhpcy5fZmxhdHRlbkxMTVJlc3VsdChvdXRwdXQpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIsIGkpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZChmbGF0dGVuZWRPdXRwdXRzW2ldKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bklkcyA9IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhpcyBkZWZpbmVzIFJVTl9LRVkgYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb3V0cHV0IG9iamVjdFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIG5vdCBzZXJpYWxpemVkIHdoZW4gdGhlIG91dHB1dCBpcyBzdHJpbmdpZmllZCwgYW5kIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgaXNudCBpbmNsdWRlZCB3aGVuIGxpc3RpbmcgdGhlIGtleXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIG91dHB1dHNfanNfMS5SVU5fS0VZLCB7XG4gICAgICAgICAgICB2YWx1ZTogcnVuSWRzID8geyBydW5JZHMgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZUNhY2hlZCh7IHByb21wdHMsIGNhY2hlLCBsbG1TdHJpbmdLZXksIHBhcnNlZE9wdGlvbnMsIGhhbmRsZWRPcHRpb25zLCBydW5JZCwgfSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUoaGFuZGxlZE9wdGlvbnMuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgaGFuZGxlZE9wdGlvbnMudGFncywgdGhpcy50YWdzLCBoYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgb3B0aW9uczogcGFyc2VkT3B0aW9ucyxcbiAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgYmF0Y2hfc2l6ZTogcHJvbXB0cy5sZW5ndGgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlTExNU3RhcnQodGhpcy50b0pTT04oKSwgcHJvbXB0cywgcnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgY29uc3QgbWlzc2luZ1Byb21wdEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9tcHRzLm1hcChhc3luYyAocHJvbXB0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUubG9va3VwKHByb21wdCwgbGxtU3RyaW5nS2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBNYXAgcnVuIG1hbmFnZXJzIHRvIHRoZSByZXN1bHRzIGJlZm9yZSBmaWx0ZXJpbmcgb3V0IG51bGwgcmVzdWx0c1xuICAgICAgICAvLyBOdWxsIHJlc3VsdHMgYXJlIGp1c3QgYWJzZW50IGZyb20gdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHsgcmVzdWx0LCBydW5NYW5hZ2VyOiBydW5NYW5hZ2Vycz8uW2luZGV4XSB9KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcmVzdWx0IH0pID0+IChyZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiICYmIHJlc3VsdC52YWx1ZSAhPSBudWxsKSB8fFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKTtcbiAgICAgICAgLy8gSGFuZGxlIHJlc3VsdHMgYW5kIGNhbGwgcnVuIG1hbmFnZXJzXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlZFJlc3VsdHMubWFwKGFzeW5jICh7IHJlc3VsdDogcHJvbWlzZVJlc3VsdCwgcnVuTWFuYWdlciB9LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZVJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9taXNlUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0Lm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2VuZXJhdGlvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVzYWdlOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXN1bHRbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW3Jlc3VsdF0sXG4gICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVycm9yKHByb21pc2VSZXN1bHQucmVhc29uLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocHJvbWlzZVJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbWlzc2luZ1Byb21wdEluZGljZXMsXG4gICAgICAgICAgICBzdGFydGVkUnVuTWFuYWdlcnM6IHJ1bk1hbmFnZXJzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgUlVOX0tFWSBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvdXRwdXQgb2JqZWN0XG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgbm90IHNlcmlhbGl6ZWQgd2hlbiB0aGUgb3V0cHV0IGlzIHN0cmluZ2lmaWVkLCBhbmQgc28gdGhhdFxuICAgICAgICAvLyBpdCBpc250IGluY2x1ZGVkIHdoZW4gbGlzdGluZyB0aGUga2V5cyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dHB1dCwgb3V0cHV0c19qc18xLlJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgTExNIG9uIHRoZSBnaXZlbiBwcm9tcHRzIGFuZCBpbnB1dCwgaGFuZGxpbmcgY2FjaGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShwcm9tcHRzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAncHJvbXB0cycgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmdbXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkT3B0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSB7IHN0b3A6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9uc0NvbXBhdChwYXJzZWRPcHRpb25zKTtcbiAgICAgICAgcnVubmFibGVDb25maWcuY2FsbGJhY2tzID0gcnVubmFibGVDb25maWcuY2FsbGJhY2tzID8/IGNhbGxiYWNrcztcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChwcm9tcHRzLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxsbVN0cmluZ0tleSA9IHRoaXMuX2dldFNlcmlhbGl6ZWRDYWNoZUtleVBhcmFtZXRlcnNGb3JDYWxsKGNhbGxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBnZW5lcmF0aW9ucywgbWlzc2luZ1Byb21wdEluZGljZXMsIHN0YXJ0ZWRSdW5NYW5hZ2VycyB9ID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVDYWNoZWQoe1xuICAgICAgICAgICAgcHJvbXB0cyxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgbGxtU3RyaW5nS2V5LFxuICAgICAgICAgICAgcGFyc2VkT3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBoYW5kbGVkT3B0aW9uczogcnVubmFibGVDb25maWcsXG4gICAgICAgICAgICBydW5JZDogcnVubmFibGVDb25maWcucnVuSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGxtT3V0cHV0ID0ge307XG4gICAgICAgIGlmIChtaXNzaW5nUHJvbXB0SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IHByb21wdHNbaV0pLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcsIHN0YXJ0ZWRSdW5NYW5hZ2VycyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IHN0YXJ0ZWRSdW5NYW5hZ2Vycz8uW2ldKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMuZ2VuZXJhdGlvbnMubWFwKGFzeW5jIChnZW5lcmF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdEluZGV4ID0gbWlzc2luZ1Byb21wdEluZGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW3Byb21wdEluZGV4XSA9IGdlbmVyYXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVwZGF0ZShwcm9tcHRzW3Byb21wdEluZGV4XSwgbGxtU3RyaW5nS2V5LCBnZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxsbU91dHB1dCA9IHJlc3VsdHMubGxtT3V0cHV0ID8/IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdlbmVyYXRpb25zLCBsbG1PdXRwdXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICogQ29udmVuaWVuY2Ugd3JhcHBlciBmb3Ige0BsaW5rIGdlbmVyYXRlfSB0aGF0IHRha2VzIGluIGEgc2luZ2xlIHN0cmluZyBwcm9tcHQgYW5kIHJldHVybnMgYSBzaW5nbGUgc3RyaW5nIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKHByb21wdCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGUoW3Byb21wdF0sIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uc1swXVswXS50ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYGNhbGxgLCBidXQgaXQncyB1c2VkIGZvciBtYWtpbmcgcHJlZGljdGlvbnNcbiAgICAgKiBiYXNlZCBvbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0gdGV4dCBJbnB1dCB0ZXh0IGZvciB0aGUgcHJlZGljdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHByZWRpY3Rpb24gYmFzZWQgb24gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgbGlzdCBvZiBtZXNzYWdlcywgb3B0aW9ucywgYW5kIGNhbGxiYWNrcywgYW5kXG4gICAgICogcmV0dXJucyBhIHByZWRpY3RlZCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBBIGxpc3Qgb2YgbWVzc2FnZXMgZm9yIHRoZSBwcmVkaWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEByZXR1cm5zIEEgcHJlZGljdGVkIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgbWVzc2FnZXMuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9ICgwLCBpbmRleF9qc18xLmdldEJ1ZmZlclN0cmluZykobWVzc2FnZXMpO1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgdGhpcy5jYWxsKHRleHQsIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMS5BSU1lc3NhZ2UocHJlZGljdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRlbnRpZnlpbmcgcGFyYW1ldGVycyBvZiB0aGUgTExNLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2lkZW50aWZ5aW5nUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfbW9kZWxUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJiYXNlX2xsbVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUxMTSA9IEJhc2VMTE07XG4vKipcbiAqIExMTSBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgc2ltcGxlciBpbnRlcmZhY2UgdG8gc3ViY2xhc3MgdGhhbiB7QGxpbmsgQmFzZUxMTX0uXG4gKlxuICogUmVxdWlyZXMgb25seSBpbXBsZW1lbnRpbmcgYSBzaW1wbGVyIHtAbGluayBfY2FsbH0gbWV0aG9kIGluc3RlYWQgb2Yge0BsaW5rIF9nZW5lcmF0ZX0uXG4gKlxuICogQGF1Z21lbnRzIEJhc2VMTE1cbiAqL1xuY2xhc3MgTExNIGV4dGVuZHMgQmFzZUxMTSB7XG4gICAgYXN5bmMgX2dlbmVyYXRlKHByb21wdHMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9tcHRzLm1hcCgocHJvbXB0LCBwcm9tcHRJbmRleCkgPT4gdGhpcy5fY2FsbChwcm9tcHQsIHsgLi4ub3B0aW9ucywgcHJvbXB0SW5kZXggfSwgcnVuTWFuYWdlcikudGhlbigodGV4dCkgPT4gW3sgdGV4dCB9XSkpKTtcbiAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGlvbnMgfTtcbiAgICB9XG59XG5leHBvcnRzLkxMTSA9IExMTTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/map_keys.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keyToJson = keyToJson;\nexports.keyFromJson = keyFromJson;\nexports.mapKeys = mapKeys;\nconst decamelize_1 = __importDefault(__webpack_require__(/*! decamelize */ \"(rsc)/./node_modules/decamelize/index.js\"));\nconst camelcase_1 = __importDefault(__webpack_require__(/*! camelcase */ \"(rsc)/./node_modules/camelcase/index.js\"));\nfunction keyToJson(key, map) {\n    return map?.[key] || (0, decamelize_1.default)(key);\n}\nfunction keyFromJson(key, map) {\n    return map?.[key] || (0, camelcase_1.default)(key);\n}\nfunction mapKeys(fields, mapper, map) {\n    const mapped = {};\n    for (const key in fields) {\n        if (Object.hasOwn(fields, key)) {\n            mapped[mapper(key, map)] = fields[key];\n        }\n    }\n    return mapped;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9tYXBfa2V5cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixxQ0FBcUMsbUJBQU8sQ0FBQyw0REFBWTtBQUN6RCxvQ0FBb0MsbUJBQU8sQ0FBQywwREFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvbWFwX2tleXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZXlUb0pzb24gPSBrZXlUb0pzb247XG5leHBvcnRzLmtleUZyb21Kc29uID0ga2V5RnJvbUpzb247XG5leHBvcnRzLm1hcEtleXMgPSBtYXBLZXlzO1xuY29uc3QgZGVjYW1lbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNhbWVsaXplXCIpKTtcbmNvbnN0IGNhbWVsY2FzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW1lbGNhc2VcIikpO1xuZnVuY3Rpb24ga2V5VG9Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgKDAsIGRlY2FtZWxpemVfMS5kZWZhdWx0KShrZXkpO1xufVxuZnVuY3Rpb24ga2V5RnJvbUpzb24oa2V5LCBtYXApIHtcbiAgICByZXR1cm4gbWFwPy5ba2V5XSB8fCAoMCwgY2FtZWxjYXNlXzEuZGVmYXVsdCkoa2V5KTtcbn1cbmZ1bmN0aW9uIG1hcEtleXMoZmllbGRzLCBtYXBwZXIsIG1hcCkge1xuICAgIGNvbnN0IG1hcHBlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaWVsZHMsIGtleSkpIHtcbiAgICAgICAgICAgIG1hcHBlZFttYXBwZXIoa2V5LCBtYXApXSA9IGZpZWxkc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/load/serializable.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Serializable = void 0;\nexports.get_lc_unique_name = get_lc_unique_name;\nconst map_keys_js_1 = __webpack_require__(/*! ./map_keys.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/map_keys.cjs\");\nfunction shallowCopy(obj) {\n    return Array.isArray(obj) ? [...obj] : { ...obj };\n}\nfunction replaceSecrets(root, secretsMap) {\n    const result = shallowCopy(root);\n    for (const [path, secretId] of Object.entries(secretsMap)) {\n        const [last, ...partsReverse] = path.split(\".\").reverse();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let current = result;\n        for (const part of partsReverse.reverse()) {\n            if (current[part] === undefined) {\n                break;\n            }\n            current[part] = shallowCopy(current[part]);\n            current = current[part];\n        }\n        if (current[last] !== undefined) {\n            current[last] = {\n                lc: 1,\n                type: \"secret\",\n                id: [secretId],\n            };\n        }\n    }\n    return result;\n}\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nfunction get_lc_unique_name(\n// eslint-disable-next-line @typescript-eslint/no-use-before-define\nserializableClass) {\n    // \"super\" here would refer to the parent class of Serializable,\n    // when we want the parent class of the module actually calling this method.\n    const parentClass = Object.getPrototypeOf(serializableClass);\n    const lcNameIsSubclassed = typeof serializableClass.lc_name === \"function\" &&\n        (typeof parentClass.lc_name !== \"function\" ||\n            serializableClass.lc_name() !== parentClass.lc_name());\n    if (lcNameIsSubclassed) {\n        return serializableClass.lc_name();\n    }\n    else {\n        return serializableClass.name;\n    }\n}\nclass Serializable {\n    /**\n     * The name of the serializable. Override to provide an alias or\n     * to preserve the serialized module name in minified environments.\n     *\n     * Implemented as a static method to support loading logic.\n     */\n    static lc_name() {\n        return this.name;\n    }\n    /**\n     * The final serialized identifier for the module.\n     */\n    get lc_id() {\n        return [\n            ...this.lc_namespace,\n            get_lc_unique_name(this.constructor),\n        ];\n    }\n    /**\n     * A map of secrets, which will be omitted from serialization.\n     * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n     * Values are the secret ids, which will be used when deserializing.\n     */\n    get lc_secrets() {\n        return undefined;\n    }\n    /**\n     * A map of additional attributes to merge with constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the attribute values, which will be serialized.\n     * These attributes need to be accepted by the constructor as arguments.\n     */\n    get lc_attributes() {\n        return undefined;\n    }\n    /**\n     * A map of aliases for constructor args.\n     * Keys are the attribute names, e.g. \"foo\".\n     * Values are the alias that will replace the key in serialization.\n     * This is used to eg. make argument names match Python.\n     */\n    get lc_aliases() {\n        return undefined;\n    }\n    /**\n     * A manual list of keys that should be serialized.\n     * If not overridden, all fields passed into the constructor will be serialized.\n     */\n    get lc_serializable_keys() {\n        return undefined;\n    }\n    constructor(kwargs, ..._args) {\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (this.lc_serializable_keys !== undefined) {\n            this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));\n        }\n        else {\n            this.lc_kwargs = kwargs ?? {};\n        }\n    }\n    toJSON() {\n        if (!this.lc_serializable) {\n            return this.toJSONNotImplemented();\n        }\n        if (\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        this.lc_kwargs instanceof Serializable ||\n            typeof this.lc_kwargs !== \"object\" ||\n            Array.isArray(this.lc_kwargs)) {\n            // We do not support serialization of classes with arg not a POJO\n            // I'm aware the check above isn't as strict as it could be\n            return this.toJSONNotImplemented();\n        }\n        const aliases = {};\n        const secrets = {};\n        const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n            acc[key] = key in this ? this[key] : this.lc_kwargs[key];\n            return acc;\n        }, {});\n        // get secrets, attributes and aliases from all superclasses\n        for (\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {\n            Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n            Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n            Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n        }\n        // include all secrets used, even if not in kwargs,\n        // will be replaced with sentinel value in replaceSecrets\n        Object.keys(secrets).forEach((keyPath) => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias, @typescript-eslint/no-explicit-any\n            let read = this;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let write = kwargs;\n            const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n            for (const key of partsReverse.reverse()) {\n                if (!(key in read) || read[key] === undefined)\n                    return;\n                if (!(key in write) || write[key] === undefined) {\n                    if (typeof read[key] === \"object\" && read[key] != null) {\n                        write[key] = {};\n                    }\n                    else if (Array.isArray(read[key])) {\n                        write[key] = [];\n                    }\n                }\n                read = read[key];\n                write = write[key];\n            }\n            if (last in read && read[last] !== undefined) {\n                write[last] = write[last] || read[last];\n            }\n        });\n        return {\n            lc: 1,\n            type: \"constructor\",\n            id: this.lc_id,\n            kwargs: (0, map_keys_js_1.mapKeys)(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, map_keys_js_1.keyToJson, aliases),\n        };\n    }\n    toJSONNotImplemented() {\n        return {\n            lc: 1,\n            type: \"not_implemented\",\n            id: this.lc_id,\n        };\n    }\n}\nexports.Serializable = Serializable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIsc0JBQXNCLG1CQUFPLENBQUMsbUZBQWdCO0FBQzlDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJpYWxpemFibGUgPSB2b2lkIDA7XG5leHBvcnRzLmdldF9sY191bmlxdWVfbmFtZSA9IGdldF9sY191bmlxdWVfbmFtZTtcbmNvbnN0IG1hcF9rZXlzX2pzXzEgPSByZXF1aXJlKFwiLi9tYXBfa2V5cy5janNcIik7XG5mdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopID8gWy4uLm9ial0gOiB7IC4uLm9iaiB9O1xufVxuZnVuY3Rpb24gcmVwbGFjZVNlY3JldHMocm9vdCwgc2VjcmV0c01hcCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNoYWxsb3dDb3B5KHJvb3QpO1xuICAgIGZvciAoY29uc3QgW3BhdGgsIHNlY3JldElkXSBvZiBPYmplY3QuZW50cmllcyhzZWNyZXRzTWFwKSkge1xuICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IHBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZXN1bHQ7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0c1JldmVyc2UucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFtwYXJ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50W3BhcnRdID0gc2hhbGxvd0NvcHkoY3VycmVudFtwYXJ0XSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFtsYXN0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50W2xhc3RdID0ge1xuICAgICAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VjcmV0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IFtzZWNyZXRJZF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldCBhIHVuaXF1ZSBuYW1lIGZvciB0aGUgbW9kdWxlLCByYXRoZXIgdGhhbiBwYXJlbnQgY2xhc3MgaW1wbGVtZW50YXRpb25zLlxuICogU2hvdWxkIG5vdCBiZSBzdWJjbGFzc2VkLCBzdWJjbGFzcyBsY19uYW1lIGFib3ZlIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGdldF9sY191bmlxdWVfbmFtZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbnNlcmlhbGl6YWJsZUNsYXNzKSB7XG4gICAgLy8gXCJzdXBlclwiIGhlcmUgd291bGQgcmVmZXIgdG8gdGhlIHBhcmVudCBjbGFzcyBvZiBTZXJpYWxpemFibGUsXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhlIG1vZHVsZSBhY3R1YWxseSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHBhcmVudENsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlcmlhbGl6YWJsZUNsYXNzKTtcbiAgICBjb25zdCBsY05hbWVJc1N1YmNsYXNzZWQgPSB0eXBlb2Ygc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcGFyZW50Q2xhc3MubGNfbmFtZSAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCkgIT09IHBhcmVudENsYXNzLmxjX25hbWUoKSk7XG4gICAgaWYgKGxjTmFtZUlzU3ViY2xhc3NlZCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUNsYXNzLm5hbWU7XG4gICAgfVxufVxuY2xhc3MgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2Ygc2VjcmV0cywgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGZyb20gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBLZXlzIGFyZSBwYXRocyB0byB0aGUgc2VjcmV0IGluIGNvbnN0cnVjdG9yIGFyZ3MsIGUuZy4gXCJmb28uYmFyLmJhelwiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIHNlY3JldCBpZHMsIHdoaWNoIHdpbGwgYmUgdXNlZCB3aGVuIGRlc2VyaWFsaXppbmcuXG4gICAgICovXG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBtZXJnZSB3aXRoIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBUaGVzZSBhdHRyaWJ1dGVzIG5lZWQgdG8gYmUgYWNjZXB0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFzIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYWxpYXNlcyBmb3IgY29uc3RydWN0b3IgYXJncy5cbiAgICAgKiBLZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBlLmcuIFwiZm9vXCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgYWxpYXMgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIGtleSBpbiBzZXJpYWxpemF0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlZy4gbWFrZSBhcmd1bWVudCBuYW1lcyBtYXRjaCBQeXRob24uXG4gICAgICovXG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFudWFsIGxpc3Qgb2Yga2V5cyB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLlxuICAgICAqIElmIG5vdCBvdmVycmlkZGVuLCBhbGwgZmllbGRzIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIHNlcmlhbGl6ZWQuXG4gICAgICovXG4gICAgZ2V0IGxjX3NlcmlhbGl6YWJsZV9rZXlzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3MsIC4uLl9hcmdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX2t3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5sY19zZXJpYWxpemFibGVfa2V5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxjX2t3YXJncyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhrd2FyZ3MgfHwge30pLmZpbHRlcigoW2tleV0pID0+IHRoaXMubGNfc2VyaWFsaXphYmxlX2tleXM/LmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGNfa3dhcmdzID0ga3dhcmdzID8/IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxjX3NlcmlhbGl6YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OTm90SW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MgaW5zdGFuY2VvZiBTZXJpYWxpemFibGUgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmxjX2t3YXJncyAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmxjX2t3YXJncykpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBzdXBwb3J0IHNlcmlhbGl6YXRpb24gb2YgY2xhc3NlcyB3aXRoIGFyZyBub3QgYSBQT0pPXG4gICAgICAgICAgICAvLyBJJ20gYXdhcmUgdGhlIGNoZWNrIGFib3ZlIGlzbid0IGFzIHN0cmljdCBhcyBpdCBjb3VsZCBiZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OTm90SW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGlhc2VzID0ge307XG4gICAgICAgIGNvbnN0IHNlY3JldHMgPSB7fTtcbiAgICAgICAgY29uc3Qga3dhcmdzID0gT2JqZWN0LmtleXModGhpcy5sY19rd2FyZ3MpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGFjY1trZXldID0ga2V5IGluIHRoaXMgPyB0aGlzW2tleV0gOiB0aGlzLmxjX2t3YXJnc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBnZXQgc2VjcmV0cywgYXR0cmlidXRlcyBhbmQgYWxpYXNlcyBmcm9tIGFsbCBzdXBlcmNsYXNzZXNcbiAgICAgICAgZm9yIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGxldCBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpOyBjdXJyZW50OyBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFsaWFzZXMsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYWxpYXNlc1wiLCB0aGlzKSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlY3JldHMsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfc2VjcmV0c1wiLCB0aGlzKSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGt3YXJncywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19hdHRyaWJ1dGVzXCIsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNsdWRlIGFsbCBzZWNyZXRzIHVzZWQsIGV2ZW4gaWYgbm90IGluIGt3YXJncyxcbiAgICAgICAgLy8gd2lsbCBiZSByZXBsYWNlZCB3aXRoIHNlbnRpbmVsIHZhbHVlIGluIHJlcGxhY2VTZWNyZXRzXG4gICAgICAgIE9iamVjdC5rZXlzKHNlY3JldHMpLmZvckVhY2goKGtleVBhdGgpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHJlYWQgPSB0aGlzO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCB3cml0ZSA9IGt3YXJncztcbiAgICAgICAgICAgIGNvbnN0IFtsYXN0LCAuLi5wYXJ0c1JldmVyc2VdID0ga2V5UGF0aC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGFydHNSZXZlcnNlLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiByZWFkKSB8fCByZWFkW2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB3cml0ZSkgfHwgd3JpdGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZFtrZXldID09PSBcIm9iamVjdFwiICYmIHJlYWRba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVtrZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWFkW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVtrZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVhZCA9IHJlYWRba2V5XTtcbiAgICAgICAgICAgICAgICB3cml0ZSA9IHdyaXRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdCBpbiByZWFkICYmIHJlYWRbbGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdyaXRlW2xhc3RdID0gd3JpdGVbbGFzdF0gfHwgcmVhZFtsYXN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICAgICAga3dhcmdzOiAoMCwgbWFwX2tleXNfanNfMS5tYXBLZXlzKShPYmplY3Qua2V5cyhzZWNyZXRzKS5sZW5ndGggPyByZXBsYWNlU2VjcmV0cyhrd2FyZ3MsIHNlY3JldHMpIDoga3dhcmdzLCBtYXBfa2V5c19qc18xLmtleVRvSnNvbiwgYWxpYXNlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSlNPTk5vdEltcGxlbWVudGVkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdF9pbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubGNfaWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/ai.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AIMessageChunk = exports.AIMessage = void 0;\nexports.isAIMessage = isAIMessage;\nexports.isAIMessageChunk = isAIMessageChunk;\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\n/**\n * Represents an AI message in a conversation.\n */\nclass AIMessage extends base_js_1.BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = (0, tool_js_1.defaultToolCallParser)(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nexports.AIMessage = AIMessage;\nfunction isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nfunction isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nclass AIMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined ||\n            fields.tool_call_chunks.length === 0) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        else {\n            const toolCallChunks = fields.tool_call_chunks ?? [];\n            const groupedToolCallChunks = toolCallChunks.reduce((acc, chunk) => {\n                const matchedChunkIndex = acc.findIndex(([match]) => {\n                    // If chunk has an id and index, match if both are present\n                    if (\"id\" in chunk &&\n                        chunk.id &&\n                        \"index\" in chunk &&\n                        chunk.index !== undefined) {\n                        return chunk.id === match.id && chunk.index === match.index;\n                    }\n                    // If chunk has an id, we match on id\n                    if (\"id\" in chunk && chunk.id) {\n                        return chunk.id === match.id;\n                    }\n                    // If chunk has an index, we match on index\n                    if (\"index\" in chunk && chunk.index !== undefined) {\n                        return chunk.index === match.index;\n                    }\n                    return false;\n                });\n                if (matchedChunkIndex !== -1) {\n                    acc[matchedChunkIndex].push(chunk);\n                }\n                else {\n                    acc.push([chunk]);\n                }\n                return acc;\n            }, []);\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const chunks of groupedToolCallChunks) {\n                let parsedArgs = {};\n                const name = chunks[0]?.name ?? \"\";\n                const joinedArgs = chunks.map((c) => c.args || \"\").join(\"\");\n                const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n                const id = chunks[0]?.id;\n                try {\n                    parsedArgs = (0, json_js_1.parsePartialJson)(argsStr);\n                    if (!id ||\n                        parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name,\n                        args: parsedArgs,\n                        id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name,\n                        args: argsStr,\n                        id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = (0, base_js_1._mergeLists)(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const inputTokenDetails = {\n                ...((this.usage_metadata?.input_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.input_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_read !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_read !==\n                        undefined) && {\n                    cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_read ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_creation !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_creation !==\n                        undefined) && {\n                    cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0),\n                }),\n            };\n            const outputTokenDetails = {\n                ...((this.usage_metadata?.output_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.output_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.output_token_details?.reasoning !==\n                    undefined ||\n                    chunk.usage_metadata?.output_token_details?.reasoning !==\n                        undefined) && {\n                    reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.reasoning ?? 0),\n                }),\n            };\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n                // Do not include `input_token_details` / `output_token_details` keys in combined fields\n                // unless their values are defined.\n                ...(Object.keys(inputTokenDetails).length > 0 && {\n                    input_token_details: inputTokenDetails,\n                }),\n                ...(Object.keys(outputTokenDetails).length > 0 && {\n                    output_token_details: outputTokenDetails,\n                }),\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\nexports.AIMessageChunk = AIMessageChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGlCQUFpQjtBQUMxQyxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFtQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYWkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BSU1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuQUlNZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc0FJTWVzc2FnZSA9IGlzQUlNZXNzYWdlO1xuZXhwb3J0cy5pc0FJTWVzc2FnZUNodW5rID0gaXNBSU1lc3NhZ2VDaHVuaztcbmNvbnN0IGpzb25fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3QgdG9vbF9qc18xID0gcmVxdWlyZShcIi4vdG9vbC5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQUkgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgQUlNZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgbGV0IGluaXRQYXJhbXM7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IGZpZWxkcztcbiAgICAgICAgICAgIGNvbnN0IHJhd1Rvb2xDYWxscyA9IGluaXRQYXJhbXMuYWRkaXRpb25hbF9rd2FyZ3M/LnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICAgICByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICh0b29sQ2FsbHMgPT09IHVuZGVmaW5lZCB8fCB0b29sQ2FsbHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihbXG4gICAgICAgICAgICAgICAgICAgIFwiTmV3IExhbmdDaGFpbiBwYWNrYWdlcyBhcmUgYXZhaWxhYmxlIHRoYXQgbW9yZSBlZmZpY2llbnRseSBoYW5kbGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0b29sIGNhbGxpbmcuXFxuXFxuUGxlYXNlIHVwZ3JhZGUgeW91ciBwYWNrYWdlcyB0byB2ZXJzaW9ucyB0aGF0IHNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lc3NhZ2UgdG9vbCBjYWxscy4gZS5nLiwgYHlhcm4gYWRkIEBsYW5nY2hhaW4vYW50aHJvcGljYCxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ5YXJuIGFkZCBAbGFuZ2NoYWluL29wZW5haWAsIGV0Yy5cIixcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmF3VG9vbENhbGxzID09IG51bGwpICYmIHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdID0gKDAsIHRvb2xfanNfMS5kZWZhdWx0VG9vbENhbGxQYXJzZXIpKHJhd1Rvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxscyA9IHRvb2xDYWxscyA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBpbnZhbGlkVG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBwYXJzaW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gW107XG4gICAgICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcHJvdmlkZWQsIHRva2VuIHVzYWdlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzYWdlX21ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdFBhcmFtcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZF90b29sX2NhbGxzID1cbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA/PyB0aGlzLmludmFsaWRfdG9vbF9jYWxscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzYWdlX21ldGFkYXRhID0gaW5pdFBhcmFtcy51c2FnZV9tZXRhZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYWlcIjtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogdGhpcy50b29sX2NhbGxzLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiB0aGlzLmludmFsaWRfdG9vbF9jYWxscyxcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiB0aGlzLnVzYWdlX21ldGFkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQUlNZXNzYWdlID0gQUlNZXNzYWdlO1xuZnVuY3Rpb24gaXNBSU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiYWlcIjtcbn1cbmZ1bmN0aW9uIGlzQUlNZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiYWlcIjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGFuIEFJIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgQUkgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIEFJTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkcy50b29sX2NhbGxfY2h1bmtzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGZpZWxkcy50b29sX2NhbGxfY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogZmllbGRzLnRvb2xfY2FsbHMgPz8gW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogZmllbGRzLnVzYWdlX21ldGFkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZHMudXNhZ2VfbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxDaHVua3MgPSBmaWVsZHMudG9vbF9jYWxsX2NodW5rcyA/PyBbXTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRUb29sQ2FsbENodW5rcyA9IHRvb2xDYWxsQ2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRDaHVua0luZGV4ID0gYWNjLmZpbmRJbmRleCgoW21hdGNoXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaHVuayBoYXMgYW4gaWQgYW5kIGluZGV4LCBtYXRjaCBpZiBib3RoIGFyZSBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImlkXCIgaW4gY2h1bmsgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBcImluZGV4XCIgaW4gY2h1bmsgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5pZCA9PT0gbWF0Y2guaWQgJiYgY2h1bmsuaW5kZXggPT09IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNodW5rIGhhcyBhbiBpZCwgd2UgbWF0Y2ggb24gaWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWRcIiBpbiBjaHVuayAmJiBjaHVuay5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLmlkID09PSBtYXRjaC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaHVuayBoYXMgYW4gaW5kZXgsIHdlIG1hdGNoIG9uIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImluZGV4XCIgaW4gY2h1bmsgJiYgY2h1bmsuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rLmluZGV4ID09PSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDaHVua0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbWF0Y2hlZENodW5rSW5kZXhdLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goW2NodW5rXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmtzIG9mIGdyb3VwZWRUb29sQ2FsbENodW5rcykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcmdzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNodW5rc1swXT8ubmFtZSA/PyBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZEFyZ3MgPSBjaHVua3MubWFwKChjKSA9PiBjLmFyZ3MgfHwgXCJcIikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzU3RyID0gam9pbmVkQXJncy5sZW5ndGggPyBqb2luZWRBcmdzIDogXCJ7fVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY2h1bmtzWzBdPy5pZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcmdzID0gKDAsIGpzb25fanNfMS5wYXJzZVBhcnRpYWxKc29uKShhcmdzU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXJncyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhcnNlZEFyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0b29sIGNhbGwgY2h1bmsgYXJncy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZEFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NTdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIk1hbGZvcm1lZCBhcmdzLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkX3Rvb2xfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBpbnZhbGlkVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiBmaWVsZHMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkcy51c2FnZV9tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FkbHksIFR5cGVTY3JpcHQgb25seSBhbGxvd3Mgc3VwZXIoKSBjYWxscyBhdCByb290IGlmIHRoZSBjbGFzcyBoYXNcbiAgICAgICAgLy8gcHJvcGVydGllcyB3aXRoIGluaXRpYWxpemVycywgc28gd2UgaGF2ZSB0byBjaGVjayB0eXBlcyB0d2ljZS5cbiAgICAgICAgc3VwZXIoaW5pdFBhcmFtcyk7XG4gICAgICAgIC8vIE11c3QgcmVkZWNsYXJlIHRvb2wgY2FsbCBmaWVsZHMgc2luY2UgdGhlcmUgaXMgbm8gbXVsdGlwbGUgaW5oZXJpdGFuY2UgaW4gSlMuXG4gICAgICAgIC8vIFRoZXNlIGFyZSB0eXBlZCBhcyBvcHRpb25hbCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzIGFuZCBhbGxvdyBmb3IgY2FzdGluZ1xuICAgICAgICAvLyBmcm9tIEJhc2VNZXNzYWdlLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW52YWxpZF90b29sX2NhbGxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2NodW5rc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfY2h1bmtzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMudG9vbF9jYWxsX2NodW5rcyA/PyB0aGlzLnRvb2xfY2FsbF9jaHVua3M7XG4gICAgICAgIHRoaXMudG9vbF9jYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscyA/PyB0aGlzLnRvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMuaW52YWxpZF90b29sX2NhbGxzID1cbiAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB0aGlzLnVzYWdlX21ldGFkYXRhID0gaW5pdFBhcmFtcy51c2FnZV9tZXRhZGF0YTtcbiAgICB9XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5sY19hbGlhc2VzLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IFwiaW52YWxpZF90b29sX2NhbGxzXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBcInRvb2xfY2FsbF9jaHVua3NcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiB0aGlzLnRvb2xfY2FsbF9jaHVua3MsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICBjb25zdCBjb21iaW5lZEZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50b29sX2NhbGxfY2h1bmtzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNodW5rLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gKDAsIGJhc2VfanNfMS5fbWVyZ2VMaXN0cykodGhpcy50b29sX2NhbGxfY2h1bmtzLCBjaHVuay50b29sX2NhbGxfY2h1bmtzKTtcbiAgICAgICAgICAgIGlmIChyYXdUb29sQ2FsbHMgIT09IHVuZGVmaW5lZCAmJiByYXdUb29sQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkRmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPSByYXdUb29sQ2FsbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRUb2tlbkRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX3JlYWQgIT09XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCkgJiYge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZV9yZWFkOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX3JlYWQgPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCkgJiYge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZV9jcmVhdGlvbjogKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfY3JlYXRpb24gPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0VG9rZW5EZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyAhPT0gdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvOiAodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LnJlYXNvbmluZyAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbmluZzogKHRoaXMudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBjaHVuay51c2FnZV9tZXRhZGF0YSA/PyB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVzYWdlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogbGVmdC5pbnB1dF90b2tlbnMgKyByaWdodC5pbnB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogbGVmdC5vdXRwdXRfdG9rZW5zICsgcmlnaHQub3V0cHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IGxlZnQudG90YWxfdG9rZW5zICsgcmlnaHQudG90YWxfdG9rZW5zLFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIGBpbnB1dF90b2tlbl9kZXRhaWxzYCAvIGBvdXRwdXRfdG9rZW5fZGV0YWlsc2Aga2V5cyBpbiBjb21iaW5lZCBmaWVsZHNcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhlaXIgdmFsdWVzIGFyZSBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIC4uLihPYmplY3Qua2V5cyhpbnB1dFRva2VuRGV0YWlscykubGVuZ3RoID4gMCAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuX2RldGFpbHM6IGlucHV0VG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLihPYmplY3Qua2V5cyhvdXRwdXRUb2tlbkRldGFpbHMpLmxlbmd0aCA+IDAgJiYge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5fZGV0YWlsczogb3V0cHV0VG9rZW5EZXRhaWxzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbWJpbmVkRmllbGRzLnVzYWdlX21ldGFkYXRhID0gdXNhZ2VfbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2VDaHVuayhjb21iaW5lZEZpZWxkcyk7XG4gICAgfVxufVxuZXhwb3J0cy5BSU1lc3NhZ2VDaHVuayA9IEFJTWVzc2FnZUNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/base.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseMessageChunk = exports.BaseMessage = void 0;\nexports.mergeContent = mergeContent;\nexports._mergeStatus = _mergeStatus;\nexports.isOpenAIToolCallArray = isOpenAIToolCallArray;\nexports._mergeDicts = _mergeDicts;\nexports._mergeLists = _mergeLists;\nexports._mergeObj = _mergeObj;\nexports._isMessageFieldWithRole = _isMessageFieldWithRole;\nexports.isBaseMessage = isBaseMessage;\nexports.isBaseMessageChunk = isBaseMessageChunk;\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst content_blocks_js_1 = __webpack_require__(/*! ./content_blocks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\");\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (firstContent === \"\") {\n            return secondContent;\n        }\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else if (Array.isArray(secondContent) &&\n            secondContent.some((c) => (0, content_blocks_js_1.isDataContentBlock)(c))) {\n            return [\n                {\n                    type: \"text\",\n                    source_type: \"text\",\n                    text: firstContent,\n                },\n                ...secondContent,\n            ];\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return (_mergeLists(firstContent, secondContent) ?? [\n            ...firstContent,\n            ...secondContent,\n        ]);\n    }\n    else {\n        if (secondContent === \"\") {\n            return firstContent;\n        }\n        else if (Array.isArray(firstContent) &&\n            firstContent.some((c) => (0, content_blocks_js_1.isDataContentBlock)(c))) {\n            return [\n                ...firstContent,\n                {\n                    type: \"file\",\n                    source_type: \"text\",\n                    text: secondContent,\n                },\n            ];\n        }\n        else {\n            return [...firstContent, { type: \"text\", text: secondContent }];\n        }\n    }\n}\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nfunction _mergeStatus(left, right) {\n    if (left === \"error\" || right === \"error\") {\n        return \"error\";\n    }\n    return \"success\";\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj, depthLimit) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function helper(obj, currentDepth) {\n        if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n            return obj;\n        }\n        if (currentDepth >= depthLimit) {\n            if (Array.isArray(obj)) {\n                return \"[Array]\";\n            }\n            return \"[Object]\";\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item) => helper(item, currentDepth + 1));\n        }\n        const result = {};\n        for (const key of Object.keys(obj)) {\n            result[key] = helper(obj[key], currentDepth + 1);\n        }\n        return result;\n    }\n    return JSON.stringify(helper(obj, 0), null, 2);\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nclass BaseMessage extends serializable_js_1.Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * Get text content of the message.\n     */\n    get text() {\n        if (typeof this.content === \"string\") {\n            return this.content;\n        }\n        if (!Array.isArray(this.content))\n            return \"\";\n        return this.content\n            .map((c) => {\n            if (typeof c === \"string\")\n                return c;\n            if (c.type === \"text\")\n                return c.text;\n            return \"\";\n        })\n            .join(\"\");\n    }\n    /** The type of the message. */\n    getType() {\n        return this._getType();\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * An optional unique identifier for the message. This should ideally be\n         * provided by the provider/model which created the message.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n        this.id = fields.id;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    static lc_name() {\n        return \"BaseMessage\";\n    }\n    // Can't be protected for silly reasons\n    get _printableFields() {\n        return {\n            id: this.id,\n            content: this.content,\n            name: this.name,\n            additional_kwargs: this.additional_kwargs,\n            response_metadata: this.response_metadata,\n        };\n    }\n    // this private method is used to update the ID for the runtime\n    // value as well as in lc_kwargs for serialisation\n    _updateId(value) {\n        this.id = value;\n        // lc_attributes wouldn't work here, because jest compares the\n        // whole object\n        this.lc_kwargs.id = value;\n    }\n    get [Symbol.toStringTag]() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.constructor.lc_name();\n    }\n    // Override the default behavior of console.log\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth) {\n        if (depth === null) {\n            return this;\n        }\n        const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return `${this.constructor.lc_name()} ${printable}`;\n    }\n}\nexports.BaseMessage = BaseMessage;\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            if (key === \"type\") {\n                // Do not merge 'type' fields\n                continue;\n            }\n            else if ([\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)) {\n                // Keep the incoming value for these fields\n                merged[key] = value;\n            }\n            else {\n                merged[key] += value;\n            }\n        }\n        else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = _mergeLists(merged[key], value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\nfunction _mergeLists(left, right) {\n    if (left === undefined && right === undefined) {\n        return undefined;\n    }\n    else if (left === undefined || right === undefined) {\n        return left || right;\n    }\n    else {\n        const merged = [...left];\n        for (const item of right) {\n            if (typeof item === \"object\" &&\n                item !== null &&\n                \"index\" in item &&\n                typeof item.index === \"number\") {\n                const toMerge = merged.findIndex((leftItem) => {\n                    const isObject = typeof leftItem === \"object\";\n                    const indiciesMatch = \"index\" in leftItem && leftItem.index === item.index;\n                    const idsMatch = \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n                    const eitherItemMissingID = !(\"id\" in leftItem) ||\n                        !leftItem?.id ||\n                        !(\"id\" in item) ||\n                        !item?.id;\n                    return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n                });\n                if (toMerge !== -1 &&\n                    typeof merged[toMerge] === \"object\" &&\n                    merged[toMerge] !== null) {\n                    merged[toMerge] = _mergeDicts(merged[toMerge], item);\n                }\n                else {\n                    merged.push(item);\n                }\n            }\n            else if (typeof item === \"object\" &&\n                item !== null &&\n                \"text\" in item &&\n                item.text === \"\") {\n                // No-op - skip empty text blocks\n                continue;\n            }\n            else {\n                merged.push(item);\n            }\n        }\n        return merged;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _mergeObj(left, right) {\n    if (!left && !right) {\n        throw new Error(\"Cannot merge two undefined objects.\");\n    }\n    if (!left || !right) {\n        return left || right;\n    }\n    else if (typeof left !== typeof right) {\n        throw new Error(`Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`);\n    }\n    else if (typeof left === \"string\" && typeof right === \"string\") {\n        return (left + right);\n    }\n    else if (Array.isArray(left) && Array.isArray(right)) {\n        return _mergeLists(left, right);\n    }\n    else if (typeof left === \"object\" && typeof right === \"object\") {\n        return _mergeDicts(left, right);\n    }\n    else if (left === right) {\n        return left;\n    }\n    else {\n        throw new Error(`Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`);\n    }\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nclass BaseMessageChunk extends BaseMessage {\n}\nexports.BaseMessageChunk = BaseMessageChunk;\nfunction _isMessageFieldWithRole(x) {\n    return typeof x.role === \"string\";\n}\nfunction isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nfunction isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLCtCQUErQjtBQUMvQixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLDBCQUEwQixtQkFBTyxDQUFDLGlHQUEwQjtBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUNBQW1DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QixFQUFFLFVBQVU7QUFDMUQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVksVUFBVSxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsS0FBSyxVQUFVLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvYmFzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLkJhc2VNZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5tZXJnZUNvbnRlbnQgPSBtZXJnZUNvbnRlbnQ7XG5leHBvcnRzLl9tZXJnZVN0YXR1cyA9IF9tZXJnZVN0YXR1cztcbmV4cG9ydHMuaXNPcGVuQUlUb29sQ2FsbEFycmF5ID0gaXNPcGVuQUlUb29sQ2FsbEFycmF5O1xuZXhwb3J0cy5fbWVyZ2VEaWN0cyA9IF9tZXJnZURpY3RzO1xuZXhwb3J0cy5fbWVyZ2VMaXN0cyA9IF9tZXJnZUxpc3RzO1xuZXhwb3J0cy5fbWVyZ2VPYmogPSBfbWVyZ2VPYmo7XG5leHBvcnRzLl9pc01lc3NhZ2VGaWVsZFdpdGhSb2xlID0gX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGU7XG5leHBvcnRzLmlzQmFzZU1lc3NhZ2UgPSBpc0Jhc2VNZXNzYWdlO1xuZXhwb3J0cy5pc0Jhc2VNZXNzYWdlQ2h1bmsgPSBpc0Jhc2VNZXNzYWdlQ2h1bms7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBjb250ZW50X2Jsb2Nrc19qc18xID0gcmVxdWlyZShcIi4vY29udGVudF9ibG9ja3MuY2pzXCIpO1xuZnVuY3Rpb24gbWVyZ2VDb250ZW50KGZpcnN0Q29udGVudCwgc2Vjb25kQ29udGVudCkge1xuICAgIC8vIElmIGZpcnN0IGNvbnRlbnQgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGZpcnN0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZmlyc3RDb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vjb25kQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY29uZENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdENvbnRlbnQgKyBzZWNvbmRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kQ29udGVudCkgJiZcbiAgICAgICAgICAgIHNlY29uZENvbnRlbnQuc29tZSgoYykgPT4gKDAsIGNvbnRlbnRfYmxvY2tzX2pzXzEuaXNEYXRhQ29udGVudEJsb2NrKShjKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX3R5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmaXJzdENvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5zZWNvbmRDb250ZW50LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogZmlyc3RDb250ZW50IH0sIC4uLnNlY29uZENvbnRlbnRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGJvdGggYXJlIGFycmF5c1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlY29uZENvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiAoX21lcmdlTGlzdHMoZmlyc3RDb250ZW50LCBzZWNvbmRDb250ZW50KSA/PyBbXG4gICAgICAgICAgICAuLi5maXJzdENvbnRlbnQsXG4gICAgICAgICAgICAuLi5zZWNvbmRDb250ZW50LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWNvbmRDb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RDb250ZW50KSAmJlxuICAgICAgICAgICAgZmlyc3RDb250ZW50LnNvbWUoKGMpID0+ICgwLCBjb250ZW50X2Jsb2Nrc19qc18xLmlzRGF0YUNvbnRlbnRCbG9jaykoYykpKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmZpcnN0Q29udGVudCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VfdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHNlY29uZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmZpcnN0Q29udGVudCwgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogc2Vjb25kQ29udGVudCB9XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogJ01lcmdlJyB0d28gc3RhdHVzZXMuIElmIGVpdGhlciB2YWx1ZSBwYXNzZWQgaXMgJ2Vycm9yJywgaXQgd2lsbCByZXR1cm4gJ2Vycm9yJy4gRWxzZVxuICogaXQgd2lsbCByZXR1cm4gJ3N1Y2Nlc3MnLlxuICpcbiAqIEBwYXJhbSB7XCJzdWNjZXNzXCIgfCBcImVycm9yXCIgfCB1bmRlZmluZWR9IGxlZnQgVGhlIGV4aXN0aW5nIHZhbHVlIHRvICdtZXJnZScgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICogQHBhcmFtIHtcInN1Y2Nlc3NcIiB8IFwiZXJyb3JcIiB8IHVuZGVmaW5lZH0gcmlnaHQgVGhlIG5ldyB2YWx1ZSB0byAnbWVyZ2UnIHdpdGggdGhlIGV4aXN0aW5nIHZhbHVlXG4gKiBAcmV0dXJucyB7XCJzdWNjZXNzXCIgfCBcImVycm9yXCJ9IFRoZSAnbWVyZ2VkJyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gX21lcmdlU3RhdHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IFwiZXJyb3JcIiB8fCByaWdodCA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN1Y2Nlc3NcIjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdChvYmosIGRlcHRoTGltaXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGZ1bmN0aW9uIGhlbHBlcihvYmosIGN1cnJlbnREZXB0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnREZXB0aCA+PSBkZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW0FycmF5XVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiW09iamVjdF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcCgoaXRlbSkgPT4gaGVscGVyKGl0ZW0sIGN1cnJlbnREZXB0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZWxwZXIob2JqW2tleV0sIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShoZWxwZXIob2JqLCAwKSwgbnVsbCwgMik7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBvZiBtZXNzYWdlcyBpbiBhIGNvbnZlcnNhdGlvbi4gSXQgaW5jbHVkZXNcbiAqIHByb3BlcnRpZXMgbGlrZSBgY29udGVudGAsIGBuYW1lYCwgYW5kIGBhZGRpdGlvbmFsX2t3YXJnc2AuIEl0IGFsc29cbiAqIGluY2x1ZGVzIG1ldGhvZHMgbGlrZSBgdG9EaWN0KClgIGFuZCBgX2dldFR5cGUoKWAuXG4gKi9cbmNsYXNzIEJhc2VNZXNzYWdlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBcImFkZGl0aW9uYWxfa3dhcmdzXCIsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogXCJyZXNwb25zZV9tZXRhZGF0YVwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGV4dCBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50XG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInRleHRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gYy50ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyxcbiAgICAgICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYWRkaXRpb25hbF9rd2FyZ3MgaXMgcGFzc2VkIGludG8gc3VwZXIoKSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoIWZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwibWVzc2FnZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBzZW5kZXIgaW4gYSBtdWx0aS11c2VyIGNoYXQuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbF9rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFJlc3BvbnNlIG1ldGFkYXRhLiBGb3IgZXhhbXBsZTogcmVzcG9uc2UgaGVhZGVycywgbG9ncHJvYnMsIHRva2VuIGNvdW50cywgbW9kZWwgbmFtZS4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbWVzc2FnZS4gVGhpcyBzaG91bGQgaWRlYWxseSBiZVxuICAgICAgICAgKiBwcm92aWRlZCBieSB0aGUgcHJvdmlkZXIvbW9kZWwgd2hpY2ggY3JlYXRlZCB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsX2t3YXJncyA9IGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncztcbiAgICAgICAgdGhpcy5yZXNwb25zZV9tZXRhZGF0YSA9IGZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG4gICAgdG9EaWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZSgpLFxuICAgICAgICAgICAgZGF0YTogdGhpcy50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5rd2FyZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCYXNlTWVzc2FnZVwiO1xuICAgIH1cbiAgICAvLyBDYW4ndCBiZSBwcm90ZWN0ZWQgZm9yIHNpbGx5IHJlYXNvbnNcbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogdGhpcy5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gdGhpcyBwcml2YXRlIG1ldGhvZCBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgSUQgZm9yIHRoZSBydW50aW1lXG4gICAgLy8gdmFsdWUgYXMgd2VsbCBhcyBpbiBsY19rd2FyZ3MgZm9yIHNlcmlhbGlzYXRpb25cbiAgICBfdXBkYXRlSWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pZCA9IHZhbHVlO1xuICAgICAgICAvLyBsY19hdHRyaWJ1dGVzIHdvdWxkbid0IHdvcmsgaGVyZSwgYmVjYXVzZSBqZXN0IGNvbXBhcmVzIHRoZVxuICAgICAgICAvLyB3aG9sZSBvYmplY3RcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MuaWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCk7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvbnNvbGUubG9nXG4gICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmludGFibGUgPSBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdCh0aGlzLl9wcmludGFibGVGaWVsZHMsIE1hdGgubWF4KDQsIGRlcHRoKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLmxjX25hbWUoKX0gJHtwcmludGFibGV9YDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VNZXNzYWdlID0gQmFzZU1lc3NhZ2U7XG5mdW5jdGlvbiBpc09wZW5BSVRvb2xDYWxsQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIHZhbHVlLmV2ZXJ5KCh2KSA9PiB0eXBlb2Ygdi5pbmRleCA9PT0gXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gX21lcmdlRGljdHMoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubGVmdCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxucmlnaHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBtZXJnZWQgPSB7IC4uLmxlZnQgfTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyaWdodCkpIHtcbiAgICAgICAgaWYgKG1lcmdlZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldICE9PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoZSBtZXNzYWdlIGNodW5rLCBidXQgd2l0aCBhIGRpZmZlcmVudCB0eXBlLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgbWVyZ2UgJ3R5cGUnIGZpZWxkc1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoW1wiaWRcIiwgXCJuYW1lXCIsIFwib3V0cHV0X3ZlcnNpb25cIiwgXCJtb2RlbF9wcm92aWRlclwiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgaW5jb21pbmcgdmFsdWUgZm9yIHRoZXNlIGZpZWxkc1xuICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZURpY3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gX21lcmdlTGlzdHMobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZWRba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoaXMgbWVzc2FnZSBjaHVuayBhbmQgdmFsdWUgaGFzIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIF9tZXJnZUxpc3RzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCB8fCByaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gWy4uLmxlZnRdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGl0ZW0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBcImluZGV4XCIgaW4gaXRlbSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9NZXJnZSA9IG1lcmdlZC5maW5kSW5kZXgoKGxlZnRJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gdHlwZW9mIGxlZnRJdGVtID09PSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRpY2llc01hdGNoID0gXCJpbmRleFwiIGluIGxlZnRJdGVtICYmIGxlZnRJdGVtLmluZGV4ID09PSBpdGVtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHNNYXRjaCA9IFwiaWRcIiBpbiBsZWZ0SXRlbSAmJiBcImlkXCIgaW4gaXRlbSAmJiBsZWZ0SXRlbT8uaWQgPT09IGl0ZW0/LmlkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlaXRoZXJJdGVtTWlzc2luZ0lEID0gIShcImlkXCIgaW4gbGVmdEl0ZW0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhbGVmdEl0ZW0/LmlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhKFwiaWRcIiBpbiBpdGVtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWl0ZW0/LmlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QgJiYgaW5kaWNpZXNNYXRjaCAmJiAoaWRzTWF0Y2ggfHwgZWl0aGVySXRlbU1pc3NpbmdJRCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRvTWVyZ2UgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtZXJnZWRbdG9NZXJnZV0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW3RvTWVyZ2VdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFt0b01lcmdlXSA9IF9tZXJnZURpY3RzKG1lcmdlZFt0b01lcmdlXSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGl0ZW0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBcInRleHRcIiBpbiBpdGVtICYmXG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8tb3AgLSBza2lwIGVtcHR5IHRleHQgYmxvY2tzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfbWVyZ2VPYmoobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSB0d28gdW5kZWZpbmVkIG9iamVjdHMuXCIpO1xuICAgIH1cbiAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCAhPT0gdHlwZW9mIHJpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1lcmdlIG9iamVjdHMgb2YgZGlmZmVyZW50IHR5cGVzLlxcbkxlZnQgJHt0eXBlb2YgbGVmdH1cXG5SaWdodCAke3R5cGVvZiByaWdodH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJpZ2h0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiAobGVmdCArIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICAgICAgICByZXR1cm4gX21lcmdlTGlzdHMobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGVmdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmlnaHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9tZXJnZURpY3RzKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgbWVyZ2Ugb2JqZWN0cyBvZiBkaWZmZXJlbnQgdHlwZXMuXFxuTGVmdCAke2xlZnR9XFxuUmlnaHQgJHtyaWdodH1gKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICogbWVzc2FnZSBjaHVua3MuIEl0IGluY2x1ZGVzIGEgbWV0aG9kIGBfbWVyZ2Vfa3dhcmdzX2RpY3QoKWAgZm9yIG1lcmdpbmdcbiAqIGFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhbm90aGVyIGBCYXNlTWVzc2FnZUNodW5rYCBpbnRvIHRoaXNcbiAqIG9uZS4gSXQgYWxzbyBvdmVycmlkZXMgdGhlIGBfX2FkZF9fKClgIG1ldGhvZCB0byBzdXBwb3J0IGNvbmNhdGVuYXRpb25cbiAqIG9mIGBCYXNlTWVzc2FnZUNodW5rYCBpbnN0YW5jZXMuXG4gKi9cbmNsYXNzIEJhc2VNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG59XG5leHBvcnRzLkJhc2VNZXNzYWdlQ2h1bmsgPSBCYXNlTWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeC5yb2xlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNCYXNlTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZUxpa2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0Jhc2VNZXNzYWdlQ2h1bmsobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gKGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpICYmXG4gICAgICAgIHR5cGVvZiBtZXNzYWdlTGlrZS5jb25jYXQgPT09IFwiZnVuY3Rpb25cIik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/chat.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatMessageChunk = exports.ChatMessage = void 0;\nexports.isChatMessage = isChatMessage;\nexports.isChatMessageChunk = isChatMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a chat message in a conversation.\n */\nclass ChatMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessage = ChatMessage;\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nclass ChatMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n            id: this.id ?? chunk.id,\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            role: this.role,\n        };\n    }\n}\nexports.ChatMessageChunk = ChatMessageChunk;\nfunction isChatMessage(x) {\n    return x._getType() === \"generic\";\n}\nfunction isChatMessageChunk(x) {\n    return x._getType() === \"generic\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9jaGF0LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhdE1lc3NhZ2VDaHVuayA9IGV4cG9ydHMuQ2hhdE1lc3NhZ2UgPSB2b2lkIDA7XG5leHBvcnRzLmlzQ2hhdE1lc3NhZ2UgPSBpc0NoYXRNZXNzYWdlO1xuZXhwb3J0cy5pc0NoYXRNZXNzYWdlQ2h1bmsgPSBpc0NoYXRNZXNzYWdlQ2h1bms7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNoYXQgbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuY2xhc3MgQ2hhdE1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0TWVzc2FnZVwiO1xuICAgIH1cbiAgICBzdGF0aWMgX2NoYXRNZXNzYWdlQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiBDaGF0TWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCByb2xlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCByb2xlOiByb2xlIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvbGUgPSBmaWVsZHMucm9sZTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5zdGFuY2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgZ2V0IF9wcmludGFibGVGaWVsZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci5fcHJpbnRhYmxlRmllbGRzLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdE1lc3NhZ2UgPSBDaGF0TWVzc2FnZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgY2hhdCBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIENoYXRNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCByb2xlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCByb2xlOiByb2xlIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvbGUgPSBmaWVsZHMucm9sZTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdE1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiAoMCwgYmFzZV9qc18xLm1lcmdlQ29udGVudCkodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0TWVzc2FnZUNodW5rID0gQ2hhdE1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGlzQ2hhdE1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xufVxuZnVuY3Rpb24gaXNDaGF0TWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/content_blocks.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDataContentBlock = isDataContentBlock;\nexports.isURLContentBlock = isURLContentBlock;\nexports.isBase64ContentBlock = isBase64ContentBlock;\nexports.isPlainTextContentBlock = isPlainTextContentBlock;\nexports.isIDContentBlock = isIDContentBlock;\nexports.convertToOpenAIImageBlock = convertToOpenAIImageBlock;\nexports.parseMimeType = parseMimeType;\nexports.parseBase64DataUrl = parseBase64DataUrl;\nexports.convertToProviderContentBlock = convertToProviderContentBlock;\nfunction isDataContentBlock(content_block) {\n    return (typeof content_block === \"object\" &&\n        content_block !== null &&\n        \"type\" in content_block &&\n        typeof content_block.type === \"string\" &&\n        \"source_type\" in content_block &&\n        (content_block.source_type === \"url\" ||\n            content_block.source_type === \"base64\" ||\n            content_block.source_type === \"text\" ||\n            content_block.source_type === \"id\"));\n}\nfunction isURLContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"url\" &&\n        \"url\" in content_block &&\n        typeof content_block.url === \"string\");\n}\nfunction isBase64ContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"base64\" &&\n        \"data\" in content_block &&\n        typeof content_block.data === \"string\");\n}\nfunction isPlainTextContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"text\" &&\n        \"text\" in content_block &&\n        typeof content_block.text === \"string\");\n}\nfunction isIDContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"id\" &&\n        \"id\" in content_block &&\n        typeof content_block.id === \"string\");\n}\nfunction convertToOpenAIImageBlock(content_block) {\n    if (isDataContentBlock(content_block)) {\n        if (content_block.source_type === \"url\") {\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: content_block.url,\n                },\n            };\n        }\n        if (content_block.source_type === \"base64\") {\n            if (!content_block.mime_type) {\n                throw new Error(\"mime_type key is required for base64 data.\");\n            }\n            const mime_type = content_block.mime_type;\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: `data:${mime_type};base64,${content_block.data}`,\n                },\n            };\n        }\n    }\n    throw new Error(\"Unsupported source type. Only 'url' and 'base64' are supported.\");\n}\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n */\nfunction parseMimeType(mime_type) {\n    const parts = mime_type.split(\";\")[0].split(\"/\");\n    if (parts.length !== 2) {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`);\n    }\n    const type = parts[0].trim();\n    const subtype = parts[1].trim();\n    if (type === \"\" || subtype === \"\") {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - type or subtype is empty.`);\n    }\n    const parameters = {};\n    for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n        const parameterParts = parameterKvp.split(\"=\");\n        if (parameterParts.length !== 2) {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        const key = parameterParts[0].trim();\n        const value = parameterParts[1].trim();\n        if (key === \"\") {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        parameters[key] = value;\n    }\n    return {\n        type,\n        subtype,\n        parameters,\n    };\n}\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n */\nfunction parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false, }) {\n    const formatMatch = data_url.match(/^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/);\n    let mime_type;\n    if (formatMatch) {\n        mime_type = formatMatch[1].toLowerCase();\n        const data = asTypedArray\n            ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n            : formatMatch[2];\n        return {\n            mime_type,\n            data,\n        };\n    }\n    return undefined;\n}\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n */\nfunction convertToProviderContentBlock(block, converter) {\n    if (block.type === \"text\") {\n        if (!converter.fromStandardTextBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`);\n        }\n        return converter.fromStandardTextBlock(block);\n    }\n    if (block.type === \"image\") {\n        if (!converter.fromStandardImageBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`);\n        }\n        return converter.fromStandardImageBlock(block);\n    }\n    if (block.type === \"audio\") {\n        if (!converter.fromStandardAudioBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`);\n        }\n        return converter.fromStandardAudioBlock(block);\n    }\n    if (block.type === \"file\") {\n        if (!converter.fromStandardFileBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`);\n        }\n        return converter.fromStandardFileBlock(block);\n    }\n    throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY29udGVudF9ibG9ja3MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLFNBQVMsbUJBQW1CO0FBQ3hFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQTBDO0FBQ3hFLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY29udGVudF9ibG9ja3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0RhdGFDb250ZW50QmxvY2sgPSBpc0RhdGFDb250ZW50QmxvY2s7XG5leHBvcnRzLmlzVVJMQ29udGVudEJsb2NrID0gaXNVUkxDb250ZW50QmxvY2s7XG5leHBvcnRzLmlzQmFzZTY0Q29udGVudEJsb2NrID0gaXNCYXNlNjRDb250ZW50QmxvY2s7XG5leHBvcnRzLmlzUGxhaW5UZXh0Q29udGVudEJsb2NrID0gaXNQbGFpblRleHRDb250ZW50QmxvY2s7XG5leHBvcnRzLmlzSURDb250ZW50QmxvY2sgPSBpc0lEQ29udGVudEJsb2NrO1xuZXhwb3J0cy5jb252ZXJ0VG9PcGVuQUlJbWFnZUJsb2NrID0gY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jaztcbmV4cG9ydHMucGFyc2VNaW1lVHlwZSA9IHBhcnNlTWltZVR5cGU7XG5leHBvcnRzLnBhcnNlQmFzZTY0RGF0YVVybCA9IHBhcnNlQmFzZTY0RGF0YVVybDtcbmV4cG9ydHMuY29udmVydFRvUHJvdmlkZXJDb250ZW50QmxvY2sgPSBjb252ZXJ0VG9Qcm92aWRlckNvbnRlbnRCbG9jaztcbmZ1bmN0aW9uIGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgY29udGVudF9ibG9jayA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2sudHlwZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBcInNvdXJjZV90eXBlXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICAoY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ1cmxcIiB8fFxuICAgICAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIiB8fFxuICAgICAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ0ZXh0XCIgfHxcbiAgICAgICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiaWRcIikpO1xufVxuZnVuY3Rpb24gaXNVUkxDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidXJsXCIgJiZcbiAgICAgICAgXCJ1cmxcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLnVybCA9PT0gXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBpc0Jhc2U2NENvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykgJiZcbiAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIiAmJlxuICAgICAgICBcImRhdGFcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLmRhdGEgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gaXNQbGFpblRleHRDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidGV4dFwiICYmXG4gICAgICAgIFwidGV4dFwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2sudGV4dCA9PT0gXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBpc0lEQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImlkXCIgJiZcbiAgICAgICAgXCJpZFwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2suaWQgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgaWYgKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSkge1xuICAgICAgICBpZiAoY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgIGltYWdlX3VybDoge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbnRlbnRfYmxvY2sudXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRfYmxvY2subWltZV90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWltZV90eXBlIGtleSBpcyByZXF1aXJlZCBmb3IgYmFzZTY0IGRhdGEuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWltZV90eXBlID0gY29udGVudF9ibG9jay5taW1lX3R5cGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYGRhdGE6JHttaW1lX3R5cGV9O2Jhc2U2NCwke2NvbnRlbnRfYmxvY2suZGF0YX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSB0eXBlLiBPbmx5ICd1cmwnIGFuZCAnYmFzZTY0JyBhcmUgc3VwcG9ydGVkLlwiKTtcbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgQ2hhdE1vZGVsUHJvdmlkZXJzLiBQYXJzZXMgYSBtaW1lIHR5cGUgaW50byBhIHR5cGUsIHN1YnR5cGUsIGFuZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSBtaW1lX3R5cGUgLSBUaGUgbWltZSB0eXBlIHRvIHBhcnNlLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHR5cGUsIHN1YnR5cGUsIGFuZCBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBwYXJzZU1pbWVUeXBlKG1pbWVfdHlwZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbWltZV90eXBlLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIi9cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiIC0gZG9lcyBub3QgbWF0Y2ggdHlwZS9zdWJ0eXBlIGZvcm1hdC5gKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFydHNbMV0udHJpbSgpO1xuICAgIGlmICh0eXBlID09PSBcIlwiIHx8IHN1YnR5cGUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1pbWUgdHlwZTogXCIke21pbWVfdHlwZX1cIiAtIHR5cGUgb3Igc3VidHlwZSBpcyBlbXB0eS5gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVyS3ZwIG9mIG1pbWVfdHlwZS5zcGxpdChcIjtcIikuc2xpY2UoMSkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyUGFydHMgPSBwYXJhbWV0ZXJLdnAuc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAocGFyYW1ldGVyUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyIHN5bnRheCBpbiBtaW1lIHR5cGU6IFwiJHttaW1lX3R5cGV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyYW1ldGVyUGFydHNbMF0udHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtZXRlclBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtZXRlciBzeW50YXggaW4gbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBzdWJ0eXBlLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgIH07XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIENoYXRNb2RlbFByb3ZpZGVycy4gUGFyc2VzIGEgYmFzZTY0IGRhdGEgVVJMIGludG8gYSB0eXBlZCBhcnJheSBvciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGRhdGFVcmwgLSBUaGUgYmFzZTY0IGRhdGEgVVJMIHRvIHBhcnNlLlxuICogQHBhcmFtIGFzVHlwZWRBcnJheSAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBkYXRhIGFzIGEgdHlwZWQgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGEgYW5kIG1pbWUgdHlwZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIFVSTCBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZUJhc2U2NERhdGFVcmwoeyBkYXRhVXJsOiBkYXRhX3VybCwgYXNUeXBlZEFycmF5ID0gZmFsc2UsIH0pIHtcbiAgICBjb25zdCBmb3JtYXRNYXRjaCA9IGRhdGFfdXJsLm1hdGNoKC9eZGF0YTooXFx3K1xcL1xcdyspO2Jhc2U2NCwoW0EtWmEtejAtOSsvXSs9KikkLyk7XG4gICAgbGV0IG1pbWVfdHlwZTtcbiAgICBpZiAoZm9ybWF0TWF0Y2gpIHtcbiAgICAgICAgbWltZV90eXBlID0gZm9ybWF0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFzVHlwZWRBcnJheVxuICAgICAgICAgICAgPyBVaW50OEFycmF5LmZyb20oYXRvYihmb3JtYXRNYXRjaFsyXSksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICA6IGZvcm1hdE1hdGNoWzJdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWltZV90eXBlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ29udmVydCBmcm9tIGEgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHRvIGEgcHJvdmlkZXIncyBwcm9wcmlldGFyeSBkYXRhIGNvbnRlbnQgYmxvY2sgZm9ybWF0LlxuICpcbiAqIERvbid0IG92ZXJyaWRlIHRoaXMgbWV0aG9kLiBJbnN0ZWFkLCBvdmVycmlkZSB0aGUgbW9yZSBzcGVjaWZpYyBjb252ZXJzaW9uIG1ldGhvZHMgYW5kIHVzZSB0aGlzXG4gKiBtZXRob2QgdW5tb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0gYmxvY2sgLSBUaGUgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgcHJvdmlkZXIgZGF0YSBjb250ZW50IGJsb2NrLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RhbmRhcmQgZGF0YSBjb250ZW50IGJsb2NrIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvUHJvdmlkZXJDb250ZW50QmxvY2soYmxvY2ssIGNvbnZlcnRlcikge1xuICAgIGlmIChibG9jay50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBpZiAoIWNvbnZlcnRlci5mcm9tU3RhbmRhcmRUZXh0QmxvY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVydGVyIGZvciAke2NvbnZlcnRlci5wcm92aWRlck5hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcXGBmcm9tU3RhbmRhcmRUZXh0QmxvY2tcXGAgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkVGV4dEJsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBpZiAoIWNvbnZlcnRlci5mcm9tU3RhbmRhcmRJbWFnZUJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnRlciBmb3IgJHtjb252ZXJ0ZXIucHJvdmlkZXJOYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgXFxgZnJvbVN0YW5kYXJkSW1hZ2VCbG9ja1xcYCBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tU3RhbmRhcmRJbWFnZUJsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwiYXVkaW9cIikge1xuICAgICAgICBpZiAoIWNvbnZlcnRlci5mcm9tU3RhbmRhcmRBdWRpb0Jsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnRlciBmb3IgJHtjb252ZXJ0ZXIucHJvdmlkZXJOYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgXFxgZnJvbVN0YW5kYXJkQXVkaW9CbG9ja1xcYCBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tU3RhbmRhcmRBdWRpb0Jsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgIGlmICghY29udmVydGVyLmZyb21TdGFuZGFyZEZpbGVCbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZEZpbGVCbG9ja1xcYCBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tU3RhbmRhcmRGaWxlQmxvY2soYmxvY2spO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0IGNvbnRlbnQgYmxvY2sgdHlwZSAnJHtibG9jay50eXBlfScgdG8gcHJvdmlkZXItc3BlY2lmaWMgZm9ybWF0OiBub3QgcmVjb2duaXplZC5gKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/function.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FunctionMessageChunk = exports.FunctionMessage = void 0;\nexports.isFunctionMessage = isFunctionMessage;\nexports.isFunctionMessageChunk = isFunctionMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a function message in a conversation.\n */\nclass FunctionMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\nexports.FunctionMessage = FunctionMessage;\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nclass FunctionMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.FunctionMessageChunk = FunctionMessageChunk;\nfunction isFunctionMessage(x) {\n    return x._getType() === \"function\";\n}\nfunction isFunctionMessageChunk(x) {\n    return x._getType() === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvZnVuY3Rpb24uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHVCQUF1QjtBQUN0RCx5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2Z1bmN0aW9uLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnVuY3Rpb25NZXNzYWdlQ2h1bmsgPSBleHBvcnRzLkZ1bmN0aW9uTWVzc2FnZSA9IHZvaWQgMDtcbmV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2UgPSBpc0Z1bmN0aW9uTWVzc2FnZTtcbmV4cG9ydHMuaXNGdW5jdGlvbk1lc3NhZ2VDaHVuayA9IGlzRnVuY3Rpb25NZXNzYWdlQ2h1bms7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGZ1bmN0aW9uIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmNsYXNzIEZ1bmN0aW9uTWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWU6IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uTWVzc2FnZSA9IEZ1bmN0aW9uTWVzc2FnZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgZnVuY3Rpb24gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciBmdW5jdGlvbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgRnVuY3Rpb25NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiAoMCwgYmFzZV9qc18xLm1lcmdlQ29udGVudCkodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5GdW5jdGlvbk1lc3NhZ2VDaHVuayA9IEZ1bmN0aW9uTWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gaXNGdW5jdGlvbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/human.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HumanMessageChunk = exports.HumanMessage = void 0;\nexports.isHumanMessage = isHumanMessage;\nexports.isHumanMessageChunk = isHumanMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a human message in a conversation.\n */\nclass HumanMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\nexports.HumanMessage = HumanMessage;\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nclass HumanMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.HumanMessageChunk = HumanMessageChunk;\nfunction isHumanMessage(x) {\n    return x.getType() === \"human\";\n}\nfunction isHumanMessageChunk(x) {\n    return x.getType() === \"human\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaHVtYW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLG9CQUFvQjtBQUNoRCxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9odW1hbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh1bWFuTWVzc2FnZUNodW5rID0gZXhwb3J0cy5IdW1hbk1lc3NhZ2UgPSB2b2lkIDA7XG5leHBvcnRzLmlzSHVtYW5NZXNzYWdlID0gaXNIdW1hbk1lc3NhZ2U7XG5leHBvcnRzLmlzSHVtYW5NZXNzYWdlQ2h1bmsgPSBpc0h1bWFuTWVzc2FnZUNodW5rO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBodW1hbiBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5jbGFzcyBIdW1hbk1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJIdW1hbk1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLkh1bWFuTWVzc2FnZSA9IEh1bWFuTWVzc2FnZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgaHVtYW4gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBodW1hbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuY2xhc3MgSHVtYW5NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkh1bWFuTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICgwLCBiYXNlX2pzXzEubWVyZ2VDb250ZW50KSh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiAoMCwgYmFzZV9qc18xLl9tZXJnZURpY3RzKSh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdW1hbk1lc3NhZ2VDaHVuayA9IEh1bWFuTWVzc2FnZUNodW5rO1xuZnVuY3Rpb24gaXNIdW1hbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4LmdldFR5cGUoKSA9PT0gXCJodW1hblwiO1xufVxuZnVuY3Rpb24gaXNIdW1hbk1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguZ2V0VHlwZSgpID09PSBcImh1bWFuXCI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isToolMessageChunk = exports.isToolMessage = exports.ToolMessageChunk = exports.ToolMessage = void 0;\n__exportStar(__webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transformers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./content_blocks.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/content_blocks.cjs\"), exports);\n// TODO: Use a star export when we deprecate the\n// existing \"ToolCall\" type in \"base.js\".\nvar tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nObject.defineProperty(exports, \"ToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessage; } }));\nObject.defineProperty(exports, \"ToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.ToolMessageChunk; } }));\nObject.defineProperty(exports, \"isToolMessage\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessage; } }));\nObject.defineProperty(exports, \"isToolMessageChunk\", ({ enumerable: true, get: function () { return tool_js_1.isToolMessageChunk; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQjtBQUNuRyxhQUFhLG1CQUFPLENBQUMsMkVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywrRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsdUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsbUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLGlGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywrRkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHVGQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsbUdBQXNCO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBWTtBQUNwQywrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsb0RBQW1ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2pJLGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxzREFBcUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1Rvb2xNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLmlzVG9vbE1lc3NhZ2UgPSBleHBvcnRzLlRvb2xNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLlRvb2xNZXNzYWdlID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FpLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoYXQuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2h1bWFuLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3lzdGVtLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1lcnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RpZmllci5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRlbnRfYmxvY2tzLmNqc1wiKSwgZXhwb3J0cyk7XG4vLyBUT0RPOiBVc2UgYSBzdGFyIGV4cG9ydCB3aGVuIHdlIGRlcHJlY2F0ZSB0aGVcbi8vIGV4aXN0aW5nIFwiVG9vbENhbGxcIiB0eXBlIGluIFwiYmFzZS5qc1wiLlxudmFyIHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuL3Rvb2wuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9vbE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5Ub29sTWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvb2xNZXNzYWdlQ2h1bmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5Ub29sTWVzc2FnZUNodW5rOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUb29sTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9vbF9qc18xLmlzVG9vbE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Rvb2xNZXNzYWdlQ2h1bmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvb2xfanNfMS5pc1Rvb2xNZXNzYWdlQ2h1bms7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/modifier.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoveMessage = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Message responsible for deleting other messages.\n */\nclass RemoveMessage extends base_js_1.BaseMessage {\n    constructor(fields) {\n        super({\n            ...fields,\n            content: \"\",\n        });\n        /**\n         * The ID of the message to remove.\n         */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = fields.id;\n    }\n    _getType() {\n        return \"remove\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            id: this.id,\n        };\n    }\n}\nexports.RemoveMessage = RemoveMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvbW9kaWZpZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9tb2RpZmllci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlbW92ZU1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbi8qKlxuICogTWVzc2FnZSByZXNwb25zaWJsZSBmb3IgZGVsZXRpbmcgb3RoZXIgbWVzc2FnZXMuXG4gKi9cbmNsYXNzIFJlbW92ZU1lc3NhZ2UgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlkID0gZmllbGRzLmlkO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicmVtb3ZlXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3ZlTWVzc2FnZSA9IFJlbW92ZU1lc3NhZ2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/system.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SystemMessageChunk = exports.SystemMessage = void 0;\nexports.isSystemMessage = isSystemMessage;\nexports.isSystemMessageChunk = isSystemMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\n/**\n * Represents a system message in a conversation.\n */\nclass SystemMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n}\nexports.SystemMessage = SystemMessage;\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nclass SystemMessageChunk extends base_js_1.BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        super(fields, kwargs);\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            id: this.id ?? chunk.id,\n        });\n    }\n}\nexports.SystemMessageChunk = SystemMessageChunk;\nfunction isSystemMessage(x) {\n    return x._getType() === \"system\";\n}\nfunction isSystemMessageChunk(x) {\n    return x._getType() === \"system\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvc3lzdGVtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUI7QUFDbEQsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvc3lzdGVtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3lzdGVtTWVzc2FnZUNodW5rID0gZXhwb3J0cy5TeXN0ZW1NZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc1N5c3RlbU1lc3NhZ2UgPSBpc1N5c3RlbU1lc3NhZ2U7XG5leHBvcnRzLmlzU3lzdGVtTWVzc2FnZUNodW5rID0gaXNTeXN0ZW1NZXNzYWdlQ2h1bms7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHN5c3RlbSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5jbGFzcyBTeXN0ZW1NZXNzYWdlIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLlN5c3RlbU1lc3NhZ2UgPSBTeXN0ZW1NZXNzYWdlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBzeXN0ZW0gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBzeXN0ZW0gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmNsYXNzIFN5c3RlbU1lc3NhZ2VDaHVuayBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzeXN0ZW1cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBrd2FyZ3MpO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlN5c3RlbU1lc3NhZ2VDaHVuayA9IFN5c3RlbU1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGlzU3lzdGVtTWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbn1cbmZ1bmN0aW9uIGlzU3lzdGVtTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/tool.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolMessageChunk = exports.ToolMessage = void 0;\nexports.isDirectToolOutput = isDirectToolOutput;\nexports.defaultToolCallParser = defaultToolCallParser;\nexports.isToolMessage = isToolMessage;\nexports.isToolMessageChunk = isToolMessageChunk;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nfunction isDirectToolOutput(x) {\n    return (x != null &&\n        typeof x === \"object\" &&\n        \"lc_direct_tool_output\" in x &&\n        x.lc_direct_tool_output === true);\n}\n/**\n * Represents a tool message in a conversation.\n */\nclass ToolMessage extends base_js_1.BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_direct_tool_output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n        this.metadata = fields.metadata;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessage = ToolMessage;\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nclass ToolMessageChunk extends base_js_1.BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Status of the tool invocation.\n         * @version 0.2.19\n         */\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Artifact of the Tool execution which is not meant to be sent to the model.\n         *\n         * Should only be specified if it is different from the message content, e.g. if only\n         * a subset of the full tool output is being passed as message content but the full\n         * output is needed in other parts of the code.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"artifact\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n        this.artifact = fields.artifact;\n        this.status = fields.status;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: (0, base_js_1.mergeContent)(this.content, chunk.content),\n            additional_kwargs: (0, base_js_1._mergeDicts)(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: (0, base_js_1._mergeDicts)(this.response_metadata, chunk.response_metadata),\n            artifact: (0, base_js_1._mergeObj)(this.artifact, chunk.artifact),\n            tool_call_id: this.tool_call_id,\n            id: this.id ?? chunk.id,\n            status: (0, base_js_1._mergeStatus)(this.status, chunk.status),\n        });\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_call_id: this.tool_call_id,\n            artifact: this.artifact,\n        };\n    }\n}\nexports.ToolMessageChunk = ToolMessageChunk;\nfunction defaultToolCallParser(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCalls) {\n    const toolCalls = [];\n    const invalidToolCalls = [];\n    for (const toolCall of rawToolCalls) {\n        if (!toolCall.function) {\n            continue;\n        }\n        else {\n            const functionName = toolCall.function.name;\n            try {\n                const functionArgs = JSON.parse(toolCall.function.arguments);\n                const parsed = {\n                    name: functionName || \"\",\n                    args: functionArgs || {},\n                    id: toolCall.id,\n                };\n                toolCalls.push(parsed);\n            }\n            catch (error) {\n                invalidToolCalls.push({\n                    name: functionName,\n                    args: toolCall.function.arguments,\n                    id: toolCall.id,\n                    error: \"Malformed args.\",\n                });\n            }\n        }\n    }\n    return [toolCalls, invalidToolCalls];\n}\nfunction isToolMessage(x) {\n    return x._getType() === \"tool\";\n}\nfunction isToolMessageChunk(x) {\n    return x._getType() === \"tool\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdG9vbC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRvb2xNZXNzYWdlQ2h1bmsgPSBleHBvcnRzLlRvb2xNZXNzYWdlID0gdm9pZCAwO1xuZXhwb3J0cy5pc0RpcmVjdFRvb2xPdXRwdXQgPSBpc0RpcmVjdFRvb2xPdXRwdXQ7XG5leHBvcnRzLmRlZmF1bHRUb29sQ2FsbFBhcnNlciA9IGRlZmF1bHRUb29sQ2FsbFBhcnNlcjtcbmV4cG9ydHMuaXNUb29sTWVzc2FnZSA9IGlzVG9vbE1lc3NhZ2U7XG5leHBvcnRzLmlzVG9vbE1lc3NhZ2VDaHVuayA9IGlzVG9vbE1lc3NhZ2VDaHVuaztcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuZnVuY3Rpb24gaXNEaXJlY3RUb29sT3V0cHV0KHgpIHtcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcImxjX2RpcmVjdF90b29sX291dHB1dFwiIGluIHggJiZcbiAgICAgICAgeC5sY19kaXJlY3RfdG9vbF9vdXRwdXQgPT09IHRydWUpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdG9vbCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5jbGFzcyBUb29sTWVzc2FnZSBleHRlbmRzIGJhc2VfanNfMS5CYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlRvb2xNZXNzYWdlXCI7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4geyB0b29sX2NhbGxfaWQ6IFwidG9vbF9jYWxsX2lkXCIgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB0b29sX2NhbGxfaWQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWUsIHRvb2xfY2FsbF9pZDogdG9vbF9jYWxsX2lkIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZGlyZWN0X3Rvb2xfb3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdHVzIG9mIHRoZSB0b29sIGludm9jYXRpb24uXG4gICAgICAgICAqIEB2ZXJzaW9uIDAuMi4xOVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbF9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHMubWV0YWRhdGE7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBhcnRpZmFjdDogdGhpcy5hcnRpZmFjdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRvb2xNZXNzYWdlID0gVG9vbE1lc3NhZ2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5jbGFzcyBUb29sTWVzc2FnZUNodW5rIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogKDAsIGJhc2VfanNfMS5tZXJnZUNvbnRlbnQpKHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogKDAsIGJhc2VfanNfMS5fbWVyZ2VEaWN0cykodGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6ICgwLCBiYXNlX2pzXzEuX21lcmdlRGljdHMpKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGFydGlmYWN0OiAoMCwgYmFzZV9qc18xLl9tZXJnZU9iaikodGhpcy5hcnRpZmFjdCwgY2h1bmsuYXJ0aWZhY3QpLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICAgICAgc3RhdHVzOiAoMCwgYmFzZV9qc18xLl9tZXJnZVN0YXR1cykodGhpcy5zdGF0dXMsIGNodW5rLnN0YXR1cyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Ub29sTWVzc2FnZUNodW5rID0gVG9vbE1lc3NhZ2VDaHVuaztcbmZ1bmN0aW9uIGRlZmF1bHRUb29sQ2FsbFBhcnNlcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbHMpIHtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiByYXdUb29sQ2FsbHMpIHtcbiAgICAgICAgaWYgKCF0b29sQ2FsbC5mdW5jdGlvbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb25BcmdzIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdO1xufVxuZnVuY3Rpb24gaXNUb29sTWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG59XG5mdW5jdGlvbiBpc1Rvb2xNZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/transformers.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.filterMessages = filterMessages;\nexports.mergeMessageRuns = mergeMessageRuns;\nexports.trimMessages = trimMessages;\nexports.defaultTextSplitter = defaultTextSplitter;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst base_js_2 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst modifier_js_1 = __webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass.getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass.getType();\n        })),\n    ];\n    const msgType = msg.getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nfunction filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return base_js_1.RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nfunction mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return base_js_1.RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg;\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr.getType() === \"tool\" ||\n            !(curr.getType() === last.getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = (0, utils_js_1.convertToChunk)(last);\n            const currChunk = (0, utils_js_1.convertToChunk)(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nfunction trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return base_js_1.RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({\n            runName: \"trim_messages\",\n        });\n    }\n}\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    // Create a copy of messages to avoid mutation\n    let messagesCopy = messages.map((message) => {\n        const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n        return _switchTypeToMessage(message.getType(), fields, (0, base_js_2.isBaseMessageChunk)(message));\n    });\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messagesCopy.length > 0 &&\n            !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) {\n            messagesCopy = messagesCopy.slice(0, -1);\n        }\n    }\n    const swappedSystem = includeSystem && messagesCopy[0]?.getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n        : messagesCopy.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: human_js_1.HumanMessage,\n        messageChunk: human_js_1.HumanMessageChunk,\n    },\n    ai: {\n        message: ai_js_1.AIMessage,\n        messageChunk: ai_js_1.AIMessageChunk,\n    },\n    system: {\n        message: system_js_1.SystemMessage,\n        messageChunk: system_js_1.SystemMessageChunk,\n    },\n    developer: {\n        message: system_js_1.SystemMessage,\n        messageChunk: system_js_1.SystemMessageChunk,\n    },\n    tool: {\n        message: tool_js_1.ToolMessage,\n        messageChunk: tool_js_1.ToolMessageChunk,\n    },\n    function: {\n        message: function_js_1.FunctionMessage,\n        messageChunk: function_js_1.FunctionMessageChunk,\n    },\n    generic: {\n        message: chat_js_1.ChatMessage,\n        messageChunk: chat_js_1.ChatMessageChunk,\n    },\n    remove: {\n        message: modifier_js_1.RemoveMessage,\n        messageChunk: modifier_js_1.RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new human_js_1.HumanMessageChunk(fields);\n            }\n            else {\n                msg = new human_js_1.HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new ai_js_1.AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new ai_js_1.AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new system_js_1.SystemMessageChunk(fields);\n            }\n            else {\n                msg = new system_js_1.SystemMessage(fields);\n            }\n            break;\n        case \"developer\":\n            if (returnChunk) {\n                chunk = new system_js_1.SystemMessageChunk({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            else {\n                msg = new system_js_1.SystemMessage({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new tool_js_1.ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new tool_js_1.ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new function_js_1.FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new function_js_1.FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new chat_js_1.ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new chat_js_1.ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk.getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nfunction defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdHJhbnNmb3JtZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsMkZBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFVO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBYTtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsbUZBQWM7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQyxZQUFZLGtGQUFrRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQixJQUFJLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5SEFBeUg7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLDBCQUEwQiw0QkFBNEI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3RyYW5zZm9ybWVycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbHRlck1lc3NhZ2VzID0gZmlsdGVyTWVzc2FnZXM7XG5leHBvcnRzLm1lcmdlTWVzc2FnZVJ1bnMgPSBtZXJnZU1lc3NhZ2VSdW5zO1xuZXhwb3J0cy50cmltTWVzc2FnZXMgPSB0cmltTWVzc2FnZXM7XG5leHBvcnRzLmRlZmF1bHRUZXh0U3BsaXR0ZXIgPSBkZWZhdWx0VGV4dFNwbGl0dGVyO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IGFpX2pzXzEgPSByZXF1aXJlKFwiLi9haS5janNcIik7XG5jb25zdCBiYXNlX2pzXzIgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGNoYXRfanNfMSA9IHJlcXVpcmUoXCIuL2NoYXQuY2pzXCIpO1xuY29uc3QgZnVuY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uLmNqc1wiKTtcbmNvbnN0IGh1bWFuX2pzXzEgPSByZXF1aXJlKFwiLi9odW1hbi5janNcIik7XG5jb25zdCBtb2RpZmllcl9qc18xID0gcmVxdWlyZShcIi4vbW9kaWZpZXIuY2pzXCIpO1xuY29uc3Qgc3lzdGVtX2pzXzEgPSByZXF1aXJlKFwiLi9zeXN0ZW0uY2pzXCIpO1xuY29uc3QgdG9vbF9qc18xID0gcmVxdWlyZShcIi4vdG9vbC5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuY2pzXCIpO1xuY29uc3QgX2lzTWVzc2FnZVR5cGUgPSAobXNnLCB0eXBlcykgPT4ge1xuICAgIGNvbnN0IHR5cGVzQXNTdHJpbmdzID0gW1xuICAgICAgICAuLi5uZXcgU2V0KHR5cGVzPy5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbnRpYXRlZE1zZ0NsYXNzID0gbmV3IHQoe30pO1xuICAgICAgICAgICAgaWYgKCEoXCJnZXRUeXBlXCIgaW4gaW5zdGFudGlhdGVkTXNnQ2xhc3MpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbnRpYXRlZE1zZ0NsYXNzLmdldFR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVkTXNnQ2xhc3MuZ2V0VHlwZSgpO1xuICAgICAgICB9KSksXG4gICAgXTtcbiAgICBjb25zdCBtc2dUeXBlID0gbXNnLmdldFR5cGUoKTtcbiAgICByZXR1cm4gdHlwZXNBc1N0cmluZ3Muc29tZSgodCkgPT4gdCA9PT0gbXNnVHlwZSk7XG59O1xuZnVuY3Rpb24gZmlsdGVyTWVzc2FnZXMobWVzc2FnZXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlc09yT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJNZXNzYWdlcyhtZXNzYWdlc09yT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJNZXNzYWdlcyhpbnB1dCwgbWVzc2FnZXNPck9wdGlvbnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gX2ZpbHRlck1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGluY2x1ZGVOYW1lcywgZXhjbHVkZU5hbWVzLCBpbmNsdWRlVHlwZXMsIGV4Y2x1ZGVUeXBlcywgaW5jbHVkZUlkcywgZXhjbHVkZUlkcywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1zZyBvZiBtZXNzYWdlcykge1xuICAgICAgICBpZiAoZXhjbHVkZU5hbWVzICYmIG1zZy5uYW1lICYmIGV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVUeXBlcyAmJiBfaXNNZXNzYWdlVHlwZShtc2csIGV4Y2x1ZGVUeXBlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4Y2x1ZGVJZHMgJiYgbXNnLmlkICYmIGV4Y2x1ZGVJZHMuaW5jbHVkZXMobXNnLmlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB0byBpbmNsdXNpb24gd2hlbiBubyBpbmNsdXNpb24gY3JpdGVyaWEgZ2l2ZW4uXG4gICAgICAgIGlmICghKGluY2x1ZGVUeXBlcyB8fCBpbmNsdWRlSWRzIHx8IGluY2x1ZGVOYW1lcykpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlTmFtZXMgJiZcbiAgICAgICAgICAgIG1zZy5uYW1lICYmXG4gICAgICAgICAgICBpbmNsdWRlTmFtZXMuc29tZSgoaU5hbWUpID0+IGlOYW1lID09PSBtc2cubmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmNsdWRlVHlwZXMgJiYgX2lzTWVzc2FnZVR5cGUobXNnLCBpbmNsdWRlVHlwZXMpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZUlkcyAmJiBtc2cuaWQgJiYgaW5jbHVkZUlkcy5zb21lKChpZCkgPT4gaWQgPT09IG1zZy5pZCkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2gobXNnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU1lc3NhZ2VSdW5zKG1lc3NhZ2VzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbShfbWVyZ2VNZXNzYWdlUnVucyk7XG59XG5mdW5jdGlvbiBfbWVyZ2VNZXNzYWdlUnVucyhtZXNzYWdlcykge1xuICAgIGlmICghbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgZm9yIChjb25zdCBtc2cgb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgY29uc3QgY3VyciA9IG1zZztcbiAgICAgICAgY29uc3QgbGFzdCA9IG1lcmdlZC5wb3AoKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyLmdldFR5cGUoKSA9PT0gXCJ0b29sXCIgfHxcbiAgICAgICAgICAgICEoY3Vyci5nZXRUeXBlKCkgPT09IGxhc3QuZ2V0VHlwZSgpKSkge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2gobGFzdCwgY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2h1bmsgPSAoMCwgdXRpbHNfanNfMS5jb252ZXJ0VG9DaHVuaykobGFzdCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyQ2h1bmsgPSAoMCwgdXRpbHNfanNfMS5jb252ZXJ0VG9DaHVuaykoY3Vycik7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRDaHVua3MgPSBsYXN0Q2h1bmsuY29uY2F0KGN1cnJDaHVuayk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RDaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJDaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLmNvbnRlbnQgPSBgJHtsYXN0Q2h1bmsuY29udGVudH1cXG4ke2N1cnJDaHVuay5jb250ZW50fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWQucHVzaChfY2h1bmtUb01zZyhtZXJnZWRDaHVua3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZnVuY3Rpb24gdHJpbU1lc3NhZ2VzKG1lc3NhZ2VzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXNPck9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPck9wdGlvbnM7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiBwcm92aWRpbmcgbWVzc2FnZXMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdHJpbU1lc3NhZ2VzSGVscGVyKG1lc3NhZ2VzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZXJPcHRpb25zID0gbWVzc2FnZXNPck9wdGlvbnM7XG4gICAgICAgIHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQpID0+IF90cmltTWVzc2FnZXNIZWxwZXIoaW5wdXQsIHRyaW1tZXJPcHRpb25zKSkud2l0aENvbmZpZyh7XG4gICAgICAgICAgICBydW5OYW1lOiBcInRyaW1fbWVzc2FnZXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX3RyaW1NZXNzYWdlc0hlbHBlcihtZXNzYWdlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbWF4VG9rZW5zLCB0b2tlbkNvdW50ZXIsIHN0cmF0ZWd5ID0gXCJsYXN0XCIsIGFsbG93UGFydGlhbCA9IGZhbHNlLCBlbmRPbiwgc3RhcnRPbiwgaW5jbHVkZVN5c3RlbSA9IGZhbHNlLCB0ZXh0U3BsaXR0ZXIsIH0gPSBvcHRpb25zO1xuICAgIGlmIChzdGFydE9uICYmIHN0cmF0ZWd5ID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHN0YXJ0T25gIHNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBgc3RyYXRlZ3lgIGlzICdsYXN0Jy5cIik7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlU3lzdGVtICYmIHN0cmF0ZWd5ID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGluY2x1ZGVTeXN0ZW1gIHNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBpZiBgc3RyYXRlZ3lgIGlzICdsYXN0Jy5cIik7XG4gICAgfVxuICAgIGxldCBsaXN0VG9rZW5Db3VudGVyO1xuICAgIGlmIChcImdldE51bVRva2Vuc1wiIGluIHRva2VuQ291bnRlcikge1xuICAgICAgICBsaXN0VG9rZW5Db3VudGVyID0gYXN5bmMgKG1zZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwobXNncy5tYXAoKG1zZykgPT4gdG9rZW5Db3VudGVyLmdldE51bVRva2Vucyhtc2cuY29udGVudCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbkNvdW50cy5yZWR1Y2UoKHN1bSwgY291bnQpID0+IHN1bSArIGNvdW50LCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxpc3RUb2tlbkNvdW50ZXIgPSBhc3luYyAobXNncykgPT4gdG9rZW5Db3VudGVyKG1zZ3MpO1xuICAgIH1cbiAgICBsZXQgdGV4dFNwbGl0dGVyRnVuYyA9IGRlZmF1bHRUZXh0U3BsaXR0ZXI7XG4gICAgaWYgKHRleHRTcGxpdHRlcikge1xuICAgICAgICBpZiAoXCJzcGxpdFRleHRcIiBpbiB0ZXh0U3BsaXR0ZXIpIHtcbiAgICAgICAgICAgIHRleHRTcGxpdHRlckZ1bmMgPSB0ZXh0U3BsaXR0ZXIuc3BsaXRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dFNwbGl0dGVyRnVuYyA9IGFzeW5jICh0ZXh0KSA9PiB0ZXh0U3BsaXR0ZXIodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmF0ZWd5ID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgcmV0dXJuIF9maXJzdE1heFRva2VucyhtZXNzYWdlcywge1xuICAgICAgICAgICAgbWF4VG9rZW5zLFxuICAgICAgICAgICAgdG9rZW5Db3VudGVyOiBsaXN0VG9rZW5Db3VudGVyLFxuICAgICAgICAgICAgdGV4dFNwbGl0dGVyOiB0ZXh0U3BsaXR0ZXJGdW5jLFxuICAgICAgICAgICAgcGFydGlhbFN0cmF0ZWd5OiBhbGxvd1BhcnRpYWwgPyBcImZpcnN0XCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbmRPbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0cmF0ZWd5ID09PSBcImxhc3RcIikge1xuICAgICAgICByZXR1cm4gX2xhc3RNYXhUb2tlbnMobWVzc2FnZXMsIHtcbiAgICAgICAgICAgIG1heFRva2VucyxcbiAgICAgICAgICAgIHRva2VuQ291bnRlcjogbGlzdFRva2VuQ291bnRlcixcbiAgICAgICAgICAgIHRleHRTcGxpdHRlcjogdGV4dFNwbGl0dGVyRnVuYyxcbiAgICAgICAgICAgIGFsbG93UGFydGlhbCxcbiAgICAgICAgICAgIGluY2x1ZGVTeXN0ZW0sXG4gICAgICAgICAgICBzdGFydE9uLFxuICAgICAgICAgICAgZW5kT24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgc3RyYXRlZ3k6ICcke3N0cmF0ZWd5fScuIE11c3QgYmUgb25lIG9mICdmaXJzdCcgb3IgJ2xhc3QnLmApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF9maXJzdE1heFRva2VucyhtZXNzYWdlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbWF4VG9rZW5zLCB0b2tlbkNvdW50ZXIsIHRleHRTcGxpdHRlciwgcGFydGlhbFN0cmF0ZWd5LCBlbmRPbiB9ID0gb3B0aW9ucztcbiAgICBsZXQgbWVzc2FnZXNDb3B5ID0gWy4uLm1lc3NhZ2VzXTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzQ29weS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCByZW1haW5pbmdNZXNzYWdlcyA9IGkgPiAwID8gbWVzc2FnZXNDb3B5LnNsaWNlKDAsIC1pKSA6IG1lc3NhZ2VzQ29weTtcbiAgICAgICAgaWYgKChhd2FpdCB0b2tlbkNvdW50ZXIocmVtYWluaW5nTWVzc2FnZXMpKSA8PSBtYXhUb2tlbnMpIHtcbiAgICAgICAgICAgIGlkeCA9IG1lc3NhZ2VzQ29weS5sZW5ndGggLSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkeCA8IG1lc3NhZ2VzQ29weS5sZW5ndGggJiYgcGFydGlhbFN0cmF0ZWd5KSB7XG4gICAgICAgIGxldCBpbmNsdWRlZFBhcnRpYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXNDb3B5W2lkeF0uY29udGVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gbWVzc2FnZXNDb3B5W2lkeF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4Y2x1ZGVkLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBjb250ZW50IHRvIGJlIGFuIGFycmF5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG51bUJsb2NrID0gZXhjbHVkZWQuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXZlcnNlZENvbnRlbnQgPSBwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiXG4gICAgICAgICAgICAgICAgPyBbLi4uZXhjbHVkZWQuY29udGVudF0ucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgOiBleGNsdWRlZC5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtQmxvY2s7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxDb250ZW50ID0gcGFydGlhbFN0cmF0ZWd5ID09PSBcImZpcnN0XCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXZlcnNlZENvbnRlbnQuc2xpY2UoMCwgaSlcbiAgICAgICAgICAgICAgICAgICAgOiByZXZlcnNlZENvbnRlbnQuc2xpY2UoLWkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhleGNsdWRlZCkuZmlsdGVyKChba10pID0+IGsgIT09IFwidHlwZVwiICYmICFrLnN0YXJ0c1dpdGgoXCJsY19cIikpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZSA9IF9zd2l0Y2hUeXBlVG9NZXNzYWdlKGV4Y2x1ZGVkLmdldFR5cGUoKSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnRpYWxDb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlZE1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzQ29weS5zbGljZSgwLCBpZHgpLCB1cGRhdGVkTWVzc2FnZV07XG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCB0b2tlbkNvdW50ZXIoc2xpY2VkTWVzc2FnZXMpKSA8PSBtYXhUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNDb3B5ID0gc2xpY2VkTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGVkUGFydGlhbCAmJiBwYXJ0aWFsU3RyYXRlZ3kgPT09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWQuY29udGVudCA9IFsuLi5yZXZlcnNlZENvbnRlbnRdLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVkUGFydGlhbCkge1xuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBtZXNzYWdlc0NvcHlbaWR4XTtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhjbHVkZWQuY29udGVudCkgJiZcbiAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50LnNvbWUoKGJsb2NrKSA9PiB0eXBlb2YgYmxvY2sgPT09IFwic3RyaW5nXCIgfHwgYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEJsb2NrID0gZXhjbHVkZWQuY29udGVudC5maW5kKChibG9jaykgPT4gYmxvY2sudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgYmxvY2sudGV4dCk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHRCbG9jaz8udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBleGNsdWRlZC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGV4Y2x1ZGVkLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0VGV4dHMgPSBhd2FpdCB0ZXh0U3BsaXR0ZXIodGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtU3BsaXRzID0gc3BsaXRUZXh0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxTdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRUZXh0cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgbnVtU3BsaXRzIC0gMTsgXyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0VGV4dHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVkLmNvbnRlbnQgPSBzcGxpdFRleHRzLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgdG9rZW5Db3VudGVyKFsuLi5tZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KSwgZXhjbHVkZWRdKSkgPD1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxTdHJhdGVneSA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlZC5jb250ZW50ID0gWy4uLnNwbGl0VGV4dHNdLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNDb3B5ID0gWy4uLm1lc3NhZ2VzQ29weS5zbGljZSgwLCBpZHgpLCBleGNsdWRlZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRPbikge1xuICAgICAgICBjb25zdCBlbmRPbkFyciA9IEFycmF5LmlzQXJyYXkoZW5kT24pID8gZW5kT24gOiBbZW5kT25dO1xuICAgICAgICB3aGlsZSAoaWR4ID4gMCAmJiAhX2lzTWVzc2FnZVR5cGUobWVzc2FnZXNDb3B5W2lkeCAtIDFdLCBlbmRPbkFycikpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlc0NvcHkuc2xpY2UoMCwgaWR4KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9sYXN0TWF4VG9rZW5zKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbGxvd1BhcnRpYWwgPSBmYWxzZSwgaW5jbHVkZVN5c3RlbSA9IGZhbHNlLCBlbmRPbiwgc3RhcnRPbiwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIG1lc3NhZ2VzIHRvIGF2b2lkIG11dGF0aW9uXG4gICAgbGV0IG1lc3NhZ2VzQ29weSA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobWVzc2FnZSkuZmlsdGVyKChba10pID0+IGsgIT09IFwidHlwZVwiICYmICFrLnN0YXJ0c1dpdGgoXCJsY19cIikpKTtcbiAgICAgICAgcmV0dXJuIF9zd2l0Y2hUeXBlVG9NZXNzYWdlKG1lc3NhZ2UuZ2V0VHlwZSgpLCBmaWVsZHMsICgwLCBiYXNlX2pzXzIuaXNCYXNlTWVzc2FnZUNodW5rKShtZXNzYWdlKSk7XG4gICAgfSk7XG4gICAgaWYgKGVuZE9uKSB7XG4gICAgICAgIGNvbnN0IGVuZE9uQXJyID0gQXJyYXkuaXNBcnJheShlbmRPbikgPyBlbmRPbiA6IFtlbmRPbl07XG4gICAgICAgIHdoaWxlIChtZXNzYWdlc0NvcHkubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgIV9pc01lc3NhZ2VUeXBlKG1lc3NhZ2VzQ29weVttZXNzYWdlc0NvcHkubGVuZ3RoIC0gMV0sIGVuZE9uQXJyKSkge1xuICAgICAgICAgICAgbWVzc2FnZXNDb3B5ID0gbWVzc2FnZXNDb3B5LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzd2FwcGVkU3lzdGVtID0gaW5jbHVkZVN5c3RlbSAmJiBtZXNzYWdlc0NvcHlbMF0/LmdldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIjtcbiAgICBsZXQgcmV2ZXJzZWRfID0gc3dhcHBlZFN5c3RlbVxuICAgICAgICA/IG1lc3NhZ2VzQ29weS5zbGljZSgwLCAxKS5jb25jYXQobWVzc2FnZXNDb3B5LnNsaWNlKDEpLnJldmVyc2UoKSlcbiAgICAgICAgOiBtZXNzYWdlc0NvcHkucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkXyA9IGF3YWl0IF9maXJzdE1heFRva2VucyhyZXZlcnNlZF8sIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgcGFydGlhbFN0cmF0ZWd5OiBhbGxvd1BhcnRpYWwgPyBcImxhc3RcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5kT246IHN0YXJ0T24sXG4gICAgfSk7XG4gICAgaWYgKHN3YXBwZWRTeXN0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFtyZXZlcnNlZF9bMF0sIC4uLnJldmVyc2VkXy5zbGljZSgxKS5yZXZlcnNlKCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2VkXy5yZXZlcnNlKCk7XG4gICAgfVxufVxuY29uc3QgX01TR19DSFVOS19NQVAgPSB7XG4gICAgaHVtYW46IHtcbiAgICAgICAgbWVzc2FnZTogaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGFpOiB7XG4gICAgICAgIG1lc3NhZ2U6IGFpX2pzXzEuQUlNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBzeXN0ZW06IHtcbiAgICAgICAgbWVzc2FnZTogc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBkZXZlbG9wZXI6IHtcbiAgICAgICAgbWVzc2FnZTogc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICB0b29sOiB7XG4gICAgICAgIG1lc3NhZ2U6IHRvb2xfanNfMS5Ub29sTWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiB0b29sX2pzXzEuVG9vbE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlLFxuICAgICAgICBtZXNzYWdlQ2h1bms6IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlQ2h1bmssXG4gICAgfSxcbiAgICBnZW5lcmljOiB7XG4gICAgICAgIG1lc3NhZ2U6IGNoYXRfanNfMS5DaGF0TWVzc2FnZSxcbiAgICAgICAgbWVzc2FnZUNodW5rOiBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayxcbiAgICB9LFxuICAgIHJlbW92ZToge1xuICAgICAgICBtZXNzYWdlOiBtb2RpZmllcl9qc18xLlJlbW92ZU1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VDaHVuazogbW9kaWZpZXJfanNfMS5SZW1vdmVNZXNzYWdlLCAvLyBSZW1vdmVNZXNzYWdlIGRvZXMgbm90IGhhdmUgYSBjaHVuayBjbGFzcy5cbiAgICB9LFxufTtcbmZ1bmN0aW9uIF9zd2l0Y2hUeXBlVG9NZXNzYWdlKG1lc3NhZ2VUeXBlLCBmaWVsZHMsIHJldHVybkNodW5rKSB7XG4gICAgbGV0IGNodW5rO1xuICAgIGxldCBtc2c7XG4gICAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChcInRvb2xfY2FsbHNcIiBpbiBhaUNodW5rRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5haUNodW5rRmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogYWlDaHVua0ZpZWxkcy50b29sX2NhbGxzPy5tYXAoKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnN0cmluZ2lmeSh0Yy5hcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgYWlfanNfMS5BSU1lc3NhZ2VDaHVuayhhaUNodW5rRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyBhaV9qc18xLkFJTWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnID0gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGV2ZWxvcGVyXCI6XG4gICAgICAgICAgICBpZiAocmV0dXJuQ2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX29wZW5haV9yb2xlX186IFwiZGV2ZWxvcGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fb3BlbmFpX3JvbGVfXzogXCJkZXZlbG9wZXJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgaWYgKFwidG9vbF9jYWxsX2lkXCIgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IHRvb2xfanNfMS5Ub29sTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFRvb2xNZXNzYWdlIHRvIFRvb2xNZXNzYWdlQ2h1bmsgaWYgJ3Rvb2xfY2FsbF9pZCcgZmllbGQgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHJldHVybkNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgZnVuY3Rpb25fanNfMS5GdW5jdGlvbk1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZHMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbk1lc3NhZ2UgbXVzdCBoYXZlIGEgJ25hbWUnIGZpZWxkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtc2cgPSBuZXcgZnVuY3Rpb25fanNfMS5GdW5jdGlvbk1lc3NhZ2UoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOlxuICAgICAgICAgICAgaWYgKFwicm9sZVwiIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gbmV3IGNoYXRfanNfMS5DaGF0TWVzc2FnZShmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBDaGF0TWVzc2FnZSB0byBDaGF0TWVzc2FnZUNodW5rIGlmICdyb2xlJyBmaWVsZCBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZSAke21lc3NhZ2VUeXBlfWApO1xuICAgIH1cbiAgICBpZiAocmV0dXJuQ2h1bmsgJiYgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZSAke21lc3NhZ2VUeXBlfWApO1xufVxuZnVuY3Rpb24gX2NodW5rVG9Nc2coY2h1bmspIHtcbiAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay5nZXRUeXBlKCk7XG4gICAgbGV0IG1zZztcbiAgICBjb25zdCBmaWVsZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2h1bmspLmZpbHRlcigoW2tdKSA9PiAhW1widHlwZVwiLCBcInRvb2xfY2FsbF9jaHVua3NcIl0uaW5jbHVkZXMoaykgJiYgIWsuc3RhcnRzV2l0aChcImxjX1wiKSkpO1xuICAgIGlmIChjaHVua1R5cGUgaW4gX01TR19DSFVOS19NQVApIHtcbiAgICAgICAgbXNnID0gX3N3aXRjaFR5cGVUb01lc3NhZ2UoY2h1bmtUeXBlLCBmaWVsZHMpO1xuICAgIH1cbiAgICBpZiAoIW1zZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtZXNzYWdlIGNodW5rIGNsYXNzICR7Y2h1bmtUeXBlfS4gU3VwcG9ydGVkIGNsYXNzZXMgYXJlICR7T2JqZWN0LmtleXMoX01TR19DSFVOS19NQVApfWApO1xuICAgIH1cbiAgICByZXR1cm4gbXNnO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCB0ZXh0IHNwbGl0dGVyIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIHRleHQgYnkgbmV3bGluZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZXMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUZXh0U3BsaXR0ZXIodGV4dCkge1xuICAgIGNvbnN0IHNwbGl0cyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXG4gICAgICAgIC4uLnNwbGl0cy5zbGljZSgwLCAtMSkubWFwKChzKSA9PiBgJHtzfVxcbmApLFxuICAgICAgICBzcGxpdHNbc3BsaXRzLmxlbmd0aCAtIDFdLFxuICAgIF0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/transformers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/messages/utils.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.coerceMessageLikeToMessage = coerceMessageLikeToMessage;\nexports.getBufferString = getBufferString;\nexports.mapStoredMessageToChatMessage = mapStoredMessageToChatMessage;\nexports.mapStoredMessagesToChatMessages = mapStoredMessagesToChatMessages;\nexports.mapChatMessagesToStoredMessages = mapChatMessagesToStoredMessages;\nexports.convertToChunk = convertToChunk;\nconst index_js_1 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ./ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst chat_js_1 = __webpack_require__(/*! ./chat.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/chat.cjs\");\nconst function_js_1 = __webpack_require__(/*! ./function.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/function.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst modifier_js_1 = __webpack_require__(/*! ./modifier.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/modifier.cjs\");\nconst system_js_1 = __webpack_require__(/*! ./system.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/system.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ./tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nfunction _coerceToolCall(toolCall) {\n    if ((0, utils_js_1._isToolCall)(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction isSerializedConstructor(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        x.lc === 1 &&\n        Array.isArray(x.id) &&\n        x.kwargs != null &&\n        typeof x.kwargs === \"object\");\n}\nfunction _constructMessageFromParams(params) {\n    let type;\n    let rest;\n    // Support serialized messages\n    if (isSerializedConstructor(params)) {\n        const className = params.id.at(-1);\n        if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n            type = \"user\";\n        }\n        else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n            type = \"assistant\";\n        }\n        else if (className === \"SystemMessage\" ||\n            className === \"SystemMessageChunk\") {\n            type = \"system\";\n        }\n        else if (className === \"FunctionMessage\" ||\n            className === \"FunctionMessageChunk\") {\n            type = \"function\";\n        }\n        else if (className === \"ToolMessage\" ||\n            className === \"ToolMessageChunk\") {\n            type = \"tool\";\n        }\n        else {\n            type = \"unknown\";\n        }\n        rest = params.kwargs;\n    }\n    else {\n        const { type: extractedType, ...otherParams } = params;\n        type = extractedType;\n        rest = otherParams;\n    }\n    if (type === \"human\" || type === \"user\") {\n        return new human_js_1.HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new ai_js_1.AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new ai_js_1.AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new system_js_1.SystemMessage(rest);\n    }\n    else if (type === \"developer\") {\n        return new system_js_1.SystemMessage({\n            ...rest,\n            additional_kwargs: {\n                ...rest.additional_kwargs,\n                __openai_role__: \"developer\",\n            },\n        });\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new tool_js_1.ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n        return new modifier_js_1.RemoveMessage({ ...rest, id: rest.id });\n    }\n    else {\n        const error = (0, index_js_1.addLangChainErrorFields)(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n        throw error;\n    }\n}\nfunction coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new human_js_1.HumanMessage(messageLike);\n    }\n    else if ((0, base_js_1.isBaseMessage)(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if ((0, base_js_1._isMessageFieldWithRole)(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nfunction getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nfunction mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new human_js_1.HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new ai_js_1.AIMessage(storedMessage.data);\n        case \"system\":\n            return new system_js_1.SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new function_js_1.FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new tool_js_1.ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new chat_js_1.ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nfunction mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nfunction mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nfunction convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new human_js_1.HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new ai_js_1.AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new system_js_1.SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new function_js_1.FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (chat_js_1.ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new chat_js_1.ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyx1QkFBdUI7QUFDdkIscUNBQXFDO0FBQ3JDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLHVGQUFnQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBYztBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQSxpTkFBaU4sZ0NBQWdDO0FBQ2pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLElBQUksUUFBUSxFQUFFLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQkFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy91dGlscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlID0gY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2U7XG5leHBvcnRzLmdldEJ1ZmZlclN0cmluZyA9IGdldEJ1ZmZlclN0cmluZztcbmV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UgPSBtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZTtcbmV4cG9ydHMubWFwU3RvcmVkTWVzc2FnZXNUb0NoYXRNZXNzYWdlcyA9IG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXM7XG5leHBvcnRzLm1hcENoYXRNZXNzYWdlc1RvU3RvcmVkTWVzc2FnZXMgPSBtYXBDaGF0TWVzc2FnZXNUb1N0b3JlZE1lc3NhZ2VzO1xuZXhwb3J0cy5jb252ZXJ0VG9DaHVuayA9IGNvbnZlcnRUb0NodW5rO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvaW5kZXguY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi90b29scy91dGlscy5janNcIik7XG5jb25zdCBhaV9qc18xID0gcmVxdWlyZShcIi4vYWkuY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjaGF0X2pzXzEgPSByZXF1aXJlKFwiLi9jaGF0LmNqc1wiKTtcbmNvbnN0IGZ1bmN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9mdW5jdGlvbi5janNcIik7XG5jb25zdCBodW1hbl9qc18xID0gcmVxdWlyZShcIi4vaHVtYW4uY2pzXCIpO1xuY29uc3QgbW9kaWZpZXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGlmaWVyLmNqc1wiKTtcbmNvbnN0IHN5c3RlbV9qc18xID0gcmVxdWlyZShcIi4vc3lzdGVtLmNqc1wiKTtcbmNvbnN0IHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuL3Rvb2wuY2pzXCIpO1xuZnVuY3Rpb24gX2NvZXJjZVRvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgaWYgKCgwLCB1dGlsc19qc18xLl9pc1Rvb2xDYWxsKSh0b29sQ2FsbCkpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xDYWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdG9vbENhbGwuaWQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdG9vbENhbGwudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbiAhPT0gbnVsbCAmJlxuICAgICAgICBcImFyZ3VtZW50c1wiIGluIHRvb2xDYWxsLmZ1bmN0aW9uICYmXG4gICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gdG9vbENhbGwuZnVuY3Rpb24gJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gSGFuZGxlIE9wZW5BSSB0b29sIGNhbGwgZm9ybWF0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICBhcmdzOiBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IFRocm93IGFuIGVycm9yP1xuICAgICAgICByZXR1cm4gdG9vbENhbGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkQ29uc3RydWN0b3IoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHgubGMgPT09IDEgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh4LmlkKSAmJlxuICAgICAgICB4Lmt3YXJncyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lmt3YXJncyA9PT0gXCJvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMocGFyYW1zKSB7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IHJlc3Q7XG4gICAgLy8gU3VwcG9ydCBzZXJpYWxpemVkIG1lc3NhZ2VzXG4gICAgaWYgKGlzU2VyaWFsaXplZENvbnN0cnVjdG9yKHBhcmFtcykpIHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gcGFyYW1zLmlkLmF0KC0xKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gXCJIdW1hbk1lc3NhZ2VcIiB8fCBjbGFzc05hbWUgPT09IFwiSHVtYW5NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwidXNlclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJBSU1lc3NhZ2VcIiB8fCBjbGFzc05hbWUgPT09IFwiQUlNZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgdHlwZSA9IFwiYXNzaXN0YW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSBcIlN5c3RlbU1lc3NhZ2VcIiB8fFxuICAgICAgICAgICAgY2xhc3NOYW1lID09PSBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJzeXN0ZW1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiRnVuY3Rpb25NZXNzYWdlXCIgfHxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9PT0gXCJGdW5jdGlvbk1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJUb29sTWVzc2FnZVwiIHx8XG4gICAgICAgICAgICBjbGFzc05hbWUgPT09IFwiVG9vbE1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ0b29sXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ1bmtub3duXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHBhcmFtcy5rd2FyZ3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGU6IGV4dHJhY3RlZFR5cGUsIC4uLm90aGVyUGFyYW1zIH0gPSBwYXJhbXM7XG4gICAgICAgIHR5cGUgPSBleHRyYWN0ZWRUeXBlO1xuICAgICAgICByZXN0ID0gb3RoZXJQYXJhbXM7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIgfHwgdHlwZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShyZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiIHx8IHR5cGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgeyB0b29sX2NhbGxzOiByYXdUb29sQ2FsbHMsIC4uLm90aGVyIH0gPSByZXN0O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3VG9vbENhbGxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhaV9qc18xLkFJTWVzc2FnZShyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sX2NhbGxzID0gcmF3VG9vbENhbGxzLm1hcChfY29lcmNlVG9vbENhbGwpO1xuICAgICAgICByZXR1cm4gbmV3IGFpX2pzXzEuQUlNZXNzYWdlKHsgLi4ub3RoZXIsIHRvb2xfY2FsbHMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlKHJlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImRldmVsb3BlclwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3lzdGVtX2pzXzEuU3lzdGVtTWVzc2FnZSh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHtcbiAgICAgICAgICAgICAgICAuLi5yZXN0LmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgICAgIF9fb3BlbmFpX3JvbGVfXzogXCJkZXZlbG9wZXJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInRvb2xcIiAmJiBcInRvb2xfY2FsbF9pZFwiIGluIHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3QuY29udGVudCxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogcmVzdC50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBuYW1lOiByZXN0Lm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInJlbW92ZVwiICYmIFwiaWRcIiBpbiByZXN0ICYmIHR5cGVvZiByZXN0LmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgbW9kaWZpZXJfanNfMS5SZW1vdmVNZXNzYWdlKHsgLi4ucmVzdCwgaWQ6IHJlc3QuaWQgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBlcnJvciA9ICgwLCBpbmRleF9qc18xLmFkZExhbmdDaGFpbkVycm9yRmllbGRzKShuZXcgRXJyb3IoYFVuYWJsZSB0byBjb2VyY2UgbWVzc2FnZSBmcm9tIGFycmF5OiBvbmx5IGh1bWFuLCBBSSwgc3lzdGVtLCBkZXZlbG9wZXIsIG9yIHRvb2wgbWVzc2FnZSBjb2VyY2lvbiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxcblxcblJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMil9YCksIFwiTUVTU0FHRV9DT0VSQ0lPTl9GQUlMVVJFXCIpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZUxpa2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZShtZXNzYWdlTGlrZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBiYXNlX2pzXzEuaXNCYXNlTWVzc2FnZSkobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlTGlrZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBjb250ZW50XSA9IG1lc3NhZ2VMaWtlO1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHsgdHlwZSwgY29udGVudCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGJhc2VfanNfMS5faXNNZXNzYWdlRmllbGRXaXRoUm9sZSkobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIGNvbnN0IHsgcm9sZTogdHlwZSwgLi4ucmVzdCB9ID0gbWVzc2FnZUxpa2U7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMoeyAuLi5yZXN0LCB0eXBlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyhtZXNzYWdlTGlrZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgY2hhdCBtZXNzYWdlIGhpc3RvcnksIGJhc2VkIG9uIHRoZSBtZXNzYWdlIGNvbnRlbnQgYW5kIHJvbGUuXG4gKi9cbmZ1bmN0aW9uIGdldEJ1ZmZlclN0cmluZyhtZXNzYWdlcywgaHVtYW5QcmVmaXggPSBcIkh1bWFuXCIsIGFpUHJlZml4ID0gXCJBSVwiKSB7XG4gICAgY29uc3Qgc3RyaW5nX21lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBtIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIGxldCByb2xlO1xuICAgICAgICBpZiAobS5fZ2V0VHlwZSgpID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBodW1hblByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiYWlcIikge1xuICAgICAgICAgICAgcm9sZSA9IGFpUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiU3lzdGVtXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIkZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcInRvb2xcIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiVG9vbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBtLnJvbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7bS5fZ2V0VHlwZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVTdHIgPSBtLm5hbWUgPyBgJHttLm5hbWV9LCBgIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250ZW50ID0gdHlwZW9mIG0uY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBtLmNvbnRlbnRcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkobS5jb250ZW50LCBudWxsLCAyKTtcbiAgICAgICAgc3RyaW5nX21lc3NhZ2VzLnB1c2goYCR7cm9sZX06ICR7bmFtZVN0cn0ke3JlYWRhYmxlQ29udGVudH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ19tZXNzYWdlcy5qb2luKFwiXFxuXCIpO1xufVxuLyoqXG4gKiBNYXBzIG1lc3NhZ2VzIGZyb20gYW4gb2xkZXIgZm9ybWF0IChWMSkgdG8gdGhlIGN1cnJlbnQgYFN0b3JlZE1lc3NhZ2VgXG4gKiBmb3JtYXQuIElmIHRoZSBtZXNzYWdlIGlzIGFscmVhZHkgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBpcy4gT3RoZXJ3aXNlLCBpdCB0cmFuc2Zvcm1zIHRoZSBWMSBtZXNzYWdlIGludG8gYVxuICogYFN0b3JlZE1lc3NhZ2VgLiBUaGlzIGZ1bmN0aW9uIGlzIGltcG9ydGFudCBmb3IgbWFpbnRhaW5pbmdcbiAqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBtZXNzYWdlIGZvcm1hdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcFYxTWVzc2FnZVRvU3RvcmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbWFwcGVyIHdoZW4gd2UgZGVwcmVjYXRlIHRoZSBvbGQgbWVzc2FnZSBmb3JtYXQuXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdjFNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHYxTWVzc2FnZS50eXBlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHYxTWVzc2FnZS50ZXh0LFxuICAgICAgICAgICAgICAgIHJvbGU6IHYxTWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHN0b3JlZE1lc3NhZ2UgPSBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgc3dpdGNoIChzdG9yZWRNZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhaV9qc18xLkFJTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN5c3RlbV9qc18xLlN5c3RlbU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWUgbXVzdCBiZSBkZWZpbmVkIGZvciBmdW5jdGlvbiBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZnVuY3Rpb25fanNfMS5GdW5jdGlvbk1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInRvb2xcIjpcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEudG9vbF9jYWxsX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29sIGNhbGwgSUQgbXVzdCBiZSBkZWZpbmVkIGZvciB0b29sIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0b29sX2pzXzEuVG9vbE1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImdlbmVyaWNcIjoge1xuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5yb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb2xlIG11c3QgYmUgZGVmaW5lZCBmb3IgY2hhdCBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgY2hhdF9qc18xLkNoYXRNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuZXhwZWN0ZWQgdHlwZTogJHtzdG9yZWRNZXNzYWdlLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIGBTdG9yZWRNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMuIEl0IHVzZXMgdGhlIGBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2VgXG4gKiBmdW5jdGlvbiB0byBlbnN1cmUgYWxsIG1lc3NhZ2VzIGFyZSBpbiB0aGUgYFN0b3JlZE1lc3NhZ2VgIGZvcm1hdCwgdGhlblxuICogY3JlYXRlcyBuZXcgaW5zdGFuY2VzIG9mIHRoZSBhcHByb3ByaWF0ZSBgQmFzZU1lc3NhZ2VgIHN1YmNsYXNzIGJhc2VkXG4gKiBvbiB0aGUgdHlwZSBvZiBlYWNoIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVwYXJlIHN0b3JlZFxuICogbWVzc2FnZXMgZm9yIHVzZSBpbiBhIGNoYXQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gbWFwU3RvcmVkTWVzc2FnZXNUb0NoYXRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAobWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBTdG9yZWRNZXNzYWdlYCBpbnN0YW5jZXMuIEl0IGRvZXMgdGhpcyBieSBjYWxsaW5nIHRoZSBgdG9EaWN0YCBtZXRob2RcbiAqIG9uIGVhY2ggYEJhc2VNZXNzYWdlYCwgd2hpY2ggcmV0dXJucyBhIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvblxuICogaXMgdXNlZCB0byBwcmVwYXJlIGNoYXQgbWVzc2FnZXMgZm9yIHN0b3JhZ2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENoYXRNZXNzYWdlc1RvU3RvcmVkTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLnRvRGljdCgpKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0NodW5rKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGh1bWFuX2pzXzEuSHVtYW5NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImFpXCIpIHtcbiAgICAgICAgbGV0IGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJ0b29sX2NhbGxzXCIgaW4gYWlDaHVua0ZpZWxkcykge1xuICAgICAgICAgICAgYWlDaHVua0ZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5haUNodW5rRmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IGFpQ2h1bmtGaWVsZHMudG9vbF9jYWxscz8ubWFwKCh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KHRjLmFyZ3MpLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmsoeyAuLi5haUNodW5rRmllbGRzIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBzeXN0ZW1fanNfMS5TeXN0ZW1NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IGZ1bmN0aW9uX2pzXzEuRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXRfanNfMS5DaGF0TWVzc2FnZS5pc0luc3RhbmNlKG1lc3NhZ2UpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBjaGF0X2pzXzEuQ2hhdE1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1lc3NhZ2UgdHlwZS5cIik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/base.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutputParserException = exports.BaseOutputParser = exports.BaseLLMOutputParser = void 0;\nconst index_js_1 = __webpack_require__(/*! ../runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../errors/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/errors/index.cjs\");\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nclass BaseLLMOutputParser extends index_js_1.Runnable {\n    /**\n     * Parses the result of an LLM call with a given prompt. By default, it\n     * simply calls `parseResult`.\n     * @param generations The generations from an LLM call.\n     * @param _prompt The prompt used in the LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parseResultWithPrompt(generations, _prompt, callbacks) {\n        return this.parseResult(generations, callbacks);\n    }\n    _baseMessageToString(message) {\n        return typeof message.content === \"string\"\n            ? message.content\n            : this._baseMessageContentToString(message.content);\n    }\n    _baseMessageContentToString(content) {\n        return JSON.stringify(content);\n    }\n    /**\n     * Calls the parser with a given input and optional configuration options.\n     * If the input is a string, it creates a generation with the input as\n     * text and calls `parseResult`. If the input is a `BaseMessage`, it\n     * creates a generation with the input as a message and the content of the\n     * input as text, and then calls `parseResult`.\n     * @param input The input to the parser, which can be a string or a `BaseMessage`.\n     * @param options Optional configuration options.\n     * @returns A promise of the parsed output.\n     */\n    async invoke(input, options) {\n        if (typeof input === \"string\") {\n            return this._callWithConfig(async (input, options) => this.parseResult([{ text: input }], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n        else {\n            return this._callWithConfig(async (input, options) => this.parseResult([\n                {\n                    message: input,\n                    text: this._baseMessageToString(input),\n                },\n            ], options?.callbacks), input, { ...options, runType: \"parser\" });\n        }\n    }\n}\nexports.BaseLLMOutputParser = BaseLLMOutputParser;\n/**\n * Class to parse the output of an LLM call.\n */\nclass BaseOutputParser extends BaseLLMOutputParser {\n    parseResult(generations, callbacks) {\n        return this.parse(generations[0].text, callbacks);\n    }\n    async parseWithPrompt(text, _prompt, callbacks) {\n        return this.parse(text, callbacks);\n    }\n    /**\n     * Return the string type key uniquely identifying this class of parser\n     */\n    _type() {\n        throw new Error(\"_type not implemented\");\n    }\n}\nexports.BaseOutputParser = BaseOutputParser;\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nclass OutputParserException extends Error {\n    constructor(message, llmOutput, observation, sendToLLM = false) {\n        super(message);\n        Object.defineProperty(this, \"llmOutput\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sendToLLM\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmOutput = llmOutput;\n        this.observation = observation;\n        this.sendToLLM = sendToLLM;\n        if (sendToLLM) {\n            if (observation === undefined || llmOutput === undefined) {\n                throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n            }\n        }\n        (0, index_js_2.addLangChainErrorFields)(this, \"OUTPUT_PARSING_FAILURE\");\n    }\n}\nexports.OutputParserException = OutputParserException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCO0FBQ3RGLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYSxpQ0FBaUMsK0JBQStCO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PdXRwdXRQYXJzZXJFeGNlcHRpb24gPSBleHBvcnRzLkJhc2VPdXRwdXRQYXJzZXIgPSBleHBvcnRzLkJhc2VMTE1PdXRwdXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9pbmRleC5janNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2Vycm9ycy9pbmRleC5janNcIik7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHBhcnNpbmcgdGhlIG91dHB1dCBvZiBhIExhcmdlIExhbmd1YWdlIE1vZGVsXG4gKiAoTExNKSBjYWxsLiBJdCBwcm92aWRlcyBtZXRob2RzIGZvciBwYXJzaW5nIHRoZSByZXN1bHQgb2YgYW4gTExNIGNhbGxcbiAqIGFuZCBpbnZva2luZyB0aGUgcGFyc2VyIHdpdGggYSBnaXZlbiBpbnB1dC5cbiAqL1xuY2xhc3MgQmFzZUxMTU91dHB1dFBhcnNlciBleHRlbmRzIGluZGV4X2pzXzEuUnVubmFibGUge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgcmVzdWx0IG9mIGFuIExMTSBjYWxsIHdpdGggYSBnaXZlbiBwcm9tcHQuIEJ5IGRlZmF1bHQsIGl0XG4gICAgICogc2ltcGx5IGNhbGxzIGBwYXJzZVJlc3VsdGAuXG4gICAgICogQHBhcmFtIGdlbmVyYXRpb25zIFRoZSBnZW5lcmF0aW9ucyBmcm9tIGFuIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBfcHJvbXB0IFRoZSBwcm9tcHQgdXNlZCBpbiB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBPcHRpb25hbCBjYWxsYmFja3MuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIHBhcnNlUmVzdWx0V2l0aFByb21wdChnZW5lcmF0aW9ucywgX3Byb21wdCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBfYmFzZU1lc3NhZ2VUb1N0cmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgICAgOiB0aGlzLl9iYXNlTWVzc2FnZUNvbnRlbnRUb1N0cmluZyhtZXNzYWdlLmNvbnRlbnQpO1xuICAgIH1cbiAgICBfYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcoY29udGVudCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBwYXJzZXIgd2l0aCBhIGdpdmVuIGlucHV0IGFuZCBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBpdCBjcmVhdGVzIGEgZ2VuZXJhdGlvbiB3aXRoIHRoZSBpbnB1dCBhc1xuICAgICAqIHRleHQgYW5kIGNhbGxzIGBwYXJzZVJlc3VsdGAuIElmIHRoZSBpbnB1dCBpcyBhIGBCYXNlTWVzc2FnZWAsIGl0XG4gICAgICogY3JlYXRlcyBhIGdlbmVyYXRpb24gd2l0aCB0aGUgaW5wdXQgYXMgYSBtZXNzYWdlIGFuZCB0aGUgY29udGVudCBvZiB0aGVcbiAgICAgKiBpbnB1dCBhcyB0ZXh0LCBhbmQgdGhlbiBjYWxscyBgcGFyc2VSZXN1bHRgLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gdGhlIHBhcnNlciwgd2hpY2ggY2FuIGJlIGEgc3RyaW5nIG9yIGEgYEJhc2VNZXNzYWdlYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcoYXN5bmMgKGlucHV0LCBvcHRpb25zKSA9PiB0aGlzLnBhcnNlUmVzdWx0KFt7IHRleHQ6IGlucHV0IH1dLCBvcHRpb25zPy5jYWxsYmFja3MpLCBpbnB1dCwgeyAuLi5vcHRpb25zLCBydW5UeXBlOiBcInBhcnNlclwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4gdGhpcy5wYXJzZVJlc3VsdChbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fYmFzZU1lc3NhZ2VUb1N0cmluZyhpbnB1dCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sIG9wdGlvbnM/LmNhbGxiYWNrcyksIGlucHV0LCB7IC4uLm9wdGlvbnMsIHJ1blR5cGU6IFwicGFyc2VyXCIgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VMTE1PdXRwdXRQYXJzZXIgPSBCYXNlTExNT3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsLlxuICovXG5jbGFzcyBCYXNlT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZUxMTU91dHB1dFBhcnNlciB7XG4gICAgcGFyc2VSZXN1bHQoZ2VuZXJhdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShnZW5lcmF0aW9uc1swXS50ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVdpdGhQcm9tcHQodGV4dCwgX3Byb21wdCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHRleHQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RyaW5nIHR5cGUga2V5IHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoaXMgY2xhc3Mgb2YgcGFyc2VyXG4gICAgICovXG4gICAgX3R5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl90eXBlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VPdXRwdXRQYXJzZXIgPSBCYXNlT3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhhdCBvdXRwdXQgcGFyc2VycyBzaG91bGQgcmFpc2UgdG8gc2lnbmlmeSBhIHBhcnNpbmcgZXJyb3IuXG4gKlxuICogVGhpcyBleGlzdHMgdG8gZGlmZmVyZW50aWF0ZSBwYXJzaW5nIGVycm9ycyBmcm9tIG90aGVyIGNvZGUgb3IgZXhlY3V0aW9uIGVycm9yc1xuICogdGhhdCBhbHNvIG1heSBhcmlzZSBpbnNpZGUgdGhlIG91dHB1dCBwYXJzZXIuIE91dHB1dFBhcnNlckV4Y2VwdGlvbnMgd2lsbCBiZVxuICogYXZhaWxhYmxlIHRvIGNhdGNoIGFuZCBoYW5kbGUgaW4gd2F5cyB0byBmaXggdGhlIHBhcnNpbmcgZXJyb3IsIHdoaWxlIG90aGVyXG4gKiBlcnJvcnMgd2lsbCBiZSByYWlzZWQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgdGhhdCdzIGJlaW5nIHJlLXJhaXNlZCBvciBhbiBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIGxsbU91dHB1dCAtIFN0cmluZyBtb2RlbCBvdXRwdXQgd2hpY2ggaXMgZXJyb3ItaW5nLlxuICogQHBhcmFtIG9ic2VydmF0aW9uIC0gU3RyaW5nIGV4cGxhbmF0aW9uIG9mIGVycm9yIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8gYVxuICogICAgIG1vZGVsIHRvIHRyeSBhbmQgcmVtZWRpYXRlIHRoZSBpc3N1ZS5cbiAqIEBwYXJhbSBzZW5kVG9MTE0gLSBXaGV0aGVyIHRvIHNlbmQgdGhlIG9ic2VydmF0aW9uIGFuZCBsbG1fb3V0cHV0IGJhY2sgdG8gYW4gQWdlbnRcbiAqICAgICBhZnRlciBhbiBPdXRwdXRQYXJzZXJFeGNlcHRpb24gaGFzIGJlZW4gcmFpc2VkLiBUaGlzIGdpdmVzIHRoZSB1bmRlcmx5aW5nXG4gKiAgICAgbW9kZWwgZHJpdmluZyB0aGUgYWdlbnQgdGhlIGNvbnRleHQgdGhhdCB0aGUgcHJldmlvdXMgb3V0cHV0IHdhcyBpbXByb3Blcmx5XG4gKiAgICAgc3RydWN0dXJlZCwgaW4gdGhlIGhvcGVzIHRoYXQgaXQgd2lsbCB1cGRhdGUgdGhlIG91dHB1dCB0byB0aGUgY29ycmVjdFxuICogICAgIGZvcm1hdC5cbiAqL1xuY2xhc3MgT3V0cHV0UGFyc2VyRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxsbU91dHB1dCwgb2JzZXJ2YXRpb24sIHNlbmRUb0xMTSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsbG1PdXRwdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VuZFRvTExNXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGxtT3V0cHV0ID0gbGxtT3V0cHV0O1xuICAgICAgICB0aGlzLm9ic2VydmF0aW9uID0gb2JzZXJ2YXRpb247XG4gICAgICAgIHRoaXMuc2VuZFRvTExNID0gc2VuZFRvTExNO1xuICAgICAgICBpZiAoc2VuZFRvTExNKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24gPT09IHVuZGVmaW5lZCB8fCBsbG1PdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyAnb2JzZXJ2YXRpb24nICYgJ2xsbU91dHB1dCcgYXJlIHJlcXVpcmVkIGlmICdzZW5kVG9MbG0nIGlzIHRydWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMpKHRoaXMsIFwiT1VUUFVUX1BBUlNJTkdfRkFJTFVSRVwiKTtcbiAgICB9XG59XG5leHBvcnRzLk91dHB1dFBhcnNlckV4Y2VwdGlvbiA9IE91dHB1dFBhcnNlckV4Y2VwdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/bytes.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BytesOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nclass BytesOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"bytes\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"textEncoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new TextEncoder()\n        });\n    }\n    static lc_name() {\n        return \"BytesOutputParser\";\n    }\n    parse(text) {\n        return Promise.resolve(this.textEncoder.encode(text));\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.BytesOutputParser = BytesOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYnl0ZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qix1QkFBdUIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9ieXRlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ5dGVzT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgdHJhbnNmb3JtX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0uY2pzXCIpO1xuLyoqXG4gKiBPdXRwdXRQYXJzZXIgdGhhdCBwYXJzZXMgTExNUmVzdWx0IGludG8gdGhlIHRvcCBsaWtlbHkgc3RyaW5nIGFuZFxuICogZW5jb2RlcyBpdCBpbnRvIGJ5dGVzLlxuICovXG5jbGFzcyBCeXRlc091dHB1dFBhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJieXRlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0RW5jb2RlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRleHRFbmNvZGVyKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCeXRlc091dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodGV4dCkpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXNPdXRwdXRQYXJzZXIgPSBCeXRlc091dHB1dFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/index.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./list.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./string.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structured.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./xml.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsdUZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHFGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsaUdBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQywrRkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHFGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxtRkFBVyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGlzdC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmluZy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cnVjdHVyZWQuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4veG1sLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/json.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseJsonMarkdown = exports.parsePartialJson = exports.JsonOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst json_patch_js_1 = __webpack_require__(/*! ../utils/json_patch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../utils/json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\");\nObject.defineProperty(exports, \"parseJsonMarkdown\", ({ enumerable: true, get: function () { return json_js_1.parseJsonMarkdown; } }));\nObject.defineProperty(exports, \"parsePartialJson\", ({ enumerable: true, get: function () { return json_js_1.parsePartialJson; } }));\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nclass JsonOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        if (this.diff) {\n            return super._concatOutputChunks(first, second);\n        }\n        return second;\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0, json_patch_js_1.compare)(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return (0, json_js_1.parseJsonMarkdown)(generations[0].text);\n    }\n    async parse(text) {\n        return (0, json_js_1.parseJsonMarkdown)(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.JsonOutputParser = JsonOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQy9FLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsbUZBQW1CO0FBQzdDLHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL2pzb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUpzb25NYXJrZG93biA9IGV4cG9ydHMucGFyc2VQYXJ0aWFsSnNvbiA9IGV4cG9ydHMuSnNvbk91dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zZm9ybV9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmNqc1wiKTtcbmNvbnN0IGpzb25fcGF0Y2hfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uX3BhdGNoLmNqc1wiKTtcbmNvbnN0IGpzb25fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSnNvbk1hcmtkb3duXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2pzXzEucGFyc2VKc29uTWFya2Rvd247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVBhcnRpYWxKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2pzXzEucGFyc2VQYXJ0aWFsSnNvbjsgfSB9KTtcbi8qKlxuICogQ2xhc3MgZm9yIHBhcnNpbmcgdGhlIG91dHB1dCBvZiBhbiBMTE0gaW50byBhIEpTT04gb2JqZWN0LlxuICovXG5jbGFzcyBKc29uT3V0cHV0UGFyc2VyIGV4dGVuZHMgdHJhbnNmb3JtX2pzXzEuQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25PdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBpZiAodGhpcy5kaWZmKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2NvbmNhdE91dHB1dENodW5rcyhmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vjb25kO1xuICAgIH1cbiAgICBfZGlmZihwcmV2LCBuZXh0KSB7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBbeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IFwiXCIsIHZhbHVlOiBuZXh0IH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwganNvbl9wYXRjaF9qc18xLmNvbXBhcmUpKHByZXYsIG5leHQpO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBhY3R1YWxseSByZXR1cm4gUGFydGlhbDxUPiwgYnV0IHRoZXJlJ3Mgbm8gd2F5XG4gICAgLy8gdG8gc3BlY2lmeSBlbWl0dGVkIGNodW5rcyBhcyBpbnN0YW5jZXMgc2VwYXJhdGUgZnJvbSB0aGUgbWFpbiBvdXRwdXQgdHlwZS5cbiAgICBhc3luYyBwYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBqc29uX2pzXzEucGFyc2VKc29uTWFya2Rvd24pKGdlbmVyYXRpb25zWzBdLnRleHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiAoMCwganNvbl9qc18xLnBhcnNlSnNvbk1hcmtkb3duKSh0ZXh0LCBKU09OLnBhcnNlKTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG5leHBvcnRzLkpzb25PdXRwdXRQYXJzZXIgPSBKc29uT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/list.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkdownListOutputParser = exports.NumberedListOutputParser = exports.CustomListOutputParser = exports.CommaSeparatedListOutputParser = exports.ListOutputParser = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nclass ListOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async *_transform(inputGenerator) {\n        let buffer = \"\";\n        for await (const input of inputGenerator) {\n            if (typeof input === \"string\") {\n                // add current chunk to buffer\n                buffer += input;\n            }\n            else {\n                // extract message content and add to buffer\n                buffer += input.content;\n            }\n            // get parts in buffer\n            if (!this.re) {\n                const parts = await this.parse(buffer);\n                if (parts.length > 1) {\n                    // if there are multiple parts, yield all but the last one\n                    for (const part of parts.slice(0, -1)) {\n                        yield [part];\n                    }\n                    // keep the last part in the buffer\n                    buffer = parts[parts.length - 1];\n                }\n            }\n            else {\n                // if there is a regex, get all matches\n                const matches = [...buffer.matchAll(this.re)];\n                if (matches.length > 1) {\n                    let doneIdx = 0;\n                    // if there are multiple matches, yield all but the last one\n                    for (const match of matches.slice(0, -1)) {\n                        yield [match[1]];\n                        doneIdx += (match.index ?? 0) + match[0].length;\n                    }\n                    // keep the last match in the buffer\n                    buffer = buffer.slice(doneIdx);\n                }\n            }\n        }\n        // yield the last part\n        for (const part of await this.parse(buffer)) {\n            yield [part];\n        }\n    }\n}\nexports.ListOutputParser = ListOutputParser;\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nclass CommaSeparatedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"CommaSeparatedListOutputParser\";\n    }\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    async parse(text) {\n        try {\n            return text\n                .trim()\n                .split(\",\")\n                .map((s) => s.trim());\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Could not parse output: ${text}`, text);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n    }\n}\nexports.CommaSeparatedListOutputParser = CommaSeparatedListOutputParser;\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nclass CustomListOutputParser extends ListOutputParser {\n    constructor({ length, separator }) {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"length\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.length = length;\n        this.separator = separator || \",\";\n    }\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    async parse(text) {\n        try {\n            const items = text\n                .trim()\n                .split(this.separator)\n                .map((s) => s.trim());\n            if (this.length !== undefined && items.length !== this.length) {\n                throw new base_js_1.OutputParserException(`Incorrect number of items. Expected ${this.length}, got ${items.length}.`);\n            }\n            return items;\n        }\n        catch (e) {\n            if (Object.getPrototypeOf(e) === base_js_1.OutputParserException.prototype) {\n                throw e;\n            }\n            throw new base_js_1.OutputParserException(`Could not parse output: ${text}`);\n        }\n    }\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions() {\n        return `Your response should be a list of ${this.length === undefined ? \"\" : `${this.length} `}items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${this.separator} baz\\`)`;\n    }\n}\nexports.CustomListOutputParser = CustomListOutputParser;\nclass NumberedListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /\\d+\\.\\s([^\\n]+)/g\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nexports.NumberedListOutputParser = NumberedListOutputParser;\nclass MarkdownListOutputParser extends ListOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"list\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"re\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: /^\\s*[-*]\\s([^\\n]+)$/gm\n        });\n    }\n    static lc_name() {\n        return \"NumberedListOutputParser\";\n    }\n    getFormatInstructions() {\n        return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n    }\n    async parse(text) {\n        return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n    }\n}\nexports.MarkdownListOutputParser = MarkdownListOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvbGlzdC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsOEJBQThCLEdBQUcsc0NBQXNDLEdBQUcsd0JBQXdCO0FBQ3hLLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3RDLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFlBQVksUUFBUSxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEtBQUs7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQyxhQUFhLEVBQUUsc0JBQXNCLGVBQWUsY0FBYyxnQkFBZ0IsS0FBSyxnQkFBZ0I7QUFDL0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL2xpc3QuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXJrZG93bkxpc3RPdXRwdXRQYXJzZXIgPSBleHBvcnRzLk51bWJlcmVkTGlzdE91dHB1dFBhcnNlciA9IGV4cG9ydHMuQ3VzdG9tTGlzdE91dHB1dFBhcnNlciA9IGV4cG9ydHMuQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyID0gZXhwb3J0cy5MaXN0T3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCB0cmFuc2Zvcm1fanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS5janNcIik7XG4vKipcbiAqIENsYXNzIHRvIHBhcnNlIHRoZSBvdXRwdXQgb2YgYW4gTExNIGNhbGwgdG8gYSBsaXN0LlxuICogQGF1Z21lbnRzIEJhc2VPdXRwdXRQYXJzZXJcbiAqL1xuY2xhc3MgTGlzdE91dHB1dFBhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbnB1dCBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBjdXJyZW50IGNodW5rIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgbWVzc2FnZSBjb250ZW50IGFuZCBhZGQgdG8gYnVmZmVyXG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgcGFydHMgaW4gYnVmZmVyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IHRoaXMucGFyc2UoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGFydHMsIHlpZWxkIGFsbCBidXQgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cy5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFtwYXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBsYXN0IHBhcnQgaW4gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHJlZ2V4LCBnZXQgYWxsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gWy4uLmJ1ZmZlci5tYXRjaEFsbCh0aGlzLnJlKV07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9uZUlkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLCB5aWVsZCBhbGwgYnV0IHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbWF0Y2hbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZUlkeCArPSAobWF0Y2guaW5kZXggPz8gMCkgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgbGFzdCBtYXRjaCBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShkb25lSWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geWllbGQgdGhlIGxhc3QgcGFydFxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYXdhaXQgdGhpcy5wYXJzZShidWZmZXIpKSB7XG4gICAgICAgICAgICB5aWVsZCBbcGFydF07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxpc3RPdXRwdXRQYXJzZXIgPSBMaXN0T3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsIGFzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QuXG4gKiBAYXVnbWVudHMgTGlzdE91dHB1dFBhcnNlclxuICovXG5jbGFzcyBDb21tYVNlcGFyYXRlZExpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ29tbWFTZXBhcmF0ZWRMaXN0T3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MsIHVzaW5nIGEgY29tbWEgYXMgdGhlXG4gICAgICogc2VwYXJhdG9yLiBJZiB0aGUgcGFyc2luZyBmYWlscywgdGhyb3dzIGFuIE91dHB1dFBhcnNlckV4Y2VwdGlvbi5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzIG9idGFpbmVkIGJ5IHNwbGl0dGluZyB0aGUgaW5wdXQgdGV4dCBhdCBlYWNoIGNvbW1hLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBiYXNlX2pzXzEuT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBDb3VsZCBub3QgcGFyc2Ugb3V0cHV0OiAke3RleHR9YCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgaW5zdHJ1Y3Rpb25zIG9uIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIHJlc3BvbnNlIGZvciB0aGVcbiAgICAgKiBDb21tYVNlcGFyYXRlZExpc3RPdXRwdXRQYXJzZXIuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyBpbnN0cnVjdGlvbnMgb24gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gYFlvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIGEgbGlzdCBvZiBjb21tYSBzZXBhcmF0ZWQgdmFsdWVzLCBlZzogXFxgZm9vLCBiYXIsIGJhelxcYGA7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tYVNlcGFyYXRlZExpc3RPdXRwdXRQYXJzZXIgPSBDb21tYVNlcGFyYXRlZExpc3RPdXRwdXRQYXJzZXI7XG4vKipcbiAqIENsYXNzIHRvIHBhcnNlIHRoZSBvdXRwdXQgb2YgYW4gTExNIGNhbGwgdG8gYSBsaXN0IHdpdGggYSBzcGVjaWZpYyBsZW5ndGggYW5kIHNlcGFyYXRvci5cbiAqIEBhdWdtZW50cyBMaXN0T3V0cHV0UGFyc2VyXG4gKi9cbmNsYXNzIEN1c3RvbUxpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGxlbmd0aCwgc2VwYXJhdG9yIH0pIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcGFyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgXCIsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MsIHVzaW5nIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBzZXBhcmF0b3IuIElmIHRoZSBwYXJzaW5nIGZhaWxzIG9yIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgICAgKiBkb2Vzbid0IG1hdGNoIHRoZSBleHBlY3RlZCBsZW5ndGgsIHRocm93cyBhbiBPdXRwdXRQYXJzZXJFeGNlcHRpb24uXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncyBvYnRhaW5lZCBieSBzcGxpdHRpbmcgdGhlIGlucHV0IHRleHQgYXQgZWFjaCBvY2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgc2VwYXJhdG9yLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGV4dFxuICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAuc3BsaXQodGhpcy5zZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgaXRlbXMubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBiYXNlX2pzXzEuT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGl0ZW1zLiBFeHBlY3RlZCAke3RoaXMubGVuZ3RofSwgZ290ICR7aXRlbXMubGVuZ3RofS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSA9PT0gYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oYENvdWxkIG5vdCBwYXJzZSBvdXRwdXQ6ICR7dGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBpbnN0cnVjdGlvbnMgb24gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgcmVzcG9uc2UgZm9yIHRoZVxuICAgICAqIEN1c3RvbUxpc3RPdXRwdXRQYXJzZXIsIGluY2x1ZGluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGFuZCB0aGVcbiAgICAgKiBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyBpbnN0cnVjdGlvbnMgb24gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gYFlvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIGEgbGlzdCBvZiAke3RoaXMubGVuZ3RoID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCR7dGhpcy5sZW5ndGh9IGB9aXRlbXMgc2VwYXJhdGVkIGJ5IFwiJHt0aGlzLnNlcGFyYXRvcn1cIiAoZWc6IFxcYGZvbyR7dGhpcy5zZXBhcmF0b3J9IGJhciR7dGhpcy5zZXBhcmF0b3J9IGJhelxcYClgO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VzdG9tTGlzdE91dHB1dFBhcnNlciA9IEN1c3RvbUxpc3RPdXRwdXRQYXJzZXI7XG5jbGFzcyBOdW1iZXJlZExpc3RPdXRwdXRQYXJzZXIgZXh0ZW5kcyBMaXN0T3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwibGlzdFwiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogL1xcZCtcXC5cXHMoW15cXG5dKykvZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIk51bWJlcmVkTGlzdE91dHB1dFBhcnNlclwiO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBgWW91ciByZXNwb25zZSBzaG91bGQgYmUgYSBudW1iZXJlZCBsaXN0IHdpdGggZWFjaCBpdGVtIG9uIGEgbmV3IGxpbmUuIEZvciBleGFtcGxlOiBcXG5cXG4xLiBmb29cXG5cXG4yLiBiYXJcXG5cXG4zLiBiYXpgO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBbLi4uKHRleHQubWF0Y2hBbGwodGhpcy5yZSkgPz8gW10pXS5tYXAoKG0pID0+IG1bMV0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyZWRMaXN0T3V0cHV0UGFyc2VyID0gTnVtYmVyZWRMaXN0T3V0cHV0UGFyc2VyO1xuY2xhc3MgTWFya2Rvd25MaXN0T3V0cHV0UGFyc2VyIGV4dGVuZHMgTGlzdE91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcImxpc3RcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IC9eXFxzKlstKl1cXHMoW15cXG5dKykkL2dtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTnVtYmVyZWRMaXN0T3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3VyIHJlc3BvbnNlIHNob3VsZCBiZSBhIG51bWJlcmVkIGxpc3Qgd2l0aCBlYWNoIGl0ZW0gb24gYSBuZXcgbGluZS4gRm9yIGV4YW1wbGU6IFxcblxcbjEuIGZvb1xcblxcbjIuIGJhclxcblxcbjMuIGJhemA7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIFsuLi4odGV4dC5tYXRjaEFsbCh0aGlzLnJlKSA/PyBbXSldLm1hcCgobSkgPT4gbVsxXSk7XG4gICAgfVxufVxuZXhwb3J0cy5NYXJrZG93bkxpc3RPdXRwdXRQYXJzZXIgPSBNYXJrZG93bkxpc3RPdXRwdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/list.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./json_output_tools_parsers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNElBQWlDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9vcGVuYWlfdG9vbHMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvbl9vdXRwdXRfdG9vbHNfcGFyc2Vycy5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonOutputKeyToolsParser = exports.JsonOutputToolsParser = void 0;\nexports.parseToolCall = parseToolCall;\nexports.convertLangChainToolCallToOpenAI = convertLangChainToolCallToOpenAI;\nexports.makeInvalidToolCall = makeInvalidToolCall;\nconst base_js_1 = __webpack_require__(/*! ../base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst json_js_1 = __webpack_require__(/*! ../json.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/json.cjs\");\nconst transform_js_1 = __webpack_require__(/*! ../transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nfunction parseToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, options) {\n    if (rawToolCall.function === undefined) {\n        return undefined;\n    }\n    let functionArgs;\n    if (options?.partial) {\n        try {\n            functionArgs = (0, json_js_1.parsePartialJson)(rawToolCall.function.arguments ?? \"{}\");\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    else {\n        try {\n            functionArgs = JSON.parse(rawToolCall.function.arguments);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException([\n                `Function \"${rawToolCall.function.name}\" arguments:`,\n                ``,\n                rawToolCall.function.arguments,\n                ``,\n                `are not valid JSON.`,\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n    const parsedToolCall = {\n        name: rawToolCall.function.name,\n        args: functionArgs,\n        type: \"tool_call\",\n    };\n    if (options?.returnId) {\n        parsedToolCall.id = rawToolCall.id;\n    }\n    return parsedToolCall;\n}\nfunction convertLangChainToolCallToOpenAI(toolCall) {\n    if (toolCall.id === undefined) {\n        throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n    }\n    return {\n        id: toolCall.id,\n        type: \"function\",\n        function: {\n            name: toolCall.name,\n            arguments: JSON.stringify(toolCall.args),\n        },\n    };\n}\nfunction makeInvalidToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, errorMsg) {\n    return {\n        name: rawToolCall.function?.name,\n        args: rawToolCall.function?.arguments,\n        id: rawToolCall.id,\n        error: errorMsg,\n        type: \"invalid_tool_call\",\n    };\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nclass JsonOutputToolsParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    _diff() {\n        throw new Error(\"Not supported.\");\n    }\n    async parse() {\n        throw new Error(\"Not implemented.\");\n    }\n    async parseResult(generations) {\n        const result = await this.parsePartialResult(generations, false);\n        return result;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parsePartialResult(generations, partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const message = generations[0].message;\n        let toolCalls;\n        if ((0, ai_js_1.isAIMessage)(message) && message.tool_calls?.length) {\n            toolCalls = message.tool_calls.map((toolCall) => {\n                const { id, ...rest } = toolCall;\n                if (!this.returnId) {\n                    return rest;\n                }\n                return {\n                    id,\n                    ...rest,\n                };\n            });\n        }\n        else if (message.additional_kwargs.tool_calls !== undefined) {\n            const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n            toolCalls = rawToolCalls.map((rawToolCall) => {\n                return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n            });\n        }\n        if (!toolCalls) {\n            return [];\n        }\n        const parsedToolCalls = [];\n        for (const toolCall of toolCalls) {\n            if (toolCall !== undefined) {\n                const backwardsCompatibleToolCall = {\n                    type: toolCall.name,\n                    args: toolCall.args,\n                    id: toolCall.id,\n                };\n                parsedToolCalls.push(backwardsCompatibleToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\nexports.JsonOutputToolsParser = JsonOutputToolsParser;\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nclass JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"zodSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.zodSchema = params.zodSchema;\n    }\n    async _validateResult(result) {\n        if (this.zodSchema === undefined) {\n            return result;\n        }\n        const zodParsedResult = await (0, zod_js_1.interopSafeParseAsync)(this.zodSchema, result);\n        if (zodParsedResult.success) {\n            return zodParsedResult.data;\n        }\n        else {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`, JSON.stringify(result, null, 2));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parsePartialResult(generations) {\n        const results = await super.parsePartialResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return returnedValues[0];\n        }\n        return returnedValues;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await super.parsePartialResult(generations, false);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return this._validateResult(returnedValues[0]);\n        }\n        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n        return toolCallResults;\n    }\n}\nexports.JsonOutputKeyToolsParser = JsonOutputKeyToolsParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2pzb25fb3V0cHV0X3Rvb2xzX3BhcnNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDZCQUE2QjtBQUNoRSxxQkFBcUI7QUFDckIsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBYTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLGdHQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtDQUFrQztBQUN0RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGdDQUFnQyxZQUFZLDhDQUE4QztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9vcGVuYWlfdG9vbHMvanNvbl9vdXRwdXRfdG9vbHNfcGFyc2Vycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25PdXRwdXRLZXlUb29sc1BhcnNlciA9IGV4cG9ydHMuSnNvbk91dHB1dFRvb2xzUGFyc2VyID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZVRvb2xDYWxsID0gcGFyc2VUb29sQ2FsbDtcbmV4cG9ydHMuY29udmVydExhbmdDaGFpblRvb2xDYWxsVG9PcGVuQUkgPSBjb252ZXJ0TGFuZ0NoYWluVG9vbENhbGxUb09wZW5BSTtcbmV4cG9ydHMubWFrZUludmFsaWRUb29sQ2FsbCA9IG1ha2VJbnZhbGlkVG9vbENhbGw7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi4vYmFzZS5janNcIik7XG5jb25zdCBqc29uX2pzXzEgPSByZXF1aXJlKFwiLi4vanNvbi5janNcIik7XG5jb25zdCB0cmFuc2Zvcm1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2Zvcm0uY2pzXCIpO1xuY29uc3QgYWlfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tZXNzYWdlcy9haS5janNcIik7XG5jb25zdCB6b2RfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy90eXBlcy96b2QuY2pzXCIpO1xuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbCwgb3B0aW9ucykge1xuICAgIGlmIChyYXdUb29sQ2FsbC5mdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbkFyZ3M7XG4gICAgaWYgKG9wdGlvbnM/LnBhcnRpYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQXJncyA9ICgwLCBqc29uX2pzXzEucGFyc2VQYXJ0aWFsSnNvbikocmF3VG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID8/IFwie31cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbihbXG4gICAgICAgICAgICAgICAgYEZ1bmN0aW9uIFwiJHtyYXdUb29sQ2FsbC5mdW5jdGlvbi5uYW1lfVwiIGFyZ3VtZW50czpgLFxuICAgICAgICAgICAgICAgIGBgLFxuICAgICAgICAgICAgICAgIHJhd1Rvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBgYCxcbiAgICAgICAgICAgICAgICBgYXJlIG5vdCB2YWxpZCBKU09OLmAsXG4gICAgICAgICAgICAgICAgYEVycm9yOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUb29sQ2FsbCA9IHtcbiAgICAgICAgbmFtZTogcmF3VG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgYXJnczogZnVuY3Rpb25BcmdzLFxuICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnM/LnJldHVybklkKSB7XG4gICAgICAgIHBhcnNlZFRvb2xDYWxsLmlkID0gcmF3VG9vbENhbGwuaWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRUb29sQ2FsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5Ub29sQ2FsbFRvT3BlbkFJKHRvb2xDYWxsKSB7XG4gICAgaWYgKHRvb2xDYWxsLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgT3BlbkFJIHRvb2wgY2FsbHMgbXVzdCBoYXZlIGFuIFwiaWRcIiBmaWVsZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZUludmFsaWRUb29sQ2FsbChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbCwgZXJyb3JNc2cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiByYXdUb29sQ2FsbC5mdW5jdGlvbj8ubmFtZSxcbiAgICAgICAgYXJnczogcmF3VG9vbENhbGwuZnVuY3Rpb24/LmFyZ3VtZW50cyxcbiAgICAgICAgaWQ6IHJhd1Rvb2xDYWxsLmlkLFxuICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgIHR5cGU6IFwiaW52YWxpZF90b29sX2NhbGxcIixcbiAgICB9O1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGEgdG9vbC1jYWxsaW5nIExMTSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKi9cbmNsYXNzIEpzb25PdXRwdXRUb29sc1BhcnNlciBleHRlbmRzIHRyYW5zZm9ybV9qc18xLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSnNvbk91dHB1dFRvb2xzUGFyc2VyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJvcGVuYWlfdG9vbHNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXR1cm5JZCA9IGZpZWxkcz8ucmV0dXJuSWQgPz8gdGhpcy5yZXR1cm5JZDtcbiAgICB9XG4gICAgX2RpZmYoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VSZXN1bHQoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBvdXRwdXQgYW5kIHJldHVybnMgYSBKU09OIG9iamVjdC4gSWYgYGFyZ3NPbmx5YCBpcyB0cnVlLFxuICAgICAqIG9ubHkgdGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gY2FsbCBhcmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGdlbmVyYXRpb25zIFRoZSBvdXRwdXQgb2YgdGhlIExMTSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyBBIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9yIGl0cyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zLCBwYXJ0aWFsID0gdHJ1ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW5lcmF0aW9uc1swXS5tZXNzYWdlO1xuICAgICAgICBsZXQgdG9vbENhbGxzO1xuICAgICAgICBpZiAoKDAsIGFpX2pzXzEuaXNBSU1lc3NhZ2UpKG1lc3NhZ2UpICYmIG1lc3NhZ2UudG9vbF9jYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHMubWFwKCh0b29sQ2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIC4uLnJlc3QgfSA9IHRvb2xDYWxsO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXR1cm5JZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MudG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MudG9vbF9jYWxscykpO1xuICAgICAgICAgICAgdG9vbENhbGxzID0gcmF3VG9vbENhbGxzLm1hcCgocmF3VG9vbENhbGwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb29sQ2FsbChyYXdUb29sQ2FsbCwgeyByZXR1cm5JZDogdGhpcy5yZXR1cm5JZCwgcGFydGlhbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9vbENhbGxzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgICAgICAgICBpZiAodG9vbENhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t3YXJkc0NvbXBhdGlibGVUb29sQ2FsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyc2VkVG9vbENhbGxzLnB1c2goYmFja3dhcmRzQ29tcGF0aWJsZVRvb2xDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVG9vbENhbGxzO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvbk91dHB1dFRvb2xzUGFyc2VyID0gSnNvbk91dHB1dFRvb2xzUGFyc2VyO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGEgdG9vbC1jYWxsaW5nIExMTSBpbnRvIGEgSlNPTiBvYmplY3QgaWYgeW91IGFyZVxuICogZXhwZWN0aW5nIG9ubHkgYSBzaW5nbGUgdG9vbCB0byBiZSBjYWxsZWQuXG4gKi9cbmNsYXNzIEpzb25PdXRwdXRLZXlUb29sc1BhcnNlciBleHRlbmRzIEpzb25PdXRwdXRUb29sc1BhcnNlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25PdXRwdXRLZXlUb29sc1BhcnNlclwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJvdXRwdXRfcGFyc2Vyc1wiLCBcIm9wZW5haV90b29sc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0b29sIGNhbGxzIHRvIHJldHVybi4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogV2hldGhlciB0byByZXR1cm4gb25seSB0aGUgZmlyc3QgdG9vbCBjYWxsLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXR1cm5TaW5nbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ6b2RTY2hlbWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXlOYW1lID0gcGFyYW1zLmtleU5hbWU7XG4gICAgICAgIHRoaXMucmV0dXJuU2luZ2xlID0gcGFyYW1zLnJldHVyblNpbmdsZSA/PyB0aGlzLnJldHVyblNpbmdsZTtcbiAgICAgICAgdGhpcy56b2RTY2hlbWEgPSBwYXJhbXMuem9kU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRhdGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnpvZFNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHpvZFBhcnNlZFJlc3VsdCA9IGF3YWl0ICgwLCB6b2RfanNfMS5pbnRlcm9wU2FmZVBhcnNlQXN5bmMpKHRoaXMuem9kU2NoZW1hLCByZXN1bHQpO1xuICAgICAgICBpZiAoem9kUGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB6b2RQYXJzZWRSZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBiYXNlX2pzXzEuT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBGYWlsZWQgdG8gcGFyc2UuIFRleHQ6IFwiJHtKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpfVwiLiBFcnJvcjogJHtKU09OLnN0cmluZ2lmeSh6b2RQYXJzZWRSZXN1bHQuZXJyb3I/Lmlzc3Vlcyl9YCwgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBwYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHN1cGVyLnBhcnNlUGFydGlhbFJlc3VsdChnZW5lcmF0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKChyZXN1bHQpID0+IHJlc3VsdC50eXBlID09PSB0aGlzLmtleU5hbWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgcmV0dXJuZWRWYWx1ZXMgPSBtYXRjaGluZ1Jlc3VsdHM7XG4gICAgICAgIGlmICghbWF0Y2hpbmdSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmV0dXJuSWQpIHtcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWVzID0gbWF0Y2hpbmdSZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0dXJuU2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWRWYWx1ZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybmVkVmFsdWVzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5wYXJzZVBhcnRpYWxSZXN1bHQoZ2VuZXJhdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0LnR5cGUgPT09IHRoaXMua2V5TmFtZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCByZXR1cm5lZFZhbHVlcyA9IG1hdGNoaW5nUmVzdWx0cztcbiAgICAgICAgaWYgKCFtYXRjaGluZ1Jlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZXR1cm5JZCkge1xuICAgICAgICAgICAgcmV0dXJuZWRWYWx1ZXMgPSBtYXRjaGluZ1Jlc3VsdHMubWFwKChyZXN1bHQpID0+IHJlc3VsdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXR1cm5TaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXR1cm5lZFZhbHVlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmV0dXJuZWRWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gdGhpcy5fdmFsaWRhdGVSZXN1bHQodmFsdWUpKSk7XG4gICAgICAgIHJldHVybiB0b29sQ2FsbFJlc3VsdHM7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uT3V0cHV0S2V5VG9vbHNQYXJzZXIgPSBKc29uT3V0cHV0S2V5VG9vbHNQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/string.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringOutputParser = void 0;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nclass StringOutputParser extends transform_js_1.BaseTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\", \"string\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"StrOutputParser\";\n    }\n    /**\n     * Parses a string output from an LLM call. This method is meant to be\n     * implemented by subclasses to define how a string output from an LLM\n     * should be parsed.\n     * @param text The string output from an LLM call.\n     * @param callbacks Optional callbacks.\n     * @returns A promise of the parsed output.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n    _textContentToString(content) {\n        return content.text;\n    }\n    _imageUrlContentToString(_content) {\n        throw new Error(`Cannot coerce a multimodal \"image_url\" message part into a string.`);\n    }\n    _messageContentComplexToString(content) {\n        switch (content.type) {\n            case \"text\":\n            case \"text_delta\":\n                if (\"text\" in content) {\n                    // Type guard for MessageContentText\n                    return this._textContentToString(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return this._imageUrlContentToString(content);\n                }\n                break;\n            default:\n                throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n        }\n        throw new Error(`Invalid content type: ${content.type}`);\n    }\n    _baseMessageContentToString(content) {\n        return content.reduce((acc, item) => acc + this._messageContentComplexToString(item), \"\");\n    }\n}\nexports.StringOutputParser = StringOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RyaW5nLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL3N0cmluZy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmluZ091dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zZm9ybV9qc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmNqc1wiKTtcbi8qKlxuICogT3V0cHV0UGFyc2VyIHRoYXQgcGFyc2VzIExMTVJlc3VsdCBpbnRvIHRoZSB0b3AgbGlrZWx5IHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICpcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAgcHJvbXB0VGVtcGxhdGUsXG4gKiAgIG5ldyBDaGF0T3BlbkFJKHsgbW9kZWw6IFwiZ3B0LTRvLW1pbmlcIiB9KSxcbiAqICAgbmV3IFN0cmluZ091dHB1dFBhcnNlcigpLFxuICogXSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhcnNcIiB9KTtcbiAqIGNvbnNvbGUubG9nKFwiV2hhdCBkbyB5b3UgY2FsbCBhIGJlYXIgd2l0aCBubyB0ZWV0aD8gQSBndW1teSBiZWFyIVwiKTtcbiAqIGBgYFxuICovXG5jbGFzcyBTdHJpbmdPdXRwdXRQYXJzZXIgZXh0ZW5kcyB0cmFuc2Zvcm1fanNfMS5CYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwic3RyaW5nXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTdHJPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIG91dHB1dCBmcm9tIGFuIExMTSBjYWxsLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxuICAgICAqIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMgdG8gZGVmaW5lIGhvdyBhIHN0cmluZyBvdXRwdXQgZnJvbSBhbiBMTE1cbiAgICAgKiBzaG91bGQgYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBzdHJpbmcgb3V0cHV0IGZyb20gYW4gTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBPcHRpb25hbCBjYWxsYmFja3MuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIG9mIHRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIHBhcnNlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0KTtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgX3RleHRDb250ZW50VG9TdHJpbmcoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudC50ZXh0O1xuICAgIH1cbiAgICBfaW1hZ2VVcmxDb250ZW50VG9TdHJpbmcoX2NvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29lcmNlIGEgbXVsdGltb2RhbCBcImltYWdlX3VybFwiIG1lc3NhZ2UgcGFydCBpbnRvIGEgc3RyaW5nLmApO1xuICAgIH1cbiAgICBfbWVzc2FnZUNvbnRlbnRDb21wbGV4VG9TdHJpbmcoY29udGVudCkge1xuICAgICAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0X2RlbHRhXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwidGV4dFwiIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBndWFyZCBmb3IgTWVzc2FnZUNvbnRlbnRUZXh0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0Q29udGVudFRvU3RyaW5nKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZV91cmxcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJpbWFnZV91cmxcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIE1lc3NhZ2VDb250ZW50SW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlVXJsQ29udGVudFRvU3RyaW5nKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29lcmNlIFwiJHtjb250ZW50LnR5cGV9XCIgbWVzc2FnZSBwYXJ0IGludG8gYSBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbnRlbnQgdHlwZTogJHtjb250ZW50LnR5cGV9YCk7XG4gICAgfVxuICAgIF9iYXNlTWVzc2FnZUNvbnRlbnRUb1N0cmluZyhjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50LnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyB0aGlzLl9tZXNzYWdlQ29udGVudENvbXBsZXhUb1N0cmluZyhpdGVtKSwgXCJcIik7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdPdXRwdXRQYXJzZXIgPSBTdHJpbmdPdXRwdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/string.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/structured.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsymmetricStructuredOutputParser = exports.JsonMarkdownStructuredOutputParser = exports.StructuredOutputParser = void 0;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nclass StructuredOutputParser extends base_js_1.BaseOutputParser {\n    static lc_name() {\n        return \"StructuredOutputParser\";\n    }\n    toJSON() {\n        return this.toJSONNotImplemented();\n    }\n    constructor(schema) {\n        super(schema);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"structured\"]\n        });\n    }\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = v3_1.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, v3_1.z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions() {\n        return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify((0, json_schema_js_1.toJsonSchema)(this.schema))}\n\\`\\`\\`\n`;\n    }\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    async parse(text) {\n        try {\n            const trimmedText = text.trim();\n            const json = \n            // first case: if back ticks appear at the start of the text\n            trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n                // second case: if back ticks with `json` appear anywhere in the text\n                trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n                // otherwise, return the trimmed text\n                trimmedText;\n            const escapedJson = json\n                .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n                const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n                return `\"${escapedInsideQuotes}\"`;\n            })\n                .replace(/\\n/g, \"\");\n            return await (0, zod_js_1.interopParseAsync)(this.schema, JSON.parse(escapedJson));\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n    }\n}\nexports.StructuredOutputParser = StructuredOutputParser;\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nclass JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n    static lc_name() {\n        return \"JsonMarkdownStructuredOutputParser\";\n    }\n    getFormatInstructions(options) {\n        const interpolationDepth = options?.interpolationDepth ?? 1;\n        if (interpolationDepth < 1) {\n            throw new Error(\"f string interpolation depth must be at least 1\");\n        }\n        return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction((0, json_schema_js_1.toJsonSchema)(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n    }\n    _schemaToInstruction(schemaInput, indent = 2) {\n        const schema = schemaInput;\n        if (\"type\" in schema) {\n            let nullable = false;\n            let type;\n            if (Array.isArray(schema.type)) {\n                const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                if (nullIdx !== -1) {\n                    nullable = true;\n                    schema.type.splice(nullIdx, 1);\n                }\n                type = schema.type.join(\" | \");\n            }\n            else {\n                type = schema.type;\n            }\n            if (schema.type === \"object\" && schema.properties) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                const properties = Object.entries(schema.properties)\n                    .map(([key, value]) => {\n                    const isOptional = schema.required?.includes(key)\n                        ? \"\"\n                        : \" (optional)\";\n                    return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                })\n                    .join(\"\\n\");\n                return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n            }\n            if (schema.type === \"array\" && schema.items) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n            }\n            const isNullable = nullable ? \" (nullable)\" : \"\";\n            const description = schema.description ? ` // ${schema.description}` : \"\";\n            return `${type}${description}${isNullable}`;\n        }\n        if (\"anyOf\" in schema) {\n            return schema.anyOf\n                .map((s) => this._schemaToInstruction(s, indent))\n                .join(`\\n${\" \".repeat(indent - 2)}`);\n        }\n        throw new Error(\"unsupported schema type\");\n    }\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = v3_1.z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, v3_1.z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n}\nexports.JsonMarkdownStructuredOutputParser = JsonMarkdownStructuredOutputParser;\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nclass AsymmetricStructuredOutputParser extends base_js_1.BaseOutputParser {\n    constructor({ inputSchema }) {\n        super(...arguments);\n        Object.defineProperty(this, \"structuredInputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n    }\n    async parse(text) {\n        let parsedInput;\n        try {\n            parsedInput = await this.structuredInputParser.parse(text);\n        }\n        catch (e) {\n            throw new base_js_1.OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n        return this.outputProcessor(parsedInput);\n    }\n    getFormatInstructions() {\n        return this.structuredInputParser.getFormatInstructions();\n    }\n}\nexports.AsymmetricStructuredOutputParser = AsymmetricStructuredOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvc3RydWN0dXJlZC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0NBQXdDLEdBQUcsMENBQTBDLEdBQUcsOEJBQThCO0FBQ3RILGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBWTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtELGdCQUFnQixTQUFTLG1FQUFtRSxzQkFBc0I7QUFDcEs7QUFDQSxtQkFBbUIsd0JBQXdCLHlFQUF5RSxnQkFBZ0IsMEJBQTBCOztBQUU5Sjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLEtBQUssWUFBWSxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RywwQkFBMEIsS0FBSztBQUMvQiwwQkFBMEIsS0FBSyw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUIsR0FBRyxJQUFJLEtBQUssNkNBQTZDLEVBQUUsV0FBVztBQUN2SCxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsSUFBSSxXQUFXLElBQUksd0JBQXdCLEVBQUUsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0Esa0NBQWtDLG1CQUFtQixFQUFFLG9EQUFvRCxJQUFJLHVCQUF1QixJQUFJLFlBQVk7QUFDdEo7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0Usc0JBQXNCLEtBQUssRUFBRSxZQUFZLEVBQUUsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsS0FBSyxZQUFZLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL3N0cnVjdHVyZWQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3ltbWV0cmljU3RydWN0dXJlZE91dHB1dFBhcnNlciA9IGV4cG9ydHMuSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlciA9IGV4cG9ydHMuU3RydWN0dXJlZE91dHB1dFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHYzXzEgPSByZXF1aXJlKFwiem9kL3YzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCB6b2RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy90eXBlcy96b2QuY2pzXCIpO1xuY29uc3QganNvbl9zY2hlbWFfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uX3NjaGVtYS5janNcIik7XG5jbGFzcyBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VPdXRwdXRQYXJzZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KU09OTm90SW1wbGVtZW50ZWQoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHNjaGVtYSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcIm91dHB1dF9wYXJzZXJzXCIsIFwic3RydWN0dXJlZFwiXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGZyb20gYSBab2Qgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBzY2hlbWEgVGhlIFpvZCBzY2hlbWEgd2hpY2ggdGhlIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGZyb20gYSBzZXQgb2YgbmFtZXMgYW5kXG4gICAgICogZGVzY3JpcHRpb25zLlxuICAgICAqIEBwYXJhbSBzY2hlbWFzIEFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIG5hbWUgYW5kIGVhY2ggdmFsdWUgaXMgYSBkZXNjcmlwdGlvblxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21OYW1lc0FuZERlc2NyaXB0aW9ucyhzY2hlbWFzKSB7XG4gICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IHYzXzEuei5vYmplY3QoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYXMpLm1hcCgoW25hbWUsIGRlc2NyaXB0aW9uXSkgPT4gW25hbWUsIHYzXzEuei5zdHJpbmcoKS5kZXNjcmliZShkZXNjcmlwdGlvbildKSkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoem9kU2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcmtkb3duIGNvZGUgc25pcHBldCB3aXRoIGEgSlNPTiBvYmplY3QgZm9ybWF0dGVkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzY2hlbWEuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwuIFRoZSBvcHRpb25zIGZvciBmb3JtYXR0aW5nIHRoZSBpbnN0cnVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyBBIG1hcmtkb3duIGNvZGUgc25pcHBldCB3aXRoIGEgSlNPTiBvYmplY3QgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc2NoZW1hLlxuICAgICAqL1xuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBmb3JtYXQgeW91ciBvdXRwdXQgYXMgYSBKU09OIHZhbHVlIHRoYXQgYWRoZXJlcyB0byBhIGdpdmVuIFwiSlNPTiBTY2hlbWFcIiBpbnN0YW5jZS5cblxuXCJKU09OIFNjaGVtYVwiIGlzIGEgZGVjbGFyYXRpdmUgbGFuZ3VhZ2UgdGhhdCBhbGxvd3MgeW91IHRvIGFubm90YXRlIGFuZCB2YWxpZGF0ZSBKU09OIGRvY3VtZW50cy5cblxuRm9yIGV4YW1wbGUsIHRoZSBleGFtcGxlIFwiSlNPTiBTY2hlbWFcIiBpbnN0YW5jZSB7e1wicHJvcGVydGllc1wiOiB7e1wiZm9vXCI6IHt7XCJkZXNjcmlwdGlvblwiOiBcImEgbGlzdCBvZiB0ZXN0IHdvcmRzXCIsIFwidHlwZVwiOiBcImFycmF5XCIsIFwiaXRlbXNcIjoge3tcInR5cGVcIjogXCJzdHJpbmdcIn19fX19fSwgXCJyZXF1aXJlZFwiOiBbXCJmb29cIl19fVxud291bGQgbWF0Y2ggYW4gb2JqZWN0IHdpdGggb25lIHJlcXVpcmVkIHByb3BlcnR5LCBcImZvb1wiLiBUaGUgXCJ0eXBlXCIgcHJvcGVydHkgc3BlY2lmaWVzIFwiZm9vXCIgbXVzdCBiZSBhbiBcImFycmF5XCIsIGFuZCB0aGUgXCJkZXNjcmlwdGlvblwiIHByb3BlcnR5IHNlbWFudGljYWxseSBkZXNjcmliZXMgaXQgYXMgXCJhIGxpc3Qgb2YgdGVzdCB3b3Jkc1wiLiBUaGUgaXRlbXMgd2l0aGluIFwiZm9vXCIgbXVzdCBiZSBzdHJpbmdzLlxuVGh1cywgdGhlIG9iamVjdCB7e1wiZm9vXCI6IFtcImJhclwiLCBcImJhelwiXX19IGlzIGEgd2VsbC1mb3JtYXR0ZWQgaW5zdGFuY2Ugb2YgdGhpcyBleGFtcGxlIFwiSlNPTiBTY2hlbWFcIi4gVGhlIG9iamVjdCB7e1wicHJvcGVydGllc1wiOiB7e1wiZm9vXCI6IFtcImJhclwiLCBcImJhelwiXX19fX0gaXMgbm90IHdlbGwtZm9ybWF0dGVkLlxuXG5Zb3VyIG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhbmQgdHlwZS1jaGVja2VkIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgc2NoZW1hIGluc3RhbmNlLCBzbyBtYWtlIHN1cmUgYWxsIGZpZWxkcyBpbiB5b3VyIG91dHB1dCBtYXRjaCB0aGUgc2NoZW1hIGV4YWN0bHkgYW5kIHRoZXJlIGFyZSBubyB0cmFpbGluZyBjb21tYXMhXG5cbkhlcmUgaXMgdGhlIEpTT04gU2NoZW1hIGluc3RhbmNlIHlvdXIgb3V0cHV0IG11c3QgYWRoZXJlIHRvLiBJbmNsdWRlIHRoZSBlbmNsb3NpbmcgbWFya2Rvd24gY29kZWJsb2NrOlxuXFxgXFxgXFxganNvblxuJHtKU09OLnN0cmluZ2lmeSgoMCwganNvbl9zY2hlbWFfanNfMS50b0pzb25TY2hlbWEpKHRoaXMuc2NoZW1hKSl9XG5cXGBcXGBcXGBcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gXG4gICAgICAgICAgICAvLyBmaXJzdCBjYXNlOiBpZiBiYWNrIHRpY2tzIGFwcGVhciBhdCB0aGUgc3RhcnQgb2YgdGhlIHRleHRcbiAgICAgICAgICAgIHRyaW1tZWRUZXh0Lm1hdGNoKC9eYGBgKD86anNvbik/XFxzKihbXFxzXFxTXSo/KWBgYC8pPy5bMV0gfHxcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmQgY2FzZTogaWYgYmFjayB0aWNrcyB3aXRoIGBqc29uYCBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHRleHRcbiAgICAgICAgICAgICAgICB0cmltbWVkVGV4dC5tYXRjaCgvYGBganNvblxccyooW1xcc1xcU10qPylgYGAvKT8uWzFdIHx8XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIHRyaW1tZWQgdGV4dFxuICAgICAgICAgICAgICAgIHRyaW1tZWRUZXh0O1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlZEpzb24gPSBqc29uXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiKFteXCJcXFxcXSooXFxcXC5bXlwiXFxcXF0qKSopXCIvZywgKF9tYXRjaCwgY2FwdHVyZWRHcm91cCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRJbnNpZGVRdW90ZXMgPSBjYXB0dXJlZEdyb3VwLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXCIke2VzY2FwZWRJbnNpZGVRdW90ZXN9XCJgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCB6b2RfanNfMS5pbnRlcm9wUGFyc2VBc3luYykodGhpcy5zY2hlbWEsIEpTT04ucGFyc2UoZXNjYXBlZEpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGJhc2VfanNfMS5PdXRwdXRQYXJzZXJFeGNlcHRpb24oYEZhaWxlZCB0byBwYXJzZS4gVGV4dDogXCIke3RleHR9XCIuIEVycm9yOiAke2V9YCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgPSBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyO1xuLyoqXG4gKiBBIHNwZWNpZmljIHR5cGUgb2YgYFN0cnVjdHVyZWRPdXRwdXRQYXJzZXJgIHRoYXQgcGFyc2VzIEpTT04gZGF0YVxuICogZm9ybWF0dGVkIGFzIGEgbWFya2Rvd24gY29kZSBzbmlwcGV0LlxuICovXG5jbGFzcyBKc29uTWFya2Rvd25TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGV4dGVuZHMgU3RydWN0dXJlZE91dHB1dFBhcnNlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgZ2V0Rm9ybWF0SW5zdHJ1Y3Rpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbkRlcHRoID0gb3B0aW9ucz8uaW50ZXJwb2xhdGlvbkRlcHRoID8/IDE7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uRGVwdGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmIHN0cmluZyBpbnRlcnBvbGF0aW9uIGRlcHRoIG11c3QgYmUgYXQgbGVhc3QgMVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFJldHVybiBhIG1hcmtkb3duIGNvZGUgc25pcHBldCB3aXRoIGEgSlNPTiBvYmplY3QgZm9ybWF0dGVkIHRvIGxvb2sgbGlrZTpcXG5cXGBcXGBcXGBqc29uXFxuJHt0aGlzLl9zY2hlbWFUb0luc3RydWN0aW9uKCgwLCBqc29uX3NjaGVtYV9qc18xLnRvSnNvblNjaGVtYSkodGhpcy5zY2hlbWEpKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ7XCIsIFwie1wiLnJlcGVhdChpbnRlcnBvbGF0aW9uRGVwdGgpKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ9XCIsIFwifVwiLnJlcGVhdChpbnRlcnBvbGF0aW9uRGVwdGgpKX1cXG5cXGBcXGBcXGBgO1xuICAgIH1cbiAgICBfc2NoZW1hVG9JbnN0cnVjdGlvbihzY2hlbWFJbnB1dCwgaW5kZW50ID0gMikge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFJbnB1dDtcbiAgICAgICAgaWYgKFwidHlwZVwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgbGV0IG51bGxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bGxJZHggPSBzY2hlbWEudHlwZS5maW5kSW5kZXgoKHR5cGUpID0+IHR5cGUgPT09IFwibnVsbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEudHlwZS5zcGxpY2UobnVsbElkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgPSBzY2hlbWEudHlwZS5qb2luKFwiIHwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiICYmIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBzY2hlbWEucmVxdWlyZWQ/LmluY2x1ZGVzKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiAob3B0aW9uYWwpXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtcIiBcIi5yZXBlYXQoaW5kZW50KX1cIiR7a2V5fVwiOiAke3RoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24odmFsdWUsIGluZGVudCArIDIpfSR7aXNPcHRpb25hbH1gO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBge1xcbiR7cHJvcGVydGllc31cXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX19JHtkZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgJiYgc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBgYXJyYXlbXFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50KX0ke3RoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24oc2NoZW1hLml0ZW1zLCBpbmRlbnQgKyAyKX1cXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX1dICR7ZGVzY3JpcHRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTnVsbGFibGUgPSBudWxsYWJsZSA/IFwiIChudWxsYWJsZSlcIiA6IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHNjaGVtYS5kZXNjcmlwdGlvbiA/IGAgLy8gJHtzY2hlbWEuZGVzY3JpcHRpb259YCA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gYCR7dHlwZX0ke2Rlc2NyaXB0aW9ufSR7aXNOdWxsYWJsZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImFueU9mXCIgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLmFueU9mXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gdGhpcy5fc2NoZW1hVG9JbnN0cnVjdGlvbihzLCBpbmRlbnQpKVxuICAgICAgICAgICAgICAgIC5qb2luKGBcXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzY2hlbWEgdHlwZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ab2RTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhzY2hlbWEpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU5hbWVzQW5kRGVzY3JpcHRpb25zKHNjaGVtYXMpIHtcbiAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gdjNfMS56Lm9iamVjdChPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2NoZW1hcykubWFwKChbbmFtZSwgZGVzY3JpcHRpb25dKSA9PiBbbmFtZSwgdjNfMS56LnN0cmluZygpLmRlc2NyaWJlKGRlc2NyaXB0aW9uKV0pKSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh6b2RTY2hlbWEpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlciA9IEpzb25NYXJrZG93blN0cnVjdHVyZWRPdXRwdXRQYXJzZXI7XG4vKipcbiAqIEEgdHlwZSBvZiBgU3RydWN0dXJlZE91dHB1dFBhcnNlcmAgdGhhdCBoYW5kbGVzIGFzeW1tZXRyaWMgaW5wdXQgYW5kXG4gKiBvdXRwdXQgc2NoZW1hcy5cbiAqL1xuY2xhc3MgQXN5bW1ldHJpY1N0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZU91dHB1dFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoeyBpbnB1dFNjaGVtYSB9KSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cnVjdHVyZWRJbnB1dFBhcnNlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cnVjdHVyZWRJbnB1dFBhcnNlciA9IG5ldyBKc29uTWFya2Rvd25TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyKGlucHV0U2NoZW1hKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICBsZXQgcGFyc2VkSW5wdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IGF3YWl0IHRoaXMuc3RydWN0dXJlZElucHV0UGFyc2VyLnBhcnNlKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYmFzZV9qc18xLk91dHB1dFBhcnNlckV4Y2VwdGlvbihgRmFpbGVkIHRvIHBhcnNlLiBUZXh0OiBcIiR7dGV4dH1cIi4gRXJyb3I6ICR7ZX1gLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRQcm9jZXNzb3IocGFyc2VkSW5wdXQpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRJbnB1dFBhcnNlci5nZXRGb3JtYXRJbnN0cnVjdGlvbnMoKTtcbiAgICB9XG59XG5leHBvcnRzLkFzeW1tZXRyaWNTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyID0gQXN5bW1ldHJpY1N0cnVjdHVyZWRPdXRwdXRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/structured.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/transform.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseCumulativeTransformOutputParser = exports.BaseTransformOutputParser = void 0;\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/base.cjs\");\nconst base_js_2 = __webpack_require__(/*! ../messages/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/base.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nclass BaseTransformOutputParser extends base_js_1.BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: this._baseMessageToString(chunk),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\nexports.BaseTransformOutputParser = BaseTransformOutputParser;\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nclass BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if ((0, base_js_2.isBaseMessageChunk)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if ((0, base_js_2.isBaseMessage)(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new outputs_js_1.ChatGenerationChunk({\n                    message: (0, utils_js_1.convertToChunk)(chunk),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new outputs_js_1.GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !(0, json_schema_1.deepCompareStrict)(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexports.BaseCumulativeTransformOutputParser = BaseCumulativeTransformOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsR0FBRyxpQ0FBaUM7QUFDL0Usc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHlGQUFzQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMsNkVBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL3RyYW5zZm9ybS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyID0gZXhwb3J0cy5CYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9zY2hlbWFfMSA9IHJlcXVpcmUoXCJAY2Z3b3JrZXIvanNvbi1zY2hlbWFcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMiA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHMuY2pzXCIpO1xuY29uc3Qgb3V0cHV0c19qc18xID0gcmVxdWlyZShcIi4uL291dHB1dHMuY2pzXCIpO1xuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsIHRoYXQgYWxzbyBhbGxvd3Mgc3RyZWFtaW5nIGlucHV0cy5cbiAqL1xuY2xhc3MgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlT3V0cHV0UGFyc2VyIHtcbiAgICBhc3luYyAqX3RyYW5zZm9ybShpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wYXJzZVJlc3VsdChbeyB0ZXh0OiBjaHVuayB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBhcnNlUmVzdWx0KFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl9iYXNlTWVzc2FnZVRvU3RyaW5nKGNodW5rKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3Igb2YgaW5wdXQgaW50byBhbiBhc3luY2hyb25vdXNcbiAgICAgKiBnZW5lcmF0b3Igb2YgcGFyc2VkIG91dHB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRHZW5lcmF0b3IgQW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvciBvZiBpbnB1dC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3Igb2YgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGlucHV0R2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHJ1blR5cGU6IFwicGFyc2VyXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXI7XG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3Igb3V0cHV0IHBhcnNlcnMgdGhhdCBjYW4gaGFuZGxlIHN0cmVhbWluZyBpbnB1dC4gSXRcbiAqIGV4dGVuZHMgdGhlIGBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyYCBjbGFzcyBhbmQgcHJvdmlkZXMgYSBtZXRob2QgZm9yXG4gKiBjb252ZXJ0aW5nIHBhcnNlZCBvdXRwdXRzIGludG8gYSBkaWZmIGZvcm1hdC5cbiAqL1xuY2xhc3MgQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlVHJhbnNmb3JtT3V0cHV0UGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlmZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlmZiA9IGZpZWxkcz8uZGlmZiA/PyB0aGlzLmRpZmY7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgIGxldCBwcmV2UGFyc2VkO1xuICAgICAgICBsZXQgYWNjR2VuO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBjaHVuay5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBub24tc3RyaW5nIG91dHB1dC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2h1bmtHZW47XG4gICAgICAgICAgICBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VNZXNzYWdlQ2h1bmspKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGFuZGxlIG5vbi1zdHJpbmcgbWVzc2FnZSBvdXRwdXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVua0dlbiA9IG5ldyBvdXRwdXRzX2pzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGJhc2VfanNfMi5pc0Jhc2VNZXNzYWdlKShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBub24tc3RyaW5nIG1lc3NhZ2Ugb3V0cHV0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmtHZW4gPSBuZXcgb3V0cHV0c19qc18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoMCwgdXRpbHNfanNfMS5jb252ZXJ0VG9DaHVuaykoY2h1bmspLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtHZW4gPSBuZXcgb3V0cHV0c19qc18xLkdlbmVyYXRpb25DaHVuayh7IHRleHQ6IGNodW5rIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY0dlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWNjR2VuID0gY2h1bmtHZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2NHZW4gPSBhY2NHZW4uY29uY2F0KGNodW5rR2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHRoaXMucGFyc2VQYXJ0aWFsUmVzdWx0KFthY2NHZW5dKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICEoMCwganNvbl9zY2hlbWFfMS5kZWVwQ29tcGFyZVN0cmljdCkocGFyc2VkLCBwcmV2UGFyc2VkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fZGlmZihwcmV2UGFyc2VkLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcGFyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciA9IEJhc2VDdW11bGF0aXZlVHJhbnNmb3JtT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/output_parsers/xml.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.XMLOutputParser = exports.XML_FORMAT_INSTRUCTIONS = void 0;\nexports.parseXMLMarkdown = parseXMLMarkdown;\nconst transform_js_1 = __webpack_require__(/*! ./transform.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/transform.cjs\");\nconst json_patch_js_1 = __webpack_require__(/*! ../utils/json_patch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\");\nconst sax_js_1 = __webpack_require__(/*! ../utils/sax-js/sax.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs\");\nexports.XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nclass XMLOutputParser extends transform_js_1.BaseCumulativeTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.tags = fields?.tags;\n    }\n    static lc_name() {\n        return \"XMLOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return (0, json_patch_js_1.compare)(prev, next);\n    }\n    async parsePartialResult(generations) {\n        return parseXMLMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseXMLMarkdown(text);\n    }\n    getFormatInstructions() {\n        const withTags = !!(this.tags && this.tags.length > 0);\n        return withTags\n            ? exports.XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n            : exports.XML_FORMAT_INSTRUCTIONS;\n    }\n}\nexports.XMLOutputParser = XMLOutputParser;\nconst strip = (text) => text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\nconst parseParsedResult = (input) => {\n    if (Object.keys(input).length === 0) {\n        return {};\n    }\n    const result = {};\n    if (input.children.length > 0) {\n        result[input.name] = input.children.map(parseParsedResult);\n        return result;\n    }\n    else {\n        result[input.name] = input.text ?? undefined;\n        return result;\n    }\n};\nfunction parseXMLMarkdown(s) {\n    const cleanedString = strip(s);\n    const parser = sax_js_1.sax.parser(true);\n    let parsedResult = {};\n    const elementStack = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onopentag = (node) => {\n        const element = {\n            name: node.name,\n            attributes: node.attributes,\n            children: [],\n            text: \"\",\n            isSelfClosing: node.isSelfClosing,\n        };\n        if (elementStack.length > 0) {\n            const parentElement = elementStack[elementStack.length - 1];\n            parentElement.children.push(element);\n        }\n        else {\n            parsedResult = element;\n        }\n        if (!node.isSelfClosing) {\n            elementStack.push(element);\n        }\n    };\n    parser.onclosetag = () => {\n        if (elementStack.length > 0) {\n            const lastElement = elementStack.pop();\n            if (elementStack.length === 0 && lastElement) {\n                parsedResult = lastElement;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.ontext = (text) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.text += text;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onattribute = (attr) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.attributes[attr.name] = attr.value;\n        }\n    };\n    // Try to find XML string within triple backticks.\n    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n    const xmlString = match ? match[2] : cleanedString;\n    parser.write(xmlString).close();\n    // Remove the XML declaration if present\n    if (parsedResult && parsedResult.name === \"?xml\") {\n        parsedResult = parsedResult.children[0];\n    }\n    return parseParsedResult(parsedResult);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMveG1sLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRywrQkFBK0I7QUFDekQsd0JBQXdCO0FBQ3hCLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ2xELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L291dHB1dF9wYXJzZXJzL3htbC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlhNTE91dHB1dFBhcnNlciA9IGV4cG9ydHMuWE1MX0ZPUk1BVF9JTlNUUlVDVElPTlMgPSB2b2lkIDA7XG5leHBvcnRzLnBhcnNlWE1MTWFya2Rvd24gPSBwYXJzZVhNTE1hcmtkb3duO1xuY29uc3QgdHJhbnNmb3JtX2pzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm0uY2pzXCIpO1xuY29uc3QganNvbl9wYXRjaF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2pzb25fcGF0Y2guY2pzXCIpO1xuY29uc3Qgc2F4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc2F4LWpzL3NheC5janNcIik7XG5leHBvcnRzLlhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TID0gYFRoZSBvdXRwdXQgc2hvdWxkIGJlIGZvcm1hdHRlZCBhcyBhIFhNTCBmaWxlLlxuMS4gT3V0cHV0IHNob3VsZCBjb25mb3JtIHRvIHRoZSB0YWdzIGJlbG93LiBcbjIuIElmIHRhZ3MgYXJlIG5vdCBnaXZlbiwgbWFrZSB0aGVtIG9uIHlvdXIgb3duLlxuMy4gUmVtZW1iZXIgdG8gYWx3YXlzIG9wZW4gYW5kIGNsb3NlIGFsbCB0aGUgdGFncy5cblxuQXMgYW4gZXhhbXBsZSwgZm9yIHRoZSB0YWdzIFtcImZvb1wiLCBcImJhclwiLCBcImJhelwiXTpcbjEuIFN0cmluZyBcIjxmb28+XFxuICAgPGJhcj5cXG4gICAgICA8YmF6PjwvYmF6PlxcbiAgIDwvYmFyPlxcbjwvZm9vPlwiIGlzIGEgd2VsbC1mb3JtYXR0ZWQgaW5zdGFuY2Ugb2YgdGhlIHNjaGVtYS4gXG4yLiBTdHJpbmcgXCI8Zm9vPlxcbiAgIDxiYXI+XFxuICAgPC9mb28+XCIgaXMgYSBiYWRseS1mb3JtYXR0ZWQgaW5zdGFuY2UuXG4zLiBTdHJpbmcgXCI8Zm9vPlxcbiAgIDx0YWc+XFxuICAgPC90YWc+XFxuPC9mb28+XCIgaXMgYSBiYWRseS1mb3JtYXR0ZWQgaW5zdGFuY2UuXG5cbkhlcmUgYXJlIHRoZSBvdXRwdXQgdGFnczpcblxcYFxcYFxcYFxue3RhZ3N9XG5cXGBcXGBcXGBgO1xuY2xhc3MgWE1MT3V0cHV0UGFyc2VyIGV4dGVuZHMgdHJhbnNmb3JtX2pzXzEuQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJvdXRwdXRfcGFyc2Vyc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhZ3MgPSBmaWVsZHM/LnRhZ3M7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJYTUxPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgX2RpZmYocHJldiwgbmV4dCkge1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBcIlwiLCB2YWx1ZTogbmV4dCB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGpzb25fcGF0Y2hfanNfMS5jb21wYXJlKShwcmV2LCBuZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVhNTE1hcmtkb3duKGdlbmVyYXRpb25zWzBdLnRleHQpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZVhNTE1hcmtkb3duKHRleHQpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHdpdGhUYWdzID0gISEodGhpcy50YWdzICYmIHRoaXMudGFncy5sZW5ndGggPiAwKTtcbiAgICAgICAgcmV0dXJuIHdpdGhUYWdzXG4gICAgICAgICAgICA/IGV4cG9ydHMuWE1MX0ZPUk1BVF9JTlNUUlVDVElPTlMucmVwbGFjZShcInt0YWdzfVwiLCB0aGlzLnRhZ3M/LmpvaW4oXCIsIFwiKSA/PyBcIlwiKVxuICAgICAgICAgICAgOiBleHBvcnRzLlhNTF9GT1JNQVRfSU5TVFJVQ1RJT05TO1xuICAgIH1cbn1cbmV4cG9ydHMuWE1MT3V0cHV0UGFyc2VyID0gWE1MT3V0cHV0UGFyc2VyO1xuY29uc3Qgc3RyaXAgPSAodGV4dCkgPT4gdGV4dFxuICAgIC5zcGxpdChcIlxcblwiKVxuICAgIC5tYXAoKGxpbmUpID0+IGxpbmUucmVwbGFjZSgvXlxccysvLCBcIlwiKSlcbiAgICAuam9pbihcIlxcblwiKVxuICAgIC50cmltKCk7XG5jb25zdCBwYXJzZVBhcnNlZFJlc3VsdCA9IChpbnB1dCkgPT4ge1xuICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGlucHV0LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0W2lucHV0Lm5hbWVdID0gaW5wdXQuY2hpbGRyZW4ubWFwKHBhcnNlUGFyc2VkUmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdFtpbnB1dC5uYW1lXSA9IGlucHV0LnRleHQgPz8gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwYXJzZVhNTE1hcmtkb3duKHMpIHtcbiAgICBjb25zdCBjbGVhbmVkU3RyaW5nID0gc3RyaXAocyk7XG4gICAgY29uc3QgcGFyc2VyID0gc2F4X2pzXzEuc2F4LnBhcnNlcih0cnVlKTtcbiAgICBsZXQgcGFyc2VkUmVzdWx0ID0ge307XG4gICAgY29uc3QgZWxlbWVudFN0YWNrID0gW107XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwYXJzZXIub25vcGVudGFnID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBpc1NlbGZDbG9zaW5nOiBub2RlLmlzU2VsZkNsb3NpbmcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGVsZW1lbnRTdGFja1tlbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5pc1NlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICBlbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VyLm9uY2xvc2V0YWcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBlbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFN0YWNrLmxlbmd0aCA9PT0gMCAmJiBsYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFJlc3VsdCA9IGxhc3RFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHBhcnNlci5vbnRleHQgPSAodGV4dCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gZWxlbWVudFN0YWNrW2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LnRleHQgKz0gdGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwYXJzZXIub25hdHRyaWJ1dGUgPSAoYXR0cikgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gZWxlbWVudFN0YWNrW2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LmF0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRyeSB0byBmaW5kIFhNTCBzdHJpbmcgd2l0aGluIHRyaXBsZSBiYWNrdGlja3MuXG4gICAgY29uc3QgbWF0Y2ggPSAvYGBgKHhtbCk/KC4qKWBgYC9zLmV4ZWMoY2xlYW5lZFN0cmluZyk7XG4gICAgY29uc3QgeG1sU3RyaW5nID0gbWF0Y2ggPyBtYXRjaFsyXSA6IGNsZWFuZWRTdHJpbmc7XG4gICAgcGFyc2VyLndyaXRlKHhtbFN0cmluZykuY2xvc2UoKTtcbiAgICAvLyBSZW1vdmUgdGhlIFhNTCBkZWNsYXJhdGlvbiBpZiBwcmVzZW50XG4gICAgaWYgKHBhcnNlZFJlc3VsdCAmJiBwYXJzZWRSZXN1bHQubmFtZSA9PT0gXCI/eG1sXCIpIHtcbiAgICAgICAgcGFyc2VkUmVzdWx0ID0gcGFyc2VkUmVzdWx0LmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VQYXJzZWRSZXN1bHQocGFyc2VkUmVzdWx0KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/output_parsers/xml.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/outputs.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/outputs.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGenerationChunk = exports.GenerationChunk = exports.RUN_KEY = void 0;\nexports.RUN_KEY = \"__run\";\n/**\n * Chunk of a single generation. Used for streaming.\n */\nclass GenerationChunk {\n    constructor(fields) {\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"generationInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.text = fields.text;\n        this.generationInfo = fields.generationInfo;\n    }\n    concat(chunk) {\n        return new GenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n        });\n    }\n}\nexports.GenerationChunk = GenerationChunk;\nclass ChatGenerationChunk extends GenerationChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.message = fields.message;\n    }\n    concat(chunk) {\n        return new ChatGenerationChunk({\n            text: this.text + chunk.text,\n            generationInfo: {\n                ...this.generationInfo,\n                ...chunk.generationInfo,\n            },\n            message: this.message.concat(chunk.message),\n        });\n    }\n}\nexports.ChatGenerationChunk = ChatGenerationChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZTtBQUN2RSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRHZW5lcmF0aW9uQ2h1bmsgPSBleHBvcnRzLkdlbmVyYXRpb25DaHVuayA9IGV4cG9ydHMuUlVOX0tFWSA9IHZvaWQgMDtcbmV4cG9ydHMuUlVOX0tFWSA9IFwiX19ydW5cIjtcbi8qKlxuICogQ2h1bmsgb2YgYSBzaW5nbGUgZ2VuZXJhdGlvbi4gVXNlZCBmb3Igc3RyZWFtaW5nLlxuICovXG5jbGFzcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRpb25JbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGV4dCA9IGZpZWxkcy50ZXh0O1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25JbmZvID0gZmllbGRzLmdlbmVyYXRpb25JbmZvO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0ICsgY2h1bmsudGV4dCxcbiAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAuLi5jaHVuay5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJhdGlvbkNodW5rID0gR2VuZXJhdGlvbkNodW5rO1xuY2xhc3MgQ2hhdEdlbmVyYXRpb25DaHVuayBleHRlbmRzIEdlbmVyYXRpb25DaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZmllbGRzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IENoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0ICsgY2h1bmsudGV4dCxcbiAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAuLi5jaHVuay5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UuY29uY2F0KGNodW5rLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNoYXRHZW5lcmF0aW9uQ2h1bmsgPSBDaGF0R2VuZXJhdGlvbkNodW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/prompt_values.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImagePromptValue = exports.ChatPromptValue = exports.StringPromptValue = exports.BasePromptValue = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst human_js_1 = __webpack_require__(/*! ./messages/human.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/human.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./messages/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/utils.cjs\");\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nclass BasePromptValue extends serializable_js_1.Serializable {\n}\nexports.BasePromptValue = BasePromptValue;\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nclass StringPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"StringPromptValue\";\n    }\n    constructor(value) {\n        super({ value });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.value = value;\n    }\n    toString() {\n        return this.value;\n    }\n    toChatMessages() {\n        return [new human_js_1.HumanMessage(this.value)];\n    }\n}\nexports.StringPromptValue = StringPromptValue;\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nclass ChatPromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ChatPromptValue\";\n    }\n    constructor(fields) {\n        if (Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { messages: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"messages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.messages = fields.messages;\n    }\n    toString() {\n        return (0, utils_js_1.getBufferString)(this.messages);\n    }\n    toChatMessages() {\n        return this.messages;\n    }\n}\nexports.ChatPromptValue = ChatPromptValue;\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nclass ImagePromptValue extends BasePromptValue {\n    static lc_name() {\n        return \"ImagePromptValue\";\n    }\n    constructor(fields) {\n        if (!(\"imageUrl\" in fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { imageUrl: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompt_values\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"imageUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** @ignore */\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.imageUrl = fields.imageUrl;\n    }\n    toString() {\n        return this.imageUrl.url;\n    }\n    toChatMessages() {\n        return [\n            new human_js_1.HumanMessage({\n                content: [\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            detail: this.imageUrl.detail,\n                            url: this.imageUrl.url,\n                        },\n                    },\n                ],\n            }),\n        ];\n    }\n}\nexports.ImagePromptValue = ImagePromptValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ3hHLDBCQUEwQixtQkFBTyxDQUFDLGdHQUF5QjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9wcm9tcHRfdmFsdWVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1hZ2VQcm9tcHRWYWx1ZSA9IGV4cG9ydHMuQ2hhdFByb21wdFZhbHVlID0gZXhwb3J0cy5TdHJpbmdQcm9tcHRWYWx1ZSA9IGV4cG9ydHMuQmFzZVByb21wdFZhbHVlID0gdm9pZCAwO1xuY29uc3Qgc2VyaWFsaXphYmxlX2pzXzEgPSByZXF1aXJlKFwiLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBodW1hbl9qc18xID0gcmVxdWlyZShcIi4vbWVzc2FnZXMvaHVtYW4uY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzL3V0aWxzLmNqc1wiKTtcbi8qKlxuICogQmFzZSBQcm9tcHRWYWx1ZSBjbGFzcy4gQWxsIHByb21wdCB2YWx1ZXMgc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLlxuICovXG5jbGFzcyBCYXNlUHJvbXB0VmFsdWUgZXh0ZW5kcyBzZXJpYWxpemFibGVfanNfMS5TZXJpYWxpemFibGUge1xufVxuZXhwb3J0cy5CYXNlUHJvbXB0VmFsdWUgPSBCYXNlUHJvbXB0VmFsdWU7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwcm9tcHQgdmFsdWUgYXMgYSBzdHJpbmcuIEl0IGV4dGVuZHMgdGhlIEJhc2VQcm9tcHRWYWx1ZVxuICogY2xhc3MgYW5kIG92ZXJyaWRlcyB0aGUgdG9TdHJpbmcgYW5kIHRvQ2hhdE1lc3NhZ2VzIG1ldGhvZHMuXG4gKi9cbmNsYXNzIFN0cmluZ1Byb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RyaW5nUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoeyB2YWx1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW25ldyBodW1hbl9qc18xLkh1bWFuTWVzc2FnZSh0aGlzLnZhbHVlKV07XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdQcm9tcHRWYWx1ZSA9IFN0cmluZ1Byb21wdFZhbHVlO1xuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBjaGF0IHByb21wdCB2YWx1ZS4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VQcm9tcHRWYWx1ZSBhbmQgaW5jbHVkZXMgYW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICovXG5jbGFzcyBDaGF0UHJvbXB0VmFsdWUgZXh0ZW5kcyBCYXNlUHJvbXB0VmFsdWUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0UHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBtZXNzYWdlczogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IGZpZWxkcy5tZXNzYWdlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5nZXRCdWZmZXJTdHJpbmcpKHRoaXMubWVzc2FnZXMpO1xuICAgIH1cbiAgICB0b0NoYXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0UHJvbXB0VmFsdWUgPSBDaGF0UHJvbXB0VmFsdWU7XG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIEltYWdlVVJMIGluc3RhbmNlLlxuICovXG5jbGFzcyBJbWFnZVByb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSW1hZ2VQcm9tcHRWYWx1ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKCEoXCJpbWFnZVVybFwiIGluIGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBpbWFnZVVybDogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW1hZ2VVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IGZpZWxkcy5pbWFnZVVybDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlVXJsLnVybDtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgaHVtYW5fanNfMS5IdW1hbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlX3VybDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogdGhpcy5pbWFnZVVybC5kZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmltYWdlVXJsLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydHMuSW1hZ2VQcm9tcHRWYWx1ZSA9IEltYWdlUHJvbXB0VmFsdWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/retrievers/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseRetriever = void 0;\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nclass BaseRetriever extends base_js_1.Runnable {\n    /**\n     * Constructs a new `BaseRetriever` instance with optional configuration fields.\n     *\n     * @param fields - Optional input configuration that can include `callbacks`,\n     *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n     */\n    constructor(fields) {\n        super(fields);\n        /**\n         * Optional callbacks to handle various events in the retrieval process.\n         */\n        Object.defineProperty(this, \"callbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Tags to label or categorize the retrieval operation.\n         */\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Metadata to provide additional context or information about the retrieval\n         * operation.\n         */\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * If set to `true`, enables verbose logging for the retrieval process.\n         */\n        Object.defineProperty(this, \"verbose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callbacks = fields?.callbacks;\n        this.tags = fields?.tags ?? [];\n        this.metadata = fields?.metadata ?? {};\n        this.verbose = fields?.verbose ?? false;\n    }\n    /**\n     * TODO: This should be an abstract method, but we'd like to avoid breaking\n     * changes to people currently using subclassed custom retrievers.\n     * Change it on next major release.\n     */\n    /**\n     * Placeholder method for retrieving relevant documents based on a query.\n     *\n     * This method is intended to be implemented by subclasses and will be\n     * converted to an abstract method in the next major release. Currently, it\n     * throws an error if not implemented, ensuring that custom retrievers define\n     * the specific retrieval logic.\n     *\n     * @param _query - The query string used to search for relevant documents.\n     * @param _callbacks - (optional) Callback manager for managing callbacks\n     *                     during retrieval.\n     * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n     * @throws {Error} Throws an error indicating the method is not implemented.\n     */\n    _getRelevantDocuments(_query, _callbacks) {\n        throw new Error(\"Not implemented!\");\n    }\n    /**\n     * Executes a retrieval operation.\n     *\n     * @param input - The query string used to search for relevant documents.\n     * @param options - (optional) Configuration options for the retrieval run,\n     *                  which may include callbacks, tags, and metadata.\n     * @returns A promise that resolves to an array of `DocumentInterface` instances\n     *          representing the most relevant documents to the query.\n     */\n    async invoke(input, options) {\n        return this.getRelevantDocuments(input, (0, config_js_1.ensureConfig)(options));\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Main method used to retrieve relevant documents. It takes a query\n     * string and an optional configuration object, and returns a promise that\n     * resolves to an array of `Document` objects. This method handles the\n     * retrieval process, including starting and ending callbacks, and error\n     * handling.\n     * @param query The query string to retrieve relevant documents for.\n     * @param config Optional configuration object for the retrieval process.\n     * @returns A promise that resolves to an array of `Document` objects.\n     */\n    async getRelevantDocuments(query, config) {\n        const parsedConfig = (0, config_js_1.ensureConfig)((0, manager_js_1.parseCallbackConfigArg)(config));\n        const callbackManager_ = await manager_js_1.CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, undefined, undefined, undefined, parsedConfig.runName);\n        try {\n            const results = await this._getRelevantDocuments(query, runManager);\n            await runManager?.handleRetrieverEnd(results);\n            return results;\n        }\n        catch (error) {\n            await runManager?.handleRetrieverError(error);\n            throw error;\n        }\n    }\n}\nexports.BaseRetriever = BaseRetriever;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcmV0cmlldmVycy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLGlHQUEwQjtBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRMQUE0TCx1QkFBdUI7QUFDbk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9yZXRyaWV2ZXJzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVJldHJpZXZlciA9IHZvaWQgMDtcbmNvbnN0IG1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9jYWxsYmFja3MvbWFuYWdlci5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2Jhc2UuY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2NvbmZpZy5janNcIik7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGEgZG9jdW1lbnQgcmV0cmlldmFsIHN5c3RlbSwgZGVzaWduZWQgdG9cbiAqIHByb2Nlc3Mgc3RyaW5nIHF1ZXJpZXMgYW5kIHJldHVybiB0aGUgbW9zdCByZWxldmFudCBkb2N1bWVudHMgZnJvbSBhIHNvdXJjZS5cbiAqXG4gKiBgQmFzZVJldHJpZXZlcmAgcHJvdmlkZXMgY29tbW9uIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIGRlcml2ZWQgcmV0cmlldmVycyxcbiAqIHN1Y2ggYXMgY2FsbGJhY2tzLCB0YWdnaW5nLCBhbmQgdmVyYm9zZSBsb2dnaW5nLiBDdXN0b20gcmV0cmlldmFsIHN5c3RlbXNcbiAqIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcyBhbmQgaW1wbGVtZW50IGBfZ2V0UmVsZXZhbnREb2N1bWVudHNgIHRvIGRlZmluZVxuICogdGhlIHNwZWNpZmljIHJldHJpZXZhbCBsb2dpYy5cbiAqXG4gKiBAdGVtcGxhdGUgTWV0YWRhdGEgLSBUaGUgdHlwZSBvZiBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggZWFjaCBkb2N1bWVudCxcbiAqICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRpbmcgdG8gYFJlY29yZDxzdHJpbmcsIGFueT5gLlxuICovXG5jbGFzcyBCYXNlUmV0cmlldmVyIGV4dGVuZHMgYmFzZV9qc18xLlJ1bm5hYmxlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBCYXNlUmV0cmlldmVyYCBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZmllbGRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkcyAtIE9wdGlvbmFsIGlucHV0IGNvbmZpZ3VyYXRpb24gdGhhdCBjYW4gaW5jbHVkZSBgY2FsbGJhY2tzYCxcbiAgICAgKiAgICAgICAgICAgICAgICAgYHRhZ3NgLCBgbWV0YWRhdGFgLCBhbmQgYHZlcmJvc2VgIHNldHRpbmdzIGZvciBjdXN0b20gcmV0cmlldmVyIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgY2FsbGJhY2tzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBpbiB0aGUgcmV0cmlldmFsIHByb2Nlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhZ3MgdG8gbGFiZWwgb3IgY2F0ZWdvcml6ZSB0aGUgcmV0cmlldmFsIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGFkYXRhIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBjb250ZXh0IG9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXRyaWV2YWxcbiAgICAgICAgICogb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIGVuYWJsZXMgdmVyYm9zZSBsb2dnaW5nIGZvciB0aGUgcmV0cmlldmFsIHByb2Nlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJib3NlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gZmllbGRzPy5jYWxsYmFja3M7XG4gICAgICAgIHRoaXMudGFncyA9IGZpZWxkcz8udGFncyA/PyBbXTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IGZpZWxkcz8ubWV0YWRhdGEgPz8ge307XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IGZpZWxkcz8udmVyYm9zZSA/PyBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhpcyBzaG91bGQgYmUgYW4gYWJzdHJhY3QgbWV0aG9kLCBidXQgd2UnZCBsaWtlIHRvIGF2b2lkIGJyZWFraW5nXG4gICAgICogY2hhbmdlcyB0byBwZW9wbGUgY3VycmVudGx5IHVzaW5nIHN1YmNsYXNzZWQgY3VzdG9tIHJldHJpZXZlcnMuXG4gICAgICogQ2hhbmdlIGl0IG9uIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBtZXRob2QgZm9yIHJldHJpZXZpbmcgcmVsZXZhbnQgZG9jdW1lbnRzIGJhc2VkIG9uIGEgcXVlcnkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIGFuZCB3aWxsIGJlXG4gICAgICogY29udmVydGVkIHRvIGFuIGFic3RyYWN0IG1ldGhvZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBDdXJyZW50bHksIGl0XG4gICAgICogdGhyb3dzIGFuIGVycm9yIGlmIG5vdCBpbXBsZW1lbnRlZCwgZW5zdXJpbmcgdGhhdCBjdXN0b20gcmV0cmlldmVycyBkZWZpbmVcbiAgICAgKiB0aGUgc3BlY2lmaWMgcmV0cmlldmFsIGxvZ2ljLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9xdWVyeSAtIFRoZSBxdWVyeSBzdHJpbmcgdXNlZCB0byBzZWFyY2ggZm9yIHJlbGV2YW50IGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gX2NhbGxiYWNrcyAtIChvcHRpb25hbCkgQ2FsbGJhY2sgbWFuYWdlciBmb3IgbWFuYWdpbmcgY2FsbGJhY2tzXG4gICAgICogICAgICAgICAgICAgICAgICAgICBkdXJpbmcgcmV0cmlldmFsLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgYERvY3VtZW50SW50ZXJmYWNlYCBpbnN0YW5jZXMgcmVsZXZhbnQgdG8gdGhlIHF1ZXJ5LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaW5kaWNhdGluZyB0aGUgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBfZ2V0UmVsZXZhbnREb2N1bWVudHMoX3F1ZXJ5LCBfY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCFcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgcmV0cmlldmFsIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBxdWVyeSBzdHJpbmcgdXNlZCB0byBzZWFyY2ggZm9yIHJlbGV2YW50IGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIChvcHRpb25hbCkgQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcmV0cmlldmFsIHJ1bixcbiAgICAgKiAgICAgICAgICAgICAgICAgIHdoaWNoIG1heSBpbmNsdWRlIGNhbGxiYWNrcywgdGFncywgYW5kIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudEludGVyZmFjZWAgaW5zdGFuY2VzXG4gICAgICogICAgICAgICAgcmVwcmVzZW50aW5nIHRoZSBtb3N0IHJlbGV2YW50IGRvY3VtZW50cyB0byB0aGUgcXVlcnkuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbGV2YW50RG9jdW1lbnRzKGlucHV0LCAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqXG4gICAgICogTWFpbiBtZXRob2QgdXNlZCB0byByZXRyaWV2ZSByZWxldmFudCBkb2N1bWVudHMuIEl0IHRha2VzIGEgcXVlcnlcbiAgICAgKiBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudGAgb2JqZWN0cy4gVGhpcyBtZXRob2QgaGFuZGxlcyB0aGVcbiAgICAgKiByZXRyaWV2YWwgcHJvY2VzcywgaW5jbHVkaW5nIHN0YXJ0aW5nIGFuZCBlbmRpbmcgY2FsbGJhY2tzLCBhbmQgZXJyb3JcbiAgICAgKiBoYW5kbGluZy5cbiAgICAgKiBAcGFyYW0gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0byByZXRyaWV2ZSByZWxldmFudCBkb2N1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSByZXRyaWV2YWwgcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRgIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVsZXZhbnREb2N1bWVudHMocXVlcnksIGNvbmZpZykge1xuICAgICAgICBjb25zdCBwYXJzZWRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKSgoMCwgbWFuYWdlcl9qc18xLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcpKGNvbmZpZykpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocGFyc2VkQ29uZmlnLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIHBhcnNlZENvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHBhcnNlZENvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVSZXRyaWV2ZXJTdGFydCh0aGlzLnRvSlNPTigpLCBxdWVyeSwgcGFyc2VkQ29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwYXJzZWRDb25maWcucnVuTmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2V0UmVsZXZhbnREb2N1bWVudHMocXVlcnksIHJ1bk1hbmFnZXIpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlUmV0cmlldmVyRW5kKHJlc3VsdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVJldHJpZXZlciA9IEJhc2VSZXRyaWV2ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/base.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableToolLike = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableParallel = exports.RunnableLambda = exports.RunnableTraceable = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\nexports._coerceToDict = _coerceToDict;\nexports._coerceToRunnable = _coerceToRunnable;\nexports.convertRunnableToTool = convertRunnableToTool;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst event_stream_js_1 = __webpack_require__(/*! ../tracers/event_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\");\nconst serializable_js_1 = __webpack_require__(/*! ../load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ../utils/signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ../utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst root_listener_js_1 = __webpack_require__(/*! ../tracers/root_listener.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst graph_js_1 = __webpack_require__(/*! ./graph.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\");\nconst wrappers_js_1 = __webpack_require__(/*! ./wrappers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\");\nconst iter_js_1 = __webpack_require__(/*! ./iter.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\");\nconst utils_js_2 = __webpack_require__(/*! ../tools/utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nclass Runnable extends serializable_js_1.Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     *\n     * @deprecated This will be removed in the next breaking release.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param fields.stopAfterAttempt The number of attempts to retry.\n     * @param fields.onFailedAttempt A function that is called when a retry fails.\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(config_js_1.ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => (0, config_js_1.ensureConfig)(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new async_caller_js_1.AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = (0, config_js_1.ensureConfig)(options);\n        }\n        else {\n            runnableConfig = (0, config_js_1.ensureConfig)({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await (0, signal_js_1.raceWithSignal)(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return (0, stream_js_1.concat)(first, second);\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const outerThis = this;\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            finalInput = outerThis._concatOutputChunks(finalInput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await (0, stream_js_1.pipeGeneratorWithSetup)(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(event_stream_js_1.isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(log_stream_js_1.isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            finalOutput = this._concatOutputChunks(finalOutput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new graph_js_1.Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: v3_1.z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: v3_1.z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = this._concatOutputChunks(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, (0, config_js_1.ensureConfig)(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new log_stream_js_1.RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return (0, wrappers_js_1.convertToHttpEventStream)(stream);\n        }\n        else {\n            return stream_js_1.IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new event_stream_js_1.EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = (0, config_js_1.ensureConfig)(options);\n        const runId = config.runId ?? (0, uuid_1.v4)();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const abortController = new AbortController();\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            let signal;\n            let listener = null;\n            try {\n                if (options?.signal) {\n                    if (\"any\" in AbortSignal) {\n                        // Use native AbortSignal.any() if available (Node 19+)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        signal = AbortSignal.any([\n                            abortController.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        // Fallback for Node 18 and below - just use the provided signal\n                        signal = options.signal;\n                        // Ensure we still abort our controller when the parent signal aborts\n                        listener = () => {\n                            abortController.abort();\n                        };\n                        options.signal.addEventListener(\"abort\", listener, { once: true });\n                    }\n                }\n                else {\n                    signal = abortController.signal;\n                }\n                const runnableStream = await outerThis.stream(input, {\n                    ...config,\n                    signal,\n                });\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                    if (abortController.signal.aborted)\n                        break;\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n                if (signal && listener) {\n                    signal.removeEventListener(\"abort\", listener);\n                }\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            abortController.abort();\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = (0, config_js_1.ensureConfig)(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new log_stream_js_1.LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new utils_js_1._RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = log_stream_js_1.RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return (0, utils_js_1.isRunnableInterface)(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\nexports.Runnable = Runnable;\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nclass RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = (0, config_js_1.mergeConfigs)(this.config, ...options);\n        return (0, config_js_1.mergeConfigs)(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig((0, config_js_1.ensureConfig)(individualOption), this.kwargs)))\n            : await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.bound._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig((0, config_js_1.ensureConfig)(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig((0, config_js_1.ensureConfig)(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new root_listener_js_1.RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\nexports.RunnableBinding = RunnableBinding;\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nclass RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\nexports.RunnableEach = RunnableEach;\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nclass RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return (0, config_js_1.patchConfig)(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return (0, p_retry_1.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await (0, p_retry_1.default)(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\nexports.RunnableRetry = RunnableRetry;\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nclass RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(config_js_1.getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return (0, config_js_1.patchConfig)(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await (0, signal_js_1.raceWithSignal)(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.last._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), (0, config_js_1.patchConfig)(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, (0, config_js_1.patchConfig)(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = this._concatOutputChunks(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new graph_js_1.Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\nexports.RunnableSequence = RunnableSequence;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nclass RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await (0, signal_js_1.raceWithSignal)(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = (0, stream_js_1.atee)(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], (0, config_js_1.patchConfig)(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await (0, signal_js_1.raceWithSignal)(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableMap = RunnableMap;\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nclass RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!(0, traceable_1.isTraceableFunction)(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const promise = this.func((0, config_js_1.patchConfig)(config, { callbacks }), input);\n        return (0, signal_js_1.raceWithSignal)(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if ((0, iter_js_1.isAsyncIterable)(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if ((0, iter_js_1.isIterator)(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nexports.RunnableTraceable = RunnableTraceable;\nfunction assertNonTraceableFunction(func) {\n    if ((0, traceable_1.isTraceableFunction)(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nclass RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if ((0, traceable_1.isTraceableFunction)(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if ((0, iter_js_1.isAsyncIterable)(output)) {\n                        let finalOutput;\n                        for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if ((0, iter_js_1.isIterableIterator)(output)) {\n                        let finalOutput;\n                        for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = this._concatOutputChunks(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = (0, config_js_1.patchConfig)(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? config_js_1.DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isAsyncIterable)(output)) {\n            for await (const chunk of (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if ((0, iter_js_1.isIterableIterator)(output)) {\n            for (const chunk of (0, iter_js_1.consumeIteratorInContext)(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableLambda = RunnableLambda;\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nclass RunnableParallel extends RunnableMap {\n}\nexports.RunnableParallel = RunnableParallel;\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nclass RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n            callbacks: runManager?.getChild(),\n        });\n        const res = await index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n            let firstError;\n            for (const runnable of this.runnables()) {\n                config?.signal?.throwIfAborted();\n                try {\n                    const output = await runnable.invoke(input, childConfig);\n                    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                    return output;\n                }\n                catch (e) {\n                    if (firstError === undefined) {\n                        firstError = e;\n                    }\n                }\n            }\n            if (firstError === undefined) {\n                throw new Error(\"No error stored at end of fallback.\");\n            }\n            await runManager?.handleChainError(firstError);\n            throw firstError;\n        });\n        return res;\n    }\n    async *_streamIterator(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = (0, config_js_1.patchConfig)(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                const originalStream = await runnable.stream(input, childConfig);\n                stream = (0, iter_js_1.consumeAsyncIterableInContext)(childConfig, originalStream);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output =\n                        output === undefined\n                            ? output\n                            : this._concatOutputChunks(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => (0, config_js_1.getCallbackManagerForConfig)(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => (0, config_js_1.patchConfig)(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nexports.RunnableWithFallbacks = RunnableWithFallbacks;\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nclass RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = (0, stream_js_1.atee)(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, (0, config_js_1.patchConfig)(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnableAssign = RunnableAssign;\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nclass RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0\n                ? undefined\n                : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = (0, config_js_1.ensureConfig)(options);\n        const wrappedGenerator = new stream_js_1.AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexports.RunnablePick = RunnablePick;\nclass RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if ((0, utils_js_2._isToolCall)(input)) {\n                    try {\n                        toolInput = await (0, zod_js_1.interopParseAsync)(this.schema, input.args);\n                    }\n                    catch (e) {\n                        throw new utils_js_2.ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\nexports.RunnableToolLike = RunnableToolLike;\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nfunction convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? (0, zod_js_1.getSchemaDescription)(fields.schema);\n    if ((0, zod_js_1.isSimpleStringZodSchema)(fields.schema)) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: v3_1.z\n                .object({ input: v3_1.z.string() })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCO0FBQ3JVLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxlQUFlLG1CQUFPLENBQUMsMkZBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWdDO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLG1HQUEyQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDL0QsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTBCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQWM7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLHlHQUE4QjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBeUI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWE7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQWdCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFvQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLGdCQUFnQixjQUFjLFFBQVE7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNMQUFzTCxXQUFXO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQscUNBQXFDLDRDQUE0QztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixZQUFZLDRCQUE0QixjQUFjO0FBQ3BKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxHQUFHLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVksNEJBQTRCLFdBQVc7QUFDN0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLGlCQUFpQjtBQUMxRSx3Q0FBd0MsZ0JBQWdCLGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLG1DQUFtQztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Qsc0RBQXNELHNDQUFzQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSx5RUFBeUUsc0JBQXNCO0FBQy9GLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0Esb0dBQW9HLE1BQU07QUFDMUcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGtCQUFrQjtBQUNsSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0EsaUhBQWlILE1BQU07QUFDdkgseUVBQXlFLDRCQUE0QjtBQUNyRyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLG9HQUFvRyxNQUFNO0FBQzFHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSwyQkFBMkI7QUFDM0I7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RSwyQkFBMkI7QUFDM0I7QUFDQSxJQUFJO0FBQ0osMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsSUFBSTtBQUNuRSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9ELGFBQWE7QUFDYix3REFBd0Qsa0JBQWtCO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLHlCQUF5QixXQUFXLFdBQVc7QUFDL0M7QUFDQSw4QkFBOEIsZUFBZSxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLG1CQUFtQixLQUFLLGNBQWM7QUFDcEU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdDQUFnQyxjQUFjLEtBQUssbUJBQW1CO0FBQ3RFLGNBQWMsb0JBQW9CLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBLFFBQVEsNENBQTRDLFNBQVMsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csbUNBQW1DO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLFlBQVksWUFBWSxlQUFlO0FBQ25FO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVywwQkFBMEI7QUFDckMsYUFBYSx1REFBdUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5SdW5uYWJsZVBpY2sgPSBleHBvcnRzLlJ1bm5hYmxlQXNzaWduID0gZXhwb3J0cy5SdW5uYWJsZVdpdGhGYWxsYmFja3MgPSBleHBvcnRzLlJ1bm5hYmxlUGFyYWxsZWwgPSBleHBvcnRzLlJ1bm5hYmxlTGFtYmRhID0gZXhwb3J0cy5SdW5uYWJsZVRyYWNlYWJsZSA9IGV4cG9ydHMuUnVubmFibGVNYXAgPSBleHBvcnRzLlJ1bm5hYmxlU2VxdWVuY2UgPSBleHBvcnRzLlJ1bm5hYmxlUmV0cnkgPSBleHBvcnRzLlJ1bm5hYmxlRWFjaCA9IGV4cG9ydHMuUnVubmFibGVCaW5kaW5nID0gZXhwb3J0cy5SdW5uYWJsZSA9IHZvaWQgMDtcbmV4cG9ydHMuX2NvZXJjZVRvRGljdCA9IF9jb2VyY2VUb0RpY3Q7XG5leHBvcnRzLl9jb2VyY2VUb1J1bm5hYmxlID0gX2NvZXJjZVRvUnVubmFibGU7XG5leHBvcnRzLmNvbnZlcnRSdW5uYWJsZVRvVG9vbCA9IGNvbnZlcnRSdW5uYWJsZVRvVG9vbDtcbmNvbnN0IHYzXzEgPSByZXF1aXJlKFwiem9kL3YzXCIpO1xuY29uc3QgcF9yZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwLXJldHJ5XCIpKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdHJhY2VhYmxlXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCIpO1xuY29uc3QgbG9nX3N0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL3RyYWNlcnMvbG9nX3N0cmVhbS5janNcIik7XG5jb25zdCBldmVudF9zdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2V2ZW50X3N0cmVhbS5janNcIik7XG5jb25zdCBzZXJpYWxpemFibGVfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3Qgc2lnbmFsX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc2lnbmFsLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5janNcIik7XG5jb25zdCByb290X2xpc3RlbmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3QgZ3JhcGhfanNfMSA9IHJlcXVpcmUoXCIuL2dyYXBoLmNqc1wiKTtcbmNvbnN0IHdyYXBwZXJzX2pzXzEgPSByZXF1aXJlKFwiLi93cmFwcGVycy5janNcIik7XG5jb25zdCBpdGVyX2pzXzEgPSByZXF1aXJlKFwiLi9pdGVyLmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzIgPSByZXF1aXJlKFwiLi4vdG9vbHMvdXRpbHMuY2pzXCIpO1xuY29uc3Qgem9kX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdHlwZXMvem9kLmNqc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBBIFJ1bm5hYmxlIGlzIGEgZ2VuZXJpYyB1bml0IG9mIHdvcmsgdGhhdCBjYW4gYmUgaW52b2tlZCwgYmF0Y2hlZCwgc3RyZWFtZWQsIGFuZC9vclxuICogdHJhbnNmb3JtZWQuXG4gKi9cbmNsYXNzIFJ1bm5hYmxlIGV4dGVuZHMgc2VyaWFsaXphYmxlX2pzXzEuU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmFtZShzdWZmaXgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLm5hbWUgPz8gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCkgPz8gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4gc3VmZml4ID8gYCR7bmFtZX0ke3N1ZmZpeH1gIDogbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBhcmd1bWVudHMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBrd2FyZ3NcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJpbmRpbmcgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIGFwcGx5IHRoZSBib3VuZCBhcmdzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayB3aXRoQ29uZmlnfSBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoeyBib3VuZDogdGhpcywga3dhcmdzLCBjb25maWc6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgUnVubmFibGUgdGhhdCBtYXBzIGEgbGlzdCBvZiBpbnB1dHMgdG8gYSBsaXN0IG9mIG91dHB1dHMsXG4gICAgICogYnkgY2FsbGluZyBpbnZva2UoKSB3aXRoIGVhY2ggaW5wdXQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLlxuICAgICAqL1xuICAgIG1hcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7IGJvdW5kOiB0aGlzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcmV0cnkgbG9naWMgdG8gYW4gZXhpc3RpbmcgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGZpZWxkcy5zdG9wQWZ0ZXJBdHRlbXB0IFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkuXG4gICAgICogQHBhcmFtIGZpZWxkcy5vbkZhaWxlZEF0dGVtcHQgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgcmV0cnkgZmFpbHMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVSZXRyeSB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgcmV0cnkgYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBrd2FyZ3M6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIG1heEF0dGVtcHROdW1iZXI6IGZpZWxkcz8uc3RvcEFmdGVyQXR0ZW1wdCxcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgY29uZmlnIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE5ldyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gYXR0YWNoIHRvIHRoZSBuZXcgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHdpdGggYSBjb25maWcgbWF0Y2hpbmcgd2hhdCdzIHBhc3NlZC5cbiAgICAgKi9cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBydW5uYWJsZSBmcm9tIHRoZSBjdXJyZW50IG9uZSB0aGF0IHdpbGwgdHJ5IGludm9raW5nXG4gICAgICogb3RoZXIgcGFzc2VkIGZhbGxiYWNrIHJ1bm5hYmxlcyBpZiB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqIEBwYXJhbSBmaWVsZHMuZmFsbGJhY2tzIE90aGVyIHJ1bm5hYmxlcyB0byBjYWxsIGlmIHRoZSBydW5uYWJsZSBlcnJvcnMuXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzLlxuICAgICAqL1xuICAgIHdpdGhGYWxsYmFja3MoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSA/IGZpZWxkcyA6IGZpZWxkcy5mYWxsYmFja3M7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVdpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgcnVubmFibGU6IHRoaXMsXG4gICAgICAgICAgICBmYWxsYmFja3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucywgbGVuZ3RoID0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBpbnB1dHMsIGJ1dCBnb3QgJHtvcHRpb25zLmxlbmd0aH0gb3B0aW9ucyBmb3IgJHtsZW5ndGh9IGlucHV0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5tYXAoY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLnJ1bklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQcm92aWRlZCBydW5JZCB3aWxsIGJlIHVzZWQgb25seSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJhdGNoLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNlcXVlbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZmlsdGVyKChba2V5XSkgPT4ga2V5ICE9PSBcInJ1bklkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sIChfLCBpKSA9PiAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShpID09PSAwID8gb3B0aW9ucyA6IHN1YnNlcXVlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBjb25maWdMaXN0WzBdPy5tYXhDb25jdXJyZW5jeSA/PyBiYXRjaE9wdGlvbnM/Lm1heENvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBjYWxsZXIgPSBuZXcgYXN5bmNfY2FsbGVyX2pzXzEuQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXRjaENhbGxzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGkpID0+IGNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQsIGNvbmZpZ0xpc3RbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGJhdGNoQ2FsbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0cmVhbWluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHN1cHBvcnQgc3RyZWFtaW5nIG91dHB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGluIGNodW5rcy5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtIHRoYXQgaXMgYWxzbyBhbiBpdGVyYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnVmZmVyIHRoZSBmaXJzdCBzdHJlYW1lZCBjaHVuayB0byBhbGxvdyBmb3IgaW5pdGlhbCBlcnJvcnNcbiAgICAgICAgLy8gdG8gc3VyZmFjZSBpbW1lZGlhdGVseS5cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgc3RyZWFtX2pzXzEuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgcnVubmFibGVDb25maWc7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydW5uYWJsZUNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG9wdGlvbnMuY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBvcHRpb25zLnJ1bk5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcHRpb25zLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogb3B0aW9ucy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogb3B0aW9ucy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBydW5JZDogb3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50YWdzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5ydW5OYW1lO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY29uZmlndXJhYmxlO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucmVjdXJzaW9uTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bklkO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMudGltZW91dDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyBfY2FsbFdpdGhDb25maWcoZnVuYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIGNvbmZpZz8ucnVuVHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5jYWxsKHRoaXMsIGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpO1xuICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBoYW5kbGVzIGJhdGNoaW5nIGFuZCBjb25maWd1cmF0aW9uIGZvciBhIHJ1bm5hYmxlXG4gICAgICogSXQgdGFrZXMgYSBmdW5jdGlvbiwgaW5wdXQgdmFsdWVzLCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiwgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaW5wdXQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfYmF0Y2hXaXRoQ29uZmlnKGZ1bmMsIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zTGlzdC5tYXAoY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIG9wdGlvbnNMaXN0W2ldLnJ1bklkLCBvcHRpb25zTGlzdFtpXS5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9uc0xpc3RbaV0ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5jYWxsKHRoaXMsIGlucHV0cywgb3B0aW9uc0xpc3QsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkocHJvbWlzZSwgb3B0aW9uc0xpc3Q/LlswXT8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGZpcnN0LCBzZWNvbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhbiBJdGVyYXRvciBvZiBJbnB1dCB2YWx1ZXMgaW50byBhbiBJdGVyYXRvciBvZlxuICAgICAqIE91dHB1dCB2YWx1ZXMsIHdpdGggY2FsbGJhY2tzLlxuICAgICAqIFVzZSB0aGlzIHRvIGltcGxlbWVudCBgc3RyZWFtKClgIG9yIGB0cmFuc2Zvcm0oKWAgaW4gUnVubmFibGUgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyAqX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoaW5wdXRHZW5lcmF0b3IsIHRyYW5zZm9ybWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmaW5hbElucHV0O1xuICAgICAgICBsZXQgZmluYWxJbnB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogd3JhcElucHV0Rm9yVHJhY2luZygpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxJbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBvdXRlclRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbElucHV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuTWFuYWdlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpcGUgPSBhd2FpdCAoMCwgc3RyZWFtX2pzXzEucGlwZUdlbmVyYXRvcldpdGhTZXR1cCkodHJhbnNmb3JtZXIuYmluZCh0aGlzKSwgd3JhcElucHV0Rm9yVHJhY2luZygpLCBhc3luYyAoKSA9PiBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHsgaW5wdXQ6IFwiXCIgfSwgY29uZmlnLnJ1bklkLCBjb25maWcucnVuVHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKSwgb3B0aW9ucz8uc2lnbmFsLCBjb25maWcpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXIgPSBwaXBlLnNldHVwO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtRXZlbnRzSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQoZXZlbnRfc3RyZWFtX2pzXzEuaXNTdHJlYW1FdmVudHNIYW5kbGVyKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHBpcGUub3V0cHV0O1xuICAgICAgICAgICAgaWYgKHN0cmVhbUV2ZW50c0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJiBydW5NYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IHN0cmVhbUV2ZW50c0hhbmRsZXIudGFwT3V0cHV0SXRlcmFibGUocnVuTWFuYWdlci5ydW5JZCwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtTG9nSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQobG9nX3N0cmVhbV9qc18xLmlzTG9nU3RyZWFtSGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoc3RyZWFtTG9nSGFuZGxlciAhPT0gdW5kZWZpbmVkICYmIHJ1bk1hbmFnZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RyZWFtTG9nSGFuZGxlci50YXBPdXRwdXRJdGVyYWJsZShydW5NYW5hZ2VyLnJ1bklkLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbE91dHB1dCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoZmluYWxPdXRwdXQgPz8ge30sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIikgfSk7XG4gICAgfVxuICAgIGdldEdyYXBoKF8pIHtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgZ3JhcGhfanNfMS5HcmFwaCgpO1xuICAgICAgICAvLyBUT0RPOiBBZGQgaW5wdXQgc2NoZW1hIGZvciBydW5uYWJsZXNcbiAgICAgICAgY29uc3QgaW5wdXROb2RlID0gZ3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmdldE5hbWUoKX1JbnB1dGAsXG4gICAgICAgICAgICBzY2hlbWE6IHYzXzEuei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlTm9kZSA9IGdyYXBoLmFkZE5vZGUodGhpcyk7XG4gICAgICAgIC8vIFRPRE86IEFkZCBvdXRwdXQgc2NoZW1hcyBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IG91dHB1dE5vZGUgPSBncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuZ2V0TmFtZSgpfU91dHB1dGAsXG4gICAgICAgICAgICBzY2hlbWE6IHYzXzEuei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoLmFkZEVkZ2UoaW5wdXROb2RlLCBydW5uYWJsZU5vZGUpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKHJ1bm5hYmxlTm9kZSwgb3V0cHV0Tm9kZSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlIHRoYXQgcnVucyBlYWNoIGluZGl2aWR1YWwgcnVubmFibGUgaW4gc2VyaWVzLFxuICAgICAqIHBpcGluZyB0aGUgb3V0cHV0IG9mIG9uZSBydW5uYWJsZSBpbnRvIGFub3RoZXIgcnVubmFibGUgb3IgcnVubmFibGUtbGlrZS5cbiAgICAgKiBAcGFyYW0gY29lcmNlYWJsZSBBIHJ1bm5hYmxlLCBmdW5jdGlvbiwgb3Igb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZnVuY3Rpb25zIG9yIHJ1bm5hYmxlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBydW5uYWJsZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMsXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpY2sga2V5cyBmcm9tIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIHBpY2soa2V5cykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUobmV3IFJ1bm5hYmxlUGljayhrZXlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGZpZWxkcyB0byB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3NpZ24obWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZUFzc2lnbihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRyYW5zZm9ybSwgd2hpY2ggYnVmZmVycyBpbnB1dCBhbmQgdGhlbiBjYWxscyBzdHJlYW0uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBjYW4gc3RhcnQgcHJvZHVjaW5nIG91dHB1dCB3aGlsZVxuICAgICAqIGlucHV0IGlzIHN0aWxsIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIGdhdGhlcmluZyBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1JdGVyYXRvcihmaW5hbENodW5rLCAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhbGwgb3V0cHV0IGZyb20gYSBydW5uYWJsZSwgYXMgcmVwb3J0ZWQgdG8gdGhlIGNhbGxiYWNrIHN5c3RlbS5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIGFsbCBpbm5lciBydW5zIG9mIExMTXMsIFJldHJpZXZlcnMsIFRvb2xzLCBldGMuXG4gICAgICogT3V0cHV0IGlzIHN0cmVhbWVkIGFzIExvZyBvYmplY3RzLCB3aGljaCBpbmNsdWRlIGEgbGlzdCBvZlxuICAgICAqIGpzb25wYXRjaCBvcHMgdGhhdCBkZXNjcmliZSBob3cgdGhlIHN0YXRlIG9mIHRoZSBydW4gaGFzIGNoYW5nZWQgaW4gZWFjaFxuICAgICAqIHN0ZXAsIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIHJ1bi5cbiAgICAgKiBUaGUganNvbnBhdGNoIG9wcyBjYW4gYmUgYXBwbGllZCBpbiBvcmRlciB0byBjb25zdHJ1Y3Qgc3RhdGUuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3RyZWFtT3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpzdHJlYW1Mb2coaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IGxvZ19zdHJlYW1fanNfMS5Mb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcIm9yaWdpbmFsXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29waWVkQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvcHkoKTtcbiAgICAgICAgICAgIGNvcGllZENhbGxiYWNrcy5hZGRIYW5kbGVyKGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW1Qcm9taXNlID0gdGhpcy5zdHJlYW0oaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVSdW5uYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSBhd2FpdCBydW5uYWJsZVN0cmVhbVByb21pc2U7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBsb2dfc3RyZWFtX2pzXzEuUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvc3RyZWFtZWRfb3V0cHV0Ly1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2UgPSBjb25zdW1lUnVubmFibGVTdHJlYW0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGxvZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gPT09IFwidjFcIikge1xuICAgICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtRXZlbnRzVjEoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudmVyc2lvbiA9PT0gXCJ2MlwiKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1FdmVudHNWMihpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgdmVyc2lvbnMgXCJ2MVwiIGFuZCBcInYyXCIgb2YgdGhlIHNjaGVtYSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHdyYXBwZXJzX2pzXzEuY29udmVydFRvSHR0cEV2ZW50U3RyZWFtKShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1FdmVudHNWMihpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBjb25zdCBldmVudFN0cmVhbWVyID0gbmV3IGV2ZW50X3N0cmVhbV9qc18xLkV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bklkID0gY29uZmlnLnJ1bklkID8/ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgIGNvbmZpZy5ydW5JZCA9IHJ1bklkO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb25maWcuY2FsbGJhY2tzO1xuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbZXZlbnRTdHJlYW1lcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvbmNhdChldmVudFN0cmVhbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihldmVudFN0cmVhbWVyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNvcGllZENhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIC8vIENhbGwgdGhlIHJ1bm5hYmxlIGluIHN0cmVhbWluZyBtb2RlLFxuICAgICAgICAvLyBhZGQgZWFjaCBjaHVuayB0byB0aGUgb3V0cHV0IHN0cmVhbVxuICAgICAgICBjb25zdCBvdXRlclRoaXMgPSB0aGlzO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICBsZXQgc2lnbmFsO1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhbnlcIiBpbiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5hdGl2ZSBBYm9ydFNpZ25hbC5hbnkoKSBpZiBhdmFpbGFibGUgKE5vZGUgMTkrKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIE5vZGUgMTggYW5kIGJlbG93IC0ganVzdCB1c2UgdGhlIHByb3ZpZGVkIHNpZ25hbFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2Ugc3RpbGwgYWJvcnQgb3VyIGNvbnRyb2xsZXIgd2hlbiB0aGUgcGFyZW50IHNpZ25hbCBhYm9ydHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9IGF3YWl0IG91dGVyVGhpcy5zdHJlYW0oaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFwcGVkU3RyZWFtID0gZXZlbnRTdHJlYW1lci50YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgcnVubmFibGVTdHJlYW0pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdGFwcGVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgaXRlcmF0ZSBzbyB0aGF0IHRoZSBjYWxsYmFjayBoYW5kbGVyIHBpY2tzIHVwIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZXZlbnRTdHJlYW1lci5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsICYmIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIGxldCBmaXJzdEV2ZW50U2VudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFJ1bklkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBldmVudFN0cmVhbWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmstYXJvdW5kIGFuIGlzc3VlIHdoZXJlIHRoZSBpbnB1dHMgaW50byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFpbiBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCB0aGUgZW50aXJlIGlucHV0IGlzIGNvbnN1bWVkLlxuICAgICAgICAgICAgICAgIC8vIEFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSdsbCBtb2RpZnkgdGhlIGlucHV0IHRvIGJlIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0RXZlbnRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEV2ZW50UnVuSWQgPSBldmVudC5ydW5faWQ7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJ1bl9pZCA9PT0gZmlyc3RFdmVudFJ1bklkICYmIGV2ZW50LmV2ZW50LmVuZHNXaXRoKFwiX2VuZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBlbmQgZXZlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBydW5uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb250IGluY2x1ZGUgdGhlIGlucHV0IGluIHRoZSBldmVudCBzaW5jZSBpdCdzIGd1YXJhbnRlZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudC5kYXRhLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBhd2FpdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtRXZlbnRzVjEoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bkxvZztcbiAgICAgICAgbGV0IGhhc0VuY291bnRlcmVkU3RhcnRFdmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgcm9vdFRhZ3MgPSBjb25maWcudGFncyA/PyBbXTtcbiAgICAgICAgY29uc3Qgcm9vdE1ldGFkYXRhID0gY29uZmlnLm1ldGFkYXRhID8/IHt9O1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGNvbmZpZy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpO1xuICAgICAgICBjb25zdCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBuZXcgbG9nX3N0cmVhbV9qc18xLkxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICAgIF9zY2hlbWFGb3JtYXQ6IFwic3RyZWFtaW5nX2V2ZW50c1wiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm9vdEV2ZW50RmlsdGVyID0gbmV3IHV0aWxzX2pzXzEuX1Jvb3RFdmVudEZpbHRlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtID0gdGhpcy5fc3RyZWFtTG9nKGlucHV0LCBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIGNvbmZpZyk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFydW5Mb2cpIHtcbiAgICAgICAgICAgICAgICBydW5Mb2cgPSBsb2dfc3RyZWFtX2pzXzEuUnVuTG9nLmZyb21SdW5Mb2dQYXRjaChsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVuTG9nID0gcnVuTG9nLmNvbmNhdChsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bkxvZy5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvcjogXCJzdHJlYW1FdmVudHNcIiBzdGF0ZSBpcyBtaXNzaW5nLiBQbGVhc2Ugb3BlbiBhIGJ1ZyByZXBvcnQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBZaWVsZCB0aGUgc3RhcnQgZXZlbnQgZm9yIHRoZSByb290IHJ1bm5hYmxlIGlmIGl0IGhhc24ndCBiZWVuIHNlZW4uXG4gICAgICAgICAgICAvLyBUaGUgcm9vdCBydW4gaXMgbmV2ZXIgZmlsdGVyZWQgb3V0XG4gICAgICAgICAgICBpZiAoIWhhc0VuY291bnRlcmVkU3RhcnRFdmVudCkge1xuICAgICAgICAgICAgICAgIGhhc0VuY291bnRlcmVkU3RhcnRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7IC4uLnJ1bkxvZy5zdGF0ZSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RhcnRgLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gbG9nLm9wc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wKSA9PiBvcC5wYXRoLnN0YXJ0c1dpdGgoXCIvbG9ncy9cIikpXG4gICAgICAgICAgICAgICAgLm1hcCgob3ApID0+IG9wLnBhdGguc3BsaXQoXCIvXCIpWzJdKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZHVwZWRQYXRocyA9IFsuLi5uZXcgU2V0KHBhdGhzKV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgZGVkdXBlZFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0gcnVuTG9nLnN0YXRlLmxvZ3NbcGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmVuZF90aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcInN0cmVhbVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcImVuZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgaW5wdXRzIHdpdGggdGhlIHN0YXJ0IGV2ZW50IGlmIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB0aGV5IHdpbGwgTk9UIGJlIGF2YWlsYWJsZSBmb3IgY29tcG9uZW50cyB0aGF0IG9wZXJhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gc3RyZWFtcywgc2luY2UgdGhvc2UgY29tcG9uZW50cyBzdHJlYW0gdGhlIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBrbm93IGl0cyBmaW5hbCB2YWx1ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlucHV0ID0gbG9nRW50cnkuaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0ID0gbG9nRW50cnkuZmluYWxfb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgb25lIGNodW5rIG9mIHN0cmVhbWVkIG91dHB1dCwgZ290ICR7Y2h1bmtDb3VudH0gaW5zdGVhZC4gRW5jb3VudGVyZWQgaW46IFwiJHtsb2dFbnRyeS5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsgY2h1bms6IGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dFswXSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtLCB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCB0aGlzIGF2b2lkcyBkdXBsaWNhdGVzIGFzIHdlbGwhXG4gICAgICAgICAgICAgICAgICAgIGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtsb2dFbnRyeS50eXBlfV8ke2V2ZW50VHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsb2dFbnRyeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IGxvZ0VudHJ5LmlkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBsb2dFbnRyeS50YWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbG9nRW50cnkubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHdlIHRha2UgY2FyZSBvZiB0aGUgc3RyZWFtaW5nIG91dHB1dCBmcm9tIHRoZSByb290IGNoYWluXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkuXG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBydW5Mb2c7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gc3RhdGUuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgb25lIGNodW5rIG9mIHN0cmVhbWVkIG91dHB1dCwgZ290ICR7Y2h1bmtDb3VudH0gaW5zdGVhZC4gRW5jb3VudGVyZWQgaW46IFwiJHtzdGF0ZS5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IGNodW5rOiBzdGF0ZS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtLCB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RyZWFtZWRfb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gcnVuTG9nPy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHlpZWxkIHRoZSBlbmQgZXZlbnQgZm9yIHRoZSByb290IHJ1bm5hYmxlLlxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X2VuZGAsXG4gICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBzdGF0ZS5maW5hbF9vdXRwdXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpXG4gICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZSh0aGluZykge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuaXNSdW5uYWJsZUludGVyZmFjZSkodGhpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZ0ZhY3RvcmllczogW1xuICAgICAgICAgICAgICAgIChjb25maWcpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHJvb3RfbGlzdGVuZXJfanNfMS5Sb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHJ1bm5hYmxlIHRvIGEgdG9vbC4gUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYFxuICAgICAqIHdoaWNoIGNvbnRhaW5zIHRoZSBydW5uYWJsZSwgbmFtZSwgZGVzY3JpcHRpb24gYW5kIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSB7VCBleHRlbmRzIFJ1bklucHV0ID0gUnVuSW5wdXR9IFJ1bklucHV0IC0gVGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLiBTaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIGBSdW5JbnB1dGAgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMubmFtZV0gVGhlIG5hbWUgb2YgdGhlIHRvb2wuIElmIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5kZXNjcmlwdGlvbl0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLiBGYWxscyBiYWNrIHRvIHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgWm9kIHNjaGVtYSBpZiBub3QgcHJvdmlkZWQsIG9yIHVuZGVmaW5lZCBpZiBuZWl0aGVyIGFyZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge3ouWm9kVHlwZTxUPn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICogQHJldHVybnMge1J1bm5hYmxlVG9vbExpa2U8ei5ab2RUeXBlPFQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAgICAgKi9cbiAgICBhc1Rvb2woZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0UnVubmFibGVUb1Rvb2wodGhpcywgZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlID0gUnVubmFibGU7XG4vKipcbiAqIFdyYXBzIGEgcnVubmFibGUgYW5kIGFwcGxpZXMgcGFydGlhbCBjb25maWcgdXBvbiBpbnZvY2F0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICB0eXBlIFJ1bm5hYmxlQ29uZmlnLFxuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBlbmhhbmNlUHJvZmlsZSA9IChcbiAqICAgcHJvZmlsZTogUmVjb3JkPHN0cmluZywgYW55PixcbiAqICAgY29uZmlnPzogUnVubmFibGVDb25maWdcbiAqICkgPT4ge1xuICogICBpZiAoY29uZmlnPy5jb25maWd1cmFibGU/LnJvbGUpIHtcbiAqICAgICByZXR1cm4geyAuLi5wcm9maWxlLCByb2xlOiBjb25maWcuY29uZmlndXJhYmxlLnJvbGUgfTtcbiAqICAgfVxuICogICByZXR1cm4gcHJvZmlsZTtcbiAqIH07XG4gKlxuICogY29uc3QgcnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGVuaGFuY2VQcm9maWxlKTtcbiAqXG4gKiAvLyBCaW5kIGNvbmZpZ3VyYXRpb24gdG8gdGhlIHJ1bm5hYmxlIHRvIHNldCB0aGUgdXNlcidzIHJvbGUgZHluYW1pY2FsbHlcbiAqIGNvbnN0IGFkbWluUnVubmFibGUgPSBydW5uYWJsZS5iaW5kKHsgY29uZmlndXJhYmxlOiB7IHJvbGU6IFwiQWRtaW5cIiB9IH0pO1xuICogY29uc3QgdXNlclJ1bm5hYmxlID0gcnVubmFibGUuYmluZCh7IGNvbmZpZ3VyYWJsZTogeyByb2xlOiBcIlVzZXJcIiB9IH0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBhZG1pblJ1bm5hYmxlLmludm9rZSh7XG4gKiAgIG5hbWU6IFwiQWxpY2VcIixcbiAqICAgZW1haWw6IFwiYWxpY2VAZXhhbXBsZS5jb21cIlxuICogfSk7XG4gKlxuICogLy8geyBuYW1lOiBcIkFsaWNlXCIsIGVtYWlsOiBcImFsaWNlQGV4YW1wbGUuY29tXCIsIHJvbGU6IFwiQWRtaW5cIiB9XG4gKlxuICogY29uc3QgcmVzdWx0MiA9IGF3YWl0IHVzZXJSdW5uYWJsZS5pbnZva2Uoe1xuICogICBuYW1lOiBcIkJvYlwiLFxuICogICBlbWFpbDogXCJib2JAZXhhbXBsZS5jb21cIlxuICogfSk7XG4gKlxuICogLy8geyBuYW1lOiBcIkJvYlwiLCBlbWFpbDogXCJib2JAZXhhbXBsZS5jb21cIiwgcm9sZTogXCJVc2VyXCIgfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlQmluZGluZyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVCaW5kaW5nXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnRmFjdG9yaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgICAgIHRoaXMua3dhcmdzID0gZmllbGRzLmt3YXJncztcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ0ZhY3RvcmllcyA9IGZpZWxkcy5jb25maWdGYWN0b3JpZXM7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmdldE5hbWUoc3VmZml4KTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLm1lcmdlQ29uZmlncykodGhpcy5jb25maWcsIC4uLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKDAsIGNvbmZpZ19qc18xLm1lcmdlQ29uZmlncykoY29uZmlnLCAuLi4odGhpcy5jb25maWdGYWN0b3JpZXNcbiAgICAgICAgICAgID8gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jb25maWdGYWN0b3JpZXMubWFwKGFzeW5jIChjb25maWdGYWN0b3J5KSA9PiBhd2FpdCBjb25maWdGYWN0b3J5KGNvbmZpZykpKVxuICAgICAgICAgICAgOiBbXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ga3dhcmdzIFRoZSBhcmd1bWVudHMgdG8gYmluZCB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bm5hYmxlQmluZGluZ2AgY2xhc3MgdGhhdCBpcyBib3VuZCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayB3aXRoQ29uZmlnfSBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogeyAuLi50aGlzLmt3YXJncywgLi4ua3dhcmdzIH0sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogeyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBtYXhBdHRlbXB0TnVtYmVyOiBmaWVsZHM/LnN0b3BBZnRlckF0dGVtcHQsXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuaW52b2tlKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICAgICAgICAgID8gYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKGluZGl2aWR1YWxPcHRpb24pID0+IHRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKGluZGl2aWR1YWxPcHRpb24pLCB0aGlzLmt3YXJncykpKVxuICAgICAgICAgICAgOiBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsIG1lcmdlZE9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29uY2F0T3V0cHV0Q2h1bmtzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuX2NvbmNhdE91dHB1dENodW5rcyhmaXJzdCwgc2Vjb25kKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCogdGhpcy5ib3VuZC5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKCgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuc3RyZWFtKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZygoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgKnRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQudHJhbnNmb3JtKGdlbmVyYXRvciwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIHN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkKiBvdXRlclRoaXMuYm91bmQuc3RyZWFtRXZlbnRzKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IG91dGVyVGhpcy5fbWVyZ2VDb25maWcoKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyksIG91dGVyVGhpcy5rd2FyZ3MpKSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgICAgICB9LCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcigpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUnVubmFibGVCaW5kaW5nKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdGhpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpbmcuYm91bmQgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZy5ib3VuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyByb290X2xpc3RlbmVyX2pzXzEuUm9vdExpc3RlbmVyc1RyYWNlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUJpbmRpbmcgPSBSdW5uYWJsZUJpbmRpbmc7XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZVxuICogd2l0aCBlYWNoIGVsZW1lbnQgb2YgdGhlIGlucHV0IHNlcXVlbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFJ1bm5hYmxlRWFjaCwgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IHRvVXBwZXJDYXNlID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4gaW5wdXQudG9VcHBlckNhc2UoKTtcbiAqIGNvbnN0IGFkZEdyZWV0aW5nID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4gYEhlbGxvLCAke2lucHV0fSFgO1xuICpcbiAqIGNvbnN0IHVwcGVyQ2FzZUxhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20odG9VcHBlckNhc2UpO1xuICogY29uc3QgZ3JlZXRpbmdMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFkZEdyZWV0aW5nKTtcbiAqXG4gKiBjb25zdCBjaGFpbiA9IG5ldyBSdW5uYWJsZUVhY2goe1xuICogICBib3VuZDogdXBwZXJDYXNlTGFtYmRhLnBpcGUoZ3JlZXRpbmdMYW1iZGEpLFxuICogfSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uaW52b2tlKFtcImFsaWNlXCIsIFwiYm9iXCIsIFwiY2Fyb2xcIl0pXG4gKlxuICogLy8gW1wiSGVsbG8sIEFMSUNFIVwiLCBcIkhlbGxvLCBCT0IhXCIsIFwiSGVsbG8sIENBUk9MIVwiXVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAqL1xuY2xhc3MgUnVubmFibGVFYWNoIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUVhY2hcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm91bmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib3VuZCA9IGZpZWxkcy5ib3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGt3YXJncyBUaGUgYXJndW1lbnRzIHRvIGJpbmQgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBSdW5uYWJsZUVhY2hgIGNsYXNzIHRoYXQgaXMgYm91bmQgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgd2l0aENvbmZpZ30gaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgcmVsZWFzZS5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC5iaW5kKGt3YXJncyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGguXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UuYmluZCh0aGlzKSwgaW5wdXRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIF9pbnZva2UoaW5wdXRzLCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGxpZmVjeWNsZSBsaXN0ZW5lcnMgdG8gYSBSdW5uYWJsZSwgcmV0dXJuaW5nIGEgbmV3IFJ1bm5hYmxlLlxuICAgICAqIFRoZSBSdW4gb2JqZWN0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBydW4sIGluY2x1ZGluZyBpdHMgaWQsXG4gICAgICogdHlwZSwgaW5wdXQsIG91dHB1dCwgZXJyb3IsIHN0YXJ0VGltZSwgZW5kVGltZSwgYW5kIGFueSB0YWdzIG9yIG1ldGFkYXRhXG4gICAgICogYWRkZWQgdG8gdGhlIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uU3RhcnQgLSBDYWxsZWQgYmVmb3JlIHRoZSBydW5uYWJsZSBzdGFydHMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRW5kIC0gQ2FsbGVkIGFmdGVyIHRoZSBydW5uYWJsZSBmaW5pc2hlcyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FcnJvciAtIENhbGxlZCBpZiB0aGUgcnVubmFibGUgdGhyb3dzIGFuIGVycm9yLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHdpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciwgfSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVFYWNoID0gUnVubmFibGVFYWNoO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW5uYWJsZXMgdGhhdCBjYW4gYmUgcmV0cmllZCBhXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVJldHJ5LFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIC8vIFNpbXVsYXRlIGFuIEFQSSBjYWxsIHRoYXQgZmFpbHNcbiAqIGNvbnN0IHNpbXVsYXRlQXBpQ2FsbCA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgQVBJIGNhbGwgd2l0aCBpbnB1dDogJHtpbnB1dH1gKTtcbiAqICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGNhbGwgZmFpbGVkIGR1ZSB0byBuZXR3b3JrIGlzc3VlXCIpO1xuICogfTtcbiAqXG4gKiBjb25zdCBhcGlDYWxsTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShzaW11bGF0ZUFwaUNhbGwpO1xuICpcbiAqIC8vIEFwcGx5IHJldHJ5IGxvZ2ljIHVzaW5nIHRoZSAud2l0aFJldHJ5KCkgbWV0aG9kXG4gKiBjb25zdCBhcGlDYWxsV2l0aFJldHJ5ID0gYXBpQ2FsbExhbWJkYS53aXRoUmV0cnkoeyBzdG9wQWZ0ZXJBdHRlbXB0OiAzIH0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlUmV0cnkgaW5zdGFuY2UgbWFudWFsbHlcbiAqIGNvbnN0IG1hbnVhbFJldHJ5ID0gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICogICBib3VuZDogYXBpQ2FsbExhbWJkYSxcbiAqICAgbWF4QXR0ZW1wdE51bWJlcjogMyxcbiAqICAgY29uZmlnOiB7fSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyB0aGUgLndpdGhSZXRyeSgpIG1ldGhvZFxuICogY29uc3QgcmVzID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeVxuICogICAuaW52b2tlKFwiUmVxdWVzdCAxXCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIG11bHRpcGxlIHJldHJpZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgdGhlIG1hbnVhbCByZXRyeSBpbnN0YW5jZVxuICogY29uc3QgcmVzMiA9IGF3YWl0IG1hbnVhbFJldHJ5XG4gKiAgIC5pbnZva2UoXCJSZXF1ZXN0IDJcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllczpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlUmV0cnkgZXh0ZW5kcyBSdW5uYWJsZUJpbmRpbmcge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVJldHJ5XCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhBdHRlbXB0TnVtYmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHsgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhBdHRlbXB0TnVtYmVyID0gZmllbGRzLm1heEF0dGVtcHROdW1iZXIgPz8gdGhpcy5tYXhBdHRlbXB0TnVtYmVyO1xuICAgICAgICB0aGlzLm9uRmFpbGVkQXR0ZW1wdCA9IGZpZWxkcy5vbkZhaWxlZEF0dGVtcHQgPz8gdGhpcy5vbkZhaWxlZEF0dGVtcHQ7XG4gICAgfVxuICAgIF9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB0YWcgPSBhdHRlbXB0ID4gMSA/IGByZXRyeTphdHRlbXB0OiR7YXR0ZW1wdH1gIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0YWcpIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwX3JldHJ5XzEuZGVmYXVsdCkoKGF0dGVtcHROdW1iZXIpID0+IHN1cGVyLmludm9rZShpbnB1dCwgdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWcsIHJ1bk1hbmFnZXIpKSwge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgaW5wdXQpLFxuICAgICAgICAgICAgcmV0cmllczogTWF0aC5tYXgodGhpcy5tYXhBdHRlbXB0TnVtYmVyIC0gMSwgMCksXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBpbnZva2VzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5wdXQsIHJ1biBtYW5hZ2VyLFxuICAgICAqIGFuZCBjb25maWcuIEl0IGhhbmRsZXMgdGhlIHJldHJ5IGxvZ2ljIGJ5IGNhdGNoaW5nIGFueSBlcnJvcnMgYW5kXG4gICAgICogcmVjdXJzaXZlbHkgaW52b2tpbmcgaXRzZWxmIHdpdGggdGhlIHVwZGF0ZWQgY29uZmlnIGZvciB0aGUgbmV4dCByZXRyeVxuICAgICAqIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBydW5NYW5hZ2VyIFRoZSBydW4gbWFuYWdlciBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZyBmb3IgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UuYmluZCh0aGlzKSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIF9iYXRjaChpbnB1dHMsIGNvbmZpZ3MsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0c01hcCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgKDAsIHBfcmV0cnlfMS5kZWZhdWx0KShhc3luYyAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0luZGV4ZXMgPSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gaSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaSkgPT4gcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXRzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZENvbmZpZ3MgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWdzPy5baV0sIHJ1bk1hbmFnZXJzPy5baV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuYmF0Y2gocmVtYWluaW5nSW5wdXRzLCBwYXRjaGVkQ29uZmlncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5iYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkV4Y2VwdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRNYXBJbmRleCA9IHJlbWFpbmluZ0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24uaW5wdXQgPSByZW1haW5pbmdJbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtyZXN1bHRNYXBJbmRleC50b1N0cmluZygpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgZXJyb3IuaW5wdXQpLFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0c01hcClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCkpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHJlc3VsdHNNYXBbcGFyc2VJbnQoa2V5LCAxMCldKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVJldHJ5ID0gUnVubmFibGVSZXRyeTtcbi8qKlxuICogQSBzZXF1ZW5jZSBvZiBydW5uYWJsZXMsIHdoZXJlIHRoZSBvdXRwdXQgb2YgZWFjaCBpcyB0aGUgaW5wdXQgb2YgdGhlIG5leHQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0VGVtcGxhdGUgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXG4gKiAgIFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiLFxuICogKTtcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtwcm9tcHRUZW1wbGF0ZSwgbmV3IENoYXRPcGVuQUkoeyBtb2RlbDogXCJncHQtNG8tbWluaVwiIH0pXSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyc1wiIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlU2VxdWVuY2UgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlU2VxdWVuY2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib21pdFNlcXVlbmNlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpZWxkcy5maXJzdDtcbiAgICAgICAgdGhpcy5taWRkbGUgPSBmaWVsZHMubWlkZGxlID8/IHRoaXMubWlkZGxlO1xuICAgICAgICB0aGlzLmxhc3QgPSBmaWVsZHMubGFzdDtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMub21pdFNlcXVlbmNlVGFncyA9IGZpZWxkcy5vbWl0U2VxdWVuY2VUYWdzID8/IHRoaXMub21pdFNlcXVlbmNlVGFncztcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIGxldCBuZXh0U3RlcElucHV0ID0gaW5wdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxTdGVwcyA9IFt0aGlzLmZpcnN0LCAuLi50aGlzLm1pZGRsZV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRpYWxTdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBpbml0aWFsU3RlcHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0ZXAuaW52b2tlKG5leHRTdGVwSW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXQgPSBhd2FpdCAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGNhbid0IGRldGVjdCB0aGF0IHRoZSBsYXN0IG91dHB1dCBvZiB0aGUgc2VxdWVuY2UgcmV0dXJucyBSdW5PdXRwdXQsIHNvIGNhbGwgaXQgb3V0IG9mIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBhd2FpdCB0aGlzLmxhc3QuaW52b2tlKG5leHRTdGVwSW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6JHt0aGlzLnN0ZXBzLmxlbmd0aH1gKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChmaW5hbE91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gZmluYWxPdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKGFzeW5jIChjYWxsYmFja01hbmFnZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0UmVzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCBjb25maWdMaXN0W2ldLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWdMaXN0W2ldLnJ1bk5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuc3RlcHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0ZXAuYmF0Y2gobmV4dFN0ZXBJbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJ1bk1hbmFnZXIgPSBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6JHtpICsgMX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnTGlzdFtqXSwgeyBjYWxsYmFja3M6IGNoaWxkUnVuTWFuYWdlciB9KTtcbiAgICAgICAgICAgICAgICB9KSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0cyA9IGF3YWl0ICgwLCBzaWduYWxfanNfMS5yYWNlV2l0aFNpZ25hbCkocHJvbWlzZSwgY29uZmlnTGlzdFswXT8uc2lnbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChuZXh0U3RlcElucHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBuZXh0U3RlcElucHV0cztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Ll9jb25jYXRPdXRwdXRDaHVua3MoZmlyc3QsIHNlY29uZCk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlck9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFt0aGlzLmZpcnN0LCAuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XTtcbiAgICAgICAgbGV0IGNvbmNhdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGlucHV0R2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmaW5hbEdlbmVyYXRvciA9IHN0ZXBzWzBdLnRyYW5zZm9ybShpbnB1dEdlbmVyYXRvcigpLCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG90aGVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOjFgKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgICAgICAgICAgZmluYWxHZW5lcmF0b3IgPSBhd2FpdCBzdGVwLnRyYW5zZm9ybShmaW5hbEdlbmVyYXRvciwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShvdGhlck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZpbmFsR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChjb25jYXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgZ2V0R3JhcGgoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBoX2pzXzEuR3JhcGgoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGN1cnJlbnRMYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBHcmFwaCA9IHN0ZXAuZ2V0R3JhcGgoY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltRmlyc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0ZXBHcmFwaC50cmltTGFzdE5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoLmV4dGVuZChzdGVwR3JhcGgpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcEZpcnN0Tm9kZSA9IHN0ZXBHcmFwaC5maXJzdE5vZGUoKTtcbiAgICAgICAgICAgIGlmICghc3RlcEZpcnN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVubmFibGUgJHtzdGVwfSBoYXMgbm8gZmlyc3Qgbm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2UoY3VycmVudExhc3ROb2RlLCBzdGVwRmlyc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYXN0Tm9kZSA9IHN0ZXBHcmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgaWYgKFJ1bm5hYmxlU2VxdWVuY2UuaXNSdW5uYWJsZVNlcXVlbmNlKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0OiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgICAgIG1pZGRsZTogdGhpcy5taWRkbGUuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0LFxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VhYmxlLmZpcnN0LFxuICAgICAgICAgICAgICAgICAgICAuLi5jb2VyY2VhYmxlLm1pZGRsZSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBsYXN0OiBjb2VyY2VhYmxlLmxhc3QsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lID8/IGNvZXJjZWFibGUubmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IFsuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XSxcbiAgICAgICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1J1bm5hYmxlU2VxdWVuY2UodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcubWlkZGxlKSAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKHRoaW5nKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZnJvbShbZmlyc3QsIC4uLnJ1bm5hYmxlc10sIG5hbWVPckZpZWxkcykge1xuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JGaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV4dHJhLm5hbWUgPSBuYW1lT3JGaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZU9yRmllbGRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4dHJhID0gbmFtZU9yRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgICAgIGZpcnN0OiBfY29lcmNlVG9SdW5uYWJsZShmaXJzdCksXG4gICAgICAgICAgICBtaWRkbGU6IHJ1bm5hYmxlcy5zbGljZSgwLCAtMSkubWFwKF9jb2VyY2VUb1J1bm5hYmxlKSxcbiAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKHJ1bm5hYmxlc1tydW5uYWJsZXMubGVuZ3RoIC0gMV0pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlU2VxdWVuY2UgPSBSdW5uYWJsZVNlcXVlbmNlO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIG1hcHBpbmcgb2YgcnVubmFibGVzIGluIHBhcmFsbGVsLFxuICogYW5kIHJldHVybnMgYSBtYXBwaW5nIG9mIHRoZWlyIG91dHB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbWFwQ2hhaW4gPSBSdW5uYWJsZU1hcC5mcm9tKHtcbiAqICAgam9rZTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqICAgcG9lbTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwid3JpdGUgYSAyLWxpbmUgcG9lbSBhYm91dCB7dG9waWN9XCIpLnBpcGUoXG4gKiAgICAgbmV3IENoYXRBbnRocm9waWMoe30pLFxuICogICApLFxuICogfSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBtYXBDaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyXCIgfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVNYXAgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTWFwXCI7XG4gICAgfVxuICAgIGdldFN0ZXBzS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RlcHMpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0ZXBzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkcy5zdGVwcykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHsgc3RlcHMgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICB9LCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0ZXBzKS5tYXAoYXN5bmMgKFtrZXksIHJ1bm5hYmxlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKShQcm9taXNlLmFsbChwcm9taXNlcyksIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgb3B0aW9ucykge1xuICAgICAgICAvLyBzaGFsbG93IGNvcHkgc3RlcHMgdG8gaWdub3JlIGNoYW5nZXMgd2hpbGUgaXRlcmF0aW5nXG4gICAgICAgIGNvbnN0IHN0ZXBzID0geyAuLi50aGlzLnN0ZXBzIH07XG4gICAgICAgIC8vIGVhY2ggc3RlcCBnZXRzIGEgY29weSBvZiB0aGUgaW5wdXQgaXRlcmF0b3JcbiAgICAgICAgY29uc3QgaW5wdXRDb3BpZXMgPSAoMCwgc3RyZWFtX2pzXzEuYXRlZSkoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYG1hcDprZXk6JHtrZXl9YCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgZ2VuLm5leHQoKS50aGVuKChyZXN1bHQpID0+ICh7IGtleSwgZ2VuLCByZXN1bHQgfSkpXTtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB5aWVsZCBjaHVua3MgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlLFxuICAgICAgICAvLyBzdGFydGluZyBuZXcgaXRlcmF0aW9ucyBhcyBuZWVkZWQsXG4gICAgICAgIC8vIHVudGlsIGFsbCBpdGVyYXRvcnMgYXJlIGRvbmVcbiAgICAgICAgd2hpbGUgKHRhc2tzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJhY2UodGFza3MudmFsdWVzKCkpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHJlc3VsdCwgZ2VuIH0gPSBhd2FpdCAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIG9wdGlvbnM/LnNpZ25hbCk7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IFtrZXldOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0YXNrcy5zZXQoa2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgc3RyZWFtX2pzXzEuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlTWFwID0gUnVubmFibGVNYXA7XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhIHRyYWNlZCBMYW5nU21pdGggZnVuY3Rpb24uXG4gKi9cbmNsYXNzIFJ1bm5hYmxlVHJhY2VhYmxlIGV4dGVuZHMgUnVubmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghKDAsIHRyYWNlYWJsZV8xLmlzVHJhY2VhYmxlRnVuY3Rpb24pKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVubmFibGVUcmFjZWFibGUgcmVxdWlyZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWddID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgMSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmZ1bmMoKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHsgY2FsbGJhY2tzIH0pLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiAoMCwgc2lnbmFsX2pzXzEucmFjZVdpdGhTaWduYWwpKHByb21pc2UsIGNvbmZpZz8uc2lnbmFsKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbY29uZmlnXSA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIDEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICgoMCwgaXRlcl9qc18xLmlzQXN5bmNJdGVyYWJsZSkocmVzdWx0KSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpdGVyX2pzXzEuaXNJdGVyYXRvcikocmVzdWx0KSkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHJlc3VsdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVHJhY2VhYmxlKHsgZnVuYyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlVHJhY2VhYmxlID0gUnVubmFibGVUcmFjZWFibGU7XG5mdW5jdGlvbiBhc3NlcnROb25UcmFjZWFibGVGdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKCgwLCB0cmFjZWFibGVfMS5pc1RyYWNlYWJsZUZ1bmN0aW9uKShmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUxhbWJkYSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvbi4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgYWRkID0gKGlucHV0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pID0+IGlucHV0LnggKyBpbnB1dC55O1xuICpcbiAqIGNvbnN0IG11bHRpcGx5ID0gKGlucHV0OiB7IHZhbHVlOiBudW1iZXI7IG11bHRpcGxpZXI6IG51bWJlciB9KSA9PlxuICogICBpbnB1dC52YWx1ZSAqIGlucHV0Lm11bHRpcGxpZXI7XG4gKlxuICogLy8gQ3JlYXRlIHJ1bm5hYmxlcyBmb3IgdGhlIGZ1bmN0aW9uc1xuICogY29uc3QgYWRkTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGQpO1xuICogY29uc3QgbXVsdGlwbHlMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKG11bHRpcGx5KTtcbiAqXG4gKiAvLyBDaGFpbiB0aGUgbGFtYmRhcyBmb3IgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uXG4gKiBjb25zdCBjaGFpbmVkTGFtYmRhID0gYWRkTGFtYmRhLnBpcGUoKHJlc3VsdCkgPT5cbiAqICAgbXVsdGlwbHlMYW1iZGEuaW52b2tlKHsgdmFsdWU6IHJlc3VsdCwgbXVsdGlwbGllcjogMiB9KVxuICogKTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gb2YgdGhlIGNoYWluZWRMYW1iZGFcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluZWRMYW1iZGEuaW52b2tlKHsgeDogMiwgeTogMyB9KTtcbiAqXG4gKiAvLyBXaWxsIGxvZyBcIjEwXCIgKHNpbmNlICgyICsgMykgKiAyID0gMTApXG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVMYW1iZGEgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTGFtYmRhXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBpZiAoKDAsIHRyYWNlYWJsZV8xLmlzVHJhY2VhYmxlRnVuY3Rpb24pKGZpZWxkcy5mdW5jKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIFJ1bm5hYmxlVHJhY2VhYmxlLmZyb20oZmllbGRzLmZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0Tm9uVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZnVuYykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHtcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfaW52b2tlKGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoKDAsIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMpKGNoaWxkQ29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgb3V0cHV0Lmludm9rZShpbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAoY2hpbGRDb25maWcucmVjdXJzaW9uTGltaXQgPz8gY29uZmlnX2pzXzEuREVGQVVMVF9SRUNVUlNJT05fTElNSVQpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBpdGVyX2pzXzEuaXNBc3luY0l0ZXJhYmxlKShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mICgwLCBpdGVyX2pzXzEuY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQpKGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdGhpcy5fY29uY2F0T3V0cHV0Q2h1bmtzKGZpbmFsT3V0cHV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgaXRlcl9qc18xLmlzSXRlcmFibGVJdGVyYXRvcikob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiAoMCwgaXRlcl9qc18xLmNvbnN1bWVJdGVyYXRvckluQ29udGV4dCkoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3MoZmluYWxPdXRwdXQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9pbnZva2UuYmluZCh0aGlzKSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIGNvbmZpZykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IHRoaXMuX2NvbmNhdE91dHB1dENodW5rcyhmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IGNvbmZpZ19qc18xLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKCgwLCBjb25maWdfanNfMS5waWNrUnVubmFibGVDb25maWdLZXlzKShjaGlsZENvbmZpZyksIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZ1bmMoZmluYWxDaHVuaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0cHV0ICYmIFJ1bm5hYmxlLmlzUnVubmFibGUob3V0cHV0KSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZz8ucmVjdXJzaW9uTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWN1cnNpb24gbGltaXQgcmVhY2hlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBvdXRwdXQuc3RyZWFtKGZpbmFsQ2h1bmssIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGl0ZXJfanNfMS5pc0FzeW5jSXRlcmFibGUpKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgKDAsIGl0ZXJfanNfMS5jb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCkoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgaXRlcl9qc18xLmlzSXRlcmFibGVJdGVyYXRvcikob3V0cHV0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiAoMCwgaXRlcl9qc18xLmNvbnN1bWVJdGVyYXRvckluQ29udGV4dCkoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZUxhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhO1xuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIG1hcHBpbmcgb2YgcnVubmFibGVzIGluIHBhcmFsbGVsLFxuICogYW5kIHJldHVybnMgYSBtYXBwaW5nIG9mIHRoZWlyIG91dHB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlUGFyYWxsZWwsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgYWRkWWVhcnMgPSAoYWdlOiBudW1iZXIpOiBudW1iZXIgPT4gYWdlICsgNTtcbiAqIGNvbnN0IHllYXJzVG9GaWZ0eSA9IChhZ2U6IG51bWJlcik6IG51bWJlciA9PiA1MCAtIGFnZTtcbiAqIGNvbnN0IHllYXJzVG9IdW5kcmVkID0gKGFnZTogbnVtYmVyKTogbnVtYmVyID0+IDEwMCAtIGFnZTtcbiAqXG4gKiBjb25zdCBhZGRZZWFyc0xhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYWRkWWVhcnMpO1xuICogY29uc3QgbWlsZXN0b25lRmlmdHlMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHllYXJzVG9GaWZ0eSk7XG4gKiBjb25zdCBtaWxlc3RvbmVIdW5kcmVkTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbSh5ZWFyc1RvSHVuZHJlZCk7XG4gKlxuICogLy8gUGlwZSB3aWxsIGNvZXJjZSBvYmplY3RzIGludG8gUnVubmFibGVQYXJhbGxlbCBieSBkZWZhdWx0LCBidXQgd2VcbiAqIC8vIGV4cGxpY2l0bHkgaW5zdGFudGlhdGUgb25lIGhlcmUgdG8gZGVtb25zdHJhdGVcbiAqIGNvbnN0IHNlcXVlbmNlID0gYWRkWWVhcnNMYW1iZGEucGlwZShcbiAqICAgUnVubmFibGVQYXJhbGxlbC5mcm9tKHtcbiAqICAgICB5ZWFyc190b19maWZ0eTogbWlsZXN0b25lRmlmdHlMYW1iZGEsXG4gKiAgICAgeWVhcnNfdG9faHVuZHJlZDogbWlsZXN0b25lSHVuZHJlZExhbWJkYSxcbiAqICAgfSlcbiAqICk7XG4gKlxuICogLy8gSW52b2tlIHRoZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIGFnZSBpbnB1dFxuICogY29uc3QgcmVzID0gYXdhaXQgc2VxdWVuY2UuaW52b2tlKDI1KTtcbiAqXG4gKiAvLyB7IHllYXJzX3RvX2ZpZnR5OiAyMCwgeWVhcnNfdG9faHVuZHJlZDogNzAgfVxuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlUGFyYWxsZWwgZXh0ZW5kcyBSdW5uYWJsZU1hcCB7XG59XG5leHBvcnRzLlJ1bm5hYmxlUGFyYWxsZWwgPSBSdW5uYWJsZVBhcmFsbGVsO1xuLyoqXG4gKiBBIFJ1bm5hYmxlIHRoYXQgY2FuIGZhbGxiYWNrIHRvIG90aGVyIFJ1bm5hYmxlcyBpZiBpdCBmYWlscy5cbiAqIEV4dGVybmFsIEFQSXMgKGUuZy4sIEFQSXMgZm9yIGEgbGFuZ3VhZ2UgbW9kZWwpIG1heSBhdCB0aW1lcyBleHBlcmllbmNlXG4gKiBkZWdyYWRlZCBwZXJmb3JtYW5jZSBvciBldmVuIGRvd250aW1lLlxuICpcbiAqIEluIHRoZXNlIGNhc2VzLCBpdCBjYW4gYmUgdXNlZnVsIHRvIGhhdmUgYSBmYWxsYmFjayBSdW5uYWJsZSB0aGF0IGNhbiBiZVxuICogdXNlZCBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgUnVubmFibGUgKGUuZy4sIGZhbGxiYWNrIHRvIGFub3RoZXIgTExNIHByb3ZpZGVyKS5cbiAqXG4gKiBGYWxsYmFja3MgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGxldmVsIG9mIGEgc2luZ2xlIFJ1bm5hYmxlLCBvciBhdCB0aGUgbGV2ZWxcbiAqIG9mIGEgY2hhaW4gb2YgUnVubmFibGVzLiBGYWxsYmFja3MgYXJlIHRyaWVkIGluIG9yZGVyIHVudGlsIG9uZSBzdWNjZWVkcyBvclxuICogYWxsIGZhaWwuXG4gKlxuICogV2hpbGUgeW91IGNhbiBpbnN0YW50aWF0ZSBhIGBSdW5uYWJsZVdpdGhGYWxsYmFja3NgIGRpcmVjdGx5LCBpdCBpcyB1c3VhbGx5XG4gKiBtb3JlIGNvbnZlbmllbnQgdG8gdXNlIHRoZSBgd2l0aEZhbGxiYWNrc2AgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIFJ1bm5hYmxlLlxuICpcbiAqIFdoZW4gc3RyZWFtaW5nLCBmYWxsYmFja3Mgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbiBmYWlsdXJlcyBkdXJpbmcgdGhlIGluaXRpYWxcbiAqIHN0cmVhbSBjcmVhdGlvbi4gRXJyb3JzIHRoYXQgb2NjdXIgYWZ0ZXIgYSBzdHJlYW0gc3RhcnRzIHdpbGwgbm90IGZhbGxiYWNrXG4gKiB0byB0aGUgbmV4dCBSdW5uYWJsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiAgIFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBwcmltYXJ5T3BlcmF0aW9uID0gKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICogICBpZiAoaW5wdXQgIT09IFwic2FmZVwiKSB7XG4gKiAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpbWFyeSBvcGVyYXRpb24gZmFpbGVkIGR1ZSB0byB1bnNhZmUgaW5wdXRcIik7XG4gKiAgIH1cbiAqICAgcmV0dXJuIGBQcm9jZXNzZWQ6ICR7aW5wdXR9YDtcbiAqIH07XG4gKlxuICogLy8gRGVmaW5lIGEgZmFsbGJhY2sgb3BlcmF0aW9uIHRoYXQgcHJvY2Vzc2VzIHRoZSBpbnB1dCBkaWZmZXJlbnRseVxuICogY29uc3QgZmFsbGJhY2tPcGVyYXRpb24gPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PlxuICogICBgRmFsbGJhY2sgcHJvY2Vzc2VkOiAke2lucHV0fWA7XG4gKlxuICogY29uc3QgcHJpbWFyeVJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShwcmltYXJ5T3BlcmF0aW9uKTtcbiAqIGNvbnN0IGZhbGxiYWNrUnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGZhbGxiYWNrT3BlcmF0aW9uKTtcbiAqXG4gKiAvLyBBcHBseSB0aGUgZmFsbGJhY2sgbG9naWMgdXNpbmcgdGhlIC53aXRoRmFsbGJhY2tzKCkgbWV0aG9kXG4gKiBjb25zdCBydW5uYWJsZVdpdGhGYWxsYmFjayA9IHByaW1hcnlSdW5uYWJsZS53aXRoRmFsbGJhY2tzKFtmYWxsYmFja1J1bm5hYmxlXSk7XG4gKlxuICogLy8gQWx0ZXJuYXRpdmVseSwgY3JlYXRlIGEgUnVubmFibGVXaXRoRmFsbGJhY2tzIGluc3RhbmNlIG1hbnVhbGx5XG4gKiBjb25zdCBtYW51YWxGYWxsYmFja0NoYWluID0gbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcyh7XG4gKiAgIHJ1bm5hYmxlOiBwcmltYXJ5UnVubmFibGUsXG4gKiAgIGZhbGxiYWNrczogW2ZhbGxiYWNrUnVubmFibGVdLFxuICogfSk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIHVzaW5nIC53aXRoRmFsbGJhY2tzKClcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IHJ1bm5hYmxlV2l0aEZhbGxiYWNrXG4gKiAgIC5pbnZva2UoXCJ1bnNhZmUgaW5wdXRcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgYWxsIGF0dGVtcHRzOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgfSk7XG4gKlxuICogLy8gXCJGYWxsYmFjayBwcm9jZXNzZWQ6IHVuc2FmZSBpbnB1dFwiXG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uIHVzaW5nIG1hbnVhbCBpbnN0YW50aWF0aW9uXG4gKiBjb25zdCByZXMgPSBhd2FpdCBtYW51YWxGYWxsYmFja0NoYWluXG4gKiAgIC5pbnZva2UoXCJzYWZlXCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIGFsbCBhdHRlbXB0czpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICpcbiAqIC8vIFwiUHJvY2Vzc2VkOiBzYWZlXCJcbiAqIGBgYFxuICovXG5jbGFzcyBSdW5uYWJsZVdpdGhGYWxsYmFja3MgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5mYWxsYmFja3MgPSBmaWVsZHMuZmFsbGJhY2tzO1xuICAgIH1cbiAgICAqcnVubmFibGVzKCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJ1bm5hYmxlO1xuICAgICAgICBmb3IgKGNvbnN0IGZhbGxiYWNrIG9mIHRoaXMuZmFsbGJhY2tzKSB7XG4gICAgICAgICAgICB5aWVsZCBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCB7IHJ1bklkLCAuLi5vdGhlckNvbmZpZ0ZpZWxkcyB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJDb25maWdGaWVsZHM/LnJ1bk5hbWUpO1xuICAgICAgICBjb25zdCBjaGlsZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3RoZXJDb25maWdGaWVsZHMsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKGNoaWxkQ29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZShpbnB1dCwgY2hpbGRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgY29uZmlnX2pzXzEuZW5zdXJlQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyQ29uZmlnRmllbGRzIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlckNvbmZpZ0ZpZWxkcz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKG90aGVyQ29uZmlnRmllbGRzLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RyZWFtID0gYXdhaXQgcnVubmFibGUuc3RyZWFtKGlucHV0LCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0gKDAsIGl0ZXJfanNfMS5jb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCkoY2hpbGRDb25maWcsIG9yaWdpbmFsU3RyZWFtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGZpcnN0RXJyb3IgPz8gbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jb25jYXRPdXRwdXRDaHVua3Mob3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoKGNvbmZpZykgPT4gKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykoY29uZmlnKSkpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKGFzeW5jIChjYWxsYmFja01hbmFnZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0UmVzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCBjb25maWdMaXN0W2ldLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWdMaXN0W2ldLnJ1bk5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgY29uZmlnTGlzdFswXS5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCBydW5uYWJsZS5iYXRjaChpbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWdMaXN0W2pdLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgICAgICB9KSksIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dHNbaV0sIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpcnN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2tzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcikpKTtcbiAgICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlV2l0aEZhbGxiYWNrcyA9IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcztcbi8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IHRoZSBjb21waWxlciBuZWVkcyBoZWxwIGVsaW1pbmF0aW5nIEVycm9yIGFzIGEgUnVuT3V0cHV0IHR5cGVcbmZ1bmN0aW9uIF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpIHtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHsgZnVuYzogY29lcmNlYWJsZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoUnVubmFibGUuaXNSdW5uYWJsZShjb2VyY2VhYmxlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlYWJsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29lcmNlYWJsZSkgJiYgdHlwZW9mIGNvZXJjZWFibGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICBydW5uYWJsZXNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHtcbiAgICAgICAgICAgIHN0ZXBzOiBydW5uYWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIFJ1bm5hYmxlLCBmdW5jdGlvbiBvciBvYmplY3QuXFxuSW5zdGVhZCBnb3QgYW4gdW5zdXBwb3J0ZWQgdHlwZS5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlQXNzaWduLFxuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqICAgUnVubmFibGVQYXJhbGxlbCxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBjYWxjdWxhdGVBZ2UgPSAoeDogeyBiaXJ0aFllYXI6IG51bWJlciB9KTogeyBhZ2U6IG51bWJlciB9ID0+IHtcbiAqICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gKiAgIHJldHVybiB7IGFnZTogY3VycmVudFllYXIgLSB4LmJpcnRoWWVhciB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBjcmVhdGVHcmVldGluZyA9ICh4OiB7IG5hbWU6IHN0cmluZyB9KTogeyBncmVldGluZzogc3RyaW5nIH0gPT4ge1xuICogICByZXR1cm4geyBncmVldGluZzogYEhlbGxvLCAke3gubmFtZX0hYCB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBtYXBwZXIgPSBSdW5uYWJsZVBhcmFsbGVsLmZyb20oe1xuICogICBhZ2Vfc3RlcDogUnVubmFibGVMYW1iZGEuZnJvbShjYWxjdWxhdGVBZ2UpLFxuICogICBncmVldGluZ19zdGVwOiBSdW5uYWJsZUxhbWJkYS5mcm9tKGNyZWF0ZUdyZWV0aW5nKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlQXNzaWduID0gbmV3IFJ1bm5hYmxlQXNzaWduKHsgbWFwcGVyIH0pO1xuICpcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IHJ1bm5hYmxlQXNzaWduLmludm9rZSh7IG5hbWU6IFwiQWxpY2VcIiwgYmlydGhZZWFyOiAxOTkwIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJBbGljZVwiLCBiaXJ0aFllYXI6IDE5OTAsIGFnZV9zdGVwOiB7IGFnZTogMzQgfSwgZ3JlZXRpbmdfc3RlcDogeyBncmVldGluZzogXCJIZWxsbywgQWxpY2UhXCIgfSB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVBc3NpZ24gZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQXNzaWduXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBSdW5uYWJsZU1hcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IG1hcHBlcjogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBwZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBmaWVsZHMubWFwcGVyO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5tYXBwZXIuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlucHV0LFxuICAgICAgICAgICAgLi4ubWFwcGVyUmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29sbGVjdCBtYXBwZXIga2V5c1xuICAgICAgICBjb25zdCBtYXBwZXJLZXlzID0gdGhpcy5tYXBwZXIuZ2V0U3RlcHNLZXlzKCk7XG4gICAgICAgIC8vIGNyZWF0ZSB0d28gaW5wdXQgZ2Vucywgb25lIGZvciB0aGUgbWFwcGVyLCBvbmUgZm9yIHRoZSBpbnB1dFxuICAgICAgICBjb25zdCBbZm9yUGFzc3Rocm91Z2gsIGZvck1hcHBlcl0gPSAoMCwgc3RyZWFtX2pzXzEuYXRlZSkoZ2VuZXJhdG9yKTtcbiAgICAgICAgLy8gY3JlYXRlIG1hcHBlciBvdXRwdXQgZ2VuXG4gICAgICAgIGNvbnN0IG1hcHBlck91dHB1dCA9IHRoaXMubWFwcGVyLnRyYW5zZm9ybShmb3JNYXBwZXIsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykob3B0aW9ucywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCkgfSkpO1xuICAgICAgICAvLyBzdGFydCB0aGUgbWFwcGVyXG4gICAgICAgIGNvbnN0IGZpcnN0TWFwcGVyQ2h1bmtQcm9taXNlID0gbWFwcGVyT3V0cHV0Lm5leHQoKTtcbiAgICAgICAgLy8geWllbGQgdGhlIHBhc3N0aHJvdWdoXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZm9yUGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5hYmxlQXNzaWduIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBvYmplY3RzIGFzIGlucHV0LCBnb3QgJHt0eXBlb2YgY2h1bmt9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaHVuaykuZmlsdGVyKChba2V5XSkgPT4gIW1hcHBlcktleXMuaW5jbHVkZXMoa2V5KSkpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbHRlcmVkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZmlsdGVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geWllbGQgdGhlIG1hcHBlciBvdXRwdXRcbiAgICAgICAgeWllbGQgKGF3YWl0IGZpcnN0TWFwcGVyQ2h1bmtQcm9taXNlKS52YWx1ZTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBtYXBwZXJPdXRwdXQpIHtcbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgc3RyZWFtX2pzXzEuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBzdHJlYW1fanNfMS5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlQXNzaWduID0gUnVubmFibGVBc3NpZ247XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICogVXNlZnVsIGZvciBzdHJlYW1pbmcsIGNhbiBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYW5kIGNoYWluZWQgYnkgY2FsbGluZyBgcnVubmFibGUucGljaygpO2AuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUnVubmFibGVQaWNrIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBpbnB1dERhdGEgPSB7XG4gKiAgIG5hbWU6IFwiSm9oblwiLFxuICogICBhZ2U6IDMwLFxuICogICBjaXR5OiBcIk5ldyBZb3JrXCIsXG4gKiAgIGNvdW50cnk6IFwiVVNBXCIsXG4gKiAgIGVtYWlsOiBcImpvaG4uZG9lQGV4YW1wbGUuY29tXCIsXG4gKiAgIHBob25lOiBcIisxMjM0NTY3ODkwXCIsXG4gKiB9O1xuICpcbiAqIGNvbnN0IGJhc2ljSW5mb1J1bm5hYmxlID0gbmV3IFJ1bm5hYmxlUGljayhbXCJuYW1lXCIsIFwiY2l0eVwiXSk7XG4gKlxuICogLy8gRXhhbXBsZSBpbnZvY2F0aW9uXG4gKiBjb25zdCByZXMgPSBhd2FpdCBiYXNpY0luZm9SdW5uYWJsZS5pbnZva2UoaW5wdXREYXRhKTtcbiAqXG4gKiAvLyB7IG5hbWU6ICdKb2huJywgY2l0eTogJ05ldyBZb3JrJyB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUnVubmFibGVQaWNrIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBpY2tcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGtleXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleXMgPSBmaWVsZHMua2V5cztcbiAgICB9XG4gICAgYXN5bmMgX3BpY2soaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFt0aGlzLmtleXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gdGhpcy5rZXlzXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBba2V5LCBpbnB1dFtrZXldXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2WzFdICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBpY2tlZC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmZyb21FbnRyaWVzKHBpY2tlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyh0aGlzLl9waWNrLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWQgPSBhd2FpdCB0aGlzLl9waWNrKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChwaWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHBpY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TdHJlYW1XaXRoQ29uZmlnKGdlbmVyYXRvciwgdGhpcy5fdHJhbnNmb3JtLmJpbmQodGhpcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IHN0cmVhbV9qc18xLkFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uYWJsZVBpY2sgPSBSdW5uYWJsZVBpY2s7XG5jbGFzcyBSdW5uYWJsZVRvb2xMaWtlIGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAgICAgICAgUnVubmFibGVMYW1iZGEuZnJvbShhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbElucHV0O1xuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMi5faXNUb29sQ2FsbCkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQgPSBhd2FpdCAoMCwgem9kX2pzXzEuaW50ZXJvcFBhcnNlQXN5bmMpKHRoaXMuc2NoZW1hLCBpbnB1dC5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHV0aWxzX2pzXzIuVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbihgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWAsIEpTT04uc3RyaW5naWZ5KGlucHV0LmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b29sSW5wdXQ7XG4gICAgICAgICAgICB9KS53aXRoQ29uZmlnKHsgcnVuTmFtZTogYCR7ZmllbGRzLm5hbWV9OnBhcnNlX2lucHV0YCB9KSxcbiAgICAgICAgICAgIGZpZWxkcy5ib3VuZCxcbiAgICAgICAgXSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IGZpZWxkcy5uYW1lIH0pO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBib3VuZDogc2VxdWVuY2UsXG4gICAgICAgICAgICBjb25maWc6IGZpZWxkcy5jb25maWcgPz8ge30sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVUb29sTGlrZVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVubmFibGVUb29sTGlrZSA9IFJ1bm5hYmxlVG9vbExpa2U7XG4vKipcbiAqIEdpdmVuIGEgcnVubmFibGUgYW5kIGEgWm9kIHNjaGVtYSwgY29udmVydCB0aGUgcnVubmFibGUgdG8gYSB0b29sLlxuICpcbiAqIEB0ZW1wbGF0ZSBSdW5JbnB1dCBUaGUgaW5wdXQgdHlwZSBmb3IgdGhlIHJ1bm5hYmxlLlxuICogQHRlbXBsYXRlIFJ1bk91dHB1dCBUaGUgb3V0cHV0IHR5cGUgZm9yIHRoZSBydW5uYWJsZS5cbiAqXG4gKiBAcGFyYW0ge1J1bm5hYmxlPFJ1bklucHV0LCBSdW5PdXRwdXQ+fSBydW5uYWJsZSBUaGUgcnVubmFibGUgdG8gY29udmVydCB0byBhIHRvb2wuXG4gKiBAcGFyYW0gZmllbGRzXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGUgdG9vbC4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIHJ1bm5hYmxlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC4gRmFsbHMgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gb24gdGhlIFpvZCBzY2hlbWEgaWYgbm90IHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgbmVpdGhlciBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFJ1bklucHV0Pn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTxJbnRlcm9wWm9kVHlwZTxSdW5JbnB1dD4sIFJ1bk91dHB1dD59IEFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYCB3aGljaCBpcyBhIHJ1bm5hYmxlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSB0b29sLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0UnVubmFibGVUb1Rvb2wocnVubmFibGUsIGZpZWxkcykge1xuICAgIGNvbnN0IG5hbWUgPSBmaWVsZHMubmFtZSA/PyBydW5uYWJsZS5nZXROYW1lKCk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBmaWVsZHMuZGVzY3JpcHRpb24gPz8gKDAsIHpvZF9qc18xLmdldFNjaGVtYURlc2NyaXB0aW9uKShmaWVsZHMuc2NoZW1hKTtcbiAgICBpZiAoKDAsIHpvZF9qc18xLmlzU2ltcGxlU3RyaW5nWm9kU2NoZW1hKShmaWVsZHMuc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVG9vbExpa2Uoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2NoZW1hOiB2M18xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHsgaW5wdXQ6IHYzXzEuei5zdHJpbmcoKSB9KVxuICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKGlucHV0KSA9PiBpbnB1dC5pbnB1dCksXG4gICAgICAgICAgICBib3VuZDogcnVubmFibGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJ1bm5hYmxlVG9vbExpa2Uoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgc2NoZW1hOiBmaWVsZHMuc2NoZW1hLFxuICAgICAgICBib3VuZDogcnVubmFibGUsXG4gICAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/branch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableBranch = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnableBranch extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            (0, base_js_1._coerceToRunnable)(condition),\n            (0, base_js_1._coerceToRunnable)(runnable),\n        ]);\n        const defaultBranch = (0, base_js_1._coerceToRunnable)(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, (0, config_js_1.patchConfig)(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\nexports.RunnableBranch = RunnableBranch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2JyYW5jaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0EsNkRBQTZELE1BQU07QUFDbkUsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2JyYW5jaC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlQnJhbmNoID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBydW5uYWJsZSBicmFuY2guIFRoZSBSdW5uYWJsZUJyYW5jaCBpc1xuICogaW5pdGlhbGl6ZWQgd2l0aCBhbiBhcnJheSBvZiBicmFuY2hlcyBhbmQgYSBkZWZhdWx0IGJyYW5jaC4gV2hlbiBpbnZva2VkLFxuICogaXQgZXZhbHVhdGVzIHRoZSBjb25kaXRpb24gb2YgZWFjaCBicmFuY2ggaW4gb3JkZXIgYW5kIGV4ZWN1dGVzIHRoZVxuICogY29ycmVzcG9uZGluZyBicmFuY2ggaWYgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLiBJZiBub25lIG9mIHRoZSBjb25kaXRpb25zXG4gKiBhcmUgdHJ1ZSwgaXQgZXhlY3V0ZXMgdGhlIGRlZmF1bHQgYnJhbmNoLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoLmZyb20oW1xuICogICBbXG4gKiAgICAgKHg6IHsgdG9waWM6IHN0cmluZzsgcXVlc3Rpb246IHN0cmluZyB9KSA9PlxuICogICAgICAgeC50b3BpYy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYW50aHJvcGljXCIpLFxuICogICAgIGFudGhyb3BpY0NoYWluLFxuICogICBdLFxuICogICBbXG4gKiAgICAgKHg6IHsgdG9waWM6IHN0cmluZzsgcXVlc3Rpb246IHN0cmluZyB9KSA9PlxuICogICAgICAgeC50b3BpYy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibGFuZ2NoYWluXCIpLFxuICogICAgIGxhbmdDaGFpbkNoYWluLFxuICogICBdLFxuICogICBnZW5lcmFsQ2hhaW4sXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBmdWxsQ2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICogICB7XG4gKiAgICAgdG9waWM6IGNsYXNzaWZpY2F0aW9uQ2hhaW4sXG4gKiAgICAgcXVlc3Rpb246IChpbnB1dDogeyBxdWVzdGlvbjogc3RyaW5nIH0pID0+IGlucHV0LnF1ZXN0aW9uLFxuICogICB9LFxuICogICBicmFuY2gsXG4gKiBdKTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBmdWxsQ2hhaW4uaW52b2tlKHtcbiAqICAgcXVlc3Rpb246IFwiaG93IGRvIEkgdXNlIExhbmdDaGFpbj9cIixcbiAqIH0pO1xuICogYGBgXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBSdW5uYWJsZUJyYW5jaCBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQnJhbmNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnJhbmNoZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5icmFuY2hlcyA9IGZpZWxkcy5icmFuY2hlcztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gZmllbGRzLmRlZmF1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW5zdGFudGlhdGluZyBhIFJ1bm5hYmxlQnJhbmNoIGZyb21cbiAgICAgKiBSdW5uYWJsZUxpa2VzIChvYmplY3RzLCBmdW5jdGlvbnMsIG9yIFJ1bm5hYmxlcykuXG4gICAgICpcbiAgICAgKiBFYWNoIGl0ZW0gaW4gdGhlIGlucHV0IGV4Y2VwdCBmb3IgdGhlIGxhc3Qgb25lIHNob3VsZCBiZSBhXG4gICAgICogdHVwbGUgd2l0aCB0d28gaXRlbXMuIFRoZSBmaXJzdCBpcyBhIFwiY29uZGl0aW9uXCIgUnVubmFibGVMaWtlIHRoYXRcbiAgICAgKiByZXR1cm5zIFwidHJ1ZVwiIGlmIHRoZSBzZWNvbmQgUnVubmFibGVMaWtlIGluIHRoZSB0dXBsZSBzaG91bGQgcnVuLlxuICAgICAqXG4gICAgICogVGhlIGZpbmFsIGl0ZW0gaW4gdGhlIGlucHV0IHNob3VsZCBiZSBhIFJ1bm5hYmxlTGlrZSB0aGF0IGFjdHMgYXMgYVxuICAgICAqIGRlZmF1bHQgYnJhbmNoIGlmIG5vIG90aGVyIGJyYW5jaGVzIG1hdGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IFJ1bm5hYmxlQnJhbmNoIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGJyYW5jaCA9IFJ1bm5hYmxlQnJhbmNoLmZyb20oW1xuICAgICAqICAgWyh4OiBudW1iZXIpID0+IHggPiAwLCAoeDogbnVtYmVyKSA9PiB4ICsgMV0sXG4gICAgICogICBbKHg6IG51bWJlcikgPT4geCA8IDAsICh4OiBudW1iZXIpID0+IHggLSAxXSxcbiAgICAgKiAgICh4OiBudW1iZXIpID0+IHhcbiAgICAgKiBdKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gYnJhbmNoZXMgQW4gYXJyYXkgd2hlcmUgdGhlIGV2ZXJ5IGl0ZW0gZXhjZXB0IHRoZSBsYXN0IGlzIGEgdHVwbGUgb2YgW2NvbmRpdGlvbiwgcnVubmFibGVdXG4gICAgICogICBwYWlycy4gVGhlIGxhc3QgaXRlbSBpcyBhIGRlZmF1bHQgcnVubmFibGUgd2hpY2ggaXMgaW52b2tlZCBpZiBubyBvdGhlciBjb25kaXRpb24gbWF0Y2hlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBSdW5uYWJsZUJyYW5jaC5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBmcm9tKGJyYW5jaGVzKSB7XG4gICAgICAgIGlmIChicmFuY2hlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUJyYW5jaCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYnJhbmNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyYW5jaExpa2VzID0gYnJhbmNoZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBjb2VyY2VkQnJhbmNoZXMgPSBicmFuY2hMaWtlcy5tYXAoKFtjb25kaXRpb24sIHJ1bm5hYmxlXSkgPT4gW1xuICAgICAgICAgICAgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9SdW5uYWJsZSkoY29uZGl0aW9uKSxcbiAgICAgICAgICAgICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvUnVubmFibGUpKHJ1bm5hYmxlKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCcmFuY2ggPSAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb1J1bm5hYmxlKShicmFuY2hlc1ticmFuY2hlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBicmFuY2hlczogY29lcmNlZEJyYW5jaGVzLFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdEJyYW5jaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnJhbmNoZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb25kaXRpb24sIGJyYW5jaFJ1bm5hYmxlXSA9IHRoaXMuYnJhbmNoZXNbaV07XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGF3YWl0IGNvbmRpdGlvbi5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgY29uZGl0aW9uOiR7aSArIDF9YCksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBicmFuY2hSdW5uYWJsZS5pbnZva2UoaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYGJyYW5jaDoke2kgKyAxfWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5kZWZhdWx0Lmludm9rZShpbnB1dCwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKFwiYnJhbmNoOmRlZmF1bHRcIiksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb0RpY3QpKGlucHV0LCBcImlucHV0XCIpLCBjb25maWc/LnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnJhbmNoZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY29uZGl0aW9uLCBicmFuY2hSdW5uYWJsZV0gPSB0aGlzLmJyYW5jaGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvblZhbHVlID0gYXdhaXQgY29uZGl0aW9uLmludm9rZShpbnB1dCwgKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgY29uZGl0aW9uOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCBicmFuY2hSdW5uYWJsZS5zdHJlYW0oaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBicmFuY2g6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gKDAsIHN0cmVhbV9qc18xLmNvbmNhdCkoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IGF3YWl0IHRoaXMuZGVmYXVsdC5zdHJlYW0oaW5wdXQsICgwLCBjb25maWdfanNfMS5wYXRjaENvbmZpZykoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoXCJicmFuY2g6ZGVmYXVsdFwiKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9KTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlQnJhbmNoID0gUnVubmFibGVCcmFuY2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/config.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_RECURSION_LIMIT = void 0;\nexports.getCallbackManagerForConfig = getCallbackManagerForConfig;\nexports.mergeConfigs = mergeConfigs;\nexports.ensureConfig = ensureConfig;\nexports.patchConfig = patchConfig;\nexports.pickRunnableConfigKeys = pickRunnableConfigKeys;\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nexports.DEFAULT_RECURSION_LIMIT = 25;\nasync function getCallbackManagerForConfig(config) {\n    return manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nfunction mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler((0, manager_js_1.ensureHandler)(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new manager_js_1.CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nfunction ensureConfig(config) {\n    const implicitConfig = index_js_1.AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nfunction patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction pickRunnableConfigKeys(config) {\n    return config\n        ? {\n            configurable: config.configurable,\n            recursionLimit: config.recursionLimit,\n            callbacks: config.callbacks,\n            tags: config.tags,\n            metadata: config.metadata,\n            maxConcurrency: config.maxConcurrency,\n            timeout: config.timeout,\n            signal: config.signal,\n        }\n        : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUksMkVBQTJFLElBQUk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvY29uZmlnLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSB2b2lkIDA7XG5leHBvcnRzLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyA9IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZztcbmV4cG9ydHMubWVyZ2VDb25maWdzID0gbWVyZ2VDb25maWdzO1xuZXhwb3J0cy5lbnN1cmVDb25maWcgPSBlbnN1cmVDb25maWc7XG5leHBvcnRzLnBhdGNoQ29uZmlnID0gcGF0Y2hDb25maWc7XG5leHBvcnRzLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMgPSBwaWNrUnVubmFibGVDb25maWdLZXlzO1xuY29uc3QgbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmNqc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vc2luZ2xldG9ucy9pbmRleC5janNcIik7XG5leHBvcnRzLkRFRkFVTFRfUkVDVVJTSU9OX0xJTUlUID0gMjU7XG5hc3luYyBmdW5jdGlvbiBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIG1hbmFnZXJfanNfMS5DYWxsYmFja01hbmFnZXIuX2NvbmZpZ3VyZVN5bmMoY29uZmlnPy5jYWxsYmFja3MsIHVuZGVmaW5lZCwgY29uZmlnPy50YWdzLCB1bmRlZmluZWQsIGNvbmZpZz8ubWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKC4uLmNvbmZpZ3MpIHtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBjYWxsIGVuc3VyZUNvbmZpZyBvbiB0aGUgZW1wdHkgc3RhdGUgaGVyZSBhcyB0aGlzIG1heSBjYXVzZVxuICAgIC8vIGRvdWJsZSBsb2FkaW5nIG9mIGNhbGxiYWNrcyBpZiBhc3luYyBsb2NhbCBzdG9yYWdlIGlzIGJlaW5nIHVzZWQuXG4gICAgY29uc3QgY29weSA9IHt9O1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb25maWdzLmZpbHRlcigoYykgPT4gISFjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VLZXlzID0gY29weVtrZXldID8/IFtdO1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFsuLi5uZXcgU2V0KGJhc2VLZXlzLmNvbmNhdChvcHRpb25zW2tleV0gPz8gW10pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY29uZmlndXJhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSB7IC4uLmNvcHlba2V5XSwgLi4ub3B0aW9uc1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwidGltZW91dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weS50aW1lb3V0ID0gTWF0aC5taW4oY29weS50aW1lb3V0LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJzaWduYWxcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnNpZ25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY2FsbGJhY2tzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQ2FsbGJhY2tzID0gY29weS5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZWRDYWxsYmFja3MgPSBvcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgY2FuIGJlIGVpdGhlciB1bmRlZmluZWQsIEFycmF5PGhhbmRsZXI+IG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBzbyBtZXJnaW5nIHR3byBjYWxsYmFja3MgdmFsdWVzIGhhcyA2IGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZWRDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IGJhc2VDYWxsYmFja3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gYmFzZUNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHByb3ZpZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKCgwLCBtYW5hZ2VyX2pzXzEuZW5zdXJlSGFuZGxlcikoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlZENhbGxiYWNrcyBpcyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IHByb3ZpZGVkQ2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYmFzZUNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSBwcm92aWRlZENhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoKDAsIG1hbmFnZXJfanNfMS5lbnN1cmVIYW5kbGVyKShjYWxsYmFjayksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBtYW5hZ2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZUNhbGxiYWNrcyBpcyBhbHNvIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBuZXcgbWFuYWdlcl9qc18xLkNhbGxiYWNrTWFuYWdlcihwcm92aWRlZENhbGxiYWNrcy5fcGFyZW50UnVuSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyczogYmFzZUNhbGxiYWNrcy5oYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaGFuZGxlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlSGFuZGxlcnM6IGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MudGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MudGFncykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0YWJsZVRhZ3M6IEFycmF5LmZyb20obmV3IFNldChiYXNlQ2FsbGJhY2tzLmluaGVyaXRhYmxlVGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3ZpZGVkQ2FsbGJhY2tzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGNvcHlbdHlwZWRLZXldID0gb3B0aW9uc1t0eXBlZEtleV0gPz8gY29weVt0eXBlZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jb25zdCBQUklNSVRJVkVTID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwYXNzZWQgY29uZmlnIGlzIGFuIG9iamVjdCB3aXRoIGFsbCByZXF1aXJlZCBrZXlzIHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBpbXBsaWNpdENvbmZpZyA9IGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRSdW5uYWJsZUNvbmZpZygpO1xuICAgIGxldCBlbXB0eSA9IHtcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgcmVjdXJzaW9uTGltaXQ6IDI1LFxuICAgICAgICBydW5JZDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgaWYgKGltcGxpY2l0Q29uZmlnKSB7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJ1bklkIGFuZCBydW5OYW1lIHRvIGJlIGxvYWRlZCBpbXBsaWNpdGx5LCBhcyB0aGlzIGNhbiBjYXVzZVxuICAgICAgICAvLyBjaGlsZCBydW5zIHRvIGltcHJvcGVybHkgaW5oZXJpdCB0aGVpciBwYXJlbnRzJyBydW4gaWRzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIHJ1bk5hbWUsIC4uLnJlc3QgfSA9IGltcGxpY2l0Q29uZmlnO1xuICAgICAgICBlbXB0eSA9IE9iamVjdC5lbnRyaWVzKHJlc3QpLnJlZHVjZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGN1cnJlbnRDb25maWcsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgICAgICB9LCBlbXB0eSk7XG4gICAgfVxuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZW1wdHkgPSBPYmplY3QuZW50cmllcyhjb25maWcpLnJlZHVjZShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGN1cnJlbnRDb25maWcsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xuICAgICAgICB9LCBlbXB0eSk7XG4gICAgfVxuICAgIGlmIChlbXB0eT8uY29uZmlndXJhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVtcHR5LmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgIGlmIChQUklNSVRJVkVTLmhhcyh0eXBlb2YgZW1wdHkuY29uZmlndXJhYmxlW2tleV0pICYmXG4gICAgICAgICAgICAgICAgIWVtcHR5Lm1ldGFkYXRhPy5ba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1wdHkubWV0YWRhdGFba2V5XSA9IGVtcHR5LmNvbmZpZ3VyYWJsZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbXB0eS50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGVtcHR5LnRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXRTaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KGVtcHR5LnRpbWVvdXQpO1xuICAgICAgICBpZiAoZW1wdHkuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChcImFueVwiIGluIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBlbXB0eS5zaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW2VtcHR5LnNpZ25hbCwgdGltZW91dFNpZ25hbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW1wdHkuc2lnbmFsID0gdGltZW91dFNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZW1wdHkudGltZW91dDtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBwYXRjaGVzIHJ1bm5hYmxlIGNvbmZpZ3Mgd2l0aCB1cGRhdGVkIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHBhdGNoQ29uZmlnKGNvbmZpZyA9IHt9LCB7IGNhbGxiYWNrcywgbWF4Q29uY3VycmVuY3ksIHJlY3Vyc2lvbkxpbWl0LCBydW5OYW1lLCBjb25maWd1cmFibGUsIHJ1bklkLCB9ID0ge30pIHtcbiAgICBjb25zdCBuZXdDb25maWcgPSBlbnN1cmVDb25maWcoY29uZmlnKTtcbiAgICBpZiAoY2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHJlcGxhY2luZyBjYWxsYmFja3Mgd2UgbmVlZCB0byB1bnNldCBydW5OYW1lXG4gICAgICAgICAqIHNpbmNlIHRoYXQgc2hvdWxkIGFwcGx5IG9ubHkgdG8gdGhlIHNhbWUgcnVuIGFzIHRoZSBvcmlnaW5hbCBjYWxsYmFja3NcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZSBuZXdDb25maWcucnVuTmFtZTtcbiAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgaWYgKHJlY3Vyc2lvbkxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLnJlY3Vyc2lvbkxpbWl0ID0gcmVjdXJzaW9uTGltaXQ7XG4gICAgfVxuICAgIGlmIChtYXhDb25jdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBpZiAocnVuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5ydW5OYW1lID0gcnVuTmFtZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ3VyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5jb25maWd1cmFibGUgPSB7IC4uLm5ld0NvbmZpZy5jb25maWd1cmFibGUsIC4uLmNvbmZpZ3VyYWJsZSB9O1xuICAgIH1cbiAgICBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnJ1bklkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Q29uZmlnO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBjb25maWcucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICBjYWxsYmFja3M6IGNvbmZpZy5jYWxsYmFja3MsXG4gICAgICAgICAgICB0YWdzOiBjb25maWcudGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogY29uZmlnLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgdGltZW91dDogY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICBzaWduYWw6IGNvbmZpZy5zaWduYWwsXG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graph = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\");\nconst graph_mermaid_js_1 = __webpack_require__(/*! ./graph_mermaid.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nfunction nodeDataStr(id, data) {\n    if (id !== undefined && !(0, uuid_1.validate)(id)) {\n        return id;\n    }\n    else if ((0, utils_js_1.isRunnableInterface)(data)) {\n        try {\n            let dataStr = data.getName();\n            dataStr = dataStr.startsWith(\"Runnable\")\n                ? dataStr.slice(\"Runnable\".length)\n                : dataStr;\n            return dataStr;\n        }\n        catch (error) {\n            return data.getName();\n        }\n    }\n    else {\n        return data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data implements Runnable\n    if ((0, utils_js_1.isRunnableInterface)(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...(0, json_schema_js_1.toJsonSchema)(node.data.schema), title: node.data.name },\n        };\n    }\n}\nclass Graph {\n    constructor(params) {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.nodes = params?.nodes ?? this.nodes;\n        this.edges = params?.edges ?? this.edges;\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = (0, uuid_1.validate)(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id ?? (0, uuid_1.v4)();\n        const node = {\n            id: nodeId,\n            data,\n            name: nodeDataStr(id, data),\n            metadata,\n        };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        return _firstNode(this);\n    }\n    lastNode() {\n        return _lastNode(this);\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(uuid_1.validate)) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode && _firstNode(this, [firstNode.id])) {\n            this.removeNode(firstNode);\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode && _lastNode(this, [lastNode.id])) {\n            this.removeNode(lastNode);\n        }\n    }\n    /**\n     * Return a new graph with all nodes re-identified,\n     * using their unique, readable names where possible.\n     */\n    reid() {\n        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));\n        const nodeLabelCounts = new Map();\n        Object.values(nodeLabels).forEach((label) => {\n            nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n        });\n        const getNodeId = (nodeId) => {\n            const label = nodeLabels[nodeId];\n            if ((0, uuid_1.validate)(nodeId) && nodeLabelCounts.get(label) === 1) {\n                return label;\n            }\n            else {\n                return nodeId;\n            }\n        };\n        return new Graph({\n            nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [\n                getNodeId(id),\n                { ...node, id: getNodeId(id) },\n            ])),\n            edges: this.edges.map((edge) => ({\n                ...edge,\n                source: getNodeId(edge.source),\n                target: getNodeId(edge.target),\n            })),\n        });\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = {\n            default: \"fill:#f2f0ff,line-height:1.2\",\n            first: \"fill-opacity:0\",\n            last: \"fill:#bfb6fc\",\n        }, wrapLabelNWords, } = params ?? {};\n        const graph = this.reid();\n        const firstNode = graph.firstNode();\n        const lastNode = graph.lastNode();\n        return (0, graph_mermaid_js_1.drawMermaid)(graph.nodes, graph.edges, {\n            firstNode: firstNode?.id,\n            lastNode: lastNode?.id,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return (0, graph_mermaid_js_1.drawMermaidPng)(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\nexports.Graph = Graph;\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n    const targets = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.source))\n        .map((edge) => edge.target));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !targets.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n    const sources = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.target))\n        .map((edge) => edge.source));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !sources.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLDJGQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFhO0FBQ3hDLDJCQUEyQixtQkFBTyxDQUFDLGtHQUFxQjtBQUN4RCx5QkFBeUIsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRkFBZ0Y7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLEdBQUcsR0FBRztBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQ0FBMkM7QUFDakUscUJBQXFCLHlDQUF5QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvZ3JhcGguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HcmFwaCA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbmNvbnN0IGdyYXBoX21lcm1haWRfanNfMSA9IHJlcXVpcmUoXCIuL2dyYXBoX21lcm1haWQuY2pzXCIpO1xuY29uc3QganNvbl9zY2hlbWFfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9qc29uX3NjaGVtYS5janNcIik7XG5mdW5jdGlvbiBub2RlRGF0YVN0cihpZCwgZGF0YSkge1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmICEoMCwgdXVpZF8xLnZhbGlkYXRlKShpZCkpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfanNfMS5pc1J1bm5hYmxlSW50ZXJmYWNlKShkYXRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGRhdGFTdHIgPSBkYXRhLmdldE5hbWUoKTtcbiAgICAgICAgICAgIGRhdGFTdHIgPSBkYXRhU3RyLnN0YXJ0c1dpdGgoXCJSdW5uYWJsZVwiKVxuICAgICAgICAgICAgICAgID8gZGF0YVN0ci5zbGljZShcIlJ1bm5hYmxlXCIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogZGF0YVN0cjtcbiAgICAgICAgICAgIHJldHVybiBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YS5uYW1lID8/IFwiVW5rbm93blNjaGVtYVwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVEYXRhSnNvbihub2RlKSB7XG4gICAgLy8gaWYgbm9kZS5kYXRhIGltcGxlbWVudHMgUnVubmFibGVcbiAgICBpZiAoKDAsIHV0aWxzX2pzXzEuaXNSdW5uYWJsZUludGVyZmFjZSkobm9kZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJydW5uYWJsZVwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlkOiBub2RlLmRhdGEubGNfaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS5kYXRhLmdldE5hbWUoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzY2hlbWFcIixcbiAgICAgICAgICAgIGRhdGE6IHsgLi4uKDAsIGpzb25fc2NoZW1hX2pzXzEudG9Kc29uU2NoZW1hKShub2RlLmRhdGEuc2NoZW1hKSwgdGl0bGU6IG5vZGUuZGF0YS5uYW1lIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgR3JhcGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2Rlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVkZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IHBhcmFtcz8ubm9kZXMgPz8gdGhpcy5ub2RlcztcbiAgICAgICAgdGhpcy5lZGdlcyA9IHBhcmFtcz8uZWRnZXMgPz8gdGhpcy5lZGdlcztcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgZ3JhcGggdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBmb3JtYXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHN0YWJsZU5vZGVJZHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVOb2RlSWRzW25vZGUuaWRdID0gKDAsIHV1aWRfMS52YWxpZGF0ZSkobm9kZS5pZCkgPyBpIDogbm9kZS5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogT2JqZWN0LnZhbHVlcyh0aGlzLm5vZGVzKS5tYXAoKG5vZGUpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IHN0YWJsZU5vZGVJZHNbbm9kZS5pZF0sXG4gICAgICAgICAgICAgICAgLi4ubm9kZURhdGFKc29uKG5vZGUpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgZWRnZXM6IHRoaXMuZWRnZXMubWFwKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzdGFibGVOb2RlSWRzW2VkZ2Uuc291cmNlXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzdGFibGVOb2RlSWRzW2VkZ2UudGFyZ2V0XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRnZS5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGF0YSA9IGVkZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlZGdlLmNvbmRpdGlvbmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uZGl0aW9uYWwgPSBlZGdlLmNvbmRpdGlvbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGROb2RlKGRhdGEsIGlkLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubm9kZXNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIGlkICR7aWR9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUlkID0gaWQgPz8gKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbmFtZTogbm9kZURhdGFTdHIoaWQsIGRhdGEpLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIG5vZGVzIG1hcFxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5lZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gbm9kZS5pZCAmJiBlZGdlLnRhcmdldCAhPT0gbm9kZS5pZCk7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIGRhdGEsIGNvbmRpdGlvbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3NvdXJjZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugbm9kZSAke3NvdXJjZS5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZXNbdGFyZ2V0LmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBub2RlICR7dGFyZ2V0LmlkfSBub3QgaW4gZ3JhcGhgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UuaWQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZmlyc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gX2ZpcnN0Tm9kZSh0aGlzKTtcbiAgICB9XG4gICAgbGFzdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBfbGFzdE5vZGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbGwgbm9kZXMgYW5kIGVkZ2VzIGZyb20gYW5vdGhlciBncmFwaC5cbiAgICAgKiBOb3RlIHRoaXMgZG9lc24ndCBjaGVjayBmb3IgZHVwbGljYXRlcywgbm9yIGRvZXMgaXQgY29ubmVjdCB0aGUgZ3JhcGhzLlxuICAgICAqL1xuICAgIGV4dGVuZChncmFwaCwgcHJlZml4ID0gXCJcIikge1xuICAgICAgICBsZXQgZmluYWxQcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBpZiAobm9kZUlkcy5ldmVyeSh1dWlkXzEudmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBmaW5hbFByZWZpeCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByZWZpeCA/IGAke2ZpbmFsUHJlZml4fToke2lkfWAgOiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ3JhcGgubm9kZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1twcmVmaXhlZChrZXkpXSA9IHsgLi4udmFsdWUsIGlkOiBwcmVmaXhlZChrZXkpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXdFZGdlcyA9IGdyYXBoLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5lZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogcHJlZml4ZWQoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcHJlZml4ZWQoZWRnZS50YXJnZXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBhbGwgZWRnZXMgZnJvbSB0aGUgb3RoZXIgZ3JhcGhcbiAgICAgICAgdGhpcy5lZGdlcyA9IFsuLi50aGlzLmVkZ2VzLCAuLi5uZXdFZGdlc107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gZ3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBncmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmlyc3QgPyB7IGlkOiBwcmVmaXhlZChmaXJzdC5pZCksIGRhdGE6IGZpcnN0LmRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhc3QgPyB7IGlkOiBwcmVmaXhlZChsYXN0LmlkKSwgZGF0YTogbGFzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRyaW1GaXJzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZmlyc3ROb2RlKCk7XG4gICAgICAgIGlmIChmaXJzdE5vZGUgJiYgX2ZpcnN0Tm9kZSh0aGlzLCBbZmlyc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShmaXJzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaW1MYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlKCk7XG4gICAgICAgIGlmIChsYXN0Tm9kZSAmJiBfbGFzdE5vZGUodGhpcywgW2xhc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGdyYXBoIHdpdGggYWxsIG5vZGVzIHJlLWlkZW50aWZpZWQsXG4gICAgICogdXNpbmcgdGhlaXIgdW5pcXVlLCByZWFkYWJsZSBuYW1lcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICByZWlkKCkge1xuICAgICAgICBjb25zdCBub2RlTGFiZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykubWFwKChub2RlKSA9PiBbbm9kZS5pZCwgbm9kZS5uYW1lXSkpO1xuICAgICAgICBjb25zdCBub2RlTGFiZWxDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobm9kZUxhYmVscykuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAgIG5vZGVMYWJlbENvdW50cy5zZXQobGFiZWwsIChub2RlTGFiZWxDb3VudHMuZ2V0KGxhYmVsKSB8fCAwKSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZUlkID0gKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBub2RlTGFiZWxzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoKDAsIHV1aWRfMS52YWxpZGF0ZSkobm9kZUlkKSAmJiBub2RlTGFiZWxDb3VudHMuZ2V0KGxhYmVsKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGgoe1xuICAgICAgICAgICAgbm9kZXM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLm5vZGVzKS5tYXAoKFtpZCwgbm9kZV0pID0+IFtcbiAgICAgICAgICAgICAgICBnZXROb2RlSWQoaWQpLFxuICAgICAgICAgICAgICAgIHsgLi4ubm9kZSwgaWQ6IGdldE5vZGVJZChpZCkgfSxcbiAgICAgICAgICAgIF0pKSxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0Tm9kZUlkKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGdldE5vZGVJZChlZGdlLnRhcmdldCksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkcmF3TWVybWFpZChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyB3aXRoU3R5bGVzLCBjdXJ2ZVN0eWxlLCBub2RlQ29sb3JzID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogXCJmaWxsOiNmMmYwZmYsbGluZS1oZWlnaHQ6MS4yXCIsXG4gICAgICAgICAgICBmaXJzdDogXCJmaWxsLW9wYWNpdHk6MFwiLFxuICAgICAgICAgICAgbGFzdDogXCJmaWxsOiNiZmI2ZmNcIixcbiAgICAgICAgfSwgd3JhcExhYmVsTldvcmRzLCB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICBjb25zdCBncmFwaCA9IHRoaXMucmVpZCgpO1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBncmFwaC5maXJzdE5vZGUoKTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBncmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gKDAsIGdyYXBoX21lcm1haWRfanNfMS5kcmF3TWVybWFpZCkoZ3JhcGgubm9kZXMsIGdyYXBoLmVkZ2VzLCB7XG4gICAgICAgICAgICBmaXJzdE5vZGU6IGZpcnN0Tm9kZT8uaWQsXG4gICAgICAgICAgICBsYXN0Tm9kZTogbGFzdE5vZGU/LmlkLFxuICAgICAgICAgICAgd2l0aFN0eWxlcyxcbiAgICAgICAgICAgIGN1cnZlU3R5bGUsXG4gICAgICAgICAgICBub2RlQ29sb3JzLFxuICAgICAgICAgICAgd3JhcExhYmVsTldvcmRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZHJhd01lcm1haWRQbmcocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1lcm1haWRTeW50YXggPSB0aGlzLmRyYXdNZXJtYWlkKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoMCwgZ3JhcGhfbWVybWFpZF9qc18xLmRyYXdNZXJtYWlkUG5nKShtZXJtYWlkU3ludGF4LCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHBhcmFtcz8uYmFja2dyb3VuZENvbG9yLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoID0gR3JhcGg7XG4vKipcbiAqIEZpbmQgdGhlIHNpbmdsZSBub2RlIHRoYXQgaXMgbm90IGEgdGFyZ2V0IG9mIGFueSBlZGdlLlxuICogRXhjbHVkZSBub2Rlcy9zb3VyY2VzIHdpdGggaWRzIGluIHRoZSBleGNsdWRlIGxpc3QuXG4gKiBJZiB0aGVyZSBpcyBubyBzdWNoIG5vZGUsIG9yIHRoZXJlIGFyZSBtdWx0aXBsZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIFdoZW4gZHJhd2luZyB0aGUgZ3JhcGgsIHRoaXMgbm9kZSB3b3VsZCBiZSB0aGUgb3JpZ2luLlxuICovXG5mdW5jdGlvbiBfZmlyc3ROb2RlKGdyYXBoLCBleGNsdWRlID0gW10pIHtcbiAgICBjb25zdCB0YXJnZXRzID0gbmV3IFNldChncmFwaC5lZGdlc1xuICAgICAgICAuZmlsdGVyKChlZGdlKSA9PiAhZXhjbHVkZS5pbmNsdWRlcyhlZGdlLnNvdXJjZSkpXG4gICAgICAgIC5tYXAoKGVkZ2UpID0+IGVkZ2UudGFyZ2V0KSk7XG4gICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcykpIHtcbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKG5vZGUuaWQpICYmICF0YXJnZXRzLmhhcyhub2RlLmlkKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQubGVuZ3RoID09PSAxID8gZm91bmRbMF0gOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEZpbmQgdGhlIHNpbmdsZSBub2RlIHRoYXQgaXMgbm90IGEgc291cmNlIG9mIGFueSBlZGdlLlxuICogRXhjbHVkZSBub2Rlcy90YXJnZXRzIHdpdGggaWRzIGluIHRoZSBleGNsdWRlIGxpc3QuXG4gKiBJZiB0aGVyZSBpcyBubyBzdWNoIG5vZGUsIG9yIHRoZXJlIGFyZSBtdWx0aXBsZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIFdoZW4gZHJhd2luZyB0aGUgZ3JhcGgsIHRoaXMgbm9kZSB3b3VsZCBiZSB0aGUgZGVzdGluYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9sYXN0Tm9kZShncmFwaCwgZXhjbHVkZSA9IFtdKSB7XG4gICAgY29uc3Qgc291cmNlcyA9IG5ldyBTZXQoZ3JhcGguZWRnZXNcbiAgICAgICAgLmZpbHRlcigoZWRnZSkgPT4gIWV4Y2x1ZGUuaW5jbHVkZXMoZWRnZS50YXJnZXQpKVxuICAgICAgICAubWFwKChlZGdlKSA9PiBlZGdlLnNvdXJjZSkpO1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpKSB7XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyhub2RlLmlkKSAmJiAhc291cmNlcy5oYXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA9PT0gMSA/IGZvdW5kWzBdIDogdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.drawMermaid = drawMermaid;\nexports.drawMermaidPng = drawMermaidPng;\nexports.drawMermaidImage = drawMermaidImage;\nfunction _escapeNodeLabel(nodeLabel) {\n    // Escapes the node label for Mermaid syntax.\n    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\nfunction _generateMermaidGraphStyles(nodeColors) {\n    let styles = \"\";\n    for (const [className, color] of Object.entries(nodeColors)) {\n        styles += `\\tclassDef ${className} ${color};\\n`;\n    }\n    return styles;\n}\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nfunction drawMermaid(nodes, edges, config) {\n    const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = \"linear\", wrapLabelNWords = 9, } = config ?? {};\n    // Initialize Mermaid graph configuration\n    let mermaidGraph = withStyles\n        ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n        : \"graph TD;\\n\";\n    if (withStyles) {\n        // Node formatting templates\n        const defaultClassLabel = \"default\";\n        const formatDict = {\n            [defaultClassLabel]: \"{0}({1})\",\n        };\n        if (firstNode !== undefined) {\n            formatDict[firstNode] = \"{0}([{1}]):::first\";\n        }\n        if (lastNode !== undefined) {\n            formatDict[lastNode] = \"{0}([{1}]):::last\";\n        }\n        // Add nodes to the graph\n        for (const [key, node] of Object.entries(nodes)) {\n            const nodeName = node.name.split(\":\").pop() ?? \"\";\n            const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char))\n                ? `<p>${nodeName}</p>`\n                : nodeName;\n            let finalLabel = label;\n            if (Object.keys(node.metadata ?? {}).length) {\n                finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n                    .map(([k, v]) => `${k} = ${v}`)\n                    .join(\"\\n\")}</em></small>`;\n            }\n            const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n                .replace(\"{0}\", _escapeNodeLabel(key))\n                .replace(\"{1}\", finalLabel);\n            mermaidGraph += `\\t${nodeLabel}\\n`;\n        }\n    }\n    // Group edges by their common prefixes\n    const edgeGroups = {};\n    for (const edge of edges) {\n        const srcParts = edge.source.split(\":\");\n        const tgtParts = edge.target.split(\":\");\n        const commonPrefix = srcParts\n            .filter((src, i) => src === tgtParts[i])\n            .join(\":\");\n        if (!edgeGroups[commonPrefix]) {\n            edgeGroups[commonPrefix] = [];\n        }\n        edgeGroups[commonPrefix].push(edge);\n    }\n    const seenSubgraphs = new Set();\n    function addSubgraph(edges, prefix) {\n        const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n        if (prefix && !selfLoop) {\n            const subgraph = prefix.split(\":\").pop();\n            if (seenSubgraphs.has(subgraph)) {\n                throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n                    \"you're reusing a subgraph node with the same name. \" +\n                    \"Please adjust your graph to have subgraph nodes with unique names.\");\n            }\n            seenSubgraphs.add(subgraph);\n            mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n        }\n        for (const edge of edges) {\n            const { source, target, data, conditional } = edge;\n            let edgeLabel = \"\";\n            if (data !== undefined) {\n                let edgeData = data;\n                const words = edgeData.split(\" \");\n                if (words.length > wrapLabelNWords) {\n                    edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words\n                        .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                        .join(\" \")).join(\"&nbsp;<br>&nbsp;\");\n                }\n                edgeLabel = conditional\n                    ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n                    : ` -- &nbsp;${edgeData}&nbsp; --> `;\n            }\n            else {\n                edgeLabel = conditional ? \" -.-> \" : \" --> \";\n            }\n            mermaidGraph += `\\t${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n        }\n        // Recursively add nested subgraphs\n        for (const nestedPrefix in edgeGroups) {\n            if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n                addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n            }\n        }\n        if (prefix && !selfLoop) {\n            mermaidGraph += \"\\tend\\n\";\n        }\n    }\n    // Start with the top-level edges (no common prefix)\n    addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n    // Add remaining subgraphs\n    for (const prefix in edgeGroups) {\n        if (!prefix.includes(\":\") && prefix !== \"\") {\n            addSubgraph(edgeGroups[prefix], prefix);\n        }\n    }\n    // Add custom styles for nodes\n    if (withStyles) {\n        mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n    }\n    return mermaidGraph;\n}\n/**\n * @deprecated Use `drawMermaidImage` instead.\n */\nasync function drawMermaidPng(mermaidSyntax, config) {\n    return drawMermaidImage(mermaidSyntax, {\n        ...config,\n        imageType: \"png\",\n    });\n}\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nasync function drawMermaidImage(mermaidSyntax, config) {\n    let backgroundColor = config?.backgroundColor ?? \"white\";\n    const imageType = config?.imageType ?? \"png\";\n    // Use btoa for compatibility, assume ASCII\n    const mermaidSyntaxEncoded = btoa(mermaidSyntax);\n    // Check if the background color is a hexadecimal color code using regex\n    if (backgroundColor !== undefined) {\n        const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n        if (!hexColorPattern.test(backgroundColor)) {\n            backgroundColor = `!${backgroundColor}`;\n        }\n    }\n    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n    const res = await fetch(imageUrl);\n    if (!res.ok) {\n        throw new Error([\n            `Failed to render the graph using the Mermaid.INK API.`,\n            `Status code: ${res.status}`,\n            `Status text: ${res.statusText}`,\n        ].join(\"\\n\"));\n    }\n    const content = await res.blob();\n    return content;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoX21lcm1haWQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxFQUFFLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtHQUFrRztBQUM5RztBQUNBO0FBQ0EsY0FBYyxPQUFPLGNBQWMsWUFBWSxXQUFXLElBQUksYUFBYTtBQUMzRSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxFQUFFLEVBQUU7QUFDekM7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLEdBQUcsRUFBRTtBQUM3QztBQUNBO0FBQ0EscUNBQXFDLEVBQUUsR0FBRyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGlEQUFpRCxrQ0FBa0M7QUFDbkYsd0NBQXdDLEdBQUcsSUFBSSxFQUFFO0FBQ2pELGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0IsMkJBQTJCLEVBQUU7QUFDN0IsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1EQUFtRDtBQUMvRjtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxTQUFTLE9BQU87QUFDbkQsaUNBQWlDLEVBQUUsU0FBUyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QixFQUFFLFVBQVUsRUFBRSwwQkFBMEI7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLEVBQUUsSUFBSTtBQUMxRDtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUIsV0FBVyxnQkFBZ0IsUUFBUSxVQUFVO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkMsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoX21lcm1haWQuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kcmF3TWVybWFpZCA9IGRyYXdNZXJtYWlkO1xuZXhwb3J0cy5kcmF3TWVybWFpZFBuZyA9IGRyYXdNZXJtYWlkUG5nO1xuZXhwb3J0cy5kcmF3TWVybWFpZEltYWdlID0gZHJhd01lcm1haWRJbWFnZTtcbmZ1bmN0aW9uIF9lc2NhcGVOb2RlTGFiZWwobm9kZUxhYmVsKSB7XG4gICAgLy8gRXNjYXBlcyB0aGUgbm9kZSBsYWJlbCBmb3IgTWVybWFpZCBzeW50YXguXG4gICAgcmV0dXJuIG5vZGVMYWJlbC5yZXBsYWNlKC9bXmEtekEtWi1fMC05XS9nLCBcIl9cIik7XG59XG5jb25zdCBNQVJLRE9XTl9TUEVDSUFMX0NIQVJTID0gW1wiKlwiLCBcIl9cIiwgXCJgXCJdO1xuZnVuY3Rpb24gX2dlbmVyYXRlTWVybWFpZEdyYXBoU3R5bGVzKG5vZGVDb2xvcnMpIHtcbiAgICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIGNvbG9yXSBvZiBPYmplY3QuZW50cmllcyhub2RlQ29sb3JzKSkge1xuICAgICAgICBzdHlsZXMgKz0gYFxcdGNsYXNzRGVmICR7Y2xhc3NOYW1lfSAke2NvbG9yfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuLyoqXG4gKiBEcmF3cyBhIE1lcm1haWQgZ3JhcGggdXNpbmcgdGhlIHByb3ZpZGVkIGdyYXBoIGRhdGFcbiAqL1xuZnVuY3Rpb24gZHJhd01lcm1haWQobm9kZXMsIGVkZ2VzLCBjb25maWcpIHtcbiAgICBjb25zdCB7IGZpcnN0Tm9kZSwgbGFzdE5vZGUsIG5vZGVDb2xvcnMsIHdpdGhTdHlsZXMgPSB0cnVlLCBjdXJ2ZVN0eWxlID0gXCJsaW5lYXJcIiwgd3JhcExhYmVsTldvcmRzID0gOSwgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICAvLyBJbml0aWFsaXplIE1lcm1haWQgZ3JhcGggY29uZmlndXJhdGlvblxuICAgIGxldCBtZXJtYWlkR3JhcGggPSB3aXRoU3R5bGVzXG4gICAgICAgID8gYCUle2luaXQ6IHsnZmxvd2NoYXJ0JzogeydjdXJ2ZSc6ICcke2N1cnZlU3R5bGV9J319fSUlXFxuZ3JhcGggVEQ7XFxuYFxuICAgICAgICA6IFwiZ3JhcGggVEQ7XFxuXCI7XG4gICAgaWYgKHdpdGhTdHlsZXMpIHtcbiAgICAgICAgLy8gTm9kZSBmb3JtYXR0aW5nIHRlbXBsYXRlc1xuICAgICAgICBjb25zdCBkZWZhdWx0Q2xhc3NMYWJlbCA9IFwiZGVmYXVsdFwiO1xuICAgICAgICBjb25zdCBmb3JtYXREaWN0ID0ge1xuICAgICAgICAgICAgW2RlZmF1bHRDbGFzc0xhYmVsXTogXCJ7MH0oezF9KVwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmlyc3ROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdERpY3RbZmlyc3ROb2RlXSA9IFwiezB9KFt7MX1dKTo6OmZpcnN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3ROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdERpY3RbbGFzdE5vZGVdID0gXCJ7MH0oW3sxfV0pOjo6bGFzdFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBub2RlcyB0byB0aGUgZ3JhcGhcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBPYmplY3QuZW50cmllcyhub2RlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5uYW1lLnNwbGl0KFwiOlwiKS5wb3AoKSA/PyBcIlwiO1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBNQVJLRE9XTl9TUEVDSUFMX0NIQVJTLnNvbWUoKGNoYXIpID0+IG5vZGVOYW1lLnN0YXJ0c1dpdGgoY2hhcikgJiYgbm9kZU5hbWUuZW5kc1dpdGgoY2hhcikpXG4gICAgICAgICAgICAgICAgPyBgPHA+JHtub2RlTmFtZX08L3A+YFxuICAgICAgICAgICAgICAgIDogbm9kZU5hbWU7XG4gICAgICAgICAgICBsZXQgZmluYWxMYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5vZGUubWV0YWRhdGEgPz8ge30pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTGFiZWwgKz0gYDxoci8+PHNtYWxsPjxlbT4ke09iamVjdC5lbnRyaWVzKG5vZGUubWV0YWRhdGEgPz8ge30pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7a30gPSAke3Z9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcXG5cIil9PC9lbT48L3NtYWxsPmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlTGFiZWwgPSAoZm9ybWF0RGljdFtrZXldID8/IGZvcm1hdERpY3RbZGVmYXVsdENsYXNzTGFiZWxdKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiezB9XCIsIF9lc2NhcGVOb2RlTGFiZWwoa2V5KSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInsxfVwiLCBmaW5hbExhYmVsKTtcbiAgICAgICAgICAgIG1lcm1haWRHcmFwaCArPSBgXFx0JHtub2RlTGFiZWx9XFxuYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHcm91cCBlZGdlcyBieSB0aGVpciBjb21tb24gcHJlZml4ZXNcbiAgICBjb25zdCBlZGdlR3JvdXBzID0ge307XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNyY1BhcnRzID0gZWRnZS5zb3VyY2Uuc3BsaXQoXCI6XCIpO1xuICAgICAgICBjb25zdCB0Z3RQYXJ0cyA9IGVkZ2UudGFyZ2V0LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgY29uc3QgY29tbW9uUHJlZml4ID0gc3JjUGFydHNcbiAgICAgICAgICAgIC5maWx0ZXIoKHNyYywgaSkgPT4gc3JjID09PSB0Z3RQYXJ0c1tpXSlcbiAgICAgICAgICAgIC5qb2luKFwiOlwiKTtcbiAgICAgICAgaWYgKCFlZGdlR3JvdXBzW2NvbW1vblByZWZpeF0pIHtcbiAgICAgICAgICAgIGVkZ2VHcm91cHNbY29tbW9uUHJlZml4XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2VHcm91cHNbY29tbW9uUHJlZml4XS5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgICBjb25zdCBzZWVuU3ViZ3JhcGhzID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGFkZFN1YmdyYXBoKGVkZ2VzLCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3Qgc2VsZkxvb3AgPSBlZGdlcy5sZW5ndGggPT09IDEgJiYgZWRnZXNbMF0uc291cmNlID09PSBlZGdlc1swXS50YXJnZXQ7XG4gICAgICAgIGlmIChwcmVmaXggJiYgIXNlbGZMb29wKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJncmFwaCA9IHByZWZpeC5zcGxpdChcIjpcIikucG9wKCk7XG4gICAgICAgICAgICBpZiAoc2VlblN1YmdyYXBocy5oYXMoc3ViZ3JhcGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBkdXBsaWNhdGUgc3ViZ3JhcGggJyR7c3ViZ3JhcGh9JyAtLSB0aGlzIGxpa2VseSBtZWFucyB0aGF0IGAgK1xuICAgICAgICAgICAgICAgICAgICBcInlvdSdyZSByZXVzaW5nIGEgc3ViZ3JhcGggbm9kZSB3aXRoIHRoZSBzYW1lIG5hbWUuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJQbGVhc2UgYWRqdXN0IHlvdXIgZ3JhcGggdG8gaGF2ZSBzdWJncmFwaCBub2RlcyB3aXRoIHVuaXF1ZSBuYW1lcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuU3ViZ3JhcGhzLmFkZChzdWJncmFwaCk7XG4gICAgICAgICAgICBtZXJtYWlkR3JhcGggKz0gYFxcdHN1YmdyYXBoICR7c3ViZ3JhcGh9XFxuYDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0YXJnZXQsIGRhdGEsIGNvbmRpdGlvbmFsIH0gPSBlZGdlO1xuICAgICAgICAgICAgbGV0IGVkZ2VMYWJlbCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VEYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JkcyA9IGVkZ2VEYXRhLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID4gd3JhcExhYmVsTldvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VEYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogTWF0aC5jZWlsKHdvcmRzLmxlbmd0aCAvIHdyYXBMYWJlbE5Xb3JkcykgfSwgKF8sIGkpID0+IHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaSAqIHdyYXBMYWJlbE5Xb3JkcywgKGkgKyAxKSAqIHdyYXBMYWJlbE5Xb3JkcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiIFwiKSkuam9pbihcIiZuYnNwOzxicj4mbmJzcDtcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkZ2VMYWJlbCA9IGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgID8gYCAtLiAmbmJzcDske2VkZ2VEYXRhfSZuYnNwOyAuLT4gYFxuICAgICAgICAgICAgICAgICAgICA6IGAgLS0gJm5ic3A7JHtlZGdlRGF0YX0mbmJzcDsgLS0+IGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGdlTGFiZWwgPSBjb25kaXRpb25hbCA/IFwiIC0uLT4gXCIgOiBcIiAtLT4gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJtYWlkR3JhcGggKz0gYFxcdCR7X2VzY2FwZU5vZGVMYWJlbChzb3VyY2UpfSR7ZWRnZUxhYmVsfSR7X2VzY2FwZU5vZGVMYWJlbCh0YXJnZXQpfTtcXG5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGFkZCBuZXN0ZWQgc3ViZ3JhcGhzXG4gICAgICAgIGZvciAoY29uc3QgbmVzdGVkUHJlZml4IGluIGVkZ2VHcm91cHMpIHtcbiAgICAgICAgICAgIGlmIChuZXN0ZWRQcmVmaXguc3RhcnRzV2l0aChgJHtwcmVmaXh9OmApICYmIG5lc3RlZFByZWZpeCAhPT0gcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgYWRkU3ViZ3JhcGgoZWRnZUdyb3Vwc1tuZXN0ZWRQcmVmaXhdLCBuZXN0ZWRQcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggJiYgIXNlbGZMb29wKSB7XG4gICAgICAgICAgICBtZXJtYWlkR3JhcGggKz0gXCJcXHRlbmRcXG5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGFydCB3aXRoIHRoZSB0b3AtbGV2ZWwgZWRnZXMgKG5vIGNvbW1vbiBwcmVmaXgpXG4gICAgYWRkU3ViZ3JhcGgoZWRnZUdyb3Vwc1tcIlwiXSA/PyBbXSwgXCJcIik7XG4gICAgLy8gQWRkIHJlbWFpbmluZyBzdWJncmFwaHNcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiBlZGdlR3JvdXBzKSB7XG4gICAgICAgIGlmICghcHJlZml4LmluY2x1ZGVzKFwiOlwiKSAmJiBwcmVmaXggIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGFkZFN1YmdyYXBoKGVkZ2VHcm91cHNbcHJlZml4XSwgcHJlZml4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgY3VzdG9tIHN0eWxlcyBmb3Igbm9kZXNcbiAgICBpZiAod2l0aFN0eWxlcykge1xuICAgICAgICBtZXJtYWlkR3JhcGggKz0gX2dlbmVyYXRlTWVybWFpZEdyYXBoU3R5bGVzKG5vZGVDb2xvcnMgPz8ge30pO1xuICAgIH1cbiAgICByZXR1cm4gbWVybWFpZEdyYXBoO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGRyYXdNZXJtYWlkSW1hZ2VgIGluc3RlYWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRyYXdNZXJtYWlkUG5nKG1lcm1haWRTeW50YXgsIGNvbmZpZykge1xuICAgIHJldHVybiBkcmF3TWVybWFpZEltYWdlKG1lcm1haWRTeW50YXgsIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbWFnZVR5cGU6IFwicG5nXCIsXG4gICAgfSk7XG59XG4vKipcbiAqIFJlbmRlcnMgTWVybWFpZCBncmFwaCB1c2luZyB0aGUgTWVybWFpZC5JTksgQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBpbWFnZSA9IGF3YWl0IGRyYXdNZXJtYWlkSW1hZ2UobWVybWFpZFN5bnRheCwge1xuICogICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIixcbiAqICAgaW1hZ2VUeXBlOiBcInBuZ1wiLFxuICogfSk7XG4gKiBmcy53cml0ZUZpbGVTeW5jKFwiaW1hZ2UucG5nXCIsIGltYWdlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBtZXJtYWlkU3ludGF4IC0gVGhlIE1lcm1haWQgc3ludGF4IHRvIHJlbmRlci5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGltYWdlLlxuICogQHJldHVybnMgVGhlIGltYWdlIGFzIGEgQmxvYi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZHJhd01lcm1haWRJbWFnZShtZXJtYWlkU3ludGF4LCBjb25maWcpIHtcbiAgICBsZXQgYmFja2dyb3VuZENvbG9yID0gY29uZmlnPy5iYWNrZ3JvdW5kQ29sb3IgPz8gXCJ3aGl0ZVwiO1xuICAgIGNvbnN0IGltYWdlVHlwZSA9IGNvbmZpZz8uaW1hZ2VUeXBlID8/IFwicG5nXCI7XG4gICAgLy8gVXNlIGJ0b2EgZm9yIGNvbXBhdGliaWxpdHksIGFzc3VtZSBBU0NJSVxuICAgIGNvbnN0IG1lcm1haWRTeW50YXhFbmNvZGVkID0gYnRvYShtZXJtYWlkU3ludGF4KTtcbiAgICAvLyBDaGVjayBpZiB0aGUgYmFja2dyb3VuZCBjb2xvciBpcyBhIGhleGFkZWNpbWFsIGNvbG9yIGNvZGUgdXNpbmcgcmVnZXhcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgaGV4Q29sb3JQYXR0ZXJuID0gL14jKD86WzAtOWEtZkEtRl17M30pezEsMn0kLztcbiAgICAgICAgaWYgKCFoZXhDb2xvclBhdHRlcm4udGVzdChiYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBgISR7YmFja2dyb3VuZENvbG9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1hZ2VVcmwgPSBgaHR0cHM6Ly9tZXJtYWlkLmluay9pbWcvJHttZXJtYWlkU3ludGF4RW5jb2RlZH0/YmdDb2xvcj0ke2JhY2tncm91bmRDb2xvcn0mdHlwZT0ke2ltYWdlVHlwZX1gO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGltYWdlVXJsKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICAgICAgYEZhaWxlZCB0byByZW5kZXIgdGhlIGdyYXBoIHVzaW5nIHRoZSBNZXJtYWlkLklOSyBBUEkuYCxcbiAgICAgICAgICAgIGBTdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWAsXG4gICAgICAgICAgICBgU3RhdHVzIHRleHQ6ICR7cmVzLnN0YXR1c1RleHR9YCxcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlcy5ibG9iKCk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/graph_mermaid.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/history.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = void 0;\nconst index_js_1 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nclass RunnableWithMessageHistory extends base_js_1.RunnableBinding {\n    constructor(fields) {\n        let historyChain = base_js_1.RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = passthrough_js_1.RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !(0, index_js_1.isBaseMessage)(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new index_js_1.HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !(0, index_js_1.isBaseMessage)(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new index_js_1.AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if ((0, index_js_1.isBaseMessage)(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\nexports.RunnableWithMessageHistory = RunnableWithMessageHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2hpc3RvcnkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBdUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDdEMseUJBQXlCLG1CQUFPLENBQUMsOEZBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILGdCQUFnQix3QkFBd0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWUsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxTQUFTO0FBQ1QsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwwQ0FBMEM7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRywyQ0FBMkM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLG9DQUFvQyw2QkFBNkIsSUFBSSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvaGlzdG9yeS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9pbmRleC5janNcIik7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IHBhc3N0aHJvdWdoX2pzXzEgPSByZXF1aXJlKFwiLi9wYXNzdGhyb3VnaC5janNcIik7XG4vKipcbiAqIFdyYXBzIGEgTENFTCBjaGFpbiBhbmQgbWFuYWdlcyBoaXN0b3J5LiBJdCBhcHBlbmRzIGlucHV0IG1lc3NhZ2VzXG4gKiBhbmQgY2hhaW4gb3V0cHV0cyBhcyBoaXN0b3J5LCBhbmQgYWRkcyB0aGUgY3VycmVudCBoaXN0b3J5IG1lc3NhZ2VzIHRvXG4gKiB0aGUgY2hhaW4gaW5wdXQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8geWFybiBhZGQgQGxhbmdjaGFpbi9hbnRocm9waWMgQGxhbmdjaGFpbi9jb21tdW5pdHkgQHVwc3Rhc2gvcmVkaXNcbiAqXG4gKiBpbXBvcnQge1xuICogICBDaGF0UHJvbXB0VGVtcGxhdGUsXG4gKiAgIE1lc3NhZ2VzUGxhY2Vob2xkZXIsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcHJvbXB0c1wiO1xuICogaW1wb3J0IHsgQ2hhdEFudGhyb3BpYyB9IGZyb20gXCJAbGFuZ2NoYWluL2FudGhyb3BpY1wiO1xuICogaW1wb3J0IHsgVXBzdGFzaFJlZGlzQ2hhdE1lc3NhZ2VIaXN0b3J5IH0gZnJvbSBcIkBsYW5nY2hhaW4vY29tbXVuaXR5L3N0b3Jlcy9tZXNzYWdlL3Vwc3Rhc2hfcmVkaXNcIjtcbiAqIC8vIEZvciBkZW1vcywgeW91IGNhbiBhbHNvIHVzZSBhbiBpbi1tZW1vcnkgc3RvcmU6XG4gKiAvLyBpbXBvcnQgeyBDaGF0TWVzc2FnZUhpc3RvcnkgfSBmcm9tIFwibGFuZ2NoYWluL3N0b3Jlcy9tZXNzYWdlL2luX21lbW9yeVwiO1xuICpcbiAqIGNvbnN0IHByb21wdCA9IENoYXRQcm9tcHRUZW1wbGF0ZS5mcm9tTWVzc2FnZXMoW1xuICogICBbXCJzeXN0ZW1cIiwgXCJZb3UncmUgYW4gYXNzaXN0YW50IHdobydzIGdvb2QgYXQge2FiaWxpdHl9XCJdLFxuICogICBuZXcgTWVzc2FnZXNQbGFjZWhvbGRlcihcImhpc3RvcnlcIiksXG4gKiAgIFtcImh1bWFuXCIsIFwie3F1ZXN0aW9ufVwiXSxcbiAqIF0pO1xuICpcbiAqIGNvbnN0IGNoYWluID0gcHJvbXB0LnBpcGUobmV3IENoYXRBbnRocm9waWMoe30pKTtcbiAqXG4gKiBjb25zdCBjaGFpbldpdGhIaXN0b3J5ID0gbmV3IFJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5KHtcbiAqICAgcnVubmFibGU6IGNoYWluLFxuICogICBnZXRNZXNzYWdlSGlzdG9yeTogKHNlc3Npb25JZCkgPT5cbiAqICAgICBuZXcgVXBzdGFzaFJlZGlzQ2hhdE1lc3NhZ2VIaXN0b3J5KHtcbiAqICAgICAgIHNlc3Npb25JZCxcbiAqICAgICAgIGNvbmZpZzoge1xuICogICAgICAgICB1cmw6IHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhLFxuICogICAgICAgICB0b2tlbjogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOISxcbiAqICAgICAgIH0sXG4gKiAgICAgfSksXG4gKiAgIGlucHV0TWVzc2FnZXNLZXk6IFwicXVlc3Rpb25cIixcbiAqICAgaGlzdG9yeU1lc3NhZ2VzS2V5OiBcImhpc3RvcnlcIixcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluV2l0aEhpc3RvcnkuaW52b2tlKFxuICogICB7XG4gKiAgICAgYWJpbGl0eTogXCJtYXRoXCIsXG4gKiAgICAgcXVlc3Rpb246IFwiV2hhdCBkb2VzIGNvc2luZSBtZWFuP1wiLFxuICogICB9LFxuICogICB7XG4gKiAgICAgY29uZmlndXJhYmxlOiB7XG4gKiAgICAgICBzZXNzaW9uSWQ6IFwic29tZV9zdHJpbmdfaWRlbnRpZnlpbmdfYV91c2VyXCIsXG4gKiAgICAgfSxcbiAqICAgfVxuICogKTtcbiAqXG4gKiBjb25zdCByZXN1bHQyID0gYXdhaXQgY2hhaW5XaXRoSGlzdG9yeS5pbnZva2UoXG4gKiAgIHtcbiAqICAgICBhYmlsaXR5OiBcIm1hdGhcIixcbiAqICAgICBxdWVzdGlvbjogXCJXaGF0J3MgaXRzIGludmVyc2U/XCIsXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBjb25maWd1cmFibGU6IHtcbiAqICAgICAgIHNlc3Npb25JZDogXCJzb21lX3N0cmluZ19pZGVudGlmeWluZ19hX3VzZXJcIixcbiAqICAgICB9LFxuICogICB9XG4gKiApO1xuICogYGBgXG4gKi9cbmNsYXNzIFJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5IGV4dGVuZHMgYmFzZV9qc18xLlJ1bm5hYmxlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGxldCBoaXN0b3J5Q2hhaW4gPSBiYXNlX2pzXzEuUnVubmFibGVMYW1iZGEuZnJvbSgoaW5wdXQsIG9wdGlvbnMpID0+IHRoaXMuX2VudGVySGlzdG9yeShpbnB1dCwgb3B0aW9ucyA/PyB7fSkpLndpdGhDb25maWcoeyBydW5OYW1lOiBcImxvYWRIaXN0b3J5XCIgfSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzS2V5ID0gZmllbGRzLmhpc3RvcnlNZXNzYWdlc0tleSA/PyBmaWVsZHMuaW5wdXRNZXNzYWdlc0tleTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzS2V5KSB7XG4gICAgICAgICAgICBoaXN0b3J5Q2hhaW4gPSBwYXNzdGhyb3VnaF9qc18xLlJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgICAgICBbbWVzc2FnZXNLZXldOiBoaXN0b3J5Q2hhaW4sXG4gICAgICAgICAgICB9KS53aXRoQ29uZmlnKHsgcnVuTmFtZTogXCJpbnNlcnRIaXN0b3J5XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmQgPSBoaXN0b3J5Q2hhaW5cbiAgICAgICAgICAgIC5waXBlKGZpZWxkcy5ydW5uYWJsZS53aXRoTGlzdGVuZXJzKHtcbiAgICAgICAgICAgIG9uRW5kOiAocnVuLCBjb25maWcpID0+IHRoaXMuX2V4aXRIaXN0b3J5KHJ1biwgY29uZmlnID8/IHt9KSxcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAud2l0aENvbmZpZyh7IHJ1bk5hbWU6IFwiUnVubmFibGVXaXRoTWVzc2FnZUhpc3RvcnlcIiB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZmllbGRzLmNvbmZpZyA/PyB7fTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgYm91bmQsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dE1lc3NhZ2VzS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dE1lc3NhZ2VzS2V5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpc3RvcnlNZXNzYWdlc0tleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRNZXNzYWdlSGlzdG9yeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bm5hYmxlID0gZmllbGRzLnJ1bm5hYmxlO1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2VIaXN0b3J5ID0gZmllbGRzLmdldE1lc3NhZ2VIaXN0b3J5O1xuICAgICAgICB0aGlzLmlucHV0TWVzc2FnZXNLZXkgPSBmaWVsZHMuaW5wdXRNZXNzYWdlc0tleTtcbiAgICAgICAgdGhpcy5vdXRwdXRNZXNzYWdlc0tleSA9IGZpZWxkcy5vdXRwdXRNZXNzYWdlc0tleTtcbiAgICAgICAgdGhpcy5oaXN0b3J5TWVzc2FnZXNLZXkgPSBmaWVsZHMuaGlzdG9yeU1lc3NhZ2VzS2V5O1xuICAgIH1cbiAgICBfZ2V0SW5wdXRNZXNzYWdlcyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlucHV0VmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcnNlZElucHV0VmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgJiZcbiAgICAgICAgICAgICEoMCwgaW5kZXhfanNfMS5pc0Jhc2VNZXNzYWdlKShpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0TWVzc2FnZXNLZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmlucHV0TWVzc2FnZXNLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhpbnB1dFZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBPYmplY3Qua2V5cyhpbnB1dFZhbHVlKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiaW5wdXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0VmFsdWVba2V5XSkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlW2tleV1bMF0pKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRWYWx1ZSA9IGlucHV0VmFsdWVba2V5XVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZElucHV0VmFsdWUgPSBpbnB1dFZhbHVlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRJbnB1dFZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZElucHV0VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IGluZGV4X2pzXzEuSHVtYW5NZXNzYWdlKHBhcnNlZElucHV0VmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZElucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkSW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgaW5kZXhfanNfMS5pc0Jhc2VNZXNzYWdlKShwYXJzZWRJbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZWRJbnB1dFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcsIEJhc2VNZXNzYWdlLCBvciBhcnJheSBvZiBCYXNlTWVzc2FnZXMuXFxuR290ICR7SlNPTi5zdHJpbmdpZnkocGFyc2VkSW5wdXRWYWx1ZSwgbnVsbCwgMil9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldE91dHB1dE1lc3NhZ2VzKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb3V0cHV0VmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcnNlZE91dHB1dFZhbHVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0cHV0VmFsdWUpICYmXG4gICAgICAgICAgICAhKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkob3V0cHV0VmFsdWUpICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3V0cHV0VmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRNZXNzYWdlc0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5vdXRwdXRNZXNzYWdlc0tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKG91dHB1dFZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBPYmplY3Qua2V5cyhvdXRwdXRWYWx1ZSlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcIm91dHB1dFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgeW91IGFyZSB3cmFwcGluZyBhIGNoYXQgbW9kZWwgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIFRoZSBvdXRwdXQgaXMgYWN0dWFsbHkgdGhpcyB3ZWlyZCBnZW5lcmF0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIGlmIChvdXRwdXRWYWx1ZS5nZW5lcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZS5nZW5lcmF0aW9uc1swXVswXS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkT3V0cHV0VmFsdWUgPSBvdXRwdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZE91dHB1dFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBpbmRleF9qc18xLkFJTWVzc2FnZShwYXJzZWRPdXRwdXRWYWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkT3V0cHV0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkT3V0cHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGluZGV4X2pzXzEuaXNCYXNlTWVzc2FnZSkocGFyc2VkT3V0cHV0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnNlZE91dHB1dFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmcsIEJhc2VNZXNzYWdlLCBvciBhcnJheSBvZiBCYXNlTWVzc2FnZXMuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHBhcnNlZE91dHB1dFZhbHVlLCBudWxsLCAyKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW50ZXJIaXN0b3J5KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW5wdXQsIGt3YXJncykge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0ga3dhcmdzPy5jb25maWd1cmFibGU/Lm1lc3NhZ2VIaXN0b3J5O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGhpc3RvcnkuZ2V0TWVzc2FnZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlcy5jb25jYXQodGhpcy5fZ2V0SW5wdXRNZXNzYWdlcyhpbnB1dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG4gICAgYXN5bmMgX2V4aXRIaXN0b3J5KHJ1biwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBjb25maWcuY29uZmlndXJhYmxlPy5tZXNzYWdlSGlzdG9yeTtcbiAgICAgICAgLy8gR2V0IGlucHV0IG1lc3NhZ2VzXG4gICAgICAgIGxldCBpbnB1dHM7XG4gICAgICAgIC8vIENoYXQgbW9kZWwgaW5wdXRzIGFyZSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bi5pbnB1dHMpICYmIEFycmF5LmlzQXJyYXkocnVuLmlucHV0c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0cyA9IHJ1bi5pbnB1dHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dHMgPSBydW4uaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnB1dE1lc3NhZ2VzID0gdGhpcy5fZ2V0SW5wdXRNZXNzYWdlcyhpbnB1dHMpO1xuICAgICAgICAvLyBJZiBoaXN0b3JpYyBtZXNzYWdlcyB3ZXJlIHByZXBlbmRlZCB0byB0aGUgaW5wdXQgbWVzc2FnZXMsIHJlbW92ZSB0aGVtIHRvXG4gICAgICAgIC8vIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgbWVzc2FnZXMgdG8gaGlzdG9yeS5cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeU1lc3NhZ2VzS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWVzc2FnZXMgPSBhd2FpdCBoaXN0b3J5LmdldE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICBpbnB1dE1lc3NhZ2VzID0gaW5wdXRNZXNzYWdlcy5zbGljZShleGlzdGluZ01lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IG91dHB1dCBtZXNzYWdlc1xuICAgICAgICBjb25zdCBvdXRwdXRWYWx1ZSA9IHJ1bi5vdXRwdXRzO1xuICAgICAgICBpZiAoIW91dHB1dFZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCB2YWx1ZXMgZnJvbSAnUnVuJyB1bmRlZmluZWQuIFJ1bjogJHtKU09OLnN0cmluZ2lmeShydW4sIG51bGwsIDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dE1lc3NhZ2VzID0gdGhpcy5fZ2V0T3V0cHV0TWVzc2FnZXMob3V0cHV0VmFsdWUpO1xuICAgICAgICBhd2FpdCBoaXN0b3J5LmFkZE1lc3NhZ2VzKFsuLi5pbnB1dE1lc3NhZ2VzLCAuLi5vdXRwdXRNZXNzYWdlc10pO1xuICAgIH1cbiAgICBhc3luYyBfbWVyZ2VDb25maWcoLi4uY29uZmlncykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBhd2FpdCBzdXBlci5fbWVyZ2VDb25maWcoLi4uY29uZmlncyk7XG4gICAgICAgIC8vIEV4dHJhY3Qgc2Vzc2lvbklkXG4gICAgICAgIGlmICghY29uZmlnLmNvbmZpZ3VyYWJsZSB8fCAhY29uZmlnLmNvbmZpZ3VyYWJsZS5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVJbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBbdGhpcy5pbnB1dE1lc3NhZ2VzS2V5ID8/IFwiaW5wdXRcIl06IFwiZm9vXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUNvbmZpZyA9IHsgY29uZmlndXJhYmxlOiB7IHNlc3Npb25JZDogXCIxMjNcIiB9IH07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNlc3Npb25JZCBpcyByZXF1aXJlZC4gUGFzcyBpdCBpbiBhcyBwYXJ0IG9mIHRoZSBjb25maWcgYXJndW1lbnQgdG8gLmludm9rZSgpIG9yIC5zdHJlYW0oKVxcbmAgK1xuICAgICAgICAgICAgICAgIGBlZy4gY2hhaW4uaW52b2tlKCR7SlNPTi5zdHJpbmdpZnkoZXhhbXBsZUlucHV0KX0sICR7SlNPTi5zdHJpbmdpZnkoZXhhbXBsZUNvbmZpZyl9KWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBtZXNzYWdlSGlzdG9yeVxuICAgICAgICBjb25zdCB7IHNlc3Npb25JZCB9ID0gY29uZmlnLmNvbmZpZ3VyYWJsZTtcbiAgICAgICAgY29uZmlnLmNvbmZpZ3VyYWJsZS5tZXNzYWdlSGlzdG9yeSA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnZUhpc3Rvcnkoc2Vzc2lvbklkKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5ID0gUnVubmFibGVXaXRoTWVzc2FnZUhpc3Rvcnk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/index.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnableWithMessageHistory = exports.RunnableBranch = exports.RouterRunnable = exports.RunnablePassthrough = exports.pickRunnableConfigKeys = exports.mergeConfigs = exports.ensureConfig = exports.patchConfig = exports.getCallbackManagerForConfig = exports.RunnableToolLike = exports._coerceToRunnable = exports.RunnablePick = exports.RunnableAssign = exports.RunnableWithFallbacks = exports.RunnableLambda = exports.RunnableParallel = exports.RunnableMap = exports.RunnableSequence = exports.RunnableRetry = exports.RunnableEach = exports.RunnableBinding = exports.Runnable = void 0;\nvar base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nObject.defineProperty(exports, \"Runnable\", ({ enumerable: true, get: function () { return base_js_1.Runnable; } }));\nObject.defineProperty(exports, \"RunnableBinding\", ({ enumerable: true, get: function () { return base_js_1.RunnableBinding; } }));\nObject.defineProperty(exports, \"RunnableEach\", ({ enumerable: true, get: function () { return base_js_1.RunnableEach; } }));\nObject.defineProperty(exports, \"RunnableRetry\", ({ enumerable: true, get: function () { return base_js_1.RunnableRetry; } }));\nObject.defineProperty(exports, \"RunnableSequence\", ({ enumerable: true, get: function () { return base_js_1.RunnableSequence; } }));\nObject.defineProperty(exports, \"RunnableMap\", ({ enumerable: true, get: function () { return base_js_1.RunnableMap; } }));\nObject.defineProperty(exports, \"RunnableParallel\", ({ enumerable: true, get: function () { return base_js_1.RunnableParallel; } }));\nObject.defineProperty(exports, \"RunnableLambda\", ({ enumerable: true, get: function () { return base_js_1.RunnableLambda; } }));\nObject.defineProperty(exports, \"RunnableWithFallbacks\", ({ enumerable: true, get: function () { return base_js_1.RunnableWithFallbacks; } }));\nObject.defineProperty(exports, \"RunnableAssign\", ({ enumerable: true, get: function () { return base_js_1.RunnableAssign; } }));\nObject.defineProperty(exports, \"RunnablePick\", ({ enumerable: true, get: function () { return base_js_1.RunnablePick; } }));\nObject.defineProperty(exports, \"_coerceToRunnable\", ({ enumerable: true, get: function () { return base_js_1._coerceToRunnable; } }));\nObject.defineProperty(exports, \"RunnableToolLike\", ({ enumerable: true, get: function () { return base_js_1.RunnableToolLike; } }));\nvar config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nObject.defineProperty(exports, \"getCallbackManagerForConfig\", ({ enumerable: true, get: function () { return config_js_1.getCallbackManagerForConfig; } }));\nObject.defineProperty(exports, \"patchConfig\", ({ enumerable: true, get: function () { return config_js_1.patchConfig; } }));\nObject.defineProperty(exports, \"ensureConfig\", ({ enumerable: true, get: function () { return config_js_1.ensureConfig; } }));\nObject.defineProperty(exports, \"mergeConfigs\", ({ enumerable: true, get: function () { return config_js_1.mergeConfigs; } }));\nObject.defineProperty(exports, \"pickRunnableConfigKeys\", ({ enumerable: true, get: function () { return config_js_1.pickRunnableConfigKeys; } }));\nvar passthrough_js_1 = __webpack_require__(/*! ./passthrough.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\");\nObject.defineProperty(exports, \"RunnablePassthrough\", ({ enumerable: true, get: function () { return passthrough_js_1.RunnablePassthrough; } }));\nvar router_js_1 = __webpack_require__(/*! ./router.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\");\nObject.defineProperty(exports, \"RouterRunnable\", ({ enumerable: true, get: function () { return router_js_1.RouterRunnable; } }));\nvar branch_js_1 = __webpack_require__(/*! ./branch.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/branch.cjs\");\nObject.defineProperty(exports, \"RunnableBranch\", ({ enumerable: true, get: function () { return branch_js_1.RunnableBranch; } }));\nvar history_js_1 = __webpack_require__(/*! ./history.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/history.cjs\");\nObject.defineProperty(exports, \"RunnableWithMessageHistory\", ({ enumerable: true, get: function () { return history_js_1.RunnableWithMessageHistory; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDcmtCLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3BDLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCxtREFBa0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDL0gsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrREFBaUQsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDN0gseURBQXdELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzNJLGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBYztBQUN4QywrREFBOEQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDekosK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsMERBQXlELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQy9JLHVCQUF1QixtQkFBTyxDQUFDLDhGQUFtQjtBQUNsRCx1REFBc0QsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDOUksa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWM7QUFDeEMsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILGtCQUFrQixtQkFBTyxDQUFDLG9GQUFjO0FBQ3hDLGtEQUFpRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMvSCxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBZTtBQUMxQyw4REFBNkQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5ID0gZXhwb3J0cy5SdW5uYWJsZUJyYW5jaCA9IGV4cG9ydHMuUm91dGVyUnVubmFibGUgPSBleHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSBleHBvcnRzLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMgPSBleHBvcnRzLm1lcmdlQ29uZmlncyA9IGV4cG9ydHMuZW5zdXJlQ29uZmlnID0gZXhwb3J0cy5wYXRjaENvbmZpZyA9IGV4cG9ydHMuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnID0gZXhwb3J0cy5SdW5uYWJsZVRvb2xMaWtlID0gZXhwb3J0cy5fY29lcmNlVG9SdW5uYWJsZSA9IGV4cG9ydHMuUnVubmFibGVQaWNrID0gZXhwb3J0cy5SdW5uYWJsZUFzc2lnbiA9IGV4cG9ydHMuUnVubmFibGVXaXRoRmFsbGJhY2tzID0gZXhwb3J0cy5SdW5uYWJsZUxhbWJkYSA9IGV4cG9ydHMuUnVubmFibGVQYXJhbGxlbCA9IGV4cG9ydHMuUnVubmFibGVNYXAgPSBleHBvcnRzLlJ1bm5hYmxlU2VxdWVuY2UgPSBleHBvcnRzLlJ1bm5hYmxlUmV0cnkgPSBleHBvcnRzLlJ1bm5hYmxlRWFjaCA9IGV4cG9ydHMuUnVubmFibGVCaW5kaW5nID0gZXhwb3J0cy5SdW5uYWJsZSA9IHZvaWQgMDtcbnZhciBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUJpbmRpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUJpbmRpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUVhY2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUVhY2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVJldHJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVSZXRyeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlU2VxdWVuY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVNlcXVlbmNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZU1hcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlUGFyYWxsZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVBhcmFsbGVsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVMYW1iZGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZUxhbWJkYTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlV2l0aEZhbGxiYWNrczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bm5hYmxlQXNzaWduXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX2pzXzEuUnVubmFibGVBc3NpZ247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVBpY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfanNfMS5SdW5uYWJsZVBpY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfY29lcmNlVG9SdW5uYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLl9jb2VyY2VUb1J1bm5hYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVUb29sTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZV9qc18xLlJ1bm5hYmxlVG9vbExpa2U7IH0gfSk7XG52YXIgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXRjaENvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEucGF0Y2hDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnN1cmVDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lcmdlQ29uZmlnc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEubWVyZ2VDb25maWdzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGlja1J1bm5hYmxlQ29uZmlnS2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5czsgfSB9KTtcbnZhciBwYXNzdGhyb3VnaF9qc18xID0gcmVxdWlyZShcIi4vcGFzc3Rocm91Z2guY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUnVubmFibGVQYXNzdGhyb3VnaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFzc3Rocm91Z2hfanNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoOyB9IH0pO1xudmFyIHJvdXRlcl9qc18xID0gcmVxdWlyZShcIi4vcm91dGVyLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlclJ1bm5hYmxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXJfanNfMS5Sb3V0ZXJSdW5uYWJsZTsgfSB9KTtcbnZhciBicmFuY2hfanNfMSA9IHJlcXVpcmUoXCIuL2JyYW5jaC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZUJyYW5jaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJhbmNoX2pzXzEuUnVubmFibGVCcmFuY2g7IH0gfSk7XG52YXIgaGlzdG9yeV9qc18xID0gcmVxdWlyZShcIi4vaGlzdG9yeS5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSdW5uYWJsZVdpdGhNZXNzYWdlSGlzdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGlzdG9yeV9qc18xLlJ1bm5hYmxlV2l0aE1lc3NhZ2VIaXN0b3J5OyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/iter.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isIterator = void 0;\nexports.isIterableIterator = isIterableIterator;\nexports.isAsyncIterable = isAsyncIterable;\nexports.consumeIteratorInContext = consumeIteratorInContext;\nexports.consumeAsyncIterableInContext = consumeAsyncIterableInContext;\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nfunction isIterableIterator(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.iterator] === \"function\" &&\n        // avoid detecting array/set as iterator\n        typeof thing.next === \"function\");\n}\nconst isIterator = (x) => x != null &&\n    typeof x === \"object\" &&\n    \"next\" in x &&\n    typeof x.next === \"function\";\nexports.isIterator = isIterator;\nfunction isAsyncIterable(thing) {\n    return (typeof thing === \"object\" &&\n        thing !== null &&\n        typeof thing[Symbol.asyncIterator] ===\n            \"function\");\n}\nfunction* consumeIteratorInContext(context, iter) {\n    while (true) {\n        const { value, done } = index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(context), iter.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\nasync function* consumeAsyncIterableInContext(context, iter) {\n    const iterator = iter[Symbol.asyncIterator]();\n    while (true) {\n        const { value, done } = await index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(context), iterator.next.bind(iter), true);\n        if (done) {\n            break;\n        }\n        else {\n            yield value;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2l0ZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvaXRlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSXRlcmF0b3IgPSB2b2lkIDA7XG5leHBvcnRzLmlzSXRlcmFibGVJdGVyYXRvciA9IGlzSXRlcmFibGVJdGVyYXRvcjtcbmV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gaXNBc3luY0l0ZXJhYmxlO1xuZXhwb3J0cy5jb25zdW1lSXRlcmF0b3JJbkNvbnRleHQgPSBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQ7XG5leHBvcnRzLmNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0ID0gY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQ7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi9jb25maWcuY2pzXCIpO1xuZnVuY3Rpb24gaXNJdGVyYWJsZUl0ZXJhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdGhpbmcgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyBhdm9pZCBkZXRlY3RpbmcgYXJyYXkvc2V0IGFzIGl0ZXJhdG9yXG4gICAgICAgIHR5cGVvZiB0aGluZy5uZXh0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuY29uc3QgaXNJdGVyYXRvciA9ICh4KSA9PiB4ICE9IG51bGwgJiZcbiAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIFwibmV4dFwiIGluIHggJiZcbiAgICB0eXBlb2YgeC5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnRzLmlzSXRlcmF0b3IgPSBpc0l0ZXJhdG9yO1xuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHRoaW5nKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdGhpbmcgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHRoaW5nW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiogY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykoY29udGV4dCksIGl0ZXIubmV4dC5iaW5kKGl0ZXIpLCB0cnVlKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiogY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQoY29udGV4dCwgaXRlcikge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykoY29udGV4dCksIGl0ZXJhdG9yLm5leHQuYmluZChpdGVyKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/iter.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/passthrough.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RunnablePassthrough = void 0;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass RunnablePassthrough extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = (0, config_js_1.ensureConfig)(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = (0, stream_js_1.concat)(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new base_js_1.RunnableAssign(new base_js_1.RunnableMap({ steps: mapping }));\n    }\n}\nexports.RunnablePassthrough = RunnablePassthrough;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3Bhc3N0aHJvdWdoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLHNCQUFzQixlQUFlLHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0JBQWdCO0FBQ3hGO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSB2b2lkIDA7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZy5janNcIik7XG4vKipcbiAqIEEgcnVubmFibGUgdG8gcGFzc3Rocm91Z2ggaW5wdXRzIHVuY2hhbmdlZCBvciB3aXRoIGFkZGl0aW9uYWwga2V5cy5cbiAqXG4gKiBUaGlzIHJ1bm5hYmxlIGJlaGF2ZXMgYWxtb3N0IGxpa2UgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLCBleGNlcHQgdGhhdCBpdFxuICogY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYWRkIGFkZGl0aW9uYWwga2V5cyB0byB0aGUgb3V0cHV0LCBpZiB0aGUgaW5wdXQgaXNcbiAqIGFuIG9iamVjdC5cbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHVzZSBgUnVubmFibGVQYXNzdGhyb3VnaCB0b1xuICogcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNoYWluID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAqICAge1xuICogICAgIHF1ZXN0aW9uOiBuZXcgUnVubmFibGVQYXNzdGhyb3VnaCgpLFxuICogICAgIGNvbnRleHQ6IGFzeW5jICgpID0+IGxvYWRDb250ZXh0RnJvbVN0b3JlKCksXG4gKiAgIH0sXG4gKiAgIHByb21wdCxcbiAqICAgbGxtLFxuICogICBvdXRwdXRQYXJzZXIsXG4gKiBdKTtcbiAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhaW4uaW52b2tlKFxuICogICBcIkkgY2FuIHBhc3MgYSBzaW5nbGUgc3RyaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHNpbmNlIEknbSB1c2luZyBgUnVubmFibGVQYXNzdGhyb3VnaGAuXCJcbiAqICk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNsYXNzIFJ1bm5hYmxlUGFzc3Rocm91Z2ggZXh0ZW5kcyBiYXNlX2pzXzEuUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBhc3N0aHJvdWdoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZ1bmNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5mdW5jKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKChpbnB1dCkgPT4gUHJvbWlzZS5yZXNvbHZlKGlucHV0KSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIChpbnB1dCkgPT4gaW5wdXQsIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSAoMCwgc3RyZWFtX2pzXzEuY29uY2F0KShmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mdW5jICYmIGZpbmFsT3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZnVuYyhmaW5hbE91dHB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gdGhlIGlucHV0LlxuICAgICAqXG4gICAgICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd3MgaG93IHlvdSBjb3VsZCB1c2UgaXQgd2l0aCBhbiBpbmxpbmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm9tcHQgPVxuICAgICAqICAgUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGBXcml0ZSBhIFNRTCBxdWVyeSB0byBhbnN3ZXIgdGhlIHF1ZXN0aW9uIHVzaW5nIHRoZSBmb2xsb3dpbmcgc2NoZW1hOiB7c2NoZW1hfVxuICAgICAqIFF1ZXN0aW9uOiB7cXVlc3Rpb259XG4gICAgICogU1FMIFF1ZXJ5OmApO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbigpYCBpcyB1c2VkIGhlcmUgdG8gcGFzc3Rocm91Z2ggdGhlIGlucHV0IGZyb20gdGhlIGAuaW52b2tlKClgXG4gICAgICogLy8gY2FsbCAoaW4gdGhpcyBleGFtcGxlIGl0J3MgdGhlIHF1ZXN0aW9uKSwgYWxvbmcgd2l0aCBhbnkgaW5wdXRzIHBhc3NlZCB0byB0aGUgYC5hc3NpZ24oKWAgbWV0aG9kLlxuICAgICAqIC8vIEluIHRoaXMgY2FzZSwgd2UncmUgcGFzc2luZyB0aGUgc2NoZW1hLlxuICAgICAqIGNvbnN0IHNxbFF1ZXJ5R2VuZXJhdG9yQ2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICAgICAqICAgUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAqICAgICBzY2hlbWE6IGFzeW5jICgpID0+IGRiLmdldFRhYmxlSW5mbygpLFxuICAgICAqICAgfSksXG4gICAgICogICBwcm9tcHQsXG4gICAgICogICBuZXcgQ2hhdE9wZW5BSSh7IG1vZGVsOiBcImdwdC00by1taW5pXCIgfSkud2l0aENvbmZpZyh7IHN0b3A6IFtcIlxcblNRTFJlc3VsdDpcIl0gfSksXG4gICAgICogICBuZXcgU3RyaW5nT3V0cHV0UGFyc2VyKCksXG4gICAgICogXSk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc3FsUXVlcnlHZW5lcmF0b3JDaGFpbi5pbnZva2Uoe1xuICAgICAqICAgcXVlc3Rpb246IFwiSG93IG1hbnkgZW1wbG95ZWVzIGFyZSB0aGVyZT9cIixcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzaWduKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBiYXNlX2pzXzEuUnVubmFibGVBc3NpZ24obmV3IGJhc2VfanNfMS5SdW5uYWJsZU1hcCh7IHN0ZXBzOiBtYXBwaW5nIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLlJ1bm5hYmxlUGFzc3Rocm91Z2ggPSBSdW5uYWJsZVBhc3N0aHJvdWdoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/passthrough.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/remote.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../documents/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\");\nconst prompt_values_js_1 = __webpack_require__(/*! ../prompt_values.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/prompt_values.cjs\");\nconst log_stream_js_1 = __webpack_require__(/*! ../tracers/log_stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\");\nconst index_js_2 = __webpack_require__(/*! ../messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nconst event_source_parse_js_1 = __webpack_require__(/*! ../utils/event_source_parse.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction isSuperset(set, subset) {\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction revive(obj) {\n    if (Array.isArray(obj))\n        return obj.map(revive);\n    if (typeof obj === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!obj || obj instanceof Date) {\n            return obj;\n        }\n        const keysArr = Object.keys(obj);\n        const keys = new Set(keysArr);\n        if (isSuperset(keys, new Set([\"page_content\", \"metadata\"]))) {\n            return new index_js_1.Document({\n                pageContent: obj.page_content,\n                metadata: obj.metadata,\n            });\n        }\n        if (isSuperset(keys, new Set([\"content\", \"type\", \"additional_kwargs\"]))) {\n            if (obj.type === \"HumanMessage\" || obj.type === \"human\") {\n                return new index_js_2.HumanMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessage\" || obj.type === \"system\") {\n                return new index_js_2.SystemMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessage\" || obj.type === \"generic\") {\n                return new index_js_2.ChatMessage({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessage\" || obj.type === \"function\") {\n                return new index_js_2.FunctionMessage({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessage\" || obj.type === \"tool\") {\n                return new index_js_2.ToolMessage({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                    artifact: obj.artifact,\n                });\n            }\n            if (obj.type === \"AIMessage\" || obj.type === \"ai\") {\n                return new index_js_2.AIMessage({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"HumanMessageChunk\") {\n                return new index_js_2.HumanMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"SystemMessageChunk\") {\n                return new index_js_2.SystemMessageChunk({\n                    content: obj.content,\n                });\n            }\n            if (obj.type === \"ChatMessageChunk\") {\n                return new index_js_2.ChatMessageChunk({\n                    content: obj.content,\n                    role: obj.role,\n                });\n            }\n            if (obj.type === \"FunctionMessageChunk\") {\n                return new index_js_2.FunctionMessageChunk({\n                    content: obj.content,\n                    name: obj.name,\n                });\n            }\n            if (obj.type === \"ToolMessageChunk\") {\n                return new index_js_2.ToolMessageChunk({\n                    content: obj.content,\n                    tool_call_id: obj.tool_call_id,\n                    status: obj.status,\n                    artifact: obj.artifact,\n                });\n            }\n            if (obj.type === \"AIMessageChunk\") {\n                return new index_js_2.AIMessageChunk({\n                    content: obj.content,\n                });\n            }\n        }\n        if (isSuperset(keys, new Set([\"text\", \"generation_info\", \"type\"]))) {\n            if (obj.type === \"ChatGenerationChunk\") {\n                return new outputs_js_1.ChatGenerationChunk({\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"ChatGeneration\") {\n                return {\n                    message: revive(obj.message),\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n            else if (obj.type === \"GenerationChunk\") {\n                return new outputs_js_1.GenerationChunk({\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                });\n            }\n            else if (obj.type === \"Generation\") {\n                return {\n                    text: obj.text,\n                    generationInfo: obj.generation_info,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"tool\", \"tool_input\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentAction\") {\n                return {\n                    tool: obj.tool,\n                    toolInput: obj.tool_input,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"return_values\", \"log\", \"type\"]))) {\n            if (obj.type === \"AgentFinish\") {\n                return {\n                    returnValues: obj.return_values,\n                    log: obj.log,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"generations\", \"run\", \"type\"]))) {\n            if (obj.type === \"LLMResult\") {\n                return {\n                    generations: revive(obj.generations),\n                    llmOutput: obj.llm_output,\n                    [outputs_js_1.RUN_KEY]: obj.run,\n                };\n            }\n        }\n        if (isSuperset(keys, new Set([\"messages\"]))) {\n            // TODO: Start checking for type: ChatPromptValue and ChatPromptValueConcrete\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.ChatPromptValue({\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                messages: obj.messages.map((msg) => revive(msg)),\n            });\n        }\n        if (isSuperset(keys, new Set([\"text\"]))) {\n            // TODO: Start checking for type: StringPromptValue\n            // when LangServe bug is fixed\n            return new prompt_values_js_1.StringPromptValue(obj.text);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerRevive = (key) => [\n            key,\n            revive(obj[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerRevive));\n        return rtn;\n    }\n    return obj;\n}\nfunction deserialize(str) {\n    const obj = JSON.parse(str);\n    return revive(obj);\n}\nfunction removeCallbacksAndSignal(options) {\n    const rest = { ...options };\n    delete rest.callbacks;\n    delete rest.signal;\n    return rest;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction serialize(input) {\n    if (Array.isArray(input))\n        return input.map(serialize);\n    if ((0, index_js_2.isBaseMessage)(input)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const serializedMessage = {\n            content: input.content,\n            type: input._getType(),\n            additional_kwargs: input.additional_kwargs,\n            name: input.name,\n            example: false,\n        };\n        if (index_js_2.ToolMessage.isInstance(input)) {\n            serializedMessage.tool_call_id = input.tool_call_id;\n        }\n        else if (index_js_2.ChatMessage.isInstance(input)) {\n            serializedMessage.role = input.role;\n        }\n        return serializedMessage;\n    }\n    if (typeof input === \"object\") {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!input || input instanceof Date) {\n            return input;\n        }\n        const keysArr = Object.keys(input);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const innerSerialize = (key) => [\n            key,\n            serialize(input[key]),\n        ];\n        const rtn = Object.fromEntries(keysArr.map(innerSerialize));\n        return rtn;\n    }\n    return input;\n}\n/**\n * Client for interacting with LangChain runnables\n * that are hosted as LangServe endpoints.\n *\n * Allows you to interact with hosted runnables using the standard\n * `.invoke()`, `.stream()`, `.streamEvents()`, etc. methods that\n * other runnables support.\n *\n * @deprecated LangServe is no longer actively developed - please consider using LangGraph Platform.\n *\n * @param url - The base URL of the LangServe endpoint.\n * @param options - Optional configuration for the remote runnable, including timeout and headers.\n * @param fetch - Optional custom fetch implementation.\n * @param fetchRequestOptions - Optional additional options for fetch requests.\n */\nclass RemoteRunnable extends base_js_1.Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // Wrap the default fetch call due to issues with illegal invocations\n        // from the browser:\n        // https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (...args) => \n            // @ts-expect-error Broad typing to support a range of fetch implementations\n            fetch(...args)\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"fetchRequestOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\", \"remote\"]\n        });\n        const { url, options, fetch: fetchImplementation, fetchRequestOptions, } = fields;\n        this.url = url.replace(/\\/$/, \"\"); // remove trailing slash\n        this.options = options;\n        this.fetchImplementation = fetchImplementation ?? this.fetchImplementation;\n        this.fetchRequestOptions = fetchRequestOptions;\n    }\n    async post(path, body, signal) {\n        return this.fetchImplementation(`${this.url}${path}`, {\n            method: \"POST\",\n            body: JSON.stringify(serialize(body)),\n            signal: signal ?? AbortSignal.timeout(this.options?.timeout ?? 60000),\n            ...this.fetchRequestOptions,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this.fetchRequestOptions?.headers,\n                ...this.options?.headers,\n            },\n        });\n    }\n    async _invoke(input, options, _) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const response = await this.post(\"/invoke\", {\n            input,\n            config: removeCallbacksAndSignal(config),\n            kwargs: kwargs ?? {},\n        }, config.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        return revive((await response.json()).output);\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async _batch(inputs, options, _, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"returnExceptions is not supported for remote clients\");\n        }\n        const configsAndKwargsArray = options?.map((opts) => this._separateRunnableConfigFromCallOptions(opts));\n        const [configs, kwargs] = configsAndKwargsArray?.reduce(([pc, pk], [c, k]) => [\n            [...pc, c],\n            [...pk, k],\n        ], [[], []]) ?? [undefined, undefined];\n        const response = await this.post(\"/batch\", {\n            inputs,\n            config: (configs ?? [])\n                .map(removeCallbacksAndSignal)\n                .map((config) => ({ ...config, ...batchOptions })),\n            kwargs,\n        }, options?.[0]?.signal);\n        if (!response.ok) {\n            throw new Error(`${response.status} Error: ${await response.text()}`);\n        }\n        const body = await response.json();\n        if (!body.output)\n            throw new Error(\"Invalid response from remote runnable\");\n        return revive(body.output);\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw Error(\"returnExceptions is not supported for remote clients\");\n        }\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let finalOutput;\n        let finalOutputSupported = true;\n        try {\n            const response = await this.post(\"/stream\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n            }, config.signal);\n            if (!response.ok) {\n                const json = await response.json();\n                const error = new Error(`RemoteRunnable call failed with status code ${response.status}: ${json.message}`);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                error.response = response;\n                throw error;\n            }\n            const { body } = response;\n            if (!body) {\n                throw new Error(\"Could not begin remote stream. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const chunk of runnableStream) {\n                const deserializedChunk = deserialize(chunk);\n                yield deserializedChunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = deserializedChunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = (0, stream_js_1.concat)(finalOutput, deserializedChunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n    async *streamLog(input, options, streamOptions) {\n        const [config, kwargs] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        // The type is in camelCase but the API only accepts snake_case.\n        const camelCaseStreamOptions = {\n            include_names: streamOptions?.includeNames,\n            include_types: streamOptions?.includeTypes,\n            include_tags: streamOptions?.includeTags,\n            exclude_names: streamOptions?.excludeNames,\n            exclude_types: streamOptions?.excludeTypes,\n            exclude_tags: streamOptions?.excludeTags,\n        };\n        let runLog;\n        try {\n            const response = await this.post(\"/stream_log\", {\n                input,\n                config: removeCallbacksAndSignal(config),\n                kwargs,\n                ...camelCaseStreamOptions,\n                diff: false,\n            }, config.signal);\n            const { body, ok } = response;\n            if (!ok) {\n                throw new Error(`${response.status} Error: ${await response.text()}`);\n            }\n            if (!body) {\n                throw new Error(\"Could not begin remote stream log. Please check the given URL and try again.\");\n            }\n            const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n            for await (const log of runnableStream) {\n                const chunk = revive(JSON.parse(log));\n                const logPatch = new log_stream_js_1.RunLogPatch({ ops: chunk.ops });\n                yield logPatch;\n                if (runLog === undefined) {\n                    runLog = log_stream_js_1.RunLog.fromRunLogPatch(logPatch);\n                }\n                else {\n                    runLog = runLog.concat(logPatch);\n                }\n            }\n        }\n        catch (err) {\n            await runManager?.handleChainError(err);\n            throw err;\n        }\n        await runManager?.handleChainEnd(runLog?.state.final_output);\n    }\n    _streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            const [config, kwargs] = outerThis._separateRunnableConfigFromCallOptions(options);\n            const callbackManager_ = await (0, config_js_1.getCallbackManagerForConfig)(options);\n            const runManager = await callbackManager_?.handleChainStart(outerThis.toJSON(), (0, base_js_1._coerceToDict)(input, \"input\"), config.runId, undefined, undefined, undefined, config.runName);\n            delete config.runId;\n            // The type is in camelCase but the API only accepts snake_case.\n            const camelCaseStreamOptions = {\n                include_names: streamOptions?.includeNames,\n                include_types: streamOptions?.includeTypes,\n                include_tags: streamOptions?.includeTags,\n                exclude_names: streamOptions?.excludeNames,\n                exclude_types: streamOptions?.excludeTypes,\n                exclude_tags: streamOptions?.excludeTags,\n            };\n            const events = [];\n            try {\n                const response = await outerThis.post(\"/stream_events\", {\n                    input,\n                    config: removeCallbacksAndSignal(config),\n                    kwargs,\n                    ...camelCaseStreamOptions,\n                    diff: false,\n                }, config.signal);\n                const { body, ok } = response;\n                if (!ok) {\n                    throw new Error(`${response.status} Error: ${await response.text()}`);\n                }\n                if (!body) {\n                    throw new Error(\"Could not begin remote stream events. Please check the given URL and try again.\");\n                }\n                const runnableStream = (0, event_source_parse_js_1.convertEventStreamToIterableReadableDataStream)(body);\n                for await (const log of runnableStream) {\n                    const chunk = revive(JSON.parse(log));\n                    const event = {\n                        event: chunk.event,\n                        name: chunk.name,\n                        run_id: chunk.run_id,\n                        tags: chunk.tags,\n                        metadata: chunk.metadata,\n                        data: chunk.data,\n                    };\n                    yield event;\n                    events.push(event);\n                }\n            }\n            catch (err) {\n                await runManager?.handleChainError(err);\n                throw err;\n            }\n            await runManager?.handleChainEnd(events);\n        };\n        return generator();\n    }\n    streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\" && options.version !== \"v2\") {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the events schema is currently supported.`);\n        }\n        if (options.encoding !== undefined) {\n            throw new Error(\"Special encodings are not supported for this runnable.\");\n        }\n        const eventStream = this._streamEvents(input, options, streamOptions);\n        return stream_js_1.IterableReadableStream.fromAsyncGenerator(eventStream);\n    }\n}\nexports.RemoteRunnable = RemoteRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JlbW90ZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDZGQUF3QjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsbUdBQTJCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDN0MsZ0NBQWdDLG1CQUFPLENBQUMsK0dBQWlDO0FBQ3pFLG9CQUFvQixtQkFBTyxDQUFDLHVGQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixpRUFBaUU7QUFDakYsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxFQUFFLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFNBQVM7QUFDVDtBQUNBLCtCQUErQixpQkFBaUIsU0FBUyxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0JBQStCLGlCQUFpQixTQUFTLHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVGQUF1RixnQkFBZ0IsSUFBSSxhQUFhO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0IsV0FBVztBQUMvQjtBQUNBLG1DQUFtQyxpQkFBaUIsU0FBUyxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0EsdUNBQXVDLGlCQUFpQixTQUFTLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvcmVtb3RlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlUnVubmFibGUgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vZG9jdW1lbnRzL2luZGV4LmNqc1wiKTtcbmNvbnN0IHByb21wdF92YWx1ZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm9tcHRfdmFsdWVzLmNqc1wiKTtcbmNvbnN0IGxvZ19zdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi90cmFjZXJzL2xvZ19zdHJlYW0uY2pzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9pbmRleC5janNcIik7XG5jb25zdCBvdXRwdXRzX2pzXzEgPSByZXF1aXJlKFwiLi4vb3V0cHV0cy5janNcIik7XG5jb25zdCBldmVudF9zb3VyY2VfcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9ldmVudF9zb3VyY2VfcGFyc2UuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmZ1bmN0aW9uIGlzU3VwZXJzZXQoc2V0LCBzdWJzZXQpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3Vic2V0KSB7XG4gICAgICAgIGlmICghc2V0LmhhcyhlbGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHJldml2ZShvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gb2JqLm1hcChyZXZpdmUpO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKCFvYmogfHwgb2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzQXJyID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoa2V5c0Fycik7XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1wicGFnZV9jb250ZW50XCIsIFwibWV0YWRhdGFcIl0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18xLkRvY3VtZW50KHtcbiAgICAgICAgICAgICAgICBwYWdlQ29udGVudDogb2JqLnBhZ2VfY29udGVudCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb2JqLm1ldGFkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJjb250ZW50XCIsIFwidHlwZVwiLCBcImFkZGl0aW9uYWxfa3dhcmdzXCJdKSkpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJIdW1hbk1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkh1bWFuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIlN5c3RlbU1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5TeXN0ZW1NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQ2hhdE1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuQ2hhdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogb2JqLnJvbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiRnVuY3Rpb25NZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5GdW5jdGlvbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogb2JqLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiVG9vbE1lc3NhZ2VcIiB8fCBvYmoudHlwZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuVG9vbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiBvYmoudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG9iai5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGFydGlmYWN0OiBvYmouYXJ0aWZhY3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQUlNZXNzYWdlXCIgfHwgb2JqLnR5cGUgPT09IFwiYWlcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5BSU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJIdW1hbk1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkh1bWFuTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiU3lzdGVtTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuU3lzdGVtTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQ2hhdE1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkNoYXRNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBvYmouY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogb2JqLnJvbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiRnVuY3Rpb25NZXNzYWdlQ2h1bmtcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5GdW5jdGlvbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvYmoubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJUb29sTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGluZGV4X2pzXzIuVG9vbE1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IG9iai50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogb2JqLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgYXJ0aWZhY3Q6IG9iai5hcnRpZmFjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJBSU1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbmRleF9qc18yLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb2JqLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJ0ZXh0XCIsIFwiZ2VuZXJhdGlvbl9pbmZvXCIsIFwidHlwZVwiXSkpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQ2hhdEdlbmVyYXRpb25DaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzX2pzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJldml2ZShvYmoubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogb2JqLmdlbmVyYXRpb25faW5mbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai50eXBlID09PSBcIkNoYXRHZW5lcmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXZpdmUob2JqLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvYmoudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IG9iai5nZW5lcmF0aW9uX2luZm8sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai50eXBlID09PSBcIkdlbmVyYXRpb25DaHVua1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzX2pzXzEuR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb2JqLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiBvYmouZ2VuZXJhdGlvbl9pbmZvLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2JqLnR5cGUgPT09IFwiR2VuZXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb2JqLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiBvYmouZ2VuZXJhdGlvbl9pbmZvLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJ0b29sXCIsIFwidG9vbF9pbnB1dFwiLCBcImxvZ1wiLCBcInR5cGVcIl0pKSkge1xuICAgICAgICAgICAgaWYgKG9iai50eXBlID09PSBcIkFnZW50QWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sOiBvYmoudG9vbCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbElucHV0OiBvYmoudG9vbF9pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBvYmoubG9nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3VwZXJzZXQoa2V5cywgbmV3IFNldChbXCJyZXR1cm5fdmFsdWVzXCIsIFwibG9nXCIsIFwidHlwZVwiXSkpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiQWdlbnRGaW5pc2hcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlczogb2JqLnJldHVybl92YWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIGxvZzogb2JqLmxvZyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1wiZ2VuZXJhdGlvbnNcIiwgXCJydW5cIiwgXCJ0eXBlXCJdKSkpIHtcbiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJMTE1SZXN1bHRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiByZXZpdmUob2JqLmdlbmVyYXRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0OiBvYmoubGxtX291dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgW291dHB1dHNfanNfMS5SVU5fS0VZXTogb2JqLnJ1bixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1wibWVzc2FnZXNcIl0pKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogU3RhcnQgY2hlY2tpbmcgZm9yIHR5cGU6IENoYXRQcm9tcHRWYWx1ZSBhbmQgQ2hhdFByb21wdFZhbHVlQ29uY3JldGVcbiAgICAgICAgICAgIC8vIHdoZW4gTGFuZ1NlcnZlIGJ1ZyBpcyBmaXhlZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9tcHRfdmFsdWVzX2pzXzEuQ2hhdFByb21wdFZhbHVlKHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBvYmoubWVzc2FnZXMubWFwKChtc2cpID0+IHJldml2ZShtc2cpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N1cGVyc2V0KGtleXMsIG5ldyBTZXQoW1widGV4dFwiXSkpKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBTdGFydCBjaGVja2luZyBmb3IgdHlwZTogU3RyaW5nUHJvbXB0VmFsdWVcbiAgICAgICAgICAgIC8vIHdoZW4gTGFuZ1NlcnZlIGJ1ZyBpcyBmaXhlZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9tcHRfdmFsdWVzX2pzXzEuU3RyaW5nUHJvbXB0VmFsdWUob2JqLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGlubmVyUmV2aXZlID0gKGtleSkgPT4gW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmV2aXZlKG9ialtrZXldKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcnRuID0gT2JqZWN0LmZyb21FbnRyaWVzKGtleXNBcnIubWFwKGlubmVyUmV2aXZlKSk7XG4gICAgICAgIHJldHVybiBydG47XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzdHIpIHtcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gICAgcmV0dXJuIHJldml2ZShvYmopO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2FsbGJhY2tzQW5kU2lnbmFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN0ID0geyAuLi5vcHRpb25zIH07XG4gICAgZGVsZXRlIHJlc3QuY2FsbGJhY2tzO1xuICAgIGRlbGV0ZSByZXN0LnNpZ25hbDtcbiAgICByZXR1cm4gcmVzdDtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpXG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoc2VyaWFsaXplKTtcbiAgICBpZiAoKDAsIGluZGV4X2pzXzIuaXNCYXNlTWVzc2FnZSkoaW5wdXQpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0ge1xuICAgICAgICAgICAgY29udGVudDogaW5wdXQuY29udGVudCxcbiAgICAgICAgICAgIHR5cGU6IGlucHV0Ll9nZXRUeXBlKCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogaW5wdXQuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICAgICAgZXhhbXBsZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleF9qc18yLlRvb2xNZXNzYWdlLmlzSW5zdGFuY2UoaW5wdXQpKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkTWVzc2FnZS50b29sX2NhbGxfaWQgPSBpbnB1dC50b29sX2NhbGxfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhfanNfMi5DaGF0TWVzc2FnZS5pc0luc3RhbmNlKGlucHV0KSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZE1lc3NhZ2Uucm9sZSA9IGlucHV0LnJvbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKCFpbnB1dCB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzQXJyID0gT2JqZWN0LmtleXMoaW5wdXQpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBpbm5lclNlcmlhbGl6ZSA9IChrZXkpID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZShpbnB1dFtrZXldKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcnRuID0gT2JqZWN0LmZyb21FbnRyaWVzKGtleXNBcnIubWFwKGlubmVyU2VyaWFsaXplKSk7XG4gICAgICAgIHJldHVybiBydG47XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cbi8qKlxuICogQ2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIExhbmdDaGFpbiBydW5uYWJsZXNcbiAqIHRoYXQgYXJlIGhvc3RlZCBhcyBMYW5nU2VydmUgZW5kcG9pbnRzLlxuICpcbiAqIEFsbG93cyB5b3UgdG8gaW50ZXJhY3Qgd2l0aCBob3N0ZWQgcnVubmFibGVzIHVzaW5nIHRoZSBzdGFuZGFyZFxuICogYC5pbnZva2UoKWAsIGAuc3RyZWFtKClgLCBgLnN0cmVhbUV2ZW50cygpYCwgZXRjLiBtZXRob2RzIHRoYXRcbiAqIG90aGVyIHJ1bm5hYmxlcyBzdXBwb3J0LlxuICpcbiAqIEBkZXByZWNhdGVkIExhbmdTZXJ2ZSBpcyBubyBsb25nZXIgYWN0aXZlbHkgZGV2ZWxvcGVkIC0gcGxlYXNlIGNvbnNpZGVyIHVzaW5nIExhbmdHcmFwaCBQbGF0Zm9ybS5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIG9mIHRoZSBMYW5nU2VydmUgZW5kcG9pbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSByZW1vdGUgcnVubmFibGUsIGluY2x1ZGluZyB0aW1lb3V0IGFuZCBoZWFkZXJzLlxuICogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIGZldGNoUmVxdWVzdE9wdGlvbnMgLSBPcHRpb25hbCBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGZldGNoIHJlcXVlc3RzLlxuICovXG5jbGFzcyBSZW1vdGVSdW5uYWJsZSBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdyYXAgdGhlIGRlZmF1bHQgZmV0Y2ggY2FsbCBkdWUgdG8gaXNzdWVzIHdpdGggaWxsZWdhbCBpbnZvY2F0aW9uc1xuICAgICAgICAvLyBmcm9tIHRoZSBicm93c2VyOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82OTg3Njg1OS93aHktZG9lcy1iaW5kLWZpeC1mYWlsZWQtdG8tZXhlY3V0ZS1mZXRjaC1vbi13aW5kb3ctaWxsZWdhbC1pbnZvY2F0aW9uLWVyclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZXRjaEltcGxlbWVudGF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoLi4uYXJncykgPT4gXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICBmZXRjaCguLi5hcmdzKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hSZXF1ZXN0T3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInNjaGVtYVwiLCBcInJ1bm5hYmxlXCIsIFwicmVtb3RlXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHVybCwgb3B0aW9ucywgZmV0Y2g6IGZldGNoSW1wbGVtZW50YXRpb24sIGZldGNoUmVxdWVzdE9wdGlvbnMsIH0gPSBmaWVsZHM7XG4gICAgICAgIHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoSW1wbGVtZW50YXRpb24gPz8gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uO1xuICAgICAgICB0aGlzLmZldGNoUmVxdWVzdE9wdGlvbnMgPSBmZXRjaFJlcXVlc3RPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBwb3N0KHBhdGgsIGJvZHksIHNpZ25hbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uKGAke3RoaXMudXJsfSR7cGF0aH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGJvZHkpKSxcbiAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsID8/IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5vcHRpb25zPy50aW1lb3V0ID8/IDYwMDAwKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoUmVxdWVzdE9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIG9wdGlvbnMsIF8pIHtcbiAgICAgICAgY29uc3QgW2NvbmZpZywga3dhcmdzXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KFwiL2ludm9rZVwiLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGNvbmZpZzogcmVtb3ZlQ2FsbGJhY2tzQW5kU2lnbmFsKGNvbmZpZyksXG4gICAgICAgICAgICBrd2FyZ3M6IGt3YXJncyA/PyB7fSxcbiAgICAgICAgfSwgY29uZmlnLnNpZ25hbCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9IEVycm9yOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlKChhd2FpdCByZXNwb25zZS5qc29uKCkpLm91dHB1dCk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9iYXRjaChpbnB1dHMsIG9wdGlvbnMsIF8sIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXR1cm5FeGNlcHRpb25zIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlbW90ZSBjbGllbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ3NBbmRLd2FyZ3NBcnJheSA9IG9wdGlvbnM/Lm1hcCgob3B0cykgPT4gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRzKSk7XG4gICAgICAgIGNvbnN0IFtjb25maWdzLCBrd2FyZ3NdID0gY29uZmlnc0FuZEt3YXJnc0FycmF5Py5yZWR1Y2UoKFtwYywgcGtdLCBbYywga10pID0+IFtcbiAgICAgICAgICAgIFsuLi5wYywgY10sXG4gICAgICAgICAgICBbLi4ucGssIGtdLFxuICAgICAgICBdLCBbW10sIFtdXSkgPz8gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3QoXCIvYmF0Y2hcIiwge1xuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgY29uZmlnOiAoY29uZmlncyA/PyBbXSlcbiAgICAgICAgICAgICAgICAubWFwKHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbClcbiAgICAgICAgICAgICAgICAubWFwKChjb25maWcpID0+ICh7IC4uLmNvbmZpZywgLi4uYmF0Y2hPcHRpb25zIH0pKSxcbiAgICAgICAgICAgIGt3YXJncyxcbiAgICAgICAgfSwgb3B0aW9ucz8uWzBdPy5zaWduYWwpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSBFcnJvcjogJHthd2FpdCByZXNwb25zZS50ZXh0KCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFib2R5Lm91dHB1dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSByZW1vdGUgcnVubmFibGVcIik7XG4gICAgICAgIHJldHVybiByZXZpdmUoYm9keS5vdXRwdXQpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInJldHVybkV4Y2VwdGlvbnMgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVtb3RlIGNsaWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW2NvbmZpZywga3dhcmdzXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCAoMCwgY29uZmlnX2pzXzEuZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgKDAsIGJhc2VfanNfMS5fY29lcmNlVG9EaWN0KShpbnB1dCwgXCJpbnB1dFwiKSwgY29uZmlnLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KFwiL3N0cmVhbVwiLCB7XG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29uZmlnOiByZW1vdmVDYWxsYmFja3NBbmRTaWduYWwoY29uZmlnKSxcbiAgICAgICAgICAgICAgICBrd2FyZ3MsXG4gICAgICAgICAgICB9LCBjb25maWcuc2lnbmFsKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBSZW1vdGVSdW5uYWJsZSBjYWxsIGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtqc29uLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBib2R5IH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBiZWdpbiByZW1vdGUgc3RyZWFtLiBQbGVhc2UgY2hlY2sgdGhlIGdpdmVuIFVSTCBhbmQgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gKDAsIGV2ZW50X3NvdXJjZV9wYXJzZV9qc18xLmNvbnZlcnRFdmVudFN0cmVhbVRvSXRlcmFibGVSZWFkYWJsZURhdGFTdHJlYW0pKGJvZHkpO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBydW5uYWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZENodW5rID0gZGVzZXJpYWxpemUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHlpZWxkIGRlc2VyaWFsaXplZENodW5rO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBkZXNlcmlhbGl6ZWRDaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9ICgwLCBzdHJlYW1fanNfMS5jb25jYXQpKGZpbmFsT3V0cHV0LCBkZXNlcmlhbGl6ZWRDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoZmluYWxPdXRwdXQgPz8ge30pO1xuICAgIH1cbiAgICBhc3luYyAqc3RyZWFtTG9nKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWcsIGt3YXJnc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgKDAsIGNvbmZpZ19qc18xLmdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksICgwLCBiYXNlX2pzXzEuX2NvZXJjZVRvRGljdCkoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICAvLyBUaGUgdHlwZSBpcyBpbiBjYW1lbENhc2UgYnV0IHRoZSBBUEkgb25seSBhY2NlcHRzIHNuYWtlX2Nhc2UuXG4gICAgICAgIGNvbnN0IGNhbWVsQ2FzZVN0cmVhbU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbmNsdWRlX25hbWVzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlTmFtZXMsXG4gICAgICAgICAgICBpbmNsdWRlX3R5cGVzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlVHlwZXMsXG4gICAgICAgICAgICBpbmNsdWRlX3RhZ3M6IHN0cmVhbU9wdGlvbnM/LmluY2x1ZGVUYWdzLFxuICAgICAgICAgICAgZXhjbHVkZV9uYW1lczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZU5hbWVzLFxuICAgICAgICAgICAgZXhjbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZVR5cGVzLFxuICAgICAgICAgICAgZXhjbHVkZV90YWdzOiBzdHJlYW1PcHRpb25zPy5leGNsdWRlVGFncyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJ1bkxvZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0KFwiL3N0cmVhbV9sb2dcIiwge1xuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcmVtb3ZlQ2FsbGJhY2tzQW5kU2lnbmFsKGNvbmZpZyksXG4gICAgICAgICAgICAgICAga3dhcmdzLFxuICAgICAgICAgICAgICAgIC4uLmNhbWVsQ2FzZVN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGlmZjogZmFsc2UsXG4gICAgICAgICAgICB9LCBjb25maWcuc2lnbmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSwgb2sgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9IEVycm9yOiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBiZWdpbiByZW1vdGUgc3RyZWFtIGxvZy4gUGxlYXNlIGNoZWNrIHRoZSBnaXZlbiBVUkwgYW5kIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9ICgwLCBldmVudF9zb3VyY2VfcGFyc2VfanNfMS5jb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtKShib2R5KTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIHJ1bm5hYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSByZXZpdmUoSlNPTi5wYXJzZShsb2cpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dQYXRjaCA9IG5ldyBsb2dfc3RyZWFtX2pzXzEuUnVuTG9nUGF0Y2goeyBvcHM6IGNodW5rLm9wcyB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCBsb2dQYXRjaDtcbiAgICAgICAgICAgICAgICBpZiAocnVuTG9nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuTG9nID0gbG9nX3N0cmVhbV9qc18xLlJ1bkxvZy5mcm9tUnVuTG9nUGF0Y2gobG9nUGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuTG9nID0gcnVuTG9nLmNvbmNhdChsb2dQYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChydW5Mb2c/LnN0YXRlLmZpbmFsX291dHB1dCk7XG4gICAgfVxuICAgIF9zdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IG91dGVyVGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBbY29uZmlnLCBrd2FyZ3NdID0gb3V0ZXJUaGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0ICgwLCBjb25maWdfanNfMS5nZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcpKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQob3V0ZXJUaGlzLnRvSlNPTigpLCAoMCwgYmFzZV9qc18xLl9jb2VyY2VUb0RpY3QpKGlucHV0LCBcImlucHV0XCIpLCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgICAgICAvLyBUaGUgdHlwZSBpcyBpbiBjYW1lbENhc2UgYnV0IHRoZSBBUEkgb25seSBhY2NlcHRzIHNuYWtlX2Nhc2UuXG4gICAgICAgICAgICBjb25zdCBjYW1lbENhc2VTdHJlYW1PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVfbmFtZXM6IHN0cmVhbU9wdGlvbnM/LmluY2x1ZGVOYW1lcyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlX3R5cGVzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlVHlwZXMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZV90YWdzOiBzdHJlYW1PcHRpb25zPy5pbmNsdWRlVGFncyxcbiAgICAgICAgICAgICAgICBleGNsdWRlX25hbWVzOiBzdHJlYW1PcHRpb25zPy5leGNsdWRlTmFtZXMsXG4gICAgICAgICAgICAgICAgZXhjbHVkZV90eXBlczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZVR5cGVzLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVfdGFnczogc3RyZWFtT3B0aW9ucz8uZXhjbHVkZVRhZ3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3V0ZXJUaGlzLnBvc3QoXCIvc3RyZWFtX2V2ZW50c1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IHJlbW92ZUNhbGxiYWNrc0FuZFNpZ25hbChjb25maWcpLFxuICAgICAgICAgICAgICAgICAgICBrd2FyZ3MsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNhbWVsQ2FzZVN0cmVhbU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRpZmY6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5zaWduYWwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYm9keSwgb2sgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c30gRXJyb3I6ICR7YXdhaXQgcmVzcG9uc2UudGV4dCgpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGJlZ2luIHJlbW90ZSBzdHJlYW0gZXZlbnRzLiBQbGVhc2UgY2hlY2sgdGhlIGdpdmVuIFVSTCBhbmQgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmFibGVTdHJlYW0gPSAoMCwgZXZlbnRfc291cmNlX3BhcnNlX2pzXzEuY29udmVydEV2ZW50U3RyZWFtVG9JdGVyYWJsZVJlYWRhYmxlRGF0YVN0cmVhbSkoYm9keSk7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsb2cgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSByZXZpdmUoSlNPTi5wYXJzZShsb2cpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogY2h1bmsuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaHVuay5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBjaHVuay5ydW5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBjaHVuay50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGNodW5rLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGV2ZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gIT09IFwidjFcIiAmJiBvcHRpb25zLnZlcnNpb24gIT09IFwidjJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IHZlcnNpb25zIFwidjFcIiBhbmQgXCJ2MlwiIG9mIHRoZSBldmVudHMgc2NoZW1hIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lhbCBlbmNvZGluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgcnVubmFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyZWFtID0gdGhpcy5fc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbUFzeW5jR2VuZXJhdG9yKGV2ZW50U3RyZWFtKTtcbiAgICB9XG59XG5leHBvcnRzLlJlbW90ZVJ1bm5hYmxlID0gUmVtb3RlUnVubmFibGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/router.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RouterRunnable = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ./config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nclass RouterRunnable extends base_js_1.Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, (0, config_js_1.ensureConfig)(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\nexports.RouterRunnable = RouterRunnable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3JvdXRlci5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFZO0FBQ3RDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMENBQTBDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvcm91dGVyLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm91dGVyUnVubmFibGUgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlLmNqc1wiKTtcbmNvbnN0IGNvbmZpZ19qc18xID0gcmVxdWlyZShcIi4vY29uZmlnLmNqc1wiKTtcbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJvdXRlcyB0byBhIHNldCBvZiBydW5uYWJsZXMgYmFzZWQgb24gSW5wdXRbJ2tleSddLlxuICogUmV0dXJucyB0aGUgb3V0cHV0IG9mIHRoZSBzZWxlY3RlZCBydW5uYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSb3V0ZXJSdW5uYWJsZSwgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXJSdW5uYWJsZSh7XG4gKiAgIHJ1bm5hYmxlczoge1xuICogICAgIHRvVXBwZXJDYXNlOiBSdW5uYWJsZUxhbWJkYS5mcm9tKCh0ZXh0OiBzdHJpbmcpID0+IHRleHQudG9VcHBlckNhc2UoKSksXG4gKiAgICAgcmV2ZXJzZVRleHQ6IFJ1bm5hYmxlTGFtYmRhLmZyb20oKHRleHQ6IHN0cmluZykgPT5cbiAqICAgICAgIHRleHQuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIilcbiAqICAgICApLFxuICogICB9LFxuICogfSk7XG4gKlxuICogLy8gSW52b2tlIHRoZSAncmV2ZXJzZVRleHQnIHJ1bm5hYmxlXG4gKiBjb25zdCByZXN1bHQxID0gcm91dGVyLmludm9rZSh7IGtleTogXCJyZXZlcnNlVGV4dFwiLCBpbnB1dDogXCJIZWxsbyBXb3JsZFwiIH0pO1xuICpcbiAqIC8vIFwiZGxyb1cgb2xsZUhcIlxuICpcbiAqIC8vIEludm9rZSB0aGUgJ3RvVXBwZXJDYXNlJyBydW5uYWJsZVxuICogY29uc3QgcmVzdWx0MiA9IHJvdXRlci5pbnZva2UoeyBrZXk6IFwidG9VcHBlckNhc2VcIiwgaW5wdXQ6IFwiSGVsbG8gV29ybGRcIiB9KTtcbiAqXG4gKiAvLyBcIkhFTExPIFdPUkxEXCJcbiAqIGBgYFxuICovXG5jbGFzcyBSb3V0ZXJSdW5uYWJsZSBleHRlbmRzIGJhc2VfanNfMS5SdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJvdXRlclJ1bm5hYmxlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5hYmxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bm5hYmxlcyA9IGZpZWxkcy5ydW5uYWJsZXM7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtleSwgaW5wdXQ6IGFjdHVhbElucHV0IH0gPSBpbnB1dDtcbiAgICAgICAgY29uc3QgcnVubmFibGUgPSB0aGlzLnJ1bm5hYmxlc1trZXldO1xuICAgICAgICBpZiAocnVubmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW5uYWJsZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5hYmxlLmludm9rZShhY3R1YWxJbnB1dCwgKDAsIGNvbmZpZ19qc18xLmVuc3VyZUNvbmZpZykob3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaChpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlzID0gaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmtleSk7XG4gICAgICAgIGNvbnN0IGFjdHVhbElucHV0cyA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiBpbnB1dC5pbnB1dCk7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXkgPSBrZXlzLmZpbmQoKGtleSkgPT4gdGhpcy5ydW5uYWJsZXNba2V5XSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1pc3NpbmdLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmUgb3IgbW9yZSBrZXlzIGRvIG5vdCBoYXZlIGEgY29ycmVzcG9uZGluZyBydW5uYWJsZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZXMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnJ1bm5hYmxlc1trZXldKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBvcHRpb25zTGlzdFswXT8ubWF4Q29uY3VycmVuY3kgPz8gYmF0Y2hPcHRpb25zPy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgYmF0Y2hTaXplID0gbWF4Q29uY3VycmVuY3kgJiYgbWF4Q29uY3VycmVuY3kgPiAwID8gbWF4Q29uY3VycmVuY3kgOiBpbnB1dHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBiYXRjaFJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3R1YWxJbnB1dHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hQcm9taXNlcyA9IGFjdHVhbElucHV0c1xuICAgICAgICAgICAgICAgIC5zbGljZShpLCBpICsgYmF0Y2hTaXplKVxuICAgICAgICAgICAgICAgIC5tYXAoKGFjdHVhbElucHV0LCBpKSA9PiBydW5uYWJsZXNbaV0uaW52b2tlKGFjdHVhbElucHV0LCBvcHRpb25zTGlzdFtpXSkpO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hSZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKTtcbiAgICAgICAgICAgIGJhdGNoUmVzdWx0cy5wdXNoKGJhdGNoUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmF0Y2hSZXN1bHRzLmZsYXQoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBpbnB1dDogYWN0dWFsSW5wdXQgfSA9IGlucHV0O1xuICAgICAgICBjb25zdCBydW5uYWJsZSA9IHRoaXMucnVubmFibGVzW2tleV07XG4gICAgICAgIGlmIChydW5uYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bm5hYmxlIGFzc29jaWF0ZWQgd2l0aCBrZXkgXCIke2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVubmFibGUuc3RyZWFtKGFjdHVhbElucHV0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlJvdXRlclJ1bm5hYmxlID0gUm91dGVyUnVubmFibGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/router.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/utils.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._RootEventFilter = void 0;\nexports.isRunnableInterface = isRunnableInterface;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableInterface(thing) {\n    return thing ? thing.lc_runnable : false;\n}\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nclass _RootEventFilter {\n    constructor(fields) {\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.includeNames = fields.includeNames;\n        this.includeTypes = fields.includeTypes;\n        this.includeTags = fields.includeTags;\n        this.excludeNames = fields.excludeNames;\n        this.excludeTypes = fields.excludeTypes;\n        this.excludeTags = fields.excludeTags;\n    }\n    includeEvent(event, rootType) {\n        let include = this.includeNames === undefined &&\n            this.includeTypes === undefined &&\n            this.includeTags === undefined;\n        const eventTags = event.tags ?? [];\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(event.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(rootType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include || eventTags.some((tag) => this.includeTags?.includes(tag));\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(event.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(rootType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n}\nexports._RootEventFilter = _RootEventFilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3V0aWxzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3V0aWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX1Jvb3RFdmVudEZpbHRlciA9IHZvaWQgMDtcbmV4cG9ydHMuaXNSdW5uYWJsZUludGVyZmFjZSA9IGlzUnVubmFibGVJbnRlcmZhY2U7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gaXNSdW5uYWJsZUludGVyZmFjZSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyA/IHRoaW5nLmxjX3J1bm5hYmxlIDogZmFsc2U7XG59XG4vKipcbiAqIFV0aWxpdHkgdG8gZmlsdGVyIHRoZSByb290IGV2ZW50IGluIHRoZSBzdHJlYW1FdmVudHMgaW1wbGVtZW50YXRpb24uXG4gKiBUaGlzIGlzIHNpbXBseSBiaW5kaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIG5hbWVzcGFjZSB0byBtYWtlIHNhdmUgb25cbiAqIGEgYml0IG9mIHR5cGluZyBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRPRE86IFJlZmFjdG9yIGFuZCByZW1vdmUuXG4gKi9cbmNsYXNzIF9Sb290RXZlbnRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHMuaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHMuaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzLmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHMuZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzLmV4Y2x1ZGVUYWdzO1xuICAgIH1cbiAgICBpbmNsdWRlRXZlbnQoZXZlbnQsIHJvb3RUeXBlKSB7XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBldmVudFRhZ3MgPSBldmVudC50YWdzID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJvb3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8IGV2ZW50VGFncy5zb21lKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBldmVudFRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbn1cbmV4cG9ydHMuX1Jvb3RFdmVudEZpbHRlciA9IF9Sb290RXZlbnRGaWx0ZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/runnables/wrappers.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertToHttpEventStream = convertToHttpEventStream;\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nfunction convertToHttpEventStream(stream) {\n    const encoder = new TextEncoder();\n    const finalStream = new ReadableStream({\n        async start(controller) {\n            for await (const chunk of stream) {\n                controller.enqueue(encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`));\n            }\n            controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n            controller.close();\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(finalStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3dyYXBwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsdUZBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL3dyYXBwZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udmVydFRvSHR0cEV2ZW50U3RyZWFtID0gY29udmVydFRvSHR0cEV2ZW50U3RyZWFtO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbShzdHJlYW0pIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZmluYWxTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShgZXZlbnQ6IGRhdGFcXG5kYXRhOiAke0pTT04uc3RyaW5naWZ5KGNodW5rKX1cXG5cXG5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoXCJldmVudDogZW5kXFxuXFxuXCIpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oZmluYWxTdHJlYW0pO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/runnables/wrappers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerConfigureHook = exports._getConfigureHooks = void 0;\nexports.setContextVariable = setContextVariable;\nexports.getContextVariable = getContextVariable;\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst globals_js_1 = __webpack_require__(/*! ./globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContextVariable(name, value) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    const contextVars = { ...runTree?.[globals_js_1._CONTEXT_VARIABLES_KEY] };\n    contextVars[name] = value;\n    let newValue = {};\n    if ((0, run_trees_1.isRunTree)(runTree)) {\n        newValue = new run_trees_1.RunTree(runTree);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    newValue[globals_js_1._CONTEXT_VARIABLES_KEY] = contextVars;\n    asyncLocalStorageInstance.enterWith(newValue);\n}\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVariable(name) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n    if (asyncLocalStorageInstance === undefined) {\n        return undefined;\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    return runTree?.[globals_js_1._CONTEXT_VARIABLES_KEY]?.[name];\n}\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\nconst _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];\nexports._getConfigureHooks = _getConfigureHooks;\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nconst registerConfigureHook = (config) => {\n    if (config.envVar && !config.handlerClass) {\n        throw new Error(\"If envVar is set, handlerClass must also be set to a non-None value.\");\n    }\n    setContextVariable(LC_CONFIGURE_HOOKS_KEY, [...(0, exports._getConfigureHooks)(), config]);\n};\nexports.registerConfigureHook = registerConfigureHook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2NvbnRleHQuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDBCQUEwQjtBQUMxRCwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFxQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvY29udGV4dC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2lzdGVyQ29uZmlndXJlSG9vayA9IGV4cG9ydHMuX2dldENvbmZpZ3VyZUhvb2tzID0gdm9pZCAwO1xuZXhwb3J0cy5zZXRDb250ZXh0VmFyaWFibGUgPSBzZXRDb250ZXh0VmFyaWFibGU7XG5leHBvcnRzLmdldENvbnRleHRWYXJpYWJsZSA9IGdldENvbnRleHRWYXJpYWJsZTtcbmNvbnN0IHJ1bl90cmVlc18xID0gcmVxdWlyZShcImxhbmdzbWl0aC9ydW5fdHJlZXNcIik7XG5jb25zdCBnbG9iYWxzX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzLmNqc1wiKTtcbi8qKlxuICogU2V0IGEgY29udGV4dCB2YXJpYWJsZS4gQ29udGV4dCB2YXJpYWJsZXMgYXJlIHNjb3BlZCB0byBhbnlcbiAqIGNoaWxkIHJ1bm5hYmxlcyBjYWxsZWQgYnkgdGhlIGN1cnJlbnQgcnVubmFibGUsIG9yIGdsb2JhbGx5IGlmIHNldCBvdXRzaWRlXG4gKiBvZiBhbnkgcnVubmFibGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBBc3luY0xvY2FsU3RvcmFnZSxcbiAqIGluY2x1ZGluZyBOb2RlLmpzLCBEZW5vLCBhbmQgQ2xvdWRmbGFyZSBXb3JrZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUnVubmFibGVMYW1iZGEgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICogaW1wb3J0IHtcbiAqICAgZ2V0Q29udGV4dFZhcmlhYmxlLFxuICogICBzZXRDb250ZXh0VmFyaWFibGVcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9jb250ZXh0XCI7XG4gKlxuICogY29uc3QgbmVzdGVkID0gUnVubmFibGVMYW1iZGEuZnJvbSgoKSA9PiB7XG4gKiAgIC8vIFwiYmFyXCIgYmVjYXVzZSBpdCB3YXMgc2V0IGJ5IGEgcGFyZW50XG4gKiAgIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogICAvLyBPdmVycmlkZSB0byBcImJhelwiLCBidXQgb25seSBmb3IgY2hpbGQgcnVubmFibGVzXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhelwiKTtcbiAqXG4gKiAgIC8vIE5vdyBcImJhelwiLCBidXQgb25seSBmb3IgY2hpbGQgcnVubmFibGVzXG4gKiAgIHJldHVybiBnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIik7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBydW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKCkgPT4ge1xuICogICAvLyBTZXQgYSBjb250ZXh0IHZhcmlhYmxlIG5hbWVkIFwiZm9vXCJcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgY29uc3QgcmVzID0gYXdhaXQgbmVzdGVkLmludm9rZSh7fSk7XG4gKlxuICogICAvLyBTdGlsbCBcImJhclwiIHNpbmNlIGNoaWxkIGNoYW5nZXMgZG8gbm90IGFmZmVjdCBwYXJlbnRzXG4gKiAgIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogICByZXR1cm4gcmVzO1xuICogfSk7XG4gKlxuICogLy8gdW5kZWZpbmVkLCBiZWNhdXNlIGNvbnRleHQgdmFyaWFibGUgaGFzIG5vdCBiZWVuIHNldCB5ZXRcbiAqIGNvbnNvbGUubG9nKGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKSk7XG4gKlxuICogLy8gRmluYWwgcmV0dXJuIHZhbHVlIGlzIFwiYmF6XCJcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJ1bm5hYmxlLmludm9rZSh7fSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGV4dCB2YXJpYWJsZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gc2V0Q29udGV4dFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgLy8gQXZvaWQgdXNpbmcgZ2xvYmFsIHNpbmdsZXRvbiBkdWUgdG8gY2lyY3VsdWFyIGRlcGVuZGVuY3kgaXNzdWVzXG4gICAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9ICgwLCBnbG9iYWxzX2pzXzEuZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSkoKTtcbiAgICBpZiAoYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3I6IEdsb2JhbCBzaGFyZWQgYXN5bmMgbG9jYWwgc3RvcmFnZSBpbnN0YW5jZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJ1blRyZWUgPSBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLmdldFN0b3JlKCk7XG4gICAgY29uc3QgY29udGV4dFZhcnMgPSB7IC4uLnJ1blRyZWU/LltnbG9iYWxzX2pzXzEuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gfTtcbiAgICBjb250ZXh0VmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgIGxldCBuZXdWYWx1ZSA9IHt9O1xuICAgIGlmICgoMCwgcnVuX3RyZWVzXzEuaXNSdW5UcmVlKShydW5UcmVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ldyBydW5fdHJlZXNfMS5SdW5UcmVlKHJ1blRyZWUpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG5ld1ZhbHVlW2dsb2JhbHNfanNfMS5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9IGNvbnRleHRWYXJzO1xuICAgIGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UuZW50ZXJXaXRoKG5ld1ZhbHVlKTtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhIHByZXZpb3VzbHkgc2V0IGNvbnRleHQgdmFyaWFibGUuIENvbnRleHQgdmFyaWFibGVzXG4gKiBhcmUgc2NvcGVkIHRvIGFueSBjaGlsZCBydW5uYWJsZXMgY2FsbGVkIGJ5IHRoZSBjdXJyZW50IHJ1bm5hYmxlLFxuICogb3IgZ2xvYmFsbHkgaWYgc2V0IG91dHNpZGUgb2YgYW55IHJ1bm5hYmxlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgQXN5bmNMb2NhbFN0b3JhZ2UsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYW5kIENsb3VkZmxhcmUgV29ya2Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqIGltcG9ydCB7XG4gKiAgIGdldENvbnRleHRWYXJpYWJsZSxcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY29udGV4dFwiO1xuICpcbiAqIGNvbnN0IG5lc3RlZCA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oKCkgPT4ge1xuICogICAvLyBcImJhclwiIGJlY2F1c2UgaXQgd2FzIHNldCBieSBhIHBhcmVudFxuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgLy8gT3ZlcnJpZGUgdG8gXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXpcIik7XG4gKlxuICogICAvLyBOb3cgXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpO1xuICogfSk7XG4gKlxuICogY29uc3QgcnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFzeW5jICgpID0+IHtcbiAqICAgLy8gU2V0IGEgY29udGV4dCB2YXJpYWJsZSBuYW1lZCBcImZvb1wiXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIGNvbnN0IHJlcyA9IGF3YWl0IG5lc3RlZC5pbnZva2Uoe30pO1xuICpcbiAqICAgLy8gU3RpbGwgXCJiYXJcIiBzaW5jZSBjaGlsZCBjaGFuZ2VzIGRvIG5vdCBhZmZlY3QgcGFyZW50c1xuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgcmV0dXJuIHJlcztcbiAqIH0pO1xuICpcbiAqIC8vIHVuZGVmaW5lZCwgYmVjYXVzZSBjb250ZXh0IHZhcmlhYmxlIGhhcyBub3QgYmVlbiBzZXQgeWV0XG4gKiBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqIC8vIEZpbmFsIHJldHVybiB2YWx1ZSBpcyBcImJhelwiXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2Uoe30pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRleHQgdmFyaWFibGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBnZXRDb250ZXh0VmFyaWFibGUobmFtZSkge1xuICAgIC8vIEF2b2lkIHVzaW5nIGdsb2JhbCBzaW5nbGV0b24gZHVlIHRvIGNpcmN1bHVhciBkZXBlbmRlbmN5IGlzc3Vlc1xuICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoMCwgZ2xvYmFsc19qc18xLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UpKCk7XG4gICAgaWYgKGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBydW5UcmVlID0gYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZS5nZXRTdG9yZSgpO1xuICAgIHJldHVybiBydW5UcmVlPy5bZ2xvYmFsc19qc18xLl9DT05URVhUX1ZBUklBQkxFU19LRVldPy5bbmFtZV07XG59XG5jb25zdCBMQ19DT05GSUdVUkVfSE9PS1NfS0VZID0gU3ltYm9sKFwibGM6Y29uZmlndXJlX2hvb2tzXCIpO1xuY29uc3QgX2dldENvbmZpZ3VyZUhvb2tzID0gKCkgPT4gZ2V0Q29udGV4dFZhcmlhYmxlKExDX0NPTkZJR1VSRV9IT09LU19LRVkpIHx8IFtdO1xuZXhwb3J0cy5fZ2V0Q29uZmlndXJlSG9va3MgPSBfZ2V0Q29uZmlndXJlSG9va3M7XG4vKipcbiAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgY29uZmlndXJlIGhvb2sgdG8gYXV0b21hdGljYWxseSBhZGQgY2FsbGJhY2sgaGFuZGxlcnMgdG8gYWxsIHJ1bnMuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSB0aGlzOlxuICpcbiAqIDEuIFVzaW5nIGEgY29udGV4dCB2YXJpYWJsZTpcbiAqICAgIC0gU2V0IGBjb250ZXh0VmFyYCB0byBzcGVjaWZ5IHRoZSB2YXJpYWJsZSBuYW1lXG4gKiAgICAtIFVzZSBgc2V0Q29udGV4dFZhcmlhYmxlKClgIHRvIHN0b3JlIHlvdXIgaGFuZGxlciBpbnN0YW5jZVxuICpcbiAqIDIuIFVzaW5nIGFuIGVudmlyb25tZW50IHZhcmlhYmxlOlxuICogICAgLSBTZXQgYm90aCBgZW52VmFyYCBhbmQgYGhhbmRsZXJDbGFzc2BcbiAqICAgIC0gVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgZW52IHZhciBpcyBzZXQgdG8gXCJ0cnVlXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIE1ldGhvZCAxOiBVc2luZyBjb250ZXh0IHZhcmlhYmxlXG4gKiBpbXBvcnQge1xuICogICByZWdpc3RlckNvbmZpZ3VyZUhvb2ssXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZVxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2NvbnRleHRcIjtcbiAqXG4gKiBjb25zdCB0cmFjZXIgPSBuZXcgTXlDYWxsYmFja0hhbmRsZXIoKTtcbiAqIHJlZ2lzdGVyQ29uZmlndXJlSG9vayh7XG4gKiAgIGNvbnRleHRWYXI6IFwibXlfdHJhY2VyXCIsXG4gKiB9KTtcbiAqIHNldENvbnRleHRWYXJpYWJsZShcIm15X3RyYWNlclwiLCB0cmFjZXIpO1xuICpcbiAqIC8vIC4uLnJ1biBjb2RlIGhlcmVcbiAqXG4gKiAvLyBNZXRob2QgMjogVXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIHJlZ2lzdGVyQ29uZmlndXJlSG9vayh7XG4gKiAgIGhhbmRsZXJDbGFzczogTXlDYWxsYmFja0hhbmRsZXIsXG4gKiAgIGVudlZhcjogXCJNWV9UUkFDRVJfRU5BQkxFRFwiLFxuICogfSk7XG4gKiBwcm9jZXNzLmVudi5NWV9UUkFDRVJfRU5BQkxFRCA9IFwidHJ1ZVwiO1xuICpcbiAqIC8vIC4uLnJ1biBjb2RlIGhlcmVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0gY29uZmlnLmNvbnRleHRWYXIgTmFtZSBvZiB0aGUgY29udGV4dCB2YXJpYWJsZSBjb250YWluaW5nIHRoZSBoYW5kbGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29uZmlnLmluaGVyaXRhYmxlIFdoZXRoZXIgY2hpbGQgcnVucyBzaG91bGQgaW5oZXJpdCB0aGlzIGhhbmRsZXJcbiAqIEBwYXJhbSBjb25maWcuaGFuZGxlckNsYXNzIE9wdGlvbmFsIGNhbGxiYWNrIGhhbmRsZXIgY2xhc3MgKHJlcXVpcmVkIGlmIHVzaW5nIGVudlZhcilcbiAqIEBwYXJhbSBjb25maWcuZW52VmFyIE9wdGlvbmFsIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWUgdG8gY29udHJvbCBoYW5kbGVyIGFjdGl2YXRpb25cbiAqL1xuY29uc3QgcmVnaXN0ZXJDb25maWd1cmVIb29rID0gKGNvbmZpZykgPT4ge1xuICAgIGlmIChjb25maWcuZW52VmFyICYmICFjb25maWcuaGFuZGxlckNsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIGVudlZhciBpcyBzZXQsIGhhbmRsZXJDbGFzcyBtdXN0IGFsc28gYmUgc2V0IHRvIGEgbm9uLU5vbmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0VmFyaWFibGUoTENfQ09ORklHVVJFX0hPT0tTX0tFWSwgWy4uLigwLCBleHBvcnRzLl9nZXRDb25maWd1cmVIb29rcykoKSwgY29uZmlnXSk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckNvbmZpZ3VyZUhvb2sgPSByZWdpc3RlckNvbmZpZ3VyZUhvb2s7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/context.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getGlobalAsyncLocalStorageInstance = exports.setGlobalAsyncLocalStorageInstance = exports._CONTEXT_VARIABLES_KEY = exports.TRACING_ALS_KEY = void 0;\nexports.TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nexports._CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst setGlobalAsyncLocalStorageInstance = (instance) => {\n    globalThis[exports.TRACING_ALS_KEY] = instance;\n};\nexports.setGlobalAsyncLocalStorageInstance = setGlobalAsyncLocalStorageInstance;\nconst getGlobalAsyncLocalStorageInstance = () => {\n    return globalThis[exports.TRACING_ALS_KEY];\n};\nexports.getGlobalAsyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2dsb2JhbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQyxHQUFHLDBDQUEwQyxHQUFHLDhCQUE4QixHQUFHLHVCQUF1QjtBQUNsSix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvYXN5bmNfbG9jYWxfc3RvcmFnZS9nbG9iYWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGV4cG9ydHMuc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGV4cG9ydHMuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IGV4cG9ydHMuVFJBQ0lOR19BTFNfS0VZID0gdm9pZCAwO1xuZXhwb3J0cy5UUkFDSU5HX0FMU19LRVkgPSBTeW1ib2wuZm9yKFwibHM6dHJhY2luZ19hc3luY19sb2NhbF9zdG9yYWdlXCIpO1xuZXhwb3J0cy5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuY29uc3Qgc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICAgIGdsb2JhbFRoaXNbZXhwb3J0cy5UUkFDSU5HX0FMU19LRVldID0gaW5zdGFuY2U7XG59O1xuZXhwb3J0cy5zZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZTtcbmNvbnN0IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXNbZXhwb3J0cy5UUkFDSU5HX0FMU19LRVldO1xufTtcbmV4cG9ydHMuZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncLocalStorageProviderSingleton = exports.MockAsyncLocalStorage = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst globals_js_1 = __webpack_require__(/*! ./globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nconst manager_js_1 = __webpack_require__(/*! ../../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_store, callback) {\n        return callback();\n    }\n    enterWith(_store) {\n        return undefined;\n    }\n}\nexports.MockAsyncLocalStorage = MockAsyncLocalStorage;\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        return (0, globals_js_1.getGlobalAsyncLocalStorageInstance)() ?? mockAsyncLocalStorage;\n    }\n    getRunnableConfig() {\n        const storage = this.getInstance();\n        // this has the runnable config\n        // which means that we should also have an instance of a LangChainTracer\n        // with the run map prepopulated\n        return storage.getStore()?.extra?.[LC_CHILD_KEY];\n    }\n    runWithConfig(config, callback, avoidCreatingRootRunTree) {\n        const callbackManager = manager_js_1.CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n        const storage = this.getInstance();\n        const previousValue = storage.getStore();\n        const parentRunId = callbackManager?.getParentRunId();\n        const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === \"langchain_tracer\");\n        let runTree;\n        if (langChainTracer && parentRunId) {\n            runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n        }\n        else if (!avoidCreatingRootRunTree) {\n            runTree = new langsmith_1.RunTree({\n                name: \"<runnable_lambda>\",\n                tracingEnabled: false,\n            });\n        }\n        if (runTree) {\n            runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n        }\n        if (previousValue !== undefined &&\n            previousValue[globals_js_1._CONTEXT_VARIABLES_KEY] !== undefined) {\n            if (runTree === undefined) {\n                runTree = {};\n            }\n            runTree[globals_js_1._CONTEXT_VARIABLES_KEY] =\n                previousValue[globals_js_1._CONTEXT_VARIABLES_KEY];\n        }\n        return storage.run(runTree, callback);\n    }\n    initializeGlobalInstance(instance) {\n        if ((0, globals_js_1.getGlobalAsyncLocalStorageInstance)() === undefined) {\n            (0, globals_js_1.setGlobalAsyncLocalStorageInstance)(instance);\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nexports.AsyncLocalStorageProviderSingleton = AsyncLocalStorageProviderSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9hc3luY19sb2NhbF9zdG9yYWdlL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQ0FBMEMsR0FBRyw2QkFBNkI7QUFDMUU7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyREFBVztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBZTtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvYXN5bmNfbG9jYWxfc3RvcmFnZS9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBleHBvcnRzLk1vY2tBc3luY0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGxhbmdzbWl0aF8xID0gcmVxdWlyZShcImxhbmdzbWl0aFwiKTtcbmNvbnN0IGdsb2JhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHMuY2pzXCIpO1xuY29uc3QgbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NhbGxiYWNrcy9tYW5hZ2VyLmNqc1wiKTtcbmNsYXNzIE1vY2tBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJ1bihfc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBlbnRlcldpdGgoX3N0b3JlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBNb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jb25zdCBMQ19DSElMRF9LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfY29uZmlnXCIpO1xuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZ2xvYmFsc19qc18xLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UpKCkgPz8gbW9ja0FzeW5jTG9jYWxTdG9yYWdlO1xuICAgIH1cbiAgICBnZXRSdW5uYWJsZUNvbmZpZygpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgLy8gdGhpcyBoYXMgdGhlIHJ1bm5hYmxlIGNvbmZpZ1xuICAgICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdlIHNob3VsZCBhbHNvIGhhdmUgYW4gaW5zdGFuY2Ugb2YgYSBMYW5nQ2hhaW5UcmFjZXJcbiAgICAgICAgLy8gd2l0aCB0aGUgcnVuIG1hcCBwcmVwb3B1bGF0ZWRcbiAgICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0U3RvcmUoKT8uZXh0cmE/LltMQ19DSElMRF9LRVldO1xuICAgIH1cbiAgICBydW5XaXRoQ29uZmlnKGNvbmZpZywgY2FsbGJhY2ssIGF2b2lkQ3JlYXRpbmdSb290UnVuVHJlZSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLl9jb25maWd1cmVTeW5jKGNvbmZpZz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIGNvbmZpZz8udGFncywgdW5kZWZpbmVkLCBjb25maWc/Lm1ldGFkYXRhKTtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuSWQgPSBjYWxsYmFja01hbmFnZXI/LmdldFBhcmVudFJ1bklkKCk7XG4gICAgICAgIGNvbnN0IGxhbmdDaGFpblRyYWNlciA9IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlcnM/LmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXI/Lm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgbGV0IHJ1blRyZWU7XG4gICAgICAgIGlmIChsYW5nQ2hhaW5UcmFjZXIgJiYgcGFyZW50UnVuSWQpIHtcbiAgICAgICAgICAgIHJ1blRyZWUgPSBsYW5nQ2hhaW5UcmFjZXIuZ2V0UnVuVHJlZVdpdGhUcmFjaW5nQ29uZmlnKHBhcmVudFJ1bklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYXZvaWRDcmVhdGluZ1Jvb3RSdW5UcmVlKSB7XG4gICAgICAgICAgICBydW5UcmVlID0gbmV3IGxhbmdzbWl0aF8xLlJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiPHJ1bm5hYmxlX2xhbWJkYT5cIixcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuVHJlZSkge1xuICAgICAgICAgICAgcnVuVHJlZS5leHRyYSA9IHsgLi4ucnVuVHJlZS5leHRyYSwgW0xDX0NISUxEX0tFWV06IGNvbmZpZyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbZ2xvYmFsc19qc18xLl9DT05URVhUX1ZBUklBQkxFU19LRVldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChydW5UcmVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBydW5UcmVlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5UcmVlW2dsb2JhbHNfanNfMS5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVtnbG9iYWxzX2pzXzEuX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2UucnVuKHJ1blRyZWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICgoMCwgZ2xvYmFsc19qc18xLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UpKCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIGdsb2JhbHNfanNfMS5zZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIoKTtcbmV4cG9ydHMuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/callbacks.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getQueue = getQueue;\nexports.consumeCallback = consumeCallback;\nexports.awaitAllCallbacks = awaitAllCallbacks;\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nconst globals_js_1 = __webpack_require__(/*! ./async_local_storage/globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nconst tracer_js_1 = __webpack_require__(/*! ./tracer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\");\nlet queue;\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n    const PQueue = \"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default;\n    return new PQueue({\n        autoStart: true,\n        concurrency: 1,\n    });\n}\nfunction getQueue() {\n    if (typeof queue === \"undefined\") {\n        queue = createQueue();\n    }\n    return queue;\n}\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nasync function consumeCallback(promiseFn, wait) {\n    if (wait === true) {\n        // Clear config since callbacks are not part of the root run\n        // Avoid using global singleton due to circuluar dependency issues\n        const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n        if (asyncLocalStorageInstance !== undefined) {\n            await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n        }\n        else {\n            await promiseFn();\n        }\n    }\n    else {\n        queue = getQueue();\n        void queue.add(async () => {\n            const asyncLocalStorageInstance = (0, globals_js_1.getGlobalAsyncLocalStorageInstance)();\n            if (asyncLocalStorageInstance !== undefined) {\n                await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n            }\n            else {\n                await promiseFn();\n            }\n        });\n    }\n}\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nasync function awaitAllCallbacks() {\n    const defaultClient = (0, tracer_js_1.getDefaultLangChainClientSingleton)();\n    await Promise.allSettled([\n        typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n        defaultClient.awaitPendingTraceBatches(),\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9jYWxsYmFja3MuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywrSEFBbUM7QUFDaEUsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9jYWxsYmFja3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRRdWV1ZSA9IGdldFF1ZXVlO1xuZXhwb3J0cy5jb25zdW1lQ2FsbGJhY2sgPSBjb25zdW1lQ2FsbGJhY2s7XG5leHBvcnRzLmF3YWl0QWxsQ2FsbGJhY2tzID0gYXdhaXRBbGxDYWxsYmFja3M7XG5jb25zdCBwX3F1ZXVlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInAtcXVldWVcIikpO1xuY29uc3QgZ2xvYmFsc19qc18xID0gcmVxdWlyZShcIi4vYXN5bmNfbG9jYWxfc3RvcmFnZS9nbG9iYWxzLmNqc1wiKTtcbmNvbnN0IHRyYWNlcl9qc18xID0gcmVxdWlyZShcIi4vdHJhY2VyLmNqc1wiKTtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gcF9xdWV1ZV8xLmRlZmF1bHQgPyBwX3F1ZXVlXzEuZGVmYXVsdC5kZWZhdWx0IDogcF9xdWV1ZV8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UXVldWUoKSB7XG4gICAgaWYgKHR5cGVvZiBxdWV1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBxdWV1ZSA9IGNyZWF0ZVF1ZXVlKCk7XG4gICAgfVxuICAgIHJldHVybiBxdWV1ZTtcbn1cbi8qKlxuICogQ29uc3VtZSBhIHByb21pc2UsIGVpdGhlciBhZGRpbmcgaXQgdG8gdGhlIHF1ZXVlIG9yIHdhaXRpbmcgZm9yIGl0IHRvIHJlc29sdmVcbiAqIEBwYXJhbSBwcm9taXNlRm4gUHJvbWlzZSB0byBjb25zdW1lXG4gKiBAcGFyYW0gd2FpdCBXaGV0aGVyIHRvIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBpbW1lZGlhdGVseVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQ2FsbGJhY2socHJvbWlzZUZuLCB3YWl0KSB7XG4gICAgaWYgKHdhaXQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gQ2xlYXIgY29uZmlnIHNpbmNlIGNhbGxiYWNrcyBhcmUgbm90IHBhcnQgb2YgdGhlIHJvb3QgcnVuXG4gICAgICAgIC8vIEF2b2lkIHVzaW5nIGdsb2JhbCBzaW5nbGV0b24gZHVlIHRvIGNpcmN1bHVhciBkZXBlbmRlbmN5IGlzc3Vlc1xuICAgICAgICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gKDAsIGdsb2JhbHNfanNfMS5nZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKSgpO1xuICAgICAgICBpZiAoYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLnJ1bih1bmRlZmluZWQsIGFzeW5jICgpID0+IHByb21pc2VGbigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2VGbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWV1ZSA9IGdldFF1ZXVlKCk7XG4gICAgICAgIHZvaWQgcXVldWUuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoMCwgZ2xvYmFsc19qc18xLmdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UpKCk7XG4gICAgICAgICAgICBpZiAoYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZS5ydW4odW5kZWZpbmVkLCBhc3luYyAoKSA9PiBwcm9taXNlRm4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIGluIHRoZSBxdWV1ZSB0byByZXNvbHZlLiBJZiB0aGUgcXVldWUgaXNcbiAqIHVuZGVmaW5lZCwgaXQgaW1tZWRpYXRlbHkgcmVzb2x2ZXMgYSBwcm9taXNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICBjb25zdCBkZWZhdWx0Q2xpZW50ID0gKDAsIHRyYWNlcl9qc18xLmdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24pKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgICAgdHlwZW9mIHF1ZXVlICE9PSBcInVuZGVmaW5lZFwiID8gcXVldWUub25JZGxlKCkgOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgICAgZGVmYXVsdENsaWVudC5hd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKSxcbiAgICBdKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/callbacks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/index.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._CONTEXT_VARIABLES_KEY = exports.MockAsyncLocalStorage = exports.AsyncLocalStorageProviderSingleton = void 0;\nconst index_js_1 = __webpack_require__(/*! ./async_local_storage/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/index.cjs\");\nObject.defineProperty(exports, \"AsyncLocalStorageProviderSingleton\", ({ enumerable: true, get: function () { return index_js_1.AsyncLocalStorageProviderSingleton; } }));\nObject.defineProperty(exports, \"MockAsyncLocalStorage\", ({ enumerable: true, get: function () { return index_js_1.MockAsyncLocalStorage; } }));\nconst globals_js_1 = __webpack_require__(/*! ./async_local_storage/globals.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/async_local_storage/globals.cjs\");\nObject.defineProperty(exports, \"_CONTEXT_VARIABLES_KEY\", ({ enumerable: true, get: function () { return globals_js_1._CONTEXT_VARIABLES_KEY; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsMENBQTBDO0FBQzNHLG1CQUFtQixtQkFBTyxDQUFDLDJIQUFpQztBQUM1RCxzRUFBcUUsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDdEsseURBQXdELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQzVJLHFCQUFxQixtQkFBTyxDQUFDLCtIQUFtQztBQUNoRSwwREFBeUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gZXhwb3J0cy5Nb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBleHBvcnRzLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4vYXN5bmNfbG9jYWxfc3RvcmFnZS9pbmRleC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNb2NrQXN5bmNMb2NhbFN0b3JhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuTW9ja0FzeW5jTG9jYWxTdG9yYWdlOyB9IH0pO1xuY29uc3QgZ2xvYmFsc19qc18xID0gcmVxdWlyZShcIi4vYXN5bmNfbG9jYWxfc3RvcmFnZS9nbG9iYWxzLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9DT05URVhUX1ZBUklBQkxFU19LRVlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbHNfanNfMS5fQ09OVEVYVF9WQVJJQUJMRVNfS0VZOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/singletons/tracer.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setDefaultLangChainClientSingleton = exports.getDefaultLangChainClientSingleton = void 0;\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nlet client;\nconst getDefaultLangChainClientSingleton = () => {\n    if (client === undefined) {\n        const clientParams = (0, env_js_1.getEnvironmentVariable)(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n            ? {\n                // LangSmith has its own backgrounding system\n                blockOnRootRunFinalization: true,\n            }\n            : {};\n        client = new langsmith_1.Client(clientParams);\n    }\n    return client;\n};\nexports.getDefaultLangChainClientSingleton = getDefaultLangChainClientSingleton;\nconst setDefaultLangChainClientSingleton = (newClient) => {\n    client = newClient;\n};\nexports.setDefaultLangChainClientSingleton = setDefaultLangChainClientSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc2luZ2xldG9ucy90cmFjZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBDQUEwQyxHQUFHLDBDQUEwQztBQUN2RixvQkFBb0IsbUJBQU8sQ0FBQywyREFBVztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL3RyYWNlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gPSBleHBvcnRzLmdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gPSB2b2lkIDA7XG5jb25zdCBsYW5nc21pdGhfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGhcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9lbnYuY2pzXCIpO1xubGV0IGNsaWVudDtcbmNvbnN0IGdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gPSAoKSA9PiB7XG4gICAgaWYgKGNsaWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudFBhcmFtcyA9ICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkxBTkdDSEFJTl9DQUxMQkFDS1NfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAvLyBMYW5nU21pdGggaGFzIGl0cyBvd24gYmFja2dyb3VuZGluZyBzeXN0ZW1cbiAgICAgICAgICAgICAgICBibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGNsaWVudCA9IG5ldyBsYW5nc21pdGhfMS5DbGllbnQoY2xpZW50UGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbn07XG5leHBvcnRzLmdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24gPSBnZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uO1xuY29uc3Qgc2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiA9IChuZXdDbGllbnQpID0+IHtcbiAgICBjbGllbnQgPSBuZXdDbGllbnQ7XG59O1xuZXhwb3J0cy5zZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uID0gc2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/stores.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/dist/stores.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryStore = exports.BaseStore = void 0;\nconst serializable_js_1 = __webpack_require__(/*! ./load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");\n/**\n * Abstract interface for a key-value store.\n */\nclass BaseStore extends serializable_js_1.Serializable {\n}\nexports.BaseStore = BaseStore;\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nclass InMemoryStore extends BaseStore {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"storage\"]\n        });\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n    }\n    /**\n     * Retrieves the values associated with the given keys from the store.\n     * @param keys Keys to retrieve values for.\n     * @returns Array of values associated with the given keys.\n     */\n    async mget(keys) {\n        return keys.map((key) => this.store[key]);\n    }\n    /**\n     * Sets the values for the given keys in the store.\n     * @param keyValuePairs Array of key-value pairs to set in the store.\n     * @returns Promise that resolves when all key-value pairs have been set.\n     */\n    async mset(keyValuePairs) {\n        for (const [key, value] of keyValuePairs) {\n            this.store[key] = value;\n        }\n    }\n    /**\n     * Deletes the given keys and their associated values from the store.\n     * @param keys Keys to delete from the store.\n     * @returns Promise that resolves when all keys have been deleted.\n     */\n    async mdelete(keys) {\n        for (const key of keys) {\n            delete this.store[key];\n        }\n    }\n    /**\n     * Asynchronous generator that yields keys from the store. If a prefix is\n     * provided, it only yields keys that start with the prefix.\n     * @param prefix Optional prefix to filter keys.\n     * @returns AsyncGenerator that yields keys from the store.\n     */\n    async *yieldKeys(prefix) {\n        const keys = Object.keys(this.store);\n        for (const key of keys) {\n            if (prefix === undefined || key.startsWith(prefix)) {\n                yield key;\n            }\n        }\n    }\n}\nexports.InMemoryStore = InMemoryStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvc3RvcmVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3N0b3Jlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluTWVtb3J5U3RvcmUgPSBleHBvcnRzLkJhc2VTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNlcmlhbGl6YWJsZV9qc18xID0gcmVxdWlyZShcIi4vbG9hZC9zZXJpYWxpemFibGUuY2pzXCIpO1xuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIGEga2V5LXZhbHVlIHN0b3JlLlxuICovXG5jbGFzcyBCYXNlU3RvcmUgZXh0ZW5kcyBzZXJpYWxpemFibGVfanNfMS5TZXJpYWxpemFibGUge1xufVxuZXhwb3J0cy5CYXNlU3RvcmUgPSBCYXNlU3RvcmU7XG4vKipcbiAqIEluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQmFzZVN0b3JlIHVzaW5nIGEgZGljdGlvbmFyeS4gVXNlZCBmb3JcbiAqIHN0b3Jpbmcga2V5LXZhbHVlIHBhaXJzIGluIG1lbW9yeS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBzdG9yZSA9IG5ldyBJbk1lbW9yeVN0b3JlPEJhc2VNZXNzYWdlPigpO1xuICogYXdhaXQgc3RvcmUubXNldChcbiAqICAgQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9KS5tYXAoKF8sIGluZGV4KSA9PiBbXG4gKiAgICAgYG1lc3NhZ2U6aWQ6JHtpbmRleH1gLFxuICogICAgIGluZGV4ICUgMiA9PT0gMFxuICogICAgICAgPyBuZXcgQUlNZXNzYWdlKFwiYWkgc3R1ZmYuLi5cIilcbiAqICAgICAgIDogbmV3IEh1bWFuTWVzc2FnZShcImh1bWFuIHN0dWZmLi4uXCIpLFxuICogICBdKSxcbiAqICk7XG4gKlxuICogY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBhd2FpdCBzdG9yZS5tZ2V0KFtcIm1lc3NhZ2U6aWQ6MFwiLCBcIm1lc3NhZ2U6aWQ6MVwiXSk7XG4gKiBhd2FpdCBzdG9yZS5tZGVsZXRlKGF3YWl0IHN0b3JlLnlpZWxkS2V5cyhcIm1lc3NhZ2U6aWQ6XCIpLnRvQXJyYXkoKSk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNsYXNzIEluTWVtb3J5U3RvcmUgZXh0ZW5kcyBCYXNlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcInN0b3JhZ2VcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXlzIGZyb20gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSBrZXlzIEtleXMgdG8gcmV0cmlldmUgdmFsdWVzIGZvci5cbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXlzLlxuICAgICAqL1xuICAgIGFzeW5jIG1nZXQoa2V5cykge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5zdG9yZVtrZXldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5cyBpbiB0aGUgc3RvcmUuXG4gICAgICogQHBhcmFtIGtleVZhbHVlUGFpcnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIHNldCBpbiB0aGUgc3RvcmUuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGtleS12YWx1ZSBwYWlycyBoYXZlIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIG1zZXQoa2V5VmFsdWVQYWlycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBnaXZlbiBrZXlzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHZhbHVlcyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcGFyYW0ga2V5cyBLZXlzIHRvIGRlbGV0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwga2V5cyBoYXZlIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBtZGVsZXRlKGtleXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgZ2VuZXJhdG9yIHRoYXQgeWllbGRzIGtleXMgZnJvbSB0aGUgc3RvcmUuIElmIGEgcHJlZml4IGlzXG4gICAgICogcHJvdmlkZWQsIGl0IG9ubHkgeWllbGRzIGtleXMgdGhhdCBzdGFydCB3aXRoIHRoZSBwcmVmaXguXG4gICAgICogQHBhcmFtIHByZWZpeCBPcHRpb25hbCBwcmVmaXggdG8gZmlsdGVyIGtleXMuXG4gICAgICogQHJldHVybnMgQXN5bmNHZW5lcmF0b3IgdGhhdCB5aWVsZHMga2V5cyBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyAqeWllbGRLZXlzKHByZWZpeCkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdG9yZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCB8fCBrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Jbk1lbW9yeVN0b3JlID0gSW5NZW1vcnlTdG9yZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseToolkit = exports.DynamicStructuredTool = exports.DynamicTool = exports.Tool = exports.StructuredTool = exports.ToolInputParsingException = exports.isStructuredToolParams = exports.isStructuredTool = exports.isRunnableToolLike = exports.isLangChainTool = void 0;\nexports.tool = tool;\nconst v3_1 = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/index.cjs\");\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst manager_js_1 = __webpack_require__(/*! ../callbacks/manager.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/manager.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst tool_js_1 = __webpack_require__(/*! ../messages/tool.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/tool.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\");\nObject.defineProperty(exports, \"ToolInputParsingException\", ({ enumerable: true, get: function () { return utils_js_1.ToolInputParsingException; } }));\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ../utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\nvar types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nObject.defineProperty(exports, \"isLangChainTool\", ({ enumerable: true, get: function () { return types_js_1.isLangChainTool; } }));\nObject.defineProperty(exports, \"isRunnableToolLike\", ({ enumerable: true, get: function () { return types_js_1.isRunnableToolLike; } }));\nObject.defineProperty(exports, \"isStructuredTool\", ({ enumerable: true, get: function () { return types_js_1.isStructuredTool; } }));\nObject.defineProperty(exports, \"isStructuredToolParams\", ({ enumerable: true, get: function () { return types_js_1.isStructuredToolParams; } }));\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nclass StructuredTool extends base_js_1.BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        /**\n         * Whether to return the tool's output directly.\n         *\n         * Setting this to true means that after the tool is called,\n         * an agent should stop looping.\n         */\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        /**\n         * Default config object for the tool runnable.\n         */\n        Object.defineProperty(this, \"defaultConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n        this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n        this.metadata = fields?.metadata ?? this.metadata;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    async invoke(input, config) {\n        let toolInput;\n        let enrichedConfig = (0, config_js_1.ensureConfig)((0, config_js_1.mergeConfigs)(this.defaultConfig, config));\n        if ((0, utils_js_1._isToolCall)(input)) {\n            toolInput = input.args;\n            enrichedConfig = {\n                ...enrichedConfig,\n                toolCall: input,\n            };\n        }\n        else {\n            toolInput = input;\n        }\n        return this.call(toolInput, enrichedConfig);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        // Determine the actual input that needs parsing/validation.\n        // If arg is a ToolCall, use its args; otherwise, use arg directly.\n        const inputForValidation = (0, utils_js_1._isToolCall)(arg) ? arg.args : arg;\n        let parsed; // This will hold the successfully parsed input of the expected output type.\n        if ((0, zod_js_1.isInteropZodSchema)(this.schema)) {\n            try {\n                // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n                parsed = await (0, zod_js_1.interopParseAsync)(this.schema, inputForValidation);\n            }\n            catch (e) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${e.message}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n        }\n        else {\n            const result = (0, json_schema_1.validate)(inputForValidation, this.schema);\n            if (!result.valid) {\n                let message = `Received tool input did not match expected schema`;\n                if (this.verboseParsingErrors) {\n                    message = `${message}\\nDetails: ${result.errors\n                        .map((e) => `${e.keywordLocation}: ${e.error}`)\n                        .join(\"\\n\")}`;\n                }\n                // Pass the original raw input arg to the exception\n                throw new utils_js_1.ToolInputParsingException(message, JSON.stringify(arg));\n            }\n            // Assign the validated input to parsed\n            // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n            parsed = inputForValidation;\n        }\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        const callbackManager_ = manager_js_1.CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), \n        // Log the original raw input arg\n        typeof arg === \"string\" ? arg : JSON.stringify(arg), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            // Pass the correctly typed parsed input to _call\n            result = await this._call(parsed, runManager, config);\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        // Extract toolCallId ONLY if the original arg was a ToolCall\n        if ((0, utils_js_1._isToolCall)(arg)) {\n            toolCallId = arg.id;\n        }\n        // Or if it was provided in the config's toolCall property\n        if (!toolCallId && (0, utils_js_1._configHasToolCallId)(config)) {\n            toolCallId = config.toolCall.id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n            metadata: this.metadata,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\nexports.StructuredTool = StructuredTool;\n/**\n * Base class for Tools that accept input as a string.\n */\nclass Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: v3_1.z\n                .object({ input: v3_1.z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    // Match the base class signature including the generics and conditional return type\n    call(arg, callbacks) {\n        // Prepare the input for the base class call method.\n        // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n        const structuredArg = typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n        // Ensure TConfig is passed to super.call\n        return super.call(structuredArg, callbacks);\n    }\n}\nexports.Tool = Tool;\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nclass DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the Tool class's call method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\nexports.DynamicTool = DynamicTool;\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nclass DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = fields.schema;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    // Match the base class signature\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = (0, manager_js_1.parseCallbackConfigArg)(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        // Call the base class method, passing generics through\n        // Cast config to TConfig to satisfy the super.call signature\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        return this.func(arg, runManager, parentConfig);\n    }\n}\nexports.DynamicStructuredTool = DynamicStructuredTool;\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nclass BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nexports.BaseToolkit = BaseToolkit;\nfunction tool(func, fields) {\n    const isSimpleStringSchema = (0, zod_js_1.isSimpleStringZodSchema)(fields.schema);\n    const isStringJSONSchema = (0, json_schema_js_1.validatesOnlyStrings)(fields.schema);\n    // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n    if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                (fields.schema && (0, zod_js_1.getSchemaDescription)(fields.schema)) ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = (0, config_js_1.patchConfig)(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const schema = fields.schema;\n    const description = fields.description ??\n        fields.schema.description ??\n        `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        schema,\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = (0, config_js_1.patchConfig)(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(childConfig), async () => {\n                    try {\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId, metadata } = params;\n    if (toolCallId && !(0, tool_js_1.isDirectToolOutput)(content)) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new tool_js_1.ToolMessage({\n                status: \"success\",\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n        else {\n            return new tool_js_1.ToolMessage({\n                status: \"success\",\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n                metadata,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2) ?? \"\";\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLDZCQUE2QixHQUFHLG1CQUFtQixHQUFHLFlBQVksR0FBRyxzQkFBc0IsR0FBRyxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUI7QUFDeFEsWUFBWTtBQUNaLGFBQWEsbUJBQU8sQ0FBQyxxREFBUTtBQUM3QixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVHQUE2QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMseUZBQXNCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN4Qyw2REFBNEQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDcEosaUJBQWlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLGlHQUEwQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN0QyxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSwwREFBeUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsYUFBYSxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsYUFBYTtBQUN0RCx1Q0FBdUMsa0JBQWtCLElBQUksUUFBUTtBQUNyRSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEtBQTRLLHVCQUF1QjtBQUNuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILHVCQUF1QjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhCQUE4QixhQUFhO0FBQzlGLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3Rvb2xzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVRvb2xraXQgPSBleHBvcnRzLkR5bmFtaWNTdHJ1Y3R1cmVkVG9vbCA9IGV4cG9ydHMuRHluYW1pY1Rvb2wgPSBleHBvcnRzLlRvb2wgPSBleHBvcnRzLlN0cnVjdHVyZWRUb29sID0gZXhwb3J0cy5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uID0gZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sUGFyYW1zID0gZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sID0gZXhwb3J0cy5pc1J1bm5hYmxlVG9vbExpa2UgPSBleHBvcnRzLmlzTGFuZ0NoYWluVG9vbCA9IHZvaWQgMDtcbmV4cG9ydHMudG9vbCA9IHRvb2w7XG5jb25zdCB2M18xID0gcmVxdWlyZShcInpvZC92M1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCIpO1xuY29uc3QgbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9tYW5hZ2VyLmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuLi9sYW5ndWFnZV9tb2RlbHMvYmFzZS5janNcIik7XG5jb25zdCBjb25maWdfanNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uYWJsZXMvY29uZmlnLmNqc1wiKTtcbmNvbnN0IHRvb2xfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy90b29sLmNqc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vc2luZ2xldG9ucy9pbmRleC5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfanNfMS5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uOyB9IH0pO1xuY29uc3Qgem9kX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdHlwZXMvem9kLmNqc1wiKTtcbmNvbnN0IGpzb25fc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvanNvbl9zY2hlbWEuY2pzXCIpO1xudmFyIHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlcy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xhbmdDaGFpblRvb2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzX2pzXzEuaXNMYW5nQ2hhaW5Ub29sOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSdW5uYWJsZVRvb2xMaWtlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18xLmlzUnVubmFibGVUb29sTGlrZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RydWN0dXJlZFRvb2xcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzX2pzXzEuaXNTdHJ1Y3R1cmVkVG9vbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RydWN0dXJlZFRvb2xQYXJhbXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzX2pzXzEuaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtczsgfSB9KTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgVG9vbHMgdGhhdCBhY2NlcHQgaW5wdXQgb2YgYW55IHNoYXBlIGRlZmluZWQgYnkgYSBab2Qgc2NoZW1hLlxuICovXG5jbGFzcyBTdHJ1Y3R1cmVkVG9vbCBleHRlbmRzIGJhc2VfanNfMS5CYXNlTGFuZ0NoYWluIHtcbiAgICBnZXQgbGNfbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gW1wibGFuZ2NoYWluXCIsIFwidG9vbHNcIl07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMgPz8ge30pO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byByZXR1cm4gdGhlIHRvb2wncyBvdXRwdXQgZGlyZWN0bHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyB0byB0cnVlIG1lYW5zIHRoYXQgYWZ0ZXIgdGhlIHRvb2wgaXMgY2FsbGVkLFxuICAgICAgICAgKiBhbiBhZ2VudCBzaG91bGQgc3RvcCBsb29waW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuRGlyZWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVBhcnNpbmdFcnJvcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvb2wgcmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBcImNvbnRlbnRcIiB0aGVuIHRoZSBvdXRwdXQgb2YgdGhlIHRvb2wgaXMgaW50ZXJwcmV0ZWQgYXMgdGhlIGNvbnRlbnRzIG9mIGFcbiAgICAgICAgICogVG9vbE1lc3NhZ2UuIElmIFwiY29udGVudF9hbmRfYXJ0aWZhY3RcIiB0aGVuIHRoZSBvdXRwdXQgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICAgICAgICAgKiB0d28tdHVwbGUgY29ycmVzcG9uZGluZyB0byB0aGUgKGNvbnRlbnQsIGFydGlmYWN0KSBvZiBhIFRvb2xNZXNzYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCBcImNvbnRlbnRcIlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY29udGVudFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBjb25maWcgb2JqZWN0IGZvciB0aGUgdG9vbCBydW5uYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRDb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJib3NlUGFyc2luZ0Vycm9ycyA9XG4gICAgICAgICAgICBmaWVsZHM/LnZlcmJvc2VQYXJzaW5nRXJyb3JzID8/IHRoaXMudmVyYm9zZVBhcnNpbmdFcnJvcnM7XG4gICAgICAgIHRoaXMucmVzcG9uc2VGb3JtYXQgPSBmaWVsZHM/LnJlc3BvbnNlRm9ybWF0ID8/IHRoaXMucmVzcG9uc2VGb3JtYXQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IGZpZWxkcz8uZGVmYXVsdENvbmZpZyA/PyB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBmaWVsZHM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgaW5wdXQgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBmb3IgdGhlIHRvb2wuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgdG9vbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0b29sJ3Mgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGxldCB0b29sSW5wdXQ7XG4gICAgICAgIGxldCBlbnJpY2hlZENvbmZpZyA9ICgwLCBjb25maWdfanNfMS5lbnN1cmVDb25maWcpKCgwLCBjb25maWdfanNfMS5tZXJnZUNvbmZpZ3MpKHRoaXMuZGVmYXVsdENvbmZpZywgY29uZmlnKSk7XG4gICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5faXNUb29sQ2FsbCkoaW5wdXQpKSB7XG4gICAgICAgICAgICB0b29sSW5wdXQgPSBpbnB1dC5hcmdzO1xuICAgICAgICAgICAgZW5yaWNoZWRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgLi4uZW5yaWNoZWRDb25maWcsXG4gICAgICAgICAgICAgICAgdG9vbENhbGw6IGlucHV0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvb2xJbnB1dCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwodG9vbElucHV0LCBlbnJpY2hlZENvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMy4wLlxuICAgICAqXG4gICAgICogQ2FsbHMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQsIGNvbmZpZ3VyYXRpb24sIGFuZCB0YWdzLiBJdFxuICAgICAqIHBhcnNlcyB0aGUgaW5wdXQgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIGhhbmRsZXMgYW55IGVycm9ycywgYW5kXG4gICAgICogbWFuYWdlcyBjYWxsYmFja3MuXG4gICAgICogQHBhcmFtIGFyZyBUaGUgaW5wdXQgYXJndW1lbnQgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSBjb25maWdBcmcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvciBjYWxsYmFja3MgZm9yIHRoZSB0b29sLlxuICAgICAqIEBwYXJhbSB0YWdzIE9wdGlvbmFsIHRhZ3MgZm9yIHRoZSB0b29sLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgdGFncykge1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGFjdHVhbCBpbnB1dCB0aGF0IG5lZWRzIHBhcnNpbmcvdmFsaWRhdGlvbi5cbiAgICAgICAgLy8gSWYgYXJnIGlzIGEgVG9vbENhbGwsIHVzZSBpdHMgYXJnczsgb3RoZXJ3aXNlLCB1c2UgYXJnIGRpcmVjdGx5LlxuICAgICAgICBjb25zdCBpbnB1dEZvclZhbGlkYXRpb24gPSAoMCwgdXRpbHNfanNfMS5faXNUb29sQ2FsbCkoYXJnKSA/IGFyZy5hcmdzIDogYXJnO1xuICAgICAgICBsZXQgcGFyc2VkOyAvLyBUaGlzIHdpbGwgaG9sZCB0aGUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBpbnB1dCBvZiB0aGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUuXG4gICAgICAgIGlmICgoMCwgem9kX2pzXzEuaXNJbnRlcm9wWm9kU2NoZW1hKSh0aGlzLnNjaGVtYSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGlucHV0Rm9yVmFsaWRhdGlvbiAtIFRTIG5lZWRzIGhlbHAgaGVyZSBhcyBpdCBjYW4ndCBleGNsdWRlIFRvb2xDYWxsIGJhc2VkIG9uIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IGF3YWl0ICgwLCB6b2RfanNfMS5pbnRlcm9wUGFyc2VBc3luYykodGhpcy5zY2hlbWEsIGlucHV0Rm9yVmFsaWRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYFJlY2VpdmVkIHRvb2wgaW5wdXQgZGlkIG5vdCBtYXRjaCBleHBlY3RlZCBzY2hlbWFgO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2VQYXJzaW5nRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbkRldGFpbHM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIG9yaWdpbmFsIHJhdyBpbnB1dCBhcmcgdG8gdGhlIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyB1dGlsc19qc18xLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24obWVzc2FnZSwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwganNvbl9zY2hlbWFfMS52YWxpZGF0ZSkoaW5wdXRGb3JWYWxpZGF0aW9uLCB0aGlzLnNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYFJlY2VpdmVkIHRvb2wgaW5wdXQgZGlkIG5vdCBtYXRjaCBleHBlY3RlZCBzY2hlbWFgO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcmJvc2VQYXJzaW5nRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbkRldGFpbHM6ICR7cmVzdWx0LmVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZS5rZXl3b3JkTG9jYXRpb259OiAke2UuZXJyb3J9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIG9yaWdpbmFsIHJhdyBpbnB1dCBhcmcgdG8gdGhlIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyB1dGlsc19qc18xLlRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb24obWVzc2FnZSwgSlNPTi5zdHJpbmdpZnkoYXJnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NpZ24gdGhlIHZhbGlkYXRlZCBpbnB1dCB0byBwYXJzZWRcbiAgICAgICAgICAgIC8vIFdlIGNhc3QgaGVyZSBiZWNhdXNlIHZhbGlkYXRlKCkgZG9lc24ndCBuYXJyb3cgdGhlIHR5cGUgc3VmZmljaWVudGx5IGZvciBUUywgYnV0IHdlIGtub3cgaXQncyB2YWxpZC5cbiAgICAgICAgICAgIHBhcnNlZCA9IGlucHV0Rm9yVmFsaWRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgbWFuYWdlcl9qc18xLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcpKGNvbmZpZ0FyZyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBtYW5hZ2VyX2pzXzEuQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShjb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgY29uZmlnLnRhZ3MgfHwgdGFncywgdGhpcy50YWdzLCBjb25maWcubWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlVG9vbFN0YXJ0KHRoaXMudG9KU09OKCksIFxuICAgICAgICAvLyBMb2cgdGhlIG9yaWdpbmFsIHJhdyBpbnB1dCBhcmdcbiAgICAgICAgdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiA/IGFyZyA6IEpTT04uc3RyaW5naWZ5KGFyZyksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBkZWxldGUgY29uZmlnLnJ1bklkO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUGFzcyB0aGUgY29ycmVjdGx5IHR5cGVkIHBhcnNlZCBpbnB1dCB0byBfY2FsbFxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fY2FsbChwYXJzZWQsIHJ1bk1hbmFnZXIsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZVRvb2xFcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgIGxldCBhcnRpZmFjdDtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VGb3JtYXQgPT09IFwiY29udGVudF9hbmRfYXJ0aWZhY3RcIikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgW2NvbnRlbnQsIGFydGlmYWN0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCByZXNwb25zZSBmb3JtYXQgaXMgXCJjb250ZW50X2FuZF9hcnRpZmFjdFwiIGJ1dCB0aGUgb3V0cHV0IHdhcyBub3QgYSB0d28tdHVwbGUuXFxuUmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sQ2FsbElkO1xuICAgICAgICAvLyBFeHRyYWN0IHRvb2xDYWxsSWQgT05MWSBpZiB0aGUgb3JpZ2luYWwgYXJnIHdhcyBhIFRvb2xDYWxsXG4gICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5faXNUb29sQ2FsbCkoYXJnKSkge1xuICAgICAgICAgICAgdG9vbENhbGxJZCA9IGFyZy5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPciBpZiBpdCB3YXMgcHJvdmlkZWQgaW4gdGhlIGNvbmZpZydzIHRvb2xDYWxsIHByb3BlcnR5XG4gICAgICAgIGlmICghdG9vbENhbGxJZCAmJiAoMCwgdXRpbHNfanNfMS5fY29uZmlnSGFzVG9vbENhbGxJZCkoY29uZmlnKSkge1xuICAgICAgICAgICAgdG9vbENhbGxJZCA9IGNvbmZpZy50b29sQ2FsbC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRPdXRwdXQgPSBfZm9ybWF0VG9vbE91dHB1dCh7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgYXJ0aWZhY3QsXG4gICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUb29sRW5kKGZvcm1hdHRlZE91dHB1dCk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRPdXRwdXQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmVkVG9vbCA9IFN0cnVjdHVyZWRUb29sO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBUb29scyB0aGF0IGFjY2VwdCBpbnB1dCBhcyBhIHN0cmluZy5cbiAqL1xuY2xhc3MgVG9vbCBleHRlbmRzIFN0cnVjdHVyZWRUb29sIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2M18xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHsgaW5wdXQ6IHYzXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpIH0pXG4gICAgICAgICAgICAgICAgLnRyYW5zZm9ybSgob2JqKSA9PiBvYmouaW5wdXQpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSB0b29sIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGFuZCBjYWxsYmFja3MuIEl0IGhhbmRsZXNcbiAgICAgKiBzdHJpbmcgaW5wdXRzIHNwZWNpZmljYWxseS5cbiAgICAgKiBAcGFyYW0gYXJnIFRoZSBpbnB1dCBhcmd1bWVudCBmb3IgdGhlIHRvb2wsIHdoaWNoIGNhbiBiZSBhIHN0cmluZywgdW5kZWZpbmVkLCBvciBhbiBpbnB1dCBvZiB0aGUgdG9vbCdzIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIE9wdGlvbmFsIGNhbGxiYWNrcyBmb3IgdGhlIHRvb2wuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIHN0cmluZy5cbiAgICAgKi9cbiAgICAvLyBNYXRjaCB0aGUgYmFzZSBjbGFzcyBzaWduYXR1cmUgaW5jbHVkaW5nIHRoZSBnZW5lcmljcyBhbmQgY29uZGl0aW9uYWwgcmV0dXJuIHR5cGVcbiAgICBjYWxsKGFyZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIGlucHV0IGZvciB0aGUgYmFzZSBjbGFzcyBjYWxsIG1ldGhvZC5cbiAgICAgICAgLy8gSWYgYXJnIGlzIHN0cmluZyBvciB1bmRlZmluZWQsIHdyYXAgaXQ7IG90aGVyd2lzZSwgcGFzcyBUb29sQ2FsbCBvciB7IGlucHV0OiAuLi4gfSBkaXJlY3RseS5cbiAgICAgICAgY29uc3Qgc3RydWN0dXJlZEFyZyA9IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgfHwgYXJnID09IG51bGwgPyB7IGlucHV0OiBhcmcgfSA6IGFyZztcbiAgICAgICAgLy8gRW5zdXJlIFRDb25maWcgaXMgcGFzc2VkIHRvIHN1cGVyLmNhbGxcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoc3RydWN0dXJlZEFyZywgY2FsbGJhY2tzKTtcbiAgICB9XG59XG5leHBvcnRzLlRvb2wgPSBUb29sO1xuLyoqXG4gKiBBIHRvb2wgdGhhdCBjYW4gYmUgY3JlYXRlZCBkeW5hbWljYWxseSBmcm9tIGEgZnVuY3Rpb24sIG5hbWUsIGFuZCBkZXNjcmlwdGlvbi5cbiAqL1xuY2xhc3MgRHluYW1pY1Rvb2wgZXh0ZW5kcyBUb29sIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRHluYW1pY1Rvb2xcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIHRoaXMucmV0dXJuRGlyZWN0ID0gZmllbGRzLnJldHVybkRpcmVjdCA/PyB0aGlzLnJldHVybkRpcmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4zLjAuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChhcmcsIGNvbmZpZ0FyZykge1xuICAgICAgICBjb25zdCBjb25maWcgPSAoMCwgbWFuYWdlcl9qc18xLnBhcnNlQ2FsbGJhY2tDb25maWdBcmcpKGNvbmZpZ0FyZyk7XG4gICAgICAgIGlmIChjb25maWcucnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcucnVuTmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRoZSBUb29sIGNsYXNzJ3MgY2FsbCBtZXRob2QsIHBhc3NpbmcgZ2VuZXJpY3MgdGhyb3VnaFxuICAgICAgICAvLyBDYXN0IGNvbmZpZyB0byBUQ29uZmlnIHRvIHNhdGlzZnkgdGhlIHN1cGVyLmNhbGwgc2lnbmF0dXJlXG4gICAgICAgIHJldHVybiBzdXBlci5jYWxsKGFyZywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfY2FsbChpbnB1dCwgLy8gRHluYW1pY1Rvb2wncyBfY2FsbCBzcGVjaWZpY2FsbHkgZXhwZWN0cyBhIHN0cmluZyBhZnRlciBzY2hlbWEgdHJhbnNmb3JtYXRpb25cbiAgICBydW5NYW5hZ2VyLCBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhpbnB1dCwgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLkR5bmFtaWNUb29sID0gRHluYW1pY1Rvb2w7XG4vKipcbiAqIEEgdG9vbCB0aGF0IGNhbiBiZSBjcmVhdGVkIGR5bmFtaWNhbGx5IGZyb20gYSBmdW5jdGlvbiwgbmFtZSwgYW5kXG4gKiBkZXNjcmlwdGlvbiwgZGVzaWduZWQgdG8gd29yayB3aXRoIHN0cnVjdHVyZWQgZGF0YS4gSXQgZXh0ZW5kcyB0aGVcbiAqIFN0cnVjdHVyZWRUb29sIGNsYXNzIGFuZCBvdmVycmlkZXMgdGhlIF9jYWxsIG1ldGhvZCB0byBleGVjdXRlIHRoZVxuICogcHJvdmlkZWQgZnVuY3Rpb24gd2hlbiB0aGUgdG9vbCBpcyBjYWxsZWQuXG4gKlxuICogU2NoZW1hIGNhbiBiZSBwYXNzZWQgYXMgWm9kIG9yIEpTT04gc2NoZW1hLiBUaGUgdG9vbCB3aWxsIG5vdCB2YWxpZGF0ZVxuICogaW5wdXQgaWYgSlNPTiBzY2hlbWEgaXMgcGFzc2VkLlxuICovXG5jbGFzcyBEeW5hbWljU3RydWN0dXJlZFRvb2wgZXh0ZW5kcyBTdHJ1Y3R1cmVkVG9vbCB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkR5bmFtaWNTdHJ1Y3R1cmVkVG9vbFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5mdW5jID0gZmllbGRzLmZ1bmM7XG4gICAgICAgIHRoaXMucmV0dXJuRGlyZWN0ID0gZmllbGRzLnJldHVybkRpcmVjdCA/PyB0aGlzLnJldHVybkRpcmVjdDtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjMuMC5cbiAgICAgKi9cbiAgICAvLyBNYXRjaCB0aGUgYmFzZSBjbGFzcyBzaWduYXR1cmVcbiAgICBhc3luYyBjYWxsKGFyZywgY29uZmlnQXJnLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICB0YWdzKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBtYW5hZ2VyX2pzXzEucGFyc2VDYWxsYmFja0NvbmZpZ0FyZykoY29uZmlnQXJnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5ydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5ydW5OYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgdGhlIGJhc2UgY2xhc3MgbWV0aG9kLCBwYXNzaW5nIGdlbmVyaWNzIHRocm91Z2hcbiAgICAgICAgLy8gQ2FzdCBjb25maWcgdG8gVENvbmZpZyB0byBzYXRpc2Z5IHRoZSBzdXBlci5jYWxsIHNpZ25hdHVyZVxuICAgICAgICByZXR1cm4gc3VwZXIuY2FsbChhcmcsIGNvbmZpZywgdGFncyk7XG4gICAgfVxuICAgIF9jYWxsKGFyZywgcnVuTWFuYWdlciwgcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMoYXJnLCBydW5NYW5hZ2VyLCBwYXJlbnRDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuRHluYW1pY1N0cnVjdHVyZWRUb29sID0gRHluYW1pY1N0cnVjdHVyZWRUb29sO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciB0b29sa2l0cyBpbiBMYW5nQ2hhaW4uIFRvb2xraXRzIGFyZSBjb2xsZWN0aW9uc1xuICogb2YgdG9vbHMgdGhhdCBhZ2VudHMgY2FuIHVzZS4gU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGUgYHRvb2xzYFxuICogcHJvcGVydHkgdG8gcHJvdmlkZSB0aGUgc3BlY2lmaWMgdG9vbHMgZm9yIHRoZSB0b29sa2l0LlxuICovXG5jbGFzcyBCYXNlVG9vbGtpdCB7XG4gICAgZ2V0VG9vbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVRvb2xraXQgPSBCYXNlVG9vbGtpdDtcbmZ1bmN0aW9uIHRvb2woZnVuYywgZmllbGRzKSB7XG4gICAgY29uc3QgaXNTaW1wbGVTdHJpbmdTY2hlbWEgPSAoMCwgem9kX2pzXzEuaXNTaW1wbGVTdHJpbmdab2RTY2hlbWEpKGZpZWxkcy5zY2hlbWEpO1xuICAgIGNvbnN0IGlzU3RyaW5nSlNPTlNjaGVtYSA9ICgwLCBqc29uX3NjaGVtYV9qc18xLnZhbGlkYXRlc09ubHlTdHJpbmdzKShmaWVsZHMuc2NoZW1hKTtcbiAgICAvLyBJZiB0aGUgc2NoZW1hIGlzIG5vdCBwcm92aWRlZCwgb3IgaXQncyBhIHNpbXBsZSBzdHJpbmcgc2NoZW1hLCBjcmVhdGUgYSBEeW5hbWljVG9vbFxuICAgIGlmICghZmllbGRzLnNjaGVtYSB8fCBpc1NpbXBsZVN0cmluZ1NjaGVtYSB8fCBpc1N0cmluZ0pTT05TY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEeW5hbWljVG9vbCh7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmllbGRzLmRlc2NyaXB0aW9uID8/XG4gICAgICAgICAgICAgICAgKGZpZWxkcy5zY2hlbWEgJiYgKDAsIHpvZF9qc18xLmdldFNjaGVtYURlc2NyaXB0aW9uKShmaWVsZHMuc2NoZW1hKSkgPz9cbiAgICAgICAgICAgICAgICBgJHtmaWVsZHMubmFtZX0gdG9vbGAsXG4gICAgICAgICAgICBmdW5jOiBhc3luYyAoaW5wdXQsIHJ1bk1hbmFnZXIsIGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gKDAsIGNvbmZpZ19qc18xLnBhdGNoQ29uZmlnKShjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgaW5kZXhfanNfMS5Bc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcoKDAsIGNvbmZpZ19qc18xLnBpY2tSdW5uYWJsZUNvbmZpZ0tleXMpKGNoaWxkQ29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUUyBkb2Vzbid0IHJlc3RyaWN0IHRoZSB0eXBlIGhlcmUgYmFzZWQgb24gdGhlIGd1YXJkIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmMoaW5wdXQsIGNoaWxkQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0gZmllbGRzLnNjaGVtYTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbiA/P1xuICAgICAgICBmaWVsZHMuc2NoZW1hLmRlc2NyaXB0aW9uID8/XG4gICAgICAgIGAke2ZpZWxkcy5uYW1lfSB0b29sYDtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNTdHJ1Y3R1cmVkVG9vbCh7XG4gICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZnVuYzogYXN5bmMgKGlucHV0LCBydW5NYW5hZ2VyLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSAoMCwgY29uZmlnX2pzXzEucGF0Y2hDb25maWcpKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdm9pZCBpbmRleF9qc18xLkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZygoMCwgY29uZmlnX2pzXzEucGlja1J1bm5hYmxlQ29uZmlnS2V5cykoY2hpbGRDb25maWcpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmMoaW5wdXQsIGNoaWxkQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZm9ybWF0VG9vbE91dHB1dChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIGFydGlmYWN0LCB0b29sQ2FsbElkLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGlmICh0b29sQ2FsbElkICYmICEoMCwgdG9vbF9qc18xLmlzRGlyZWN0VG9vbE91dHB1dCkoY29udGVudCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjb250ZW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbnRlbnQuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdG9vbF9qc18xLlRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgYXJ0aWZhY3QsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRvb2xfanNfMS5Ub29sTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfc3RyaW5naWZ5KGNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIGFydGlmYWN0LFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBfc3RyaW5naWZ5KGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGVudCwgbnVsbCwgMikgPz8gXCJcIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9ub09wKSB7XG4gICAgICAgIHJldHVybiBgJHtjb250ZW50fWA7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/types.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isStructuredTool = isStructuredTool;\nexports.isRunnableToolLike = isRunnableToolLike;\nexports.isStructuredToolParams = isStructuredToolParams;\nexports.isLangChainTool = isLangChainTool;\nconst base_js_1 = __webpack_require__(/*! ../runnables/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/base.cjs\");\nconst zod_js_1 = __webpack_require__(/*! ../utils/types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nfunction isStructuredTool(tool) {\n    return (tool !== undefined &&\n        Array.isArray(tool.lc_namespace));\n}\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nfunction isRunnableToolLike(tool) {\n    return (tool !== undefined &&\n        base_js_1.Runnable.isRunnable(tool) &&\n        \"lc_name\" in tool.constructor &&\n        typeof tool.constructor.lc_name === \"function\" &&\n        tool.constructor.lc_name() === \"RunnableToolLike\");\n}\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nfunction isStructuredToolParams(tool) {\n    return (!!tool &&\n        typeof tool === \"object\" &&\n        \"name\" in tool &&\n        \"schema\" in tool &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((0, zod_js_1.isInteropZodSchema)(tool.schema) ||\n            (tool.schema != null &&\n                typeof tool.schema === \"object\" &&\n                \"type\" in tool.schema &&\n                typeof tool.schema.type === \"string\" &&\n                [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(tool.schema.type))));\n}\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nfunction isLangChainTool(tool) {\n    return (isStructuredToolParams(tool) ||\n        isRunnableToolLike(tool) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        isStructuredTool(tool));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQWtEO0FBQzdELGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdHlwZXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sID0gaXNTdHJ1Y3R1cmVkVG9vbDtcbmV4cG9ydHMuaXNSdW5uYWJsZVRvb2xMaWtlID0gaXNSdW5uYWJsZVRvb2xMaWtlO1xuZXhwb3J0cy5pc1N0cnVjdHVyZWRUb29sUGFyYW1zID0gaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcztcbmV4cG9ydHMuaXNMYW5nQ2hhaW5Ub29sID0gaXNMYW5nQ2hhaW5Ub29sO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL3J1bm5hYmxlcy9iYXNlLmNqc1wiKTtcbmNvbnN0IHpvZF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3R5cGVzL3pvZC5janNcIik7XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0dXJlZFRvb2xJbnRlcmZhY2UgfCBKU09OU2NoZW1hIHwgdW5kZWZpbmVkfSB0b29sIFRoZSB0b29sIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGluc3RhbmNlIG9mIGBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZWAuXG4gKiBAcmV0dXJucyB7dG9vbCBpcyBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZX0gV2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgU3RydWN0dXJlZFRvb2xJbnRlcmZhY2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cnVjdHVyZWRUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gKHRvb2wgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHRvb2wubGNfbmFtZXNwYWNlKSk7XG59XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAuXG4gKlxuICogQHBhcmFtIHt1bmtub3duIHwgdW5kZWZpbmVkfSB0b29sIFRoZSB0b29sIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFJ1bm5hYmxlVG9vbExpa2V9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgLlxuICovXG5mdW5jdGlvbiBpc1J1bm5hYmxlVG9vbExpa2UodG9vbCkge1xuICAgIHJldHVybiAodG9vbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhc2VfanNfMS5SdW5uYWJsZS5pc1J1bm5hYmxlKHRvb2wpICYmXG4gICAgICAgIFwibGNfbmFtZVwiIGluIHRvb2wuY29uc3RydWN0b3IgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSgpID09PSBcIlJ1bm5hYmxlVG9vbExpa2VcIik7XG59XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciBvciBub3QgdGhlIHRvb2wgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIGJlIGNvbnNpZGVyZWQgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93biB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgb2JqZWN0IHRvIGNoZWNrIGlmIGl0IGlzIGEgYFN0cnVjdHVyZWRUb29sUGFyYW1zYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCBvYmplY3QgaXMgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICovXG5mdW5jdGlvbiBpc1N0cnVjdHVyZWRUb29sUGFyYW1zKHRvb2wpIHtcbiAgICByZXR1cm4gKCEhdG9vbCAmJlxuICAgICAgICB0eXBlb2YgdG9vbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sICYmXG4gICAgICAgIFwic2NoZW1hXCIgaW4gdG9vbCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoKDAsIHpvZF9qc18xLmlzSW50ZXJvcFpvZFNjaGVtYSkodG9vbC5zY2hlbWEpIHx8XG4gICAgICAgICAgICAodG9vbC5zY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sLnNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIFwidHlwZVwiIGluIHRvb2wuc2NoZW1hICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRvb2wuc2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBbXCJudWxsXCIsIFwiYm9vbGVhblwiLCBcIm9iamVjdFwiLCBcImFycmF5XCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCJdLmluY2x1ZGVzKHRvb2wuc2NoZW1hLnR5cGUpKSkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgdG9vbCBpcyBvbmUgb2YgU3RydWN0dXJlZFRvb2wsIFJ1bm5hYmxlVG9vbCBvciBTdHJ1Y3R1cmVkVG9vbFBhcmFtcy5cbiAqIEl0IHJldHVybnMgYGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zYCBzaW5jZSB0aGF0IGlzIHRoZSBtb3N0IG1pbmltYWwgaW50ZXJmYWNlIG9mIHRoZSB0aHJlZSxcbiAqIHdoaWxlIHN0aWxsIGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIGJlIHBhc3NlZCB0byBhIExMTSBmb3IgdG9vbCBjYWxsaW5nLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93biB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgdG9vbCB0byBjaGVjayBpZiBpdCBpcyBhIExhbmdDaGFpbiB0b29sLlxuICogQHJldHVybnMge3Rvb2wgaXMgU3RydWN0dXJlZFRvb2xQYXJhbXN9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYSBMYW5nQ2hhaW4gdG9vbC5cbiAqL1xuZnVuY3Rpb24gaXNMYW5nQ2hhaW5Ub29sKHRvb2wpIHtcbiAgICByZXR1cm4gKGlzU3RydWN0dXJlZFRvb2xQYXJhbXModG9vbCkgfHxcbiAgICAgICAgaXNSdW5uYWJsZVRvb2xMaWtlKHRvb2wpIHx8XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlzU3RydWN0dXJlZFRvb2wodG9vbCkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tools/utils.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolInputParsingException = void 0;\nexports._isToolCall = _isToolCall;\nexports._configHasToolCallId = _configHasToolCallId;\nfunction _isToolCall(toolCall) {\n    return !!(toolCall &&\n        typeof toolCall === \"object\" &&\n        \"type\" in toolCall &&\n        toolCall.type === \"tool_call\");\n}\nfunction _configHasToolCallId(config) {\n    return !!(config &&\n        typeof config === \"object\" &&\n        \"toolCall\" in config &&\n        config.toolCall != null &&\n        typeof config.toolCall === \"object\" &&\n        \"id\" in config.toolCall &&\n        typeof config.toolCall.id === \"string\");\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nclass ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\nexports.ToolInputParsingException = ToolInputParsingException;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uID0gdm9pZCAwO1xuZXhwb3J0cy5faXNUb29sQ2FsbCA9IF9pc1Rvb2xDYWxsO1xuZXhwb3J0cy5fY29uZmlnSGFzVG9vbENhbGxJZCA9IF9jb25maWdIYXNUb29sQ2FsbElkO1xuZnVuY3Rpb24gX2lzVG9vbENhbGwodG9vbENhbGwpIHtcbiAgICByZXR1cm4gISEodG9vbENhbGwgJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwidHlwZVwiIGluIHRvb2xDYWxsICYmXG4gICAgICAgIHRvb2xDYWxsLnR5cGUgPT09IFwidG9vbF9jYWxsXCIpO1xufVxuZnVuY3Rpb24gX2NvbmZpZ0hhc1Rvb2xDYWxsSWQoY29uZmlnKSB7XG4gICAgcmV0dXJuICEhKGNvbmZpZyAmJlxuICAgICAgICB0eXBlb2YgY29uZmlnID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwidG9vbENhbGxcIiBpbiBjb25maWcgJiZcbiAgICAgICAgY29uZmlnLnRvb2xDYWxsICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNvbmZpZy50b29sQ2FsbCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcImlkXCIgaW4gY29uZmlnLnRvb2xDYWxsICYmXG4gICAgICAgIHR5cGVvZiBjb25maWcudG9vbENhbGwuaWQgPT09IFwic3RyaW5nXCIpO1xufVxuLyoqXG4gKiBDdXN0b20gZXJyb3IgY2xhc3MgdXNlZCB0byBoYW5kbGUgZXhjZXB0aW9ucyByZWxhdGVkIHRvIHRvb2wgaW5wdXQgcGFyc2luZy5cbiAqIEl0IGV4dGVuZHMgdGhlIGJ1aWx0LWluIGBFcnJvcmAgY2xhc3MgYW5kIGFkZHMgYW4gb3B0aW9uYWwgYG91dHB1dGBcbiAqIHByb3BlcnR5IHRoYXQgY2FuIGhvbGQgdGhlIG91dHB1dCB0aGF0IGNhdXNlZCB0aGUgZXhjZXB0aW9uLlxuICovXG5jbGFzcyBUb29sSW5wdXRQYXJzaW5nRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG91dHB1dCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIH1cbn1cbmV4cG9ydHMuVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiA9IFRvb2xJbnB1dFBhcnNpbmdFeGNlcHRpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tools/utils.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/base.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseTracer = void 0;\nexports.isBaseTracer = isBaseTracer;\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst base_js_1 = __webpack_require__(/*! ../callbacks/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/callbacks/base.cjs\");\nconst env_js_1 = __webpack_require__(/*! ../utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree) => {\n    if (!runTree) {\n        return undefined;\n    }\n    // Important that we return the raw run tree object since the reference\n    // is mutated in other places.\n    // TODO: Remove places where this is being done.\n    // eslint-disable-next-line no-param-reassign\n    runTree.events = runTree.events ?? [];\n    // eslint-disable-next-line no-param-reassign\n    runTree.child_runs = runTree.child_runs ?? [];\n    // TODO: Remove this cast and just use the LangSmith RunTree type.\n    return runTree;\n};\nfunction convertRunToRunTree(run, parentRun) {\n    if (!run) {\n        return undefined;\n    }\n    return new run_trees_1.RunTree({\n        ...run,\n        start_time: run._serialized_start_time ?? run.start_time,\n        parent_run: convertRunToRunTree(parentRun),\n        child_runs: run.child_runs\n            .map((r) => convertRunToRunTree(r))\n            .filter((r) => r !== undefined),\n        extra: {\n            ...run.extra,\n            runtime: (0, env_js_1.getRuntimeEnvironmentSync)(),\n        },\n        tracingEnabled: false,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nclass BaseTracer extends base_js_1.BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        /** @deprecated Use `runTreeMap` instead. */\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"runTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    copy() {\n        return this;\n    }\n    getRunById(runId) {\n        if (runId === undefined) {\n            return undefined;\n        }\n        return this.usesRunTreeMap\n            ? convertRunTreeToRun(this.runTreeMap.get(runId))\n            : this.runMap.get(runId);\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = (0, run_trees_1.convertToDottedOrderFormat)(new Date(run.start_time).getTime(), run.id, run.execution_order);\n        const storedRun = { ...run };\n        const parentRun = this.getRunById(storedRun.parent_run_id);\n        if (storedRun.parent_run_id !== undefined) {\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                    storedRun._serialized_start_time = microsecondPrecisionDatestring;\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n            storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        }\n        if (this.usesRunTreeMap) {\n            const runTree = convertRunToRunTree(storedRun, parentRun);\n            if (runTree !== undefined) {\n                this.runTreeMap.set(storedRun.id, runTree);\n            }\n        }\n        else {\n            this.runMap.set(storedRun.id, storedRun);\n        }\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        await this.onRunUpdate?.(run);\n        if (this.usesRunTreeMap) {\n            this.runTreeMap.delete(run.id);\n        }\n        else {\n            this.runMap.delete(run.id);\n        }\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\nexports.BaseTracer = BaseTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFrRTtBQUNsRiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQsU0FBUztBQUNULGlEQUFpRCxzQkFBc0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2Jhc2UuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlVHJhY2VyID0gdm9pZCAwO1xuZXhwb3J0cy5pc0Jhc2VUcmFjZXIgPSBpc0Jhc2VUcmFjZXI7XG5jb25zdCBydW5fdHJlZXNfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGgvcnVuX3RyZWVzXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4uL2NhbGxiYWNrcy9iYXNlLmNqc1wiKTtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2Vudi5janNcIik7XG4vLyBUT0RPOiBSZW1vdmUgYW5kIGp1c3QgdXNlIGJhc2UgTGFuZ1NtaXRoIFJ1biB0eXBlXG5jb25zdCBjb252ZXJ0UnVuVHJlZVRvUnVuID0gKHJ1blRyZWUpID0+IHtcbiAgICBpZiAoIXJ1blRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSW1wb3J0YW50IHRoYXQgd2UgcmV0dXJuIHRoZSByYXcgcnVuIHRyZWUgb2JqZWN0IHNpbmNlIHRoZSByZWZlcmVuY2VcbiAgICAvLyBpcyBtdXRhdGVkIGluIG90aGVyIHBsYWNlcy5cbiAgICAvLyBUT0RPOiBSZW1vdmUgcGxhY2VzIHdoZXJlIHRoaXMgaXMgYmVpbmcgZG9uZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBydW5UcmVlLmV2ZW50cyA9IHJ1blRyZWUuZXZlbnRzID8/IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJ1blRyZWUuY2hpbGRfcnVucyA9IHJ1blRyZWUuY2hpbGRfcnVucyA/PyBbXTtcbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBjYXN0IGFuZCBqdXN0IHVzZSB0aGUgTGFuZ1NtaXRoIFJ1blRyZWUgdHlwZS5cbiAgICByZXR1cm4gcnVuVHJlZTtcbn07XG5mdW5jdGlvbiBjb252ZXJ0UnVuVG9SdW5UcmVlKHJ1biwgcGFyZW50UnVuKSB7XG4gICAgaWYgKCFydW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBydW5fdHJlZXNfMS5SdW5UcmVlKHtcbiAgICAgICAgLi4ucnVuLFxuICAgICAgICBzdGFydF90aW1lOiBydW4uX3NlcmlhbGl6ZWRfc3RhcnRfdGltZSA/PyBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgcGFyZW50X3J1bjogY29udmVydFJ1blRvUnVuVHJlZShwYXJlbnRSdW4pLFxuICAgICAgICBjaGlsZF9ydW5zOiBydW4uY2hpbGRfcnVuc1xuICAgICAgICAgICAgLm1hcCgocikgPT4gY29udmVydFJ1blRvUnVuVHJlZShyKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHIpID0+IHIgIT09IHVuZGVmaW5lZCksXG4gICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICBydW50aW1lOiAoMCwgZW52X2pzXzEuZ2V0UnVudGltZUVudmlyb25tZW50U3luYykoKSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG5mdW5jdGlvbiBpc0Jhc2VUcmFjZXIoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeC5fYWRkUnVuVG9SdW5NYXAgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmNsYXNzIEJhc2VUcmFjZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2ZpZWxkcykge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBydW5UcmVlTWFwYCBpbnN0ZWFkLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuVHJlZU1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VzUnVuVHJlZU1hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRSdW5CeUlkKHJ1bklkKSB7XG4gICAgICAgIGlmIChydW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXNSdW5UcmVlTWFwXG4gICAgICAgICAgICA/IGNvbnZlcnRSdW5UcmVlVG9SdW4odGhpcy5ydW5UcmVlTWFwLmdldChydW5JZCkpXG4gICAgICAgICAgICA6IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgfVxuICAgIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlICsgKGVycm9yPy5zdGFjayA/IGBcXG5cXG4ke2Vycm9yLnN0YWNrfWAgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Vycm9yfWA7XG4gICAgfVxuICAgIF9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIGNoaWxkUnVuKSB7XG4gICAgICAgIHBhcmVudFJ1bi5jaGlsZF9ydW5zLnB1c2goY2hpbGRSdW4pO1xuICAgIH1cbiAgICBfYWRkUnVuVG9SdW5NYXAocnVuKSB7XG4gICAgICAgIGNvbnN0IHsgZG90dGVkT3JkZXI6IGN1cnJlbnREb3R0ZWRPcmRlciwgbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nIH0gPSAoMCwgcnVuX3RyZWVzXzEuY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQpKG5ldyBEYXRlKHJ1bi5zdGFydF90aW1lKS5nZXRUaW1lKCksIHJ1bi5pZCwgcnVuLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJ1biA9IHsgLi4ucnVuIH07XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHRoaXMuZ2V0UnVuQnlJZChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50UnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGRSdW4ocGFyZW50UnVuLCBzdG9yZWRSdW4pO1xuICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBzdG9yZWRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgICAgICBzdG9yZWRSdW4udHJhY2VfaWQgPSBwYXJlbnRSdW4udHJhY2VfaWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRSdW4uZG90dGVkX29yZGVyID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREb3R0ZWRPcmRlcixcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPSBtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gbmF0dXJhbGx5IGZvciBjYWxsYmFja3MgYWRkZWQgd2l0aGluIGEgcnVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IGhhcyBubyBkb3R0ZWQgb3JkZXIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgLy8gICBgUGFyZW50IHJ1biB3aXRoIFVVSUQgJHtzdG9yZWRSdW4ucGFyZW50X3J1bl9pZH0gbm90IGZvdW5kLmBcbiAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gc3RvcmVkUnVuLmlkO1xuICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi5fc2VyaWFsaXplZF9zdGFydF90aW1lID0gbWljcm9zZWNvbmRQcmVjaXNpb25EYXRlc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZXNSdW5UcmVlTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBydW5UcmVlID0gY29udmVydFJ1blRvUnVuVHJlZShzdG9yZWRSdW4sIHBhcmVudFJ1bik7XG4gICAgICAgICAgICBpZiAocnVuVHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UcmVlTWFwLnNldChzdG9yZWRSdW4uaWQsIHJ1blRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ydW5NYXAuc2V0KHN0b3JlZFJ1bi5pZCwgc3RvcmVkUnVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmVkUnVuO1xuICAgIH1cbiAgICBhc3luYyBfZW5kVHJhY2UocnVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHJ1bi5wYXJlbnRfcnVuX2lkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRSdW5CeUlkKHJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsIHJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0UnVuKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1blVwZGF0ZT8uKHJ1bik7XG4gICAgICAgIGlmICh0aGlzLnVzZXNSdW5UcmVlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRyZWVNYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50UnVuID0gcGFyZW50UnVuSWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldFJ1bkJ5SWQocGFyZW50UnVuSWQpO1xuICAgICAgICAvLyBJZiBhIHJ1biBoYXMgbm8gcGFyZW50IHRoZW4gZXhlY3V0aW9uIG9yZGVyIGlzIDFcbiAgICAgICAgaWYgKCFwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIExMTSBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxFeHRyYVBhcmFtcyA9IG1ldGFkYXRhXG4gICAgICAgICAgICA/IHsgLi4uZXh0cmFQYXJhbXMsIG1ldGFkYXRhIH1cbiAgICAgICAgICAgIDogZXh0cmFQYXJhbXM7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gbGxtLmlkW2xsbS5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGxsbSxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHByb21wdHMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhdCBtb2RlbCBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAgICAgICAgZXh0cmE6IGZpbmFsRXh0cmFQYXJhbXMgPz8ge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTVN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IG91dHB1dDtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBydW4uZXh0cmEgPSB7IC4uLnJ1bi5leHRyYSwgLi4uZXh0cmFQYXJhbXMgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZXh0cmFQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJsbG1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTExNIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcnVuLmV4dHJhID0geyAuLi5ydW4uZXh0cmEsIC4uLmV4dHJhUGFyYW1zIH07XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1FcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciBjaGFpbiBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvckNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGNoYWluLmlkW2NoYWluLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogY2hhaW4sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUgPz8gXCJjaGFpblwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpblN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FbmQob3V0cHV0cywgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhaW4gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBfY29lcmNlVG9EaWN0KG91dHB1dHMsIFwib3V0cHV0XCIpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyb3IsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGt3YXJncz8uaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBfY29lcmNlVG9EaWN0KGt3YXJncy5pbnB1dHMsIFwiaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgdG9vbCBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IHRvb2wuaWRbdG9vbC5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHRvb2wsXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBpbnB1dCB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJ0b29sXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpID8/XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwidG9vbFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0b29sIHJ1biB0byBlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSB7IG91dHB1dCB9O1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50QWN0aW9uKGFjdGlvbiwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnRSdW4gPSBydW47XG4gICAgICAgIGFnZW50UnVuLmFjdGlvbnMgPSBhZ2VudFJ1bi5hY3Rpb25zIHx8IFtdO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgYWdlbnRSdW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJhZ2VudF9hY3Rpb25cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyBhY3Rpb24gfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25BZ2VudEFjdGlvbj8uKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50RW5kKGFjdGlvbiwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5nZXRSdW5CeUlkKHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRFbmQ/LihydW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgcmV0cmlldmVyIHN0YXJ0IGV2ZW50cy5cbiAgICAgKiBUaGlzIG11c3Qgc29tZXRpbWVzIGJlIGRvbmUgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgKiB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLCBzbyB3ZSBleHBvc2UgaXQgYXMgYSBzZXBhcmF0ZSBtZXRob2QgaGVyZS5cbiAgICAgKi9cbiAgICBfY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IHJldHJpZXZlci5pZFtyZXRyaWV2ZXIuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiByZXRyaWV2ZXIsXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBxdWVyeSB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJyZXRyaWV2ZXJcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpID8/XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5Gb3JSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBkb2N1bWVudHMgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyb3IsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmdldFJ1bkJ5SWQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgdGV4dCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRleHQ/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMuZ2V0UnVuQnlJZChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJ1bklkXCIgcHJvdmlkZWQgdG8gXCJoYW5kbGVMTE1OZXdUb2tlblwiIGNhbGxiYWNrLmApO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcIm5ld190b2tlblwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRva2VuLCBpZHgsIGNodW5rOiBmaWVsZHM/LmNodW5rIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNTmV3VG9rZW4/LihydW4sIHRva2VuLCB7IGNodW5rOiBmaWVsZHM/LmNodW5rIH0pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVRyYWNlciA9IEJhc2VUcmFjZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/console.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConsoleCallbackHandler = void 0;\nconst ansi_styles_1 = __importDefault(__webpack_require__(/*! ansi-styles */ \"(rsc)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js\"));\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nfunction wrap(style, text) {\n    return `${style.open}${text}${style.close}`;\n}\nfunction tryJsonStringify(obj, fallback) {\n    try {\n        return JSON.stringify(obj, null, 2);\n    }\n    catch (err) {\n        return fallback;\n    }\n}\nfunction formatKVMapItem(value) {\n    if (typeof value === \"string\") {\n        return value.trim();\n    }\n    if (value === null || value === undefined) {\n        return value;\n    }\n    return tryJsonStringify(value, value.toString());\n}\nfunction elapsed(run) {\n    if (!run.end_time)\n        return \"\";\n    const elapsed = run.end_time - run.start_time;\n    if (elapsed < 1000) {\n        return `${elapsed}ms`;\n    }\n    return `${(elapsed / 1000).toFixed(2)}s`;\n}\nconst { color } = ansi_styles_1.default;\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nclass ConsoleCallbackHandler extends base_js_1.BaseTracer {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"console_callback_handler\"\n        });\n    }\n    /**\n     * Method used to persist the run. In this case, it simply returns a\n     * resolved promise as there's no persistence logic.\n     * @param _run The run to persist.\n     * @returns A resolved promise.\n     */\n    persistRun(_run) {\n        return Promise.resolve();\n    }\n    // utility methods\n    /**\n     * Method used to get all the parent runs of a given run.\n     * @param run The run whose parents are to be retrieved.\n     * @returns An array of parent runs.\n     */\n    getParents(run) {\n        const parents = [];\n        let currentRun = run;\n        while (currentRun.parent_run_id) {\n            const parent = this.runMap.get(currentRun.parent_run_id);\n            if (parent) {\n                parents.push(parent);\n                currentRun = parent;\n            }\n            else {\n                break;\n            }\n        }\n        return parents;\n    }\n    /**\n     * Method used to get a string representation of the run's lineage, which\n     * is used in logging.\n     * @param run The run whose lineage is to be retrieved.\n     * @returns A string representation of the run's lineage.\n     */\n    getBreadcrumbs(run) {\n        const parents = this.getParents(run).reverse();\n        const string = [...parents, run]\n            .map((parent, i, arr) => {\n            const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n            return i === arr.length - 1 ? wrap(ansi_styles_1.default.bold, name) : name;\n        })\n            .join(\" > \");\n        return wrap(color.grey, string);\n    }\n    // logging methods\n    /**\n     * Method used to log the start of a chain run.\n     * @param run The chain run that has started.\n     * @returns void\n     */\n    onChainStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[chain/start]\")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a chain run.\n     * @param run The chain run that has ended.\n     * @returns void\n     */\n    onChainEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a chain run.\n     * @param run The chain run that has errored.\n     * @returns void\n     */\n    onChainError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of an LLM run.\n     * @param run The LLM run that has started.\n     * @returns void\n     */\n    onLLMStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        const inputs = \"prompts\" in run.inputs\n            ? { prompts: run.inputs.prompts.map((p) => p.trim()) }\n            : run.inputs;\n        console.log(`${wrap(color.green, \"[llm/start]\")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of an LLM run.\n     * @param run The LLM run that has ended.\n     * @returns void\n     */\n    onLLMEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, \"[response]\")}`);\n    }\n    /**\n     * Method used to log any errors of an LLM run.\n     * @param run The LLM run that has errored.\n     * @returns void\n     */\n    onLLMError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a tool run.\n     * @param run The tool run that has started.\n     * @returns void\n     */\n    onToolStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[tool/start]\")} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(run.inputs.input)}\"`);\n    }\n    /**\n     * Method used to log the end of a tool run.\n     * @param run The tool run that has ended.\n     * @returns void\n     */\n    onToolEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: \"${formatKVMapItem(run.outputs?.output)}\"`);\n    }\n    /**\n     * Method used to log any errors of a tool run.\n     * @param run The tool run that has errored.\n     * @returns void\n     */\n    onToolError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the start of a retriever run.\n     * @param run The retriever run that has started.\n     * @returns void\n     */\n    onRetrieverStart(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.green, \"[retriever/start]\")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, \"[inputs]\")}`);\n    }\n    /**\n     * Method used to log the end of a retriever run.\n     * @param run The retriever run that has ended.\n     * @returns void\n     */\n    onRetrieverEnd(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, \"[outputs]\")}`);\n    }\n    /**\n     * Method used to log any errors of a retriever run.\n     * @param run The retriever run that has errored.\n     * @returns void\n     */\n    onRetrieverError(run) {\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`);\n    }\n    /**\n     * Method used to log the action selected by the agent.\n     * @param run The run in which the agent action occurred.\n     * @returns void\n     */\n    onAgentAction(run) {\n        const agentRun = run;\n        const crumbs = this.getBreadcrumbs(run);\n        console.log(`${wrap(color.blue, \"[agent/action]\")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], \"[action]\")}`);\n    }\n}\nexports.ConsoleCallbackHandler = ConsoleCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9jb25zb2xlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixzQ0FBc0MsbUJBQU8sQ0FBQywyRkFBYTtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBLGNBQWMsV0FBVyxFQUFFLEtBQUssRUFBRSxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLFlBQVk7QUFDckY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLG1DQUFtQyx5Q0FBeUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUMsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMsMkNBQTJDO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxLQUFLLGFBQWEsa0NBQWtDLHVDQUF1QztBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSx1QkFBdUIsa0NBQWtDLEdBQUcsT0FBTyxpQ0FBaUMscUNBQXFDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLDRDQUE0QztBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxHQUFHLE9BQU8sS0FBSyxhQUFhLGdDQUFnQyx1Q0FBdUM7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQ0FBbUMsR0FBRyxPQUFPLG1DQUFtQyxrQ0FBa0M7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsR0FBRyxPQUFPLEtBQUssYUFBYSxtQ0FBbUMscUNBQXFDO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEdBQUcsT0FBTyxLQUFLLGFBQWEsaUNBQWlDLHVDQUF1QztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdDQUF3QyxHQUFHLE9BQU8sdUNBQXVDLHlDQUF5QztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQyxHQUFHLE9BQU8sS0FBSyxhQUFhLHVDQUF1QywyQ0FBMkM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0MsR0FBRyxPQUFPLEtBQUssYUFBYSxzQ0FBc0MsdUNBQXVDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0MsR0FBRyxPQUFPLDJCQUEyQiw0RUFBNEU7QUFDNUs7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9jb25zb2xlLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc29sZUNhbGxiYWNrSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGFuc2lfc3R5bGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFuc2ktc3R5bGVzXCIpKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuZnVuY3Rpb24gd3JhcChzdHlsZSwgdGV4dCkge1xuICAgIHJldHVybiBgJHtzdHlsZS5vcGVufSR7dGV4dH0ke3N0eWxlLmNsb3NlfWA7XG59XG5mdW5jdGlvbiB0cnlKc29uU3RyaW5naWZ5KG9iaiwgZmFsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0S1ZNYXBJdGVtKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0cnlKc29uU3RyaW5naWZ5KHZhbHVlLCB2YWx1ZS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGVsYXBzZWQocnVuKSB7XG4gICAgaWYgKCFydW4uZW5kX3RpbWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBydW4uZW5kX3RpbWUgLSBydW4uc3RhcnRfdGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIGAke2VsYXBzZWR9bXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7KGVsYXBzZWQgLyAxMDAwKS50b0ZpeGVkKDIpfXNgO1xufVxuY29uc3QgeyBjb2xvciB9ID0gYW5zaV9zdHlsZXNfMS5kZWZhdWx0O1xuLyoqXG4gKiBBIHRyYWNlciB0aGF0IGxvZ3MgYWxsIGV2ZW50cyB0byB0aGUgY29uc29sZS4gSXQgZXh0ZW5kcyBmcm9tIHRoZVxuICogYEJhc2VUcmFjZXJgIGNsYXNzIGFuZCBvdmVycmlkZXMgaXRzIG1ldGhvZHMgdG8gcHJvdmlkZSBjdXN0b20gbG9nZ2luZ1xuICogZnVuY3Rpb25hbGl0eS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogY29uc3QgbGxtID0gbmV3IENoYXRBbnRocm9waWMoe1xuICogICB0ZW1wZXJhdHVyZTogMCxcbiAqICAgdGFnczogW1wiZXhhbXBsZVwiLCBcImNhbGxiYWNrc1wiLCBcImNvbnN0cnVjdG9yXCJdLFxuICogICBjYWxsYmFja3M6IFtuZXcgQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpXSxcbiAqIH0pO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBwZXJzaXN0IHRoZSBydW4uIEluIHRoaXMgY2FzZSwgaXQgc2ltcGx5IHJldHVybnMgYVxuICAgICAqIHJlc29sdmVkIHByb21pc2UgYXMgdGhlcmUncyBubyBwZXJzaXN0ZW5jZSBsb2dpYy5cbiAgICAgKiBAcGFyYW0gX3J1biBUaGUgcnVuIHRvIHBlcnNpc3QuXG4gICAgICogQHJldHVybnMgQSByZXNvbHZlZCBwcm9taXNlLlxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIHV0aWxpdHkgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHBhcmVudCBydW5zIG9mIGEgZ2l2ZW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBwYXJlbnRzIGFyZSB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgcGFyZW50IHJ1bnMuXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudFJ1biA9IHJ1bjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5ydW5NYXAuZ2V0KGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFJ1biA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UsIHdoaWNoXG4gICAgICogaXMgdXNlZCBpbiBsb2dnaW5nLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBsaW5lYWdlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZS5cbiAgICAgKi9cbiAgICBnZXRCcmVhZGNydW1icyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXMuZ2V0UGFyZW50cyhydW4pLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gWy4uLnBhcmVudHMsIHJ1bl1cbiAgICAgICAgICAgIC5tYXAoKHBhcmVudCwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7cGFyZW50LmV4ZWN1dGlvbl9vcmRlcn06JHtwYXJlbnQucnVuX3R5cGV9OiR7cGFyZW50Lm5hbWV9YDtcbiAgICAgICAgICAgIHJldHVybiBpID09PSBhcnIubGVuZ3RoIC0gMSA/IHdyYXAoYW5zaV9zdHlsZXNfMS5kZWZhdWx0LmJvbGQsIG5hbWUpIDogbmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiID4gXCIpO1xuICAgICAgICByZXR1cm4gd3JhcChjb2xvci5ncmV5LCBzdHJpbmcpO1xuICAgIH1cbiAgICAvLyBsb2dnaW5nIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbY2hhaW4vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBDaGFpbiBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2NoYWluL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgQ2hhaW4gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltjaGFpbi9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIENoYWluIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBcInByb21wdHNcIiBpbiBydW4uaW5wdXRzXG4gICAgICAgICAgICA/IHsgcHJvbXB0czogcnVuLmlucHV0cy5wcm9tcHRzLm1hcCgocCkgPT4gcC50cmltKCkpIH1cbiAgICAgICAgICAgIDogcnVuLmlucHV0cztcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbbGxtL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgTExNIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkoaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbbGxtL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgTExNIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltyZXNwb25zZV1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltsbG0vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBMTE0gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbdG9vbC9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFRvb2wgcnVuIHdpdGggaW5wdXQ6IFwiJHtmb3JtYXRLVk1hcEl0ZW0ocnVuLmlucHV0cy5pbnB1dCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbdG9vbC9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFRvb2wgcnVuIHdpdGggb3V0cHV0OiBcIiR7Zm9ybWF0S1ZNYXBJdGVtKHJ1bi5vdXRwdXRzPy5vdXRwdXQpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3Rvb2wvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBUb29sIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlclN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3JldHJpZXZlci9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFJldHJpZXZlciBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3JldHJpZXZlci9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFJldHJpZXZlciBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3JldHJpZXZlci9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFJldHJpZXZlciBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgYWN0aW9uIHNlbGVjdGVkIGJ5IHRoZSBhZ2VudC5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gaW4gd2hpY2ggdGhlIGFnZW50IGFjdGlvbiBvY2N1cnJlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25BZ2VudEFjdGlvbihydW4pIHtcbiAgICAgICAgY29uc3QgYWdlbnRSdW4gPSBydW47XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ibHVlLCBcIlthZ2VudC9hY3Rpb25dXCIpfSBbJHtjcnVtYnN9XSBBZ2VudCBzZWxlY3RlZCBhY3Rpb246ICR7dHJ5SnNvblN0cmluZ2lmeShhZ2VudFJ1bi5hY3Rpb25zW2FnZW50UnVuLmFjdGlvbnMubGVuZ3RoIC0gMV0sIFwiW2FjdGlvbl1cIil9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25zb2xlQ2FsbGJhY2tIYW5kbGVyID0gQ29uc29sZUNhbGxiYWNrSGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/console.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/event_stream.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventStreamCallbackHandler = exports.isStreamEventsHandler = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\nconst outputs_js_1 = __webpack_require__(/*! ../outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nconst isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\nexports.isStreamEventsHandler = isStreamEventsHandler;\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass EventStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new outputs_js_1.GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new ai_js_1.AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new outputs_js_1.GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\nexports.EventStreamCallbackHandler = EventStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDZCQUE2QjtBQUNsRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM3QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkJBQTJCLE9BQU8sR0FBRztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlciA9IGV4cG9ydHMuaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJlYW0uY2pzXCIpO1xuY29uc3QgYWlfanNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlcy9haS5janNcIik7XG5jb25zdCBvdXRwdXRzX2pzXzEgPSByZXF1aXJlKFwiLi4vb3V0cHV0cy5janNcIik7XG5mdW5jdGlvbiBhc3NpZ25OYW1lKHsgbmFtZSwgc2VyaWFsaXplZCwgfSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkPy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWFsaXplZD8uaWQgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQ/LmlkKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5pZFtzZXJpYWxpemVkLmlkLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXCJVbm5hbWVkXCI7XG59XG5jb25zdCBpc1N0cmVhbUV2ZW50c0hhbmRsZXIgPSAoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImV2ZW50X3N0cmVhbV90cmFjZXJcIjtcbmV4cG9ydHMuaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gaXNTdHJlYW1FdmVudHNIYW5kbGVyO1xuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCYXNlVHJhY2VyYCBjbGFzcyBmcm9tIHRoZVxuICogYGxhbmdjaGFpbi5jYWxsYmFja3MudHJhY2Vycy5iYXNlYCBtb2R1bGUuIEl0IHJlcHJlc2VudHMgYSBjYWxsYmFja1xuICogaGFuZGxlciB0aGF0IGxvZ3MgdGhlIGV4ZWN1dGlvbiBvZiBydW5zIGFuZCBlbWl0cyBgUnVuTG9nYCBpbnN0YW5jZXMgdG8gYVxuICogYFJ1bkxvZ1N0cmVhbWAuXG4gKi9cbmNsYXNzIEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7IF9hd2FpdEhhbmRsZXI6IHRydWUsIC4uLmZpZWxkcyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0Nsb3NlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuSW5mb01hcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YXBwZWRQcm9taXNlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc2Zvcm1TdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JpdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlY2VpdmVTdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJldmVudF9zdHJlYW1fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3ByZWZlcl9zdHJlYW1pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0b0Nsb3NlID0gZmllbGRzPy5hdXRvQ2xvc2UgPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHM/LmluY2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPSBmaWVsZHM/LmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcz8uaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzPy5leGNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVR5cGVzID0gZmllbGRzPy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHM/LmV4Y2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB0aGlzLnRyYW5zZm9ybVN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlU3RyZWFtID0gc3RyZWFtX2pzXzEuSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0odGhpcy50cmFuc2Zvcm1TdHJlYW0ucmVhZGFibGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlU3RyZWFtO1xuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBtZXRob2Qgb25seSBjYWxsZWQgb25jZSBmb3IgYW4gZW50aXJlIHJ1biB0cmVlXG4gICAgICAgIC8vIGFuZCBpcyB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgfVxuICAgIF9pbmNsdWRlUnVuKHJ1bikge1xuICAgICAgICBjb25zdCBydW5UYWdzID0gcnVuLnRhZ3MgPz8gW107XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSB8fFxuICAgICAgICAgICAgICAgICAgICBydW5UYWdzLmZpbmQoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIHJ1blRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbiAgICBhc3luYyAqdGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIG91dHB1dFN0cmVhbSkge1xuICAgICAgICBjb25zdCBmaXJzdENodW5rID0gYXdhaXQgb3V0cHV0U3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKGZpcnN0Q2h1bmsuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgLy8gUnVuIGhhcyBmaW5pc2hlZCwgZG9uJ3QgaXNzdWUgYW55IHN0cmVhbSBldmVudHMuXG4gICAgICAgIC8vIEFuIGV4YW1wbGUgb2YgdGhpcyBpcyBmb3IgcnVubmFibGVzIHRoYXQgdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIC5zdHJlYW0oKSwgd2hpY2ggZGVsZWdhdGVzIHRvIC5pbnZva2UoKVxuICAgICAgICAvLyBhbmQgY2FsbHMgLm9uQ2hhaW5FbmQoKSBiZWZvcmUgcGFzc2luZyBpdCB0byB0aGUgaXRlcmF0b3IuXG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHlpZWxkIGZpcnN0Q2h1bmsudmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF0Y2ggZm9ybWF0IGZyb20gaGFuZGxlcnMgYmVsb3dcbiAgICAgICAgZnVuY3Rpb24gX2Zvcm1hdE91dHB1dENodW5rKGV2ZW50VHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJsbG1cIiAmJiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb3V0cHV0c19qc18xLkdlbmVyYXRpb25DaHVuayh7IHRleHQ6IGRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFwcGVkUHJvbWlzZSA9IHRoaXMudGFwcGVkUHJvbWlzZXMuZ2V0KHJ1bklkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlIHRoZSBmaXJzdCB0byB0YXAsIGlzc3VlIHN0cmVhbSBldmVudHNcbiAgICAgICAgaWYgKHRhcHBlZFByb21pc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHRhcHBlZFByb21pc2VSZXNvbHZlcjtcbiAgICAgICAgICAgIHRhcHBlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRhcHBlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGFwcGVkUHJvbWlzZXMuc2V0KHJ1bklkLCB0YXBwZWRQcm9taXNlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtydW5JbmZvLnJ1blR5cGV9X3N0cmVhbWAsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IF9mb3JtYXRPdXRwdXRDaHVuayhydW5JbmZvLnJ1blR5cGUsIGZpcnN0Q2h1bmsudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIHJ1bkluZm8pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGZpcnN0Q2h1bmsudmFsdWU7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBvdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgeWllbGQgdG9vbCBhbmQgcmV0cmlldmVyIHN0cmVhbSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bkluZm8ucnVuVHlwZSAhPT0gXCJ0b29sXCIgJiYgcnVuSW5mby5ydW5UeXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IF9mb3JtYXRPdXRwdXRDaHVuayhydW5JbmZvLnJ1blR5cGUsIGNodW5rKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICB0YXBwZWRQcm9taXNlUmVzb2x2ZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkZWxldGUgZnJvbSB0aGUgcHJvbWlzZXMgbWFwIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcnVucyBoYXZlIGJlZW4gdGFwcGVkLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcGFzcyB0aHJvdWdoXG4gICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBvdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kKHBheWxvYWQsIHJ1bikge1xuICAgICAgICBpZiAodGhpcy5faW5jbHVkZVJ1bihydW4pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kRW5kRXZlbnQocGF5bG9hZCwgcnVuKSB7XG4gICAgICAgIGNvbnN0IHRhcHBlZFByb21pc2UgPSB0aGlzLnRhcHBlZFByb21pc2VzLmdldChwYXlsb2FkLnJ1bl9pZCk7XG4gICAgICAgIGlmICh0YXBwZWRQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZvaWQgdGFwcGVkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc2VuZChwYXlsb2FkLCBydW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQocGF5bG9hZCwgcnVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkxMTVN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5UeXBlID0gcnVuLmlucHV0cy5tZXNzYWdlcyAhPT0gdW5kZWZpbmVkID8gXCJjaGF0X21vZGVsXCIgOiBcImxsbVwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlLFxuICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGBvbl8ke3J1blR5cGV9X3N0YXJ0YDtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uTExNTmV3VG9rZW4ocnVuLCB0b2tlbiwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICBsZXQgZXZlbnROYW1lO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNTmV3VG9rZW46IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG9wLWxldmVsIHN0cmVhbWluZyBldmVudHMgYXJlIGNvdmVyZWQgYnkgdGFwT3V0cHV0SXRlcmFibGVcbiAgICAgICAgaWYgKHRoaXMucnVuSW5mb01hcC5zaXplID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJjaGF0X21vZGVsXCIpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25fY2hhdF9tb2RlbF9zdHJlYW1cIjtcbiAgICAgICAgICAgIGlmIChrd2FyZ3M/LmNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBhaV9qc18xLkFJTWVzc2FnZUNodW5rKHsgY29udGVudDogdG9rZW4sIGlkOiBgcnVuLSR7cnVuLmlkfWAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGt3YXJncy5jaHVuay5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9sbG1fc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoa3dhcmdzPy5jaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgb3V0cHV0c19qc18xLkdlbmVyYXRpb25DaHVuayh7IHRleHQ6IHRva2VuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBrd2FyZ3MuY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcnVuIHR5cGUgJHtydW5JbmZvLnJ1blR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uTExNRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGxldCBldmVudE5hbWU7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25MTE1FbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBydW4ub3V0cHV0cz8uZ2VuZXJhdGlvbnM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwiY2hhdF9tb2RlbFwiKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRpb24gb2YgZ2VuZXJhdGlvbnMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGdlbmVyYXRpb25bMF0/Lm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2NoYXRfbW9kZWxfZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IGdlbmVyYXRpb25zPy5tYXAoKGdlbmVyYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRpb24ubWFwKChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvOiBjaHVuay5nZW5lcmF0aW9uSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxsbU91dHB1dDogcnVuLm91dHB1dHM/LmxsbU91dHB1dCA/PyB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2xsbV9lbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25MTE1FbmQ6IFVuZXhwZWN0ZWQgcnVuIHR5cGU6ICR7cnVuSW5mby5ydW5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0OiBydW5JbmZvLmlucHV0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25DaGFpblN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5UeXBlID0gcnVuLnJ1bl90eXBlID8/IFwiY2hhaW5cIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZXZlbnREYXRhID0ge307XG4gICAgICAgIC8vIFdvcmthcm91bmQgUnVubmFibGUgY29yZSBjb2RlIG5vdCBzZW5kaW5nIGlucHV0IHdoZW4gdHJhbnNmb3JtIHN0cmVhbWluZy5cbiAgICAgICAgaWYgKHJ1bi5pbnB1dHMuaW5wdXQgPT09IFwiXCIgJiYgT2JqZWN0LmtleXMocnVuLmlucHV0cykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBldmVudERhdGEgPSB7fTtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuLmlucHV0cy5pbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBldmVudERhdGEuaW5wdXQgPSBydW4uaW5wdXRzLmlucHV0O1xuICAgICAgICAgICAgcnVuSW5mby5pbnB1dHMgPSBydW4uaW5wdXRzLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnREYXRhLmlucHV0ID0gcnVuLmlucHV0cztcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gcnVuLmlucHV0cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogYG9uXyR7cnVuVHlwZX1fc3RhcnRgLFxuICAgICAgICAgICAgZGF0YTogZXZlbnREYXRhLFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkNoYWluRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGBvbl8ke3J1bi5ydW5fdHlwZX1fZW5kYDtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gcnVuLmlucHV0cyA/PyBydW5JbmZvLmlucHV0cyA/PyB7fTtcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IHJ1bi5vdXRwdXRzPy5vdXRwdXQgPz8gcnVuLm91dHB1dHM7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dHMsXG4gICAgICAgICAgICBpbnB1dDogaW5wdXRzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5wdXRzLmlucHV0ICYmIE9iamVjdC5rZXlzKGlucHV0cykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkYXRhLmlucHV0ID0gaW5wdXRzLmlucHV0O1xuICAgICAgICAgICAgcnVuSW5mby5pbnB1dHMgPSBpbnB1dHMuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRW5kRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhID8/IHt9LFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25Ub29sU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgaW5wdXRzOiBydW4uaW5wdXRzID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl90b29sX3N0YXJ0XCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bi5pbnB1dHMgPz8ge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uVG9vbEVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uVG9vbEVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuSW5mby5pbnB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblRvb2xFbmQ6IFJ1biBJRCAke3J1bi5pZH0gaXMgYSB0b29sIGNhbGwsIGFuZCBpcyBleHBlY3RlZCB0byBoYXZlIHRyYWNlZCBpbnB1dHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcnVuLm91dHB1dHM/Lm91dHB1dCA9PT0gdW5kZWZpbmVkID8gcnVuLm91dHB1dHMgOiBydW4ub3V0cHV0cy5vdXRwdXQ7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3Rvb2xfZW5kXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0OiBydW5JbmZvLmlucHV0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bkluZm8ubmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgb25SZXRyaWV2ZXJTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IFwicmV0cmlldmVyXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGUsXG4gICAgICAgICAgICBpbnB1dHM6IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogcnVuLmlucHV0cy5xdWVyeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5zZXQocnVuLmlkLCBydW5JbmZvKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3JldHJpZXZlcl9zdGFydFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBydW4uaW5wdXRzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25SZXRyaWV2ZXJFbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kRW5kRXZlbnQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fcmV0cmlldmVyX2VuZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dDogcnVuLm91dHB1dHM/LmRvY3VtZW50cyA/PyBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkYXRhLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFuZGxlQ3VzdG9tRXZlbnQ6IFJ1biBJRCAke3J1bklkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fY3VzdG9tX2V2ZW50XCIsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9LCBydW5JbmZvKTtcbiAgICB9XG4gICAgYXN5bmMgZmluaXNoKCkge1xuICAgICAgICBjb25zdCBwZW5kaW5nUHJvbWlzZXMgPSBbLi4udGhpcy50YXBwZWRQcm9taXNlcy52YWx1ZXMoKV07XG4gICAgICAgIHZvaWQgUHJvbWlzZS5hbGwocGVuZGluZ1Byb21pc2VzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlciA9IEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/event_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/log_stream.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogStreamCallbackHandler = exports.isLogStreamHandler = exports.RunLog = exports.RunLogPatch = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst stream_js_1 = __webpack_require__(/*! ../utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nconst ai_js_1 = __webpack_require__(/*! ../messages/ai.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/ai.cjs\");\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nclass RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLogPatch = RunLogPatch;\nclass RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = (0, index_js_1.applyPatch)(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = (0, index_js_1.applyPatch)({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexports.RunLog = RunLog;\nconst isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\nexports.isLogStreamHandler = isLogStreamHandler;\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nclass LogStreamCallbackHandler extends base_js_1.BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = stream_js_1.IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new ai_js_1.AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\nexports.LogStreamCallbackHandler = LogStreamCallbackHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxjQUFjLEdBQUcsbUJBQW1CO0FBQ3BHLG1CQUFtQixtQkFBTyxDQUFDLHFIQUFvQztBQUMvRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQW1EO0FBQy9FO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLEdBQUcsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2xvZ19zdHJlYW0uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIgPSBleHBvcnRzLmlzTG9nU3RyZWFtSGFuZGxlciA9IGV4cG9ydHMuUnVuTG9nID0gZXhwb3J0cy5SdW5Mb2dQYXRjaCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmNqc1wiKTtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY29uc3Qgc3RyZWFtX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNvbnN0IGFpX2pzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvYWkuY2pzXCIpO1xuLyoqXG4gKiBMaXN0IG9mIGpzb25wYXRjaCBKU09OUGF0Y2hPcGVyYXRpb25zLCB3aGljaCBkZXNjcmliZSBob3cgdG8gY3JlYXRlIHRoZSBydW4gc3RhdGVcbiAqIGZyb20gYW4gZW1wdHkgZGljdC4gVGhpcyBpcyB0aGUgbWluaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbG9nLCBkZXNpZ25lZCB0b1xuICogYmUgc2VyaWFsaXplZCBhcyBKU09OIGFuZCBzZW50IG92ZXIgdGhlIHdpcmUgdG8gcmVjb25zdHJ1Y3QgdGhlIGxvZyBvbiB0aGUgb3RoZXJcbiAqIHNpZGUuIFJlY29uc3RydWN0aW9uIG9mIHRoZSBzdGF0ZSBjYW4gYmUgZG9uZSB3aXRoIGFueSBqc29ucGF0Y2gtY29tcGxpYW50IGxpYnJhcnksXG4gKiBzZWUgaHR0cHM6Ly9qc29ucGF0Y2guY29tIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBSdW5Mb2dQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wcyA9IGZpZWxkcy5vcHMgPz8gW107XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcy5jb25jYXQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gKDAsIGluZGV4X2pzXzEuYXBwbHlQYXRjaCkoe30sIG9wcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coe1xuICAgICAgICAgICAgb3BzLFxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0ubmV3RG9jdW1lbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuTG9nUGF0Y2ggPSBSdW5Mb2dQYXRjaDtcbmNsYXNzIFJ1bkxvZyBleHRlbmRzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZpZWxkcy5zdGF0ZTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSAoMCwgaW5kZXhfanNfMS5hcHBseVBhdGNoKSh0aGlzLnN0YXRlLCBvdGhlci5vcHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJ1bkxvZyh7IG9wcywgc3RhdGU6IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0ubmV3RG9jdW1lbnQgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUnVuTG9nUGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gKDAsIGluZGV4X2pzXzEuYXBwbHlQYXRjaCkoe30sIHBhdGNoLm9wcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coe1xuICAgICAgICAgICAgb3BzOiBwYXRjaC5vcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW5Mb2cgPSBSdW5Mb2c7XG5jb25zdCBpc0xvZ1N0cmVhbUhhbmRsZXIgPSAoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxvZ19zdHJlYW1fdHJhY2VyXCI7XG5leHBvcnRzLmlzTG9nU3RyZWFtSGFuZGxlciA9IGlzTG9nU3RyZWFtSGFuZGxlcjtcbi8qKlxuICogRXh0cmFjdCBzdGFuZGFyZGl6ZWQgaW5wdXRzIGZyb20gYSBydW4uXG4gKlxuICogU3RhbmRhcmRpemVzIHRoZSBpbnB1dHMgYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIHJ1bm5hYmxlIHVzZWQuXG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1biBvYmplY3RcbiAqIEBwYXJhbSBzY2hlbWFGb3JtYXQgLSBUaGUgc2NoZW1hIGZvcm1hdCB0byB1c2UuXG4gKlxuICogQHJldHVybnMgVmFsaWQgaW5wdXRzIGFyZSBvbmx5IGRpY3QuIEJ5IGNvbnZlbnRpb25zLCBpbnB1dHMgYWx3YXlzIHJlcHJlc2VudGVkXG4gKiBpbnZvY2F0aW9uIHVzaW5nIG5hbWVkIGFyZ3VtZW50cy5cbiAqIEEgbnVsbCBtZWFucyB0aGF0IHRoZSBpbnB1dCBpcyBub3QgeWV0IGtub3duIVxuICovXG5hc3luYyBmdW5jdGlvbiBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgc2NoZW1hRm9ybWF0KSB7XG4gICAgaWYgKHNjaGVtYUZvcm1hdCA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCBhc3NpZ24gaW5wdXRzIHdpdGggb3JpZ2luYWwgc2NoZW1hIGRyb3AgdGhlIGtleSBmb3Igbm93LiBcIiArXG4gICAgICAgICAgICBcIldoZW4gaW5wdXRzIGFyZSBhZGRlZCB0byBzdHJlYW1Mb2cgdGhleSBzaG91bGQgYmUgYWRkZWQgd2l0aCBcIiArXG4gICAgICAgICAgICBcInN0YW5kYXJkaXplZCBzY2hlbWEgZm9yIHN0cmVhbWluZyBldmVudHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlucHV0cyB9ID0gcnVuO1xuICAgIGlmIChbXCJyZXRyaWV2ZXJcIiwgXCJsbG1cIiwgXCJwcm9tcHRcIl0uaW5jbHVkZXMocnVuLnJ1bl90eXBlKSkge1xuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXRzKS5sZW5ndGggPT09IDEgJiYgaW5wdXRzPy5pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBuZXcgc3R5bGUgY2hhaW5zXG4gICAgLy8gVGhlc2UgbmVzdCBhbiBhZGRpdGlvbmFsICdpbnB1dCcga2V5IGluc2lkZSB0aGUgJ2lucHV0cycgdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIGlucHV0IGlzIGFsd2F5cyBhIGRpY3QuIFdlIG5lZWQgdG8gdW5wYWNrIGFuZCB1c2VyIHRoZSBpbm5lciB2YWx1ZS5cbiAgICAvLyBXZSBzaG91bGQgdHJ5IHRvIGZpeCB0aGlzIGluIFJ1bm5hYmxlcyBhbmQgY2FsbGJhY2tzL3RyYWNlcnNcbiAgICAvLyBSdW5uYWJsZXMgc2hvdWxkIGJlIHVzaW5nIGEgbnVsbCB0eXBlIGhlcmUgbm90IGEgcGxhY2Vob2xkZXJcbiAgICAvLyBkaWN0LlxuICAgIHJldHVybiBpbnB1dHMuaW5wdXQ7XG59XG5hc3luYyBmdW5jdGlvbiBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHNjaGVtYUZvcm1hdCkge1xuICAgIGNvbnN0IHsgb3V0cHV0cyB9ID0gcnVuO1xuICAgIGlmIChzY2hlbWFGb3JtYXQgPT09IFwib3JpZ2luYWxcIikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG9sZCBzY2hlbWEsIHdpdGhvdXQgc3RhbmRhcmRpemluZyBhbnl0aGluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgaWYgKFtcInJldHJpZXZlclwiLCBcImxsbVwiLCBcInByb21wdFwiXS5pbmNsdWRlcyhydW4ucnVuX3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBoYWNreSBjaGVja1xuICAgIGlmIChvdXRwdXRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgT2JqZWN0LmtleXMob3V0cHV0cykubGVuZ3RoID09PSAxICYmXG4gICAgICAgIG91dHB1dHM/Lm91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzLm91dHB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dHM7XG59XG5mdW5jdGlvbiBpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoeCkge1xuICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQgJiYgeC5tZXNzYWdlICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuY2xhc3MgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgYmFzZV9qc18xLkJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7IF9hd2FpdEhhbmRsZXI6IHRydWUsIC4uLmZpZWxkcyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0Nsb3NlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYUZvcm1hdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJvcmlnaW5hbFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5TWFwQnlSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvdW50ZXJNYXBCeVJ1bk5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc2Zvcm1TdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JpdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlY2VpdmVTdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsb2dfc3RyZWFtX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19wcmVmZXJfc3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1dG9DbG9zZSA9IGZpZWxkcz8uYXV0b0Nsb3NlID8/IHRydWU7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzPy5pbmNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID0gZmllbGRzPy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHM/LmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcz8uZXhjbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUeXBlcyA9IGZpZWxkcz8uZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzPy5leGNsdWRlVGFncztcbiAgICAgICAgdGhpcy5fc2NoZW1hRm9ybWF0ID0gZmllbGRzPy5fc2NoZW1hRm9ybWF0ID8/IHRoaXMuX3NjaGVtYUZvcm1hdDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdGhpcy50cmFuc2Zvcm1TdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZVN0cmVhbSA9IHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHRoaXMudHJhbnNmb3JtU3RyZWFtLnJlYWRhYmxlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZVN0cmVhbTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAgICAvLyBhbmQgaXMgdGhlcmVmb3JlIG5vdCB1c2VmdWwgaGVyZVxuICAgIH1cbiAgICBfaW5jbHVkZVJ1bihydW4pIHtcbiAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5UYWdzID0gcnVuLnRhZ3MgPz8gW107XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuX3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVuVGFncy5maW5kKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuX3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0KSB7XG4gICAgICAgIC8vIFRhcCBhbiBvdXRwdXQgYXN5bmMgaXRlcmF0b3IgdG8gc3RyZWFtIGl0cyB2YWx1ZXMgdG8gdGhlIGxvZy5cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBvdXRwdXQpIHtcbiAgICAgICAgICAgIC8vIHJvb3QgcnVuIGlzIGhhbmRsZWQgaW4gLnN0cmVhbUxvZygpXG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUgcnVuIHNpbGVudGx5IGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIGVnLiBiZWNhdXNlIHRoaXMgcnVuIHdhc24ndCBpbmNsdWRlZCBpbiB0aGUgbG9nXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bklkXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtrZXl9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25SdW5DcmVhdGUocnVuKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RJZCA9IHJ1bi5pZDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxfb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlUnVuKHJ1bikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdICs9IDE7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXTtcbiAgICAgICAgdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF0gPVxuICAgICAgICAgICAgY291bnQgPT09IDEgPyBydW4ubmFtZSA6IGAke3J1bi5uYW1lfToke2NvdW50fWA7XG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKHJ1bi5zdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0OiBbXSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dF9zdHI6IFtdLFxuICAgICAgICAgICAgZmluYWxfb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbmRfdGltZTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgbG9nRW50cnkuaW5wdXRzID0gYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3RoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdfWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dFbnRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk5hbWUgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXTtcbiAgICAgICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2hlbWFGb3JtYXQgPT09IFwic3RyZWFtaW5nX2V2ZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2lucHV0c2AsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9maW5hbF9vdXRwdXRgLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2VuZF90aW1lYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHsgb3BzIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9maW5hbF9vdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uTExNTmV3VG9rZW4ocnVuLCB0b2tlbiwga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXTtcbiAgICAgICAgaWYgKHJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBoYWNrXG4gICAgICAgIGNvbnN0IGlzQ2hhdE1vZGVsID0gcnVuLmlucHV0cy5tZXNzYWdlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3RyZWFtZWRPdXRwdXRWYWx1ZTtcbiAgICAgICAgaWYgKGlzQ2hhdE1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDaGF0R2VuZXJhdGlvbkNodW5rKGt3YXJncz8uY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IGt3YXJncz8uY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0gbmV3IGFpX2pzXzEuQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYHJ1bi0ke3J1bi5pZH1gLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9zdHJlYW1lZF9vdXRwdXRfc3RyLy1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9zdHJlYW1lZF9vdXRwdXQvLWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJlYW1lZE91dHB1dFZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/log_stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/root_listener.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RootListenersTracer = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nclass RootListenersTracer extends base_js_1.BaseTracer {\n    constructor({ config, onStart, onEnd, onError, }) {\n        super({ _awaitHandler: true });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"RootListenersTracer\"\n        });\n        /** The Run's ID. Type UUID */\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnStart\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argOnError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.config = config;\n        this.argOnStart = onStart;\n        this.argOnEnd = onEnd;\n        this.argOnError = onError;\n    }\n    /**\n     * This is a legacy method only called once for an entire run tree\n     * therefore not useful here\n     * @param {Run} _ Not used\n     */\n    persistRun(_) {\n        return Promise.resolve();\n    }\n    async onRunCreate(run) {\n        if (this.rootId) {\n            return;\n        }\n        this.rootId = run.id;\n        if (this.argOnStart) {\n            await this.argOnStart(run, this.config);\n        }\n    }\n    async onRunUpdate(run) {\n        if (run.id !== this.rootId) {\n            return;\n        }\n        if (!run.error) {\n            if (this.argOnEnd) {\n                await this.argOnEnd(run, this.config);\n            }\n        }\n        else if (this.argOnError) {\n            await this.argOnError(run, this.config);\n        }\n    }\n}\nexports.RootListenersTracer = RootListenersTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsOEVBQVk7QUFDdEM7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUm9vdExpc3RlbmVyc1RyYWNlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2UuY2pzXCIpO1xuY2xhc3MgUm9vdExpc3RlbmVyc1RyYWNlciBleHRlbmRzIGJhc2VfanNfMS5CYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmZpZywgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlJvb3RMaXN0ZW5lcnNUcmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBSdW4ncyBJRC4gVHlwZSBVVUlEICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvb3RJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25TdGFydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFyZ09uU3RhcnQgPSBvblN0YXJ0O1xuICAgICAgICB0aGlzLmFyZ09uRW5kID0gb25FbmQ7XG4gICAgICAgIHRoaXMuYXJnT25FcnJvciA9IG9uRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAqIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICAgKiBAcGFyYW0ge1J1bn0gXyBOb3QgdXNlZFxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oXykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3RJZCA9IHJ1bi5pZDtcbiAgICAgICAgaWYgKHRoaXMuYXJnT25TdGFydCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVuLmVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdPbkVuZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FbmQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcmdPbkVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJvb3RMaXN0ZW5lcnNUcmFjZXIgPSBSb290TGlzdGVuZXJzVHJhY2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/root_listener.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangChainTracer = void 0;\nconst langsmith_1 = __webpack_require__(/*! langsmith */ \"(rsc)/./node_modules/langsmith/index.cjs\");\nconst run_trees_1 = __webpack_require__(/*! langsmith/run_trees */ \"(rsc)/./node_modules/langsmith/run_trees.cjs\");\nconst traceable_1 = __webpack_require__(/*! langsmith/singletons/traceable */ \"(rsc)/./node_modules/langsmith/singletons/traceable.cjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tracers/base.cjs\");\nconst tracer_js_1 = __webpack_require__(/*! ../singletons/tracer.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/tracer.cjs\");\nclass LangChainTracer extends base_js_1.BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        const { exampleId, projectName, client, replicas } = fields;\n        this.projectName = projectName ?? (0, langsmith_1.getDefaultProjectName)();\n        this.replicas = replicas;\n        this.exampleId = exampleId;\n        this.client = client ?? (0, tracer_js_1.getDefaultLangChainClientSingleton)();\n        const traceableTree = LangChainTracer.getTraceableRunTree();\n        if (traceableTree) {\n            this.updateFromRunTree(traceableTree);\n        }\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.postRun();\n    }\n    async onRunUpdate(run) {\n        const runTree = this.getRunTreeWithTracingConfig(run.id);\n        await runTree?.patchRun();\n    }\n    getRun(id) {\n        return this.runTreeMap.get(id);\n    }\n    updateFromRunTree(runTree) {\n        this.runTreeMap.set(runTree.id, runTree);\n        let rootRun = runTree;\n        const visited = new Set();\n        while (rootRun.parent_run) {\n            if (visited.has(rootRun.id))\n                break;\n            visited.add(rootRun.id);\n            if (!rootRun.parent_run)\n                break;\n            rootRun = rootRun.parent_run;\n        }\n        visited.clear();\n        const queue = [rootRun];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (!current || visited.has(current.id))\n                continue;\n            visited.add(current.id);\n            this.runTreeMap.set(current.id, current);\n            if (current.child_runs) {\n                queue.push(...current.child_runs);\n            }\n        }\n        this.client = runTree.client ?? this.client;\n        this.replicas = runTree.replicas ?? this.replicas;\n        this.projectName = runTree.project_name ?? this.projectName;\n        this.exampleId = runTree.reference_example_id ?? this.exampleId;\n    }\n    getRunTreeWithTracingConfig(id) {\n        const runTree = this.runTreeMap.get(id);\n        if (!runTree)\n            return undefined;\n        return new run_trees_1.RunTree({\n            ...runTree,\n            client: this.client,\n            project_name: this.projectName,\n            replicas: this.replicas,\n            reference_example_id: this.exampleId,\n            tracingEnabled: true,\n        });\n    }\n    static getTraceableRunTree() {\n        try {\n            return (\n            // The type cast here provides forward compatibility. Old versions of LangSmith will just\n            // ignore the permitAbsentRunTree arg.\n            traceable_1.getCurrentRunTree(true));\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\nexports.LangChainTracer = LangChainTracer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsMkRBQVc7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUVBQXFCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFnQztBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDdEQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nQ2hhaW5UcmFjZXIgPSB2b2lkIDA7XG5jb25zdCBsYW5nc21pdGhfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGhcIik7XG5jb25zdCBydW5fdHJlZXNfMSA9IHJlcXVpcmUoXCJsYW5nc21pdGgvcnVuX3RyZWVzXCIpO1xuY29uc3QgdHJhY2VhYmxlXzEgPSByZXF1aXJlKFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCIpO1xuY29uc3QgYmFzZV9qc18xID0gcmVxdWlyZShcIi4vYmFzZS5janNcIik7XG5jb25zdCB0cmFjZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9zaW5nbGV0b25zL3RyYWNlci5janNcIik7XG5jbGFzcyBMYW5nQ2hhaW5UcmFjZXIgZXh0ZW5kcyBiYXNlX2pzXzEuQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsYW5nY2hhaW5fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3ROYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbGljYXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlc1J1blRyZWVNYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZXhhbXBsZUlkLCBwcm9qZWN0TmFtZSwgY2xpZW50LCByZXBsaWNhcyB9ID0gZmllbGRzO1xuICAgICAgICB0aGlzLnByb2plY3ROYW1lID0gcHJvamVjdE5hbWUgPz8gKDAsIGxhbmdzbWl0aF8xLmdldERlZmF1bHRQcm9qZWN0TmFtZSkoKTtcbiAgICAgICAgdGhpcy5yZXBsaWNhcyA9IHJlcGxpY2FzO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IGV4YW1wbGVJZDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQgPz8gKDAsIHRyYWNlcl9qc18xLmdldERlZmF1bHRMYW5nQ2hhaW5DbGllbnRTaW5nbGV0b24pKCk7XG4gICAgICAgIGNvbnN0IHRyYWNlYWJsZVRyZWUgPSBMYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICBpZiAodHJhY2VhYmxlVHJlZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUnVuVHJlZSh0cmFjZWFibGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwZXJzaXN0UnVuKF9ydW4pIHsgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBjb25zdCBydW5UcmVlID0gdGhpcy5nZXRSdW5UcmVlV2l0aFRyYWNpbmdDb25maWcocnVuLmlkKTtcbiAgICAgICAgYXdhaXQgcnVuVHJlZT8ucG9zdFJ1bigpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcnVuVHJlZSA9IHRoaXMuZ2V0UnVuVHJlZVdpdGhUcmFjaW5nQ29uZmlnKHJ1bi5pZCk7XG4gICAgICAgIGF3YWl0IHJ1blRyZWU/LnBhdGNoUnVuKCk7XG4gICAgfVxuICAgIGdldFJ1bihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmVlTWFwLmdldChpZCk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21SdW5UcmVlKHJ1blRyZWUpIHtcbiAgICAgICAgdGhpcy5ydW5UcmVlTWFwLnNldChydW5UcmVlLmlkLCBydW5UcmVlKTtcbiAgICAgICAgbGV0IHJvb3RSdW4gPSBydW5UcmVlO1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB3aGlsZSAocm9vdFJ1bi5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICBpZiAodmlzaXRlZC5oYXMocm9vdFJ1bi5pZCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChyb290UnVuLmlkKTtcbiAgICAgICAgICAgIGlmICghcm9vdFJ1bi5wYXJlbnRfcnVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcm9vdFJ1biA9IHJvb3RSdW4ucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW3Jvb3RSdW5dO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgdmlzaXRlZC5oYXMoY3VycmVudC5pZCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIHRoaXMucnVuVHJlZU1hcC5zZXQoY3VycmVudC5pZCwgY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5jaGlsZF9ydW5zKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCguLi5jdXJyZW50LmNoaWxkX3J1bnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50ID0gcnVuVHJlZS5jbGllbnQgPz8gdGhpcy5jbGllbnQ7XG4gICAgICAgIHRoaXMucmVwbGljYXMgPSBydW5UcmVlLnJlcGxpY2FzID8/IHRoaXMucmVwbGljYXM7XG4gICAgICAgIHRoaXMucHJvamVjdE5hbWUgPSBydW5UcmVlLnByb2plY3RfbmFtZSA/PyB0aGlzLnByb2plY3ROYW1lO1xuICAgICAgICB0aGlzLmV4YW1wbGVJZCA9IHJ1blRyZWUucmVmZXJlbmNlX2V4YW1wbGVfaWQgPz8gdGhpcy5leGFtcGxlSWQ7XG4gICAgfVxuICAgIGdldFJ1blRyZWVXaXRoVHJhY2luZ0NvbmZpZyhpZCkge1xuICAgICAgICBjb25zdCBydW5UcmVlID0gdGhpcy5ydW5UcmVlTWFwLmdldChpZCk7XG4gICAgICAgIGlmICghcnVuVHJlZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgcnVuX3RyZWVzXzEuUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5ydW5UcmVlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHJlcGxpY2FzOiB0aGlzLnJlcGxpY2FzLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMuZXhhbXBsZUlkLFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VHJhY2VhYmxlUnVuVHJlZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBUaGUgdHlwZSBjYXN0IGhlcmUgcHJvdmlkZXMgZm9yd2FyZCBjb21wYXRpYmlsaXR5LiBPbGQgdmVyc2lvbnMgb2YgTGFuZ1NtaXRoIHdpbGwganVzdFxuICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBwZXJtaXRBYnNlbnRSdW5UcmVlIGFyZy5cbiAgICAgICAgICAgIHRyYWNlYWJsZV8xLmdldEN1cnJlbnRSdW5UcmVlKHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nQ2hhaW5UcmFjZXIgPSBMYW5nQ2hhaW5UcmFjZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/tracers/tracer_langchain.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/async_caller.cjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncCaller = void 0;\nconst p_retry_1 = __importDefault(__webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\"));\nconst p_queue_1 = __importDefault(__webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\"));\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment Required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error) => {\n    if (error.message.startsWith(\"Cancel\") ||\n        error.message.startsWith(\"AbortError\") ||\n        error.name === \"AbortError\") {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.code === \"ECONNABORTED\") {\n        throw error;\n    }\n    const status = \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error?.response?.status ?? error?.status;\n    if (status && STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (error?.error?.code === \"insufficient_quota\") {\n        const err = new Error(error?.message);\n        err.name = \"InsufficientQuotaError\";\n        throw err;\n    }\n};\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.onFailedAttempt =\n            params.onFailedAttempt ?? defaultFailedAttemptHandler;\n        const PQueue = (\"default\" in p_queue_1.default ? p_queue_1.default.default : p_queue_1.default);\n        this.queue = new PQueue({ concurrency: this.maxConcurrency });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(() => (0, p_retry_1.default)(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(() => fetch(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\nexports.AsyncCaller = AsyncCaller;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixrQ0FBa0MsbUJBQU8sQ0FBQyxzREFBUztBQUNuRCxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jQ2FsbGVyID0gdm9pZCAwO1xuY29uc3QgcF9yZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwLXJldHJ5XCIpKTtcbmNvbnN0IHBfcXVldWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicC1xdWV1ZVwiKSk7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLCAvLyBCYWQgUmVxdWVzdFxuICAgIDQwMSwgLy8gVW5hdXRob3JpemVkXG4gICAgNDAyLCAvLyBQYXltZW50IFJlcXVpcmVkXG4gICAgNDAzLCAvLyBGb3JiaWRkZW5cbiAgICA0MDQsIC8vIE5vdCBGb3VuZFxuICAgIDQwNSwgLy8gTWV0aG9kIE5vdCBBbGxvd2VkXG4gICAgNDA2LCAvLyBOb3QgQWNjZXB0YWJsZVxuICAgIDQwNywgLy8gUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSB8fFxuICAgICAgICBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPz8gZXJyb3I/LnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICYmIFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmVycm9yPy5jb2RlID09PSBcImluc3VmZmljaWVudF9xdW90YVwiKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJvcj8ubWVzc2FnZSk7XG4gICAgICAgIGVyci5uYW1lID0gXCJJbnN1ZmZpY2llbnRRdW90YUVycm9yXCI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICB0aGlzLm9uRmFpbGVkQXR0ZW1wdCA9XG4gICAgICAgICAgICBwYXJhbXMub25GYWlsZWRBdHRlbXB0ID8/IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlcjtcbiAgICAgICAgY29uc3QgUFF1ZXVlID0gKFwiZGVmYXVsdFwiIGluIHBfcXVldWVfMS5kZWZhdWx0ID8gcF9xdWV1ZV8xLmRlZmF1bHQuZGVmYXVsdCA6IHBfcXVldWVfMS5kZWZhdWx0KTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiAoMCwgcF9yZXRyeV8xLmRlZmF1bHQpKCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IHRoaXMub25GYWlsZWRBdHRlbXB0LFxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IGZldGNoKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gKHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY0NhbGxlciA9IEFzeW5jQ2FsbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/callbacks.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracingEnabled = void 0;\nconst env_js_1 = __webpack_require__(/*! ./env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");\nconst isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGSMITH_TRACING\",\n        \"LANGCHAIN_TRACING\",\n    ];\n    return !!envVars.find((envVar) => (0, env_js_1.getEnvironmentVariable)(envVar) === \"true\");\n};\nexports.isTracingEnabled = isTracingEnabled;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9jYWxsYmFja3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1RyYWNpbmdFbmFibGVkID0gdm9pZCAwO1xuY29uc3QgZW52X2pzXzEgPSByZXF1aXJlKFwiLi9lbnYuY2pzXCIpO1xuY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcbiAgICAgICAgXCJMQU5HU01JVEhfVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR1wiLFxuICAgIF07XG4gICAgcmV0dXJuICEhZW52VmFycy5maW5kKChlbnZWYXIpID0+ICgwLCBlbnZfanNfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShlbnZWYXIpID09PSBcInRydWVcIik7XG59O1xuZXhwb3J0cy5pc1RyYWNpbmdFbmFibGVkID0gaXNUcmFjaW5nRW5hYmxlZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/callbacks.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/chunk_array.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chunkArray = void 0;\nconst chunkArray = (arr, chunkSize) => arr.reduce((chunks, elem, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n    const chunk = chunks[chunkIndex] || [];\n    // eslint-disable-next-line no-param-reassign\n    chunks[chunkIndex] = chunk.concat([elem]);\n    return chunks;\n}, []);\nexports.chunkArray = chunkArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2h1bmtfYXJyYXkuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9jaHVua19hcnJheS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNodW5rQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBjaHVua0FycmF5ID0gKGFyciwgY2h1bmtTaXplKSA9PiBhcnIucmVkdWNlKChjaHVua3MsIGVsZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBjaHVua1NpemUpO1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2NodW5rSW5kZXhdIHx8IFtdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNodW5rc1tjaHVua0luZGV4XSA9IGNodW5rLmNvbmNhdChbZWxlbV0pO1xuICAgIHJldHVybiBjaHVua3M7XG59LCBbXSk7XG5leHBvcnRzLmNodW5rQXJyYXkgPSBjaHVua0FycmF5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/env.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEnv = exports.isNode = exports.isDeno = exports.isJsDom = exports.isWebWorker = exports.isBrowser = void 0;\nexports.getRuntimeEnvironment = getRuntimeEnvironment;\nexports.getRuntimeEnvironmentSync = getRuntimeEnvironmentSync;\nexports.getEnvironmentVariable = getEnvironmentVariable;\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nexports.isBrowser = isBrowser;\nconst isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nexports.isWebWorker = isWebWorker;\nconst isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\nexports.isJsDom = isJsDom;\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = () => typeof Deno !== \"undefined\";\nexports.isDeno = isDeno;\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !(0, exports.isDeno)();\nexports.isNode = isNode;\nconst getEnv = () => {\n    let env;\n    if ((0, exports.isBrowser)()) {\n        env = \"browser\";\n    }\n    else if ((0, exports.isNode)()) {\n        env = \"node\";\n    }\n    else if ((0, exports.isWebWorker)()) {\n        env = \"webworker\";\n    }\n    else if ((0, exports.isJsDom)()) {\n        env = \"jsdom\";\n    }\n    else if ((0, exports.isDeno)()) {\n        env = \"deno\";\n    }\n    else {\n        env = \"other\";\n    }\n    return env;\n};\nexports.getEnv = getEnv;\nlet runtimeEnvironment;\n/**\n * @deprecated Use getRuntimeEnvironmentSync instead\n */\nasync function getRuntimeEnvironment() {\n    return getRuntimeEnvironmentSync();\n}\nfunction getRuntimeEnvironmentSync() {\n    if (runtimeEnvironment === undefined) {\n        const env = (0, exports.getEnv)();\n        runtimeEnvironment = {\n            library: \"langchain-js\",\n            runtime: env,\n        };\n    }\n    return runtimeEnvironment;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/langchain-ai/langchainjs/issues/1412\n    try {\n        if (typeof process !== \"undefined\") {\n            // eslint-disable-next-line no-process-env\n            return process.env?.[name];\n        }\n        else if ((0, exports.isDeno)()) {\n            return Deno?.env.get(name);\n        }\n        else {\n            return undefined;\n        }\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQzVHLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW52ID0gZXhwb3J0cy5pc05vZGUgPSBleHBvcnRzLmlzRGVubyA9IGV4cG9ydHMuaXNKc0RvbSA9IGV4cG9ydHMuaXNXZWJXb3JrZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0UnVudGltZUVudmlyb25tZW50ID0gZ2V0UnVudGltZUVudmlyb25tZW50O1xuZXhwb3J0cy5nZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jID0gZ2V0UnVudGltZUVudmlyb25tZW50U3luYztcbmV4cG9ydHMuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSA9IGdldEVudmlyb25tZW50VmFyaWFibGU7XG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnRzLmlzV2ViV29ya2VyID0gaXNXZWJXb3JrZXI7XG5jb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKTtcbmV4cG9ydHMuaXNKc0RvbSA9IGlzSnNEb207XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5jb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMuaXNEZW5vID0gaXNEZW5vO1xuLy8gTWFyayBub3QtYXMtbm9kZSBpZiBpbiBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uXG5jb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICEoMCwgZXhwb3J0cy5pc0Rlbm8pKCk7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBsZXQgZW52O1xuICAgIGlmICgoMCwgZXhwb3J0cy5pc0Jyb3dzZXIpKCkpIHtcbiAgICAgICAgZW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzTm9kZSkoKSkge1xuICAgICAgICBlbnYgPSBcIm5vZGVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGV4cG9ydHMuaXNXZWJXb3JrZXIpKCkpIHtcbiAgICAgICAgZW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGV4cG9ydHMuaXNKc0RvbSkoKSkge1xuICAgICAgICBlbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBleHBvcnRzLmlzRGVubykoKSkge1xuICAgICAgICBlbnYgPSBcImRlbm9cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IFwib3RoZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudjtcbn07XG5leHBvcnRzLmdldEVudiA9IGdldEVudjtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBnZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jIGluc3RlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIHJldHVybiBnZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jKCk7XG59XG5mdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnRTeW5jKCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSAoMCwgZXhwb3J0cy5nZXRFbnYpKCk7XG4gICAgICAgIHJ1bnRpbWVFbnZpcm9ubWVudCA9IHtcbiAgICAgICAgICAgIGxpYnJhcnk6IFwibGFuZ2NoYWluLWpzXCIsXG4gICAgICAgICAgICBydW50aW1lOiBlbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG5mdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICAvLyBDZXJ0YWluIERlbm8gc2V0dXBzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeSB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xhbmdjaGFpbi1haS9sYW5nY2hhaW5qcy9pc3N1ZXMvMTQxMlxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnY/LltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgZXhwb3J0cy5pc0Rlbm8pKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZW5vPy5lbnYuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/event_source_parse.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventStreamContentType = void 0;\nexports.getBytes = getBytes;\nexports.getLines = getLines;\nexports.getMessages = getMessages;\nexports.convertEventStreamToIterableReadableDataStream = convertEventStreamToIterableReadableDataStream;\n/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nconst stream_js_1 = __webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");\nexports.EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nstream, onChunk) {\n    // TODO: Use Async iteration for both cases?\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (stream instanceof ReadableStream) {\n        const reader = stream.getReader();\n        // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n        //          This change is essential to ensure that we capture every last piece of information from streams,\n        //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n        //          mechanism, we risk ignoring a possibly significant last message.\n        //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                onChunk(new Uint8Array(), true);\n                break;\n            }\n            onChunk(result.value);\n        }\n    }\n    else {\n        try {\n            // Handle Node.js Readable streams with async iteration\n            for await (const chunk of stream) {\n                onChunk(new Uint8Array(chunk));\n            }\n            onChunk(new Uint8Array(), true);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new Error([\n                \"Parsing event source stream failed.\",\n                \"Ensure your implementation of fetch returns a web or Node readable stream.\",\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr, flush) {\n        if (flush) {\n            onLine(arr, 0, true);\n            return;\n        }\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength, flush) {\n        if (flush) {\n            if (!isEmpty(message)) {\n                onMessage?.(message);\n                message = newMessage();\n            }\n            return;\n        }\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\nfunction convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {\n    const dataStream = new ReadableStream({\n        async start(controller) {\n            const enqueueLine = getMessages((msg) => {\n                if (msg.event === \"error\") {\n                    throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n                }\n                else if (msg.event === \"metadata\") {\n                    onMetadataEvent?.(msg);\n                }\n                else {\n                    if (msg.data)\n                        controller.enqueue(msg.data);\n                }\n            });\n            const onLine = (line, fieldLength, flush) => {\n                enqueueLine(line, fieldLength, flush);\n                if (flush)\n                    controller.close();\n            };\n            await getBytes(stream, getLines(onLine));\n        },\n    });\n    return stream_js_1.IterableReadableStream.fromReadableStream(dataStream);\n}\nfunction isEmpty(message) {\n    return (message.data === \"\" &&\n        message.event === \"\" &&\n        message.id === \"\" &&\n        message.retry === undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZXZlbnRfc291cmNlX3BhcnNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFjO0FBQzFDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2V2ZW50X3NvdXJjZV9wYXJzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50U3RyZWFtQ29udGVudFR5cGUgPSB2b2lkIDA7XG5leHBvcnRzLmdldEJ5dGVzID0gZ2V0Qnl0ZXM7XG5leHBvcnRzLmdldExpbmVzID0gZ2V0TGluZXM7XG5leHBvcnRzLmdldE1lc3NhZ2VzID0gZ2V0TWVzc2FnZXM7XG5leHBvcnRzLmNvbnZlcnRFdmVudFN0cmVhbVRvSXRlcmFibGVSZWFkYWJsZURhdGFTdHJlYW0gPSBjb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtO1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXRlbXBsYXRlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBkZWZhdWx0LWNhc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dmb3J0YWluZS9mZXRjaC1ldmVudC1zb3VyY2UvYmxvYi9tYWluL3NyYy9wYXJzZS50c1xuLy8gZHVlIHRvIGEgcGFja2FnaW5nIGlzc3VlIGluIHRoZSBvcmlnaW5hbC5cbi8vIE1JVCBMaWNlbnNlXG5jb25zdCBzdHJlYW1fanNfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS5janNcIik7XG5leHBvcnRzLkV2ZW50U3RyZWFtQ29udGVudFR5cGUgPSBcInRleHQvZXZlbnQtc3RyZWFtXCI7XG4vKipcbiAqIENvbnZlcnRzIGEgUmVhZGFibGVTdHJlYW0gaW50byBhIGNhbGxiYWNrIHBhdHRlcm4uXG4gKiBAcGFyYW0gc3RyZWFtIFRoZSBpbnB1dCBSZWFkYWJsZVN0cmVhbS5cbiAqIEBwYXJhbSBvbkNodW5rIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIG5ldyBieXRlIGNodW5rIGluIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBzdHJlYW0gY2xvc2VzLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRCeXRlcyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5zdHJlYW0sIG9uQ2h1bmspIHtcbiAgICAvLyBUT0RPOiBVc2UgQXN5bmMgaXRlcmF0aW9uIGZvciBib3RoIGNhc2VzP1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAvLyBDSEFOR0VEOiBJbnRyb2R1Y2VkIGEgXCJmbHVzaFwiIG1lY2hhbmlzbSB0byBwcm9jZXNzIHBvdGVudGlhbCBwZW5kaW5nIG1lc3NhZ2VzIHdoZW4gdGhlIHN0cmVhbSBlbmRzLlxuICAgICAgICAvLyAgICAgICAgICBUaGlzIGNoYW5nZSBpcyBlc3NlbnRpYWwgdG8gZW5zdXJlIHRoYXQgd2UgY2FwdHVyZSBldmVyeSBsYXN0IHBpZWNlIG9mIGluZm9ybWF0aW9uIGZyb20gc3RyZWFtcyxcbiAgICAgICAgLy8gICAgICAgICAgc3VjaCBhcyB0aG9zZSBmcm9tIEF6dXJlIE9wZW5BSSwgd2hpY2ggbWF5IG5vdCB0ZXJtaW5hdGUgd2l0aCBhIGJsYW5rIGxpbmUuIFdpdGhvdXQgdGhpc1xuICAgICAgICAvLyAgICAgICAgICBtZWNoYW5pc20sIHdlIHJpc2sgaWdub3JpbmcgYSBwb3NzaWJseSBzaWduaWZpY2FudCBsYXN0IG1lc3NhZ2UuXG4gICAgICAgIC8vICAgICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL2lzc3Vlcy8xMjk5IGZvciBkZXRhaWxzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheSgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2h1bmsocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBOb2RlLmpzIFJlYWRhYmxlIHN0cmVhbXMgd2l0aCBhc3luYyBpdGVyYXRpb25cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheShjaHVuaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25DaHVuayhuZXcgVWludDhBcnJheSgpLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICAgICAgXCJQYXJzaW5nIGV2ZW50IHNvdXJjZSBzdHJlYW0gZmFpbGVkLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHlvdXIgaW1wbGVtZW50YXRpb24gb2YgZmV0Y2ggcmV0dXJucyBhIHdlYiBvciBOb2RlIHJlYWRhYmxlIHN0cmVhbS5cIixcbiAgICAgICAgICAgICAgICBgRXJyb3I6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZXMgYXJiaXRhcnkgYnl0ZSBjaHVua3MgaW50byBFdmVudFNvdXJjZSBsaW5lIGJ1ZmZlcnMuXG4gKiBFYWNoIGxpbmUgc2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgXCJmaWVsZDogdmFsdWVcIiBhbmQgZW5kcyB3aXRoIFxcciwgXFxuLCBvciBcXHJcXG4uXG4gKiBAcGFyYW0gb25MaW5lIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIG5ldyBFdmVudFNvdXJjZSBsaW5lLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgZm9yIGVhY2ggaW5jb21pbmcgYnl0ZSBjaHVuay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXMob25MaW5lKSB7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBsZXQgcG9zaXRpb247IC8vIGN1cnJlbnQgcmVhZCBwb3NpdGlvblxuICAgIGxldCBmaWVsZExlbmd0aDsgLy8gbGVuZ3RoIG9mIHRoZSBgZmllbGRgIHBvcnRpb24gb2YgdGhlIGxpbmVcbiAgICBsZXQgZGlzY2FyZFRyYWlsaW5nTmV3bGluZSA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIHByb2Nlc3MgZWFjaCBpbmNvbWluZyBieXRlIGNodW5rOlxuICAgIHJldHVybiBmdW5jdGlvbiBvbkNodW5rKGFyciwgZmx1c2gpIHtcbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICBvbkxpbmUoYXJyLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGFycjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBzdGlsbCBwYXJzaW5nIHRoZSBvbGQgbGluZS4gQXBwZW5kIHRoZSBuZXcgYnl0ZXMgaW50byBidWZmZXI6XG4gICAgICAgICAgICBidWZmZXIgPSBjb25jYXQoYnVmZmVyLCBhcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Zkxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSAwOyAvLyBpbmRleCB3aGVyZSB0aGUgY3VycmVudCBsaW5lIHN0YXJ0c1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBidWZMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaXNjYXJkVHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcltwb3NpdGlvbl0gPT09IDEwIC8qIENvbnRyb2xDaGFycy5OZXdMaW5lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9ICsrcG9zaXRpb247IC8vIHNraXAgdG8gbmV4dCBjaGFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0YXJ0IGxvb2tpbmcgZm9yd2FyZCB0aWxsIHRoZSBlbmQgb2YgbGluZTpcbiAgICAgICAgICAgIGxldCBsaW5lRW5kID0gLTE7IC8vIGluZGV4IG9mIHRoZSBcXHIgb3IgXFxuIGNoYXJcbiAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGJ1Zkxlbmd0aCAmJiBsaW5lRW5kID09PSAtMTsgKytwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyW3Bvc2l0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU4IC8qIENvbnRyb2xDaGFycy5Db2xvbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjb2xvbiBpbiBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRMZW5ndGggPSBwb3NpdGlvbiAtIGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6NzAyOSBcXHIgY2FzZSBiZWxvdyBzaG91bGQgZmFsbHRocm91Z2ggdG8gXFxuOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIENvbnRyb2xDaGFycy5DYXJyaWFnZVJldHVybiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBDb250cm9sQ2hhcnMuTmV3TGluZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbmQgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lRW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGJ1dCB0aGUgbGluZSBoYXNuJ3QgZW5kZWQuXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIG5leHQgYXJyIGFuZCB0aGVuIGNvbnRpbnVlIHBhcnNpbmc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSd2ZSByZWFjaGVkIHRoZSBsaW5lIGVuZCwgc2VuZCBpdCBvdXQ6XG4gICAgICAgICAgICBvbkxpbmUoYnVmZmVyLnN1YmFycmF5KGxpbmVTdGFydCwgbGluZUVuZCksIGZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IHBvc2l0aW9uOyAvLyB3ZSdyZSBub3cgb24gdGhlIG5leHQgbGluZVxuICAgICAgICAgICAgZmllbGRMZW5ndGggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVN0YXJ0ID09PSBidWZMZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDsgLy8gd2UndmUgZmluaXNoZWQgcmVhZGluZyBpdFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZpZXcgaW50byBidWZmZXIgYmVnaW5uaW5nIGF0IGxpbmVTdGFydCBzbyB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb3B5IG92ZXIgdGhlIHByZXZpb3VzIGxpbmVzIHdoZW4gd2UgZ2V0IHRoZSBuZXcgYXJyOlxuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KGxpbmVTdGFydCk7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSBsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgbGluZSBidWZmZXJzIGludG8gRXZlbnRTb3VyY2VNZXNzYWdlcy5cbiAqIEBwYXJhbSBvbklkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGBpZGAgZmllbGQuXG4gKiBAcGFyYW0gb25SZXRyeSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBgcmV0cnlgIGZpZWxkLlxuICogQHBhcmFtIG9uTWVzc2FnZSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBtZXNzYWdlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgZm9yIGVhY2ggaW5jb21pbmcgbGluZSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzKG9uTWVzc2FnZSwgb25JZCwgb25SZXRyeSkge1xuICAgIGxldCBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBwcm9jZXNzIGVhY2ggaW5jb21pbmcgbGluZSBidWZmZXI6XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTGluZShsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpIHtcbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2U/LihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBkZW5vdGVzIGVuZCBvZiBtZXNzYWdlLiBUcmlnZ2VyIHRoZSBjYWxsYmFjayBhbmQgc3RhcnQgYSBuZXcgbWVzc2FnZTpcbiAgICAgICAgICAgIG9uTWVzc2FnZT8uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG5ld01lc3NhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGV4Y2x1ZGUgY29tbWVudHMgYW5kIGxpbmVzIHdpdGggbm8gdmFsdWVzXG4gICAgICAgICAgICAvLyBsaW5lIGlzIG9mIGZvcm1hdCBcIjxmaWVsZD46PHZhbHVlPlwiIG9yIFwiPGZpZWxkPjogPHZhbHVlPlwiXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNldmVudC1zdHJlYW0taW50ZXJwcmV0YXRpb25cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSgwLCBmaWVsZExlbmd0aCkpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBmaWVsZExlbmd0aCArIChsaW5lW2ZpZWxkTGVuZ3RoICsgMV0gPT09IDMyIC8qIENvbnRyb2xDaGFycy5TcGFjZSAqLyA/IDIgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSh2YWx1ZU9mZnNldCkpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbWVzc2FnZSBhbHJlYWR5IGhhcyBkYXRhLCBhcHBlbmQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgb2xkLlxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3Qgc2V0IHRvIHRoZSBuZXcgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YSA/IG1lc3NhZ2UuZGF0YSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlOyAvLyBvdGhlcndpc2UsXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgICAgICAgICAgICBvbklkPy4oKG1lc3NhZ2UuaWQgPSB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmV0cnlcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHNwZWMsIGlnbm9yZSBub24taW50ZWdlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmV0cnk/LigobWVzc2FnZS5yZXRyeSA9IHJldHJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgcmVzLnNldChhKTtcbiAgICByZXMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbmV3TWVzc2FnZSgpIHtcbiAgICAvLyBkYXRhLCBldmVudCwgYW5kIGlkIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gZW1wdHkgc3RyaW5nczpcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNldmVudC1zdHJlYW0taW50ZXJwcmV0YXRpb25cbiAgICAvLyByZXRyeSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIHNvIHdlIHJldHVybiBhIGNvbnNpc3RlbnQgc2hhcGVcbiAgICAvLyB0byB0aGUganMgZW5naW5lIGFsbCB0aGUgdGltZTogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL3NoYXBlcy1pY3MjdGFrZWF3YXlzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogXCJcIixcbiAgICAgICAgZXZlbnQ6IFwiXCIsXG4gICAgICAgIGlkOiBcIlwiLFxuICAgICAgICByZXRyeTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RXZlbnRTdHJlYW1Ub0l0ZXJhYmxlUmVhZGFibGVEYXRhU3RyZWFtKHN0cmVhbSwgb25NZXRhZGF0YUV2ZW50KSB7XG4gICAgY29uc3QgZGF0YVN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVucXVldWVMaW5lID0gZ2V0TWVzc2FnZXMoKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuZXZlbnQgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnLmRhdGEgPz8gXCJVbnNwZWNpZmllZCBldmVudCBzdHJlYW1pbmcgZXJyb3IuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtc2cuZXZlbnQgPT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgICAgICBvbk1ldGFkYXRhRXZlbnQ/Lihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9uTGluZSA9IChsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpID0+IHtcbiAgICAgICAgICAgICAgICBlbnF1ZXVlTGluZShsaW5lLCBmaWVsZExlbmd0aCwgZmx1c2gpO1xuICAgICAgICAgICAgICAgIGlmIChmbHVzaClcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGdldEJ5dGVzKHN0cmVhbSwgZ2V0TGluZXMob25MaW5lKSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbV9qc18xLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKGRhdGFTdHJlYW0pO1xufVxuZnVuY3Rpb24gaXNFbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlLmRhdGEgPT09IFwiXCIgJiZcbiAgICAgICAgbWVzc2FnZS5ldmVudCA9PT0gXCJcIiAmJlxuICAgICAgICBtZXNzYWdlLmlkID09PSBcIlwiICYmXG4gICAgICAgIG1lc3NhZ2UucmV0cnkgPT09IHVuZGVmaW5lZCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/event_source_parse.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescapePathComponent = exports.escapePathComponent = exports.deepClone = exports.JsonPatchError = void 0;\n__exportStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./src/duplex.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\"), exports);\nvar helpers_js_1 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nObject.defineProperty(exports, \"JsonPatchError\", ({ enumerable: true, get: function () { return helpers_js_1.PatchError; } }));\nObject.defineProperty(exports, \"deepClone\", ({ enumerable: true, get: function () { return helpers_js_1._deepClone; } }));\nObject.defineProperty(exports, \"escapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.escapePathComponent; } }));\nObject.defineProperty(exports, \"unescapePathComponent\", ({ enumerable: true, get: function () { return helpers_js_1.unescapePathComponent; } }));\n/**\n * Default export for backwards compat\n */\nconst core = __importStar(__webpack_require__(/*! ./src/core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\"));\nconst helpers_js_2 = __webpack_require__(/*! ./src/helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports[\"default\"] = {\n    ...core,\n    // ...duplex,\n    JsonPatchError: helpers_js_2.PatchError,\n    deepClone: helpers_js_2._deepClone,\n    escapePathComponent: helpers_js_2.escapePathComponent,\n    unescapePathComponent: helpers_js_2.unescapePathComponent,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0I7QUFDeEcsYUFBYSxtQkFBTyxDQUFDLG9HQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsd0dBQWtCO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDBHQUFtQjtBQUM5QyxrREFBaUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDNUgsNkNBQTRDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3ZILHVEQUFzRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMxSSx5REFBd0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDOUk7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsb0dBQWdCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDBHQUFtQjtBQUNoRCxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSBleHBvcnRzLmVzY2FwZVBhdGhDb21wb25lbnQgPSBleHBvcnRzLmRlZXBDbG9uZSA9IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3JjL2NvcmUuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvZHVwbGV4LmNqc1wiKSwgZXhwb3J0cyk7XG52YXIgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vc3JjL2hlbHBlcnMuY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblBhdGNoRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlbHBlcnNfanNfMS5QYXRjaEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVlcENsb25lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVBhdGhDb21wb25lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5lc2NhcGVQYXRoQ29tcG9uZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWxwZXJzX2pzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50OyB9IH0pO1xuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5jb25zdCBjb3JlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9jb3JlLmNqc1wiKSk7XG5jb25zdCBoZWxwZXJzX2pzXzIgPSByZXF1aXJlKFwiLi9zcmMvaGVscGVycy5janNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLi4uY29yZSxcbiAgICAvLyAuLi5kdXBsZXgsXG4gICAgSnNvblBhdGNoRXJyb3I6IGhlbHBlcnNfanNfMi5QYXRjaEVycm9yLFxuICAgIGRlZXBDbG9uZTogaGVscGVyc19qc18yLl9kZWVwQ2xvbmUsXG4gICAgZXNjYXBlUGF0aENvbXBvbmVudDogaGVscGVyc19qc18yLmVzY2FwZVBhdGhDb21wb25lbnQsXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50OiBoZWxwZXJzX2pzXzIudW5lc2NhcGVQYXRoQ29tcG9uZW50LFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deepClone = exports.JsonPatchError = void 0;\nexports.getValueByPointer = getValueByPointer;\nexports.applyOperation = applyOperation;\nexports.applyPatch = applyPatch;\nexports.applyReducer = applyReducer;\nexports.validator = validator;\nexports.validate = validate;\nexports._areEquals = _areEquals;\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nexports.JsonPatchError = helpers_js_1.PatchError;\nexports.deepClone = helpers_js_1._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nconst objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        let removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = (0, helpers_js_1._deepClone)(removed);\n        }\n        const originalValue = applyOperation(document, {\n            op: \"remove\",\n            path: this.from,\n        }).removed;\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: originalValue,\n        });\n        return { newDocument: document, removed };\n    },\n    copy: function (obj, key, document) {\n        const valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, {\n            op: \"add\",\n            path: this.path,\n            value: (0, helpers_js_1._deepClone)(valueToCopy),\n        });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    },\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if ((0, helpers_js_1.isInteger)(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else {\n            // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get,\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == \"\") {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {\n    if (validateOperation) {\n        if (typeof validateOperation == \"function\") {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        let returnValue = { newDocument: document };\n        if (operation.op === \"add\") {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === \"replace\") {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === \"move\") {\n                // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === \"test\") {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === \"remove\") {\n            // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === \"_get\") {\n            operation.value = document;\n            return returnValue;\n        }\n        else {\n            /* bad operation */\n            if (validateOperation) {\n                throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = (0, helpers_js_1._deepClone)(document);\n        }\n        const path = operation.path || \"\";\n        const keys = path.split(\"/\");\n        let obj = document;\n        let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        let len = keys.length;\n        let existingPathFragment = undefined;\n        let key;\n        let validateFunction;\n        if (typeof validateOperation == \"function\") {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf(\"~\") != -1) {\n                key = (0, helpers_js_1.unescapePathComponent)(key);\n            }\n            if (banPrototypeModifications &&\n                (key == \"__proto__\" ||\n                    (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))) {\n                throw new TypeError(\"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\");\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join(\"/\");\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === \"-\") {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !(0, helpers_js_1.isInteger)(key)) {\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if ((0, helpers_js_1.isInteger)(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    const returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    const returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new exports.JsonPatchError(\"Cannot perform operation at the desired path\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n    }\n    if (!mutateDocument) {\n        document = (0, helpers_js_1._deepClone)(document);\n    }\n    const results = new Array(patch.length);\n    for (let i = 0, length = patch.length; i < length; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    const operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) {\n        // failed test\n        throw new exports.JsonPatchError(\"Test operation failed\", \"TEST_OPERATION_FAILED\", index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== \"object\" ||\n        operation === null ||\n        Array.isArray(operation)) {\n        throw new exports.JsonPatchError(\"Operation is not an object\", \"OPERATION_NOT_AN_OBJECT\", index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new exports.JsonPatchError(\"Operation `op` property is not one of operations defined in RFC-6902\", \"OPERATION_OP_INVALID\", index, operation, document);\n    }\n    else if (typeof operation.path !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `path` property is not a string\", \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', \"OPERATION_PATH_INVALID\", index, operation, document);\n    }\n    else if ((operation.op === \"move\" || operation.op === \"copy\") &&\n        typeof operation.from !== \"string\") {\n        throw new exports.JsonPatchError(\"Operation `from` property is not present (applicable in `move` and `copy` operations)\", \"OPERATION_FROM_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        operation.value === undefined) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_REQUIRED\", index, operation, document);\n    }\n    else if ((operation.op === \"add\" ||\n        operation.op === \"replace\" ||\n        operation.op === \"test\") &&\n        (0, helpers_js_1.hasUndefined)(operation.value)) {\n        throw new exports.JsonPatchError(\"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\", \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\", index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new exports.JsonPatchError(\"Cannot perform an `add` operation at the desired path\", \"OPERATION_PATH_CANNOT_ADD\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"replace\" ||\n            operation.op === \"remove\" ||\n            operation.op === \"_get\") {\n            if (operation.path !== existingPathFragment) {\n                throw new exports.JsonPatchError(\"Cannot perform the operation at a path that does not exist\", \"OPERATION_PATH_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n        else if (operation.op === \"move\" || operation.op === \"copy\") {\n            var existingValue = {\n                op: \"_get\",\n                path: operation.from,\n                value: undefined,\n            };\n            var error = validate([existingValue], document);\n            if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n                throw new exports.JsonPatchError(\"Cannot perform the operation from a path that does not exist\", \"OPERATION_FROM_UNRESOLVABLE\", index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new exports.JsonPatchError(\"Patch sequence must be an array\", \"SEQUENCE_NOT_AN_ARRAY\");\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch((0, helpers_js_1._deepClone)(document), (0, helpers_js_1._deepClone)(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof exports.JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9jb3JlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHNCQUFzQjtBQUMxQyx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIscUJBQXFCLG1CQUFPLENBQUMsc0dBQWU7QUFDNUMsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2NvcmUuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLW5vY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVlcENsb25lID0gZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBnZXRWYWx1ZUJ5UG9pbnRlcjtcbmV4cG9ydHMuYXBwbHlPcGVyYXRpb24gPSBhcHBseU9wZXJhdGlvbjtcbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGFwcGx5UmVkdWNlcjtcbmV4cG9ydHMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuZXhwb3J0cy5fYXJlRXF1YWxzID0gX2FyZUVxdWFscztcbmNvbnN0IGhlbHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuY2pzXCIpO1xuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfanNfMS5QYXRjaEVycm9yO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xuY29uc3Qgb2JqT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgcmV0dXJuIHRoZSByZW1vdmVkIHZhbHVlLCB0aGlzIGNhbiBiZSB0YXhpbmcgcGVyZm9ybWFuY2Utd2lzZSxcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXG4gICAgICAgIGxldCByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5mcm9tLFxuICAgICAgICB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKSh2YWx1ZVRvQ29weSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBfYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfanNfMS5pc0ludGVnZXIpKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXQsXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT0gXCJcIikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcbiAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbik7XG4gICAgcmV0dXJuIGdldE9yaWdpbmFsRGVzdGluYXRpb24udmFsdWU7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgb3BlcmF0aW9uLlxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgYW5kIGBvcGVyYXRpb25gIG9iamVjdHMgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBqc29ucGF0Y2guX2RlZXBDbG9uZShvcGVyYXRpb24pKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xuICogQHBhcmFtIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgV2hldGhlciB0byBiYW4gbW9kaWZpY2F0aW9ucyB0byBgX19wcm90b19fYCwgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogQHJldHVybiBge25ld0RvY3VtZW50LCByZXN1bHR9YCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uID0gZmFsc2UsIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUsIGluZGV4ID0gMCkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoID09PSBcIlwiKSB7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50OyAvL2RvY3VtZW50IHdlIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiIHx8IG9wZXJhdGlvbi5vcCA9PT0gXCJjb3B5XCIpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgYSBtb3ZlIG9yIGNvcHkgdG8gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IFwibW92ZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwb3J0IHJlbW92ZWQgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gX2FyZUVxdWFscyhkb2N1bWVudCwgb3BlcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyXCIsIFwiT1BFUkFUSU9OX09QX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAvKiBFTkQgUk9PVCBPUEVSQVRJT05TICovXG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50ID0gKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGtleXMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9iaiA9IGRvY3VtZW50O1xuICAgICAgICBsZXQgdCA9IDE7IC8vc2tpcCBlbXB0eSBlbGVtZW50IC0gaHR0cDovL2pzcGVyZi5jb20vdG8tc2hpZnQtb3Itbm90LXRvLXNoaWZ0XG4gICAgICAgIGxldCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBsZXQgdmFsaWRhdGVGdW5jdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKFwiflwiKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGtleSA9ICgwLCBoZWxwZXJzX2pzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAoa2V5ID09IFwiX19wcm90b19fXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGtleSA9PSBcInByb3RvdHlwZVwiICYmIHQgPiAwICYmIGtleXNbdCAtIDFdID09IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkpTT04tUGF0Y2g6IG1vZGlmeWluZyBgX19wcm90b19fYCBvciBgY29uc3RydWN0b3IvcHJvdG90eXBlYCBwcm9wIGlzIGJhbm5lZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgaWYgdGhpcyB3YXMgb24gcHVycG9zZSwgcGxlYXNlIHNldCBgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9uc2AgZmxhZyBmYWxzZSBhbmQgcGFzcyBpdCB0byB0aGlzIGZ1bmN0aW9uLiBNb3JlIGluZm8gaW4gZmFzdC1qc29uLXBhdGNoIFJFQURNRVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA9PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IG9wZXJhdGlvbi5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uKG9wZXJhdGlvbiwgMCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICEoMCwgaGVscGVyc19qc18xLmlzSW50ZWdlcikoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGhlbHBlcnNfanNfMS5pc0ludGVnZXIpKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IH5+a2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgb3BlcmF0aW9uLm9wID09PSBcImFkZFwiICYmIGtleSA+IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGhlIHNwZWNpZmllZCBpbmRleCBNVVNUIE5PVCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcIiwgXCJPUEVSQVRJT05fVkFMVUVfT1VUX09GX0JPVU5EU1wiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9iak9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUga2V5cyBpbiB0aGUgcGF0aCwgYnV0IHRoZSBuZXh0IHZhbHVlIGlzbid0IGEgbm9uLW51bGwgb2JqZWN0LFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFIGVycm9yIGluc3RlYWQgb2YgaXRlcmF0aW5nIGFnYWluLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmIHQgPCBsZW4gJiYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UGF0Y2goZG9jdW1lbnQsIHBhdGNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlBhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXlcIiwgXCJTRVFVRU5DRV9OT1RfQU5fQVJSQVlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudCA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkoZG9jdW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHBhdGNoLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtdXRhdGVEb2N1bWVudCBhcmd1bWVudCBiZWNhdXNlIGlmIGl0IHdhcyB0cnVlLCB3ZSBhbHJlYWR5IGRlZXAgY2xvbmVkIHRoZSBvYmplY3QsIHdlJ2xsIGp1c3QgcGFzcyBgdHJ1ZWBcbiAgICAgICAgcmVzdWx0c1tpXSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBwYXRjaFtpXSwgdmFsaWRhdGVPcGVyYXRpb24sIHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMsIGkpO1xuICAgICAgICBkb2N1bWVudCA9IHJlc3VsdHNbaV0ubmV3RG9jdW1lbnQ7IC8vIGluIGNhc2Ugcm9vdCB3YXMgcmVwbGFjZWRcbiAgICB9XG4gICAgcmVzdWx0cy5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5uZXdEb2N1bWVudDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2luZ2xlIG9wZXJhdGlvbi4gQ2FsbGVkIGZyb20gYGpzb25wYXRjaC52YWxpZGF0ZWAuIFRocm93cyBgSnNvblBhdGNoRXJyb3JgIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG9iamVjdCAocGF0Y2gpXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBvcGVyYXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge29iamVjdH0gW2RvY3VtZW50XSAtIG9iamVjdCB3aGVyZSB0aGUgb3BlcmF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhpc3RpbmdQYXRoRnJhZ21lbnRdIC0gY29tZXMgYWxvbmcgd2l0aCBgZG9jdW1lbnRgXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRvcihvcGVyYXRpb24sIGluZGV4LCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBvcGVyYXRpb24gPT09IG51bGwgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3RcIiwgXCJPUEVSQVRJT05fTk9UX0FOX09CSkVDVFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyXCIsIFwiT1BFUkFUSU9OX09QX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZ1wiLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5pbmRleE9mKFwiL1wiKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhdGhzIHRoYXQgYXJlbid0IGVtcHR5IHN0cmluZyBzaG91bGQgc3RhcnQgd2l0aCBcIi9cIlxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYGZyb21gIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBtb3ZlYCBhbmQgYGNvcHlgIG9wZXJhdGlvbnMpXCIsIFwiT1BFUkFUSU9OX0ZST01fUkVRVUlSRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcImFkZFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikgJiZcbiAgICAgICAgb3BlcmF0aW9uLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfUkVRVUlSRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcImFkZFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInRlc3RcIikgJiZcbiAgICAgICAgKDAsIGhlbHBlcnNfanNfMS5oYXNVbmRlZmluZWQpKG9wZXJhdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gYW4gYGFkZGAgb3BlcmF0aW9uIGF0IHRoZSBkZXNpcmVkIHBhdGhcIiwgXCJPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVtb3ZlXCIgfHxcbiAgICAgICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJfZ2V0XCIpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gYXQgYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3RcIiwgXCJPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEVcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgb3A6IFwiX2dldFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IG9wZXJhdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGVycm9yID0gdmFsaWRhdGUoW2V4aXN0aW5nVmFsdWVdLCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEVcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoc2VxdWVuY2UsIGRvY3VtZW50LCBleHRlcm5hbFZhbGlkYXRvcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaCgoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKGRvY3VtZW50KSwgKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShzZXF1ZW5jZSksIGV4dGVybmFsVmFsaWRhdG9yIHx8IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3IgPSBleHRlcm5hbFZhbGlkYXRvciB8fCB2YWxpZGF0b3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3Ioc2VxdWVuY2VbaV0sIGksIGRvY3VtZW50LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5mdW5jdGlvbiBfYXJlRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGFyckEgPSBBcnJheS5pc0FycmF5KGEpLCBhcnJCID0gQXJyYXkuaXNBcnJheShiKSwgaSwgbGVuZ3RoLCBrZXk7XG4gICAgICAgIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyQSAhPSBhcnJCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unobserve = unobserve;\nexports.observe = observe;\nexports.generate = generate;\nexports.compare = compare;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\nconst helpers_js_1 = __webpack_require__(/*! ./helpers.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\");\nconst core_js_1 = __webpack_require__(/*! ./core.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.cjs\");\nvar beforeDict = new WeakMap();\nclass Mirror {\n    constructor(obj) {\n        Object.defineProperty(this, \"obj\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.obj = obj;\n    }\n}\nclass ObserverInfo {\n    constructor(callback, observer) {\n        Object.defineProperty(this, \"callback\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"observer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.callback = callback;\n        this.observer = observer;\n    }\n}\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        const observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = (0, helpers_js_1._deepClone)(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = () => {\n            generate(observer);\n        };\n        var fastCheck = () => {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== \"undefined\") {\n            //not Node\n            window.addEventListener(\"mouseup\", fastCheck);\n            window.addEventListener(\"keyup\", fastCheck);\n            window.addEventListener(\"mousedown\", fastCheck);\n            window.addEventListener(\"keydown\", fastCheck);\n            window.addEventListener(\"change\", fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = () => {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== \"undefined\") {\n            window.removeEventListener(\"mouseup\", fastCheck);\n            window.removeEventListener(\"keyup\", fastCheck);\n            window.removeEventListener(\"mousedown\", fastCheck);\n            window.removeEventListener(\"keydown\", fastCheck);\n            window.removeEventListener(\"change\", fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible = false) {\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        (0, core_js_1.applyPatch)(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = (0, helpers_js_1._objectKeys)(obj);\n    var oldKeys = (0, helpers_js_1._objectKeys)(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if ((0, helpers_js_1.hasOwnProperty)(obj, key) &&\n            !(obj[key] === undefined &&\n                oldVal !== undefined &&\n                Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" &&\n                oldVal != null &&\n                typeof newVal == \"object\" &&\n                newVal != null &&\n                Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + (0, helpers_js_1.escapePathComponent)(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({\n                            op: \"test\",\n                            path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                            value: (0, helpers_js_1._deepClone)(oldVal),\n                        });\n                    }\n                    patches.push({\n                        op: \"replace\",\n                        path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                        value: (0, helpers_js_1._deepClone)(newVal),\n                    });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({\n                    op: \"test\",\n                    path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                    value: (0, helpers_js_1._deepClone)(oldVal),\n                });\n            }\n            patches.push({\n                op: \"remove\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n            });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!(0, helpers_js_1.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {\n            patches.push({\n                op: \"add\",\n                path: path + \"/\" + (0, helpers_js_1.escapePathComponent)(key),\n                value: (0, helpers_js_1._deepClone)(obj[key]),\n            });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible = false) {\n    var patches = [];\n    _generate(tree1, tree2, patches, \"\", invertible);\n    return patches;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLHNHQUFlO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQHRzLW5vY2hlY2tcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcbmV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTMtMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuY29uc3QgaGVscGVyc19qc18xID0gcmVxdWlyZShcIi4vaGVscGVycy5janNcIik7XG5jb25zdCBjb3JlX2pzXzEgPSByZXF1aXJlKFwiLi9jb3JlLmNqc1wiKTtcbnZhciBiZWZvcmVEaWN0ID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIE1pcnJvciB7XG4gICAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ialwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYnNlcnZlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgfVxufVxuY2xhc3MgT2JzZXJ2ZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbi8qKlxuICogT2JzZXJ2ZXMgY2hhbmdlcyBtYWRlIHRvIGFuIG9iamVjdCwgd2hpY2ggY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGdlbmVyYXRlXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcbiAgICBpZiAoIW1pcnJvcikge1xuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkob2JqKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG51bGw7XG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmFzdENoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IHNldFRpbWVvdXQoZGlydHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvL25vdCBOb2RlXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9ICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gYW4gb2JzZXJ2ZXJcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUob2JzZXJ2ZXIsIGludmVydGlibGUgPSBmYWxzZSkge1xuICAgIHZhciBtaXJyb3IgPSBiZWZvcmVEaWN0LmdldChvYnNlcnZlci5vYmplY3QpO1xuICAgIF9nZW5lcmF0ZShtaXJyb3IudmFsdWUsIG9ic2VydmVyLm9iamVjdCwgb2JzZXJ2ZXIucGF0Y2hlcywgXCJcIiwgaW52ZXJ0aWJsZSk7XG4gICAgaWYgKG9ic2VydmVyLnBhdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICgwLCBjb3JlX2pzXzEuYXBwbHlQYXRjaCkobWlycm9yLnZhbHVlLCBvYnNlcnZlci5wYXRjaGVzKTtcbiAgICB9XG4gICAgdmFyIHRlbXAgPSBvYnNlcnZlci5wYXRjaGVzO1xuICAgIGlmICh0ZW1wLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAob2JzZXJ2ZXIuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHRlbXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wO1xufVxuLy8gRGlydHkgY2hlY2sgaWYgb2JqIGlzIGRpZmZlcmVudCBmcm9tIG1pcnJvciwgZ2VuZXJhdGUgcGF0Y2hlcyBhbmQgdXBkYXRlIG1pcnJvclxuZnVuY3Rpb24gX2dlbmVyYXRlKG1pcnJvciwgb2JqLCBwYXRjaGVzLCBwYXRoLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKG9iaiA9PT0gbWlycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmoudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICB2YXIgbmV3S2V5cyA9ICgwLCBoZWxwZXJzX2pzXzEuX29iamVjdEtleXMpKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSAoMCwgaGVscGVyc19qc18xLl9vYmplY3RLZXlzKShtaXJyb3IpO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAvL2lmIGV2ZXIgXCJtb3ZlXCIgb3BlcmF0aW9uIGlzIGltcGxlbWVudGVkIGhlcmUsIG1ha2Ugc3VyZSB0aGlzIHRlc3QgcnVucyBPSzogXCJzaG91bGQgbm90IGdlbmVyYXRlIHRoZSBzYW1lIHBhdGNoIHR3aWNlIChtb3ZlKVwiXG4gICAgZm9yICh2YXIgdCA9IG9sZEtleXMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9sZEtleXNbdF07XG4gICAgICAgIHZhciBvbGRWYWwgPSBtaXJyb3Jba2V5XTtcbiAgICAgICAgaWYgKCgwLCBoZWxwZXJzX2pzXzEuaGFzT3duUHJvcGVydHkpKG9iaiwga2V5KSAmJlxuICAgICAgICAgICAgIShvYmpba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2xkVmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5ld1ZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgbmV3VmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9sZFZhbCkgPT09IEFycmF5LmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIF9nZW5lcmF0ZShvbGRWYWwsIG5ld1ZhbCwgcGF0Y2hlcywgcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLCBpbnZlcnRpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IG5ld1ZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIGhlbHBlcnNfanNfMS5fZGVlcENsb25lKShvbGRWYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG5ld1ZhbCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJ0ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArICgwLCBoZWxwZXJzX2pzXzEuZXNjYXBlUGF0aENvbXBvbmVudCkoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICgwLCBoZWxwZXJzX2pzXzEuX2RlZXBDbG9uZSkob2xkVmFsKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghKDAsIGhlbHBlcnNfanNfMS5oYXNPd25Qcm9wZXJ0eSkobWlycm9yLCBrZXkpICYmIG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCArIFwiL1wiICsgKDAsIGhlbHBlcnNfanNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KShrZXkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoMCwgaGVscGVyc19qc18xLl9kZWVwQ2xvbmUpKG9ialtrZXldKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIHRoZSBkaWZmZXJlbmNlcyBpbiB0d28gb2JqZWN0c1xuICovXG5mdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMiwgaW52ZXJ0aWJsZSA9IGZhbHNlKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchError = void 0;\nexports.hasOwnProperty = hasOwnProperty;\nexports._objectKeys = _objectKeys;\nexports._deepClone = _deepClone;\nexports.isInteger = isInteger;\nexports.escapePathComponent = escapePathComponent;\nexports.unescapePathComponent = unescapePathComponent;\nexports._getPathRecursive = _getPathRecursive;\nexports.getPath = getPath;\nexports.hasUndefined = hasUndefined;\n// Inlined because of ESM import issues\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        const keys = new Array(obj.length);\n        for (let k = 0; k < keys.length; k++) {\n            keys[k] = \"\" + k;\n        }\n        return keys;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    let keys = [];\n    for (let i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    let i = 0;\n    const len = str.length;\n    let charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nfunction escapePathComponent(path) {\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction _getPathRecursive(root, obj) {\n    let found;\n    for (let key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + \"/\";\n            }\n            else if (typeof root[key] === \"object\") {\n                found = _getPathRecursive(root[key], obj);\n                if (found != \"\") {\n                    return escapePathComponent(key) + \"/\" + found;\n                }\n            }\n        }\n    }\n    return \"\";\n}\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return \"/\";\n    }\n    const path = _getPathRecursive(root, obj);\n    if (path === \"\") {\n        throw new Error(\"Object not found in root\");\n    }\n    return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (let i = 0, len = obj.length; i < len; i++) {\n                if (hasUndefined(obj[i])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            const objKeys = _objectKeys(obj);\n            const objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    const messageParts = [message];\n    for (const key in args) {\n        const value = typeof args[key] === \"object\"\n            ? JSON.stringify(args[key], null, 2)\n            : args[key]; // pretty print\n        if (typeof value !== \"undefined\") {\n            messageParts.push(`${key}: ${value}`);\n        }\n    }\n    return messageParts.join(\"\\n\");\n}\nclass PatchError extends Error {\n    constructor(message, name, index, operation, tree) {\n        super(patchErrorMessageFormatter(message, { name, index, operation, tree }));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: name\n        });\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: index\n        });\n        Object.defineProperty(this, \"operation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: operation\n        });\n        Object.defineProperty(this, \"tree\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tree\n        });\n        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        this.message = patchErrorMessageFormatter(message, {\n            name,\n            index,\n            operation,\n            tree,\n        });\n    }\n}\nexports.PatchError = PatchError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlDQUFpQyxJQUFJLElBQUksTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOEJBQThCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEB0cy1ub2NoZWNrXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGNoRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHk7XG5leHBvcnRzLl9vYmplY3RLZXlzID0gX29iamVjdEtleXM7XG5leHBvcnRzLl9kZWVwQ2xvbmUgPSBfZGVlcENsb25lO1xuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG5leHBvcnRzLmVzY2FwZVBhdGhDb21wb25lbnQgPSBlc2NhcGVQYXRoQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQ7XG5leHBvcnRzLl9nZXRQYXRoUmVjdXJzaXZlID0gX2dldFBhdGhSZWN1cnNpdmU7XG5leHBvcnRzLmdldFBhdGggPSBnZXRQYXRoO1xuZXhwb3J0cy5oYXNVbmRlZmluZWQgPSBoYXNVbmRlZmluZWQ7XG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTctMjAyMiBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VkXG4gKi9cbmNvbnN0IF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5mdW5jdGlvbiBfb2JqZWN0S2V5cyhvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAga2V5c1trXSA9IFwiXCIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIGxldCBrZXlzID0gW107XG4gICAgZm9yIChsZXQgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbi8qKlxuICogRGVlcGx5IGNsb25lIHRoZSBvYmplY3QuXG4gKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxuICogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcbiAqIEByZXR1cm4ge2FueX0gY2xvbmVkIG9ialxuICovXG5mdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3RoaXMgaXMgaG93IEpTT04uc3RyaW5naWZ5IGJlaGF2ZXMgZm9yIGFycmF5IGl0ZW1zXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqOyAvL25vIG5lZWQgdG8gY2xvbmUgcHJpbWl0aXZlc1xuICAgIH1cbn1cbi8vM3ggZmFzdGVyIHRoYW4gY2FjaGVkIC9eXFxkKyQvLnRlc3Qoc3RyKVxuZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4gKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZihcIi9cIikgPT09IC0xICYmIHBhdGguaW5kZXhPZihcIn5cIikgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG4vKipcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG5mdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZm9yIChsZXQga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCIgKyBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xuICAgIGlmIChyb290ID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKTtcbiAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XG4gICAgfVxuICAgIHJldHVybiBgLyR7cGF0aH1gO1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cbiAqL1xuZnVuY3Rpb24gaGFzVW5kZWZpbmVkKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXNMZW5ndGggPSBvYmpLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW21lc3NhZ2VdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgYXJnc1trZXldID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGFyZ3Nba2V5XSwgbnVsbCwgMilcbiAgICAgICAgICAgIDogYXJnc1trZXldOyAvLyBwcmV0dHkgcHJpbnRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goYCR7a2V5fTogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZVBhcnRzLmpvaW4oXCJcXG5cIik7XG59XG5jbGFzcyBQYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgc3VwZXIocGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJlZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRjaEVycm9yID0gUGF0Y2hFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/function_calling.cjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLangChainTool = exports.isRunnableToolLike = exports.isStructuredToolParams = exports.isStructuredTool = void 0;\nexports.convertToOpenAIFunction = convertToOpenAIFunction;\nexports.convertToOpenAITool = convertToOpenAITool;\nconst types_js_1 = __webpack_require__(/*! ../tools/types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nconst json_schema_js_1 = __webpack_require__(/*! ./json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\nvar types_js_2 = __webpack_require__(/*! ../tools/types.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/types.cjs\");\nObject.defineProperty(exports, \"isStructuredTool\", ({ enumerable: true, get: function () { return types_js_2.isStructuredTool; } }));\nObject.defineProperty(exports, \"isStructuredToolParams\", ({ enumerable: true, get: function () { return types_js_2.isStructuredToolParams; } }));\nObject.defineProperty(exports, \"isRunnableToolLike\", ({ enumerable: true, get: function () { return types_js_2.isRunnableToolLike; } }));\nObject.defineProperty(exports, \"isLangChainTool\", ({ enumerable: true, get: function () { return types_js_2.isLangChainTool; } }));\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nfunction convertToOpenAIFunction(tool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    return {\n        name: tool.name,\n        description: tool.description,\n        parameters: (0, json_schema_js_1.toJsonSchema)(tool.schema),\n        // Do not include the `strict` field if it is `undefined`.\n        ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n    };\n}\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nfunction convertToOpenAITool(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntool, fields) {\n    // @TODO 0.3.0 Remove the `number` typing\n    const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n    let toolDef;\n    if ((0, types_js_1.isLangChainTool)(tool)) {\n        toolDef = {\n            type: \"function\",\n            function: convertToOpenAIFunction(tool),\n        };\n    }\n    else {\n        toolDef = tool;\n    }\n    if (fieldsCopy?.strict !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        toolDef.function.strict = fieldsCopy.strict;\n    }\n    return toolDef;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCO0FBQ2hILCtCQUErQjtBQUMvQiwyQkFBMkI7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQW9CO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLDBGQUFtQjtBQUNwRDtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscUZBQW9CO0FBQzdDLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSwwREFBeUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDOUksc0RBQXFELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3RJLG1EQUFrRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNEJBQTRCLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtFO0FBQzdFLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mdW5jdGlvbl9jYWxsaW5nLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNMYW5nQ2hhaW5Ub29sID0gZXhwb3J0cy5pc1J1bm5hYmxlVG9vbExpa2UgPSBleHBvcnRzLmlzU3RydWN0dXJlZFRvb2xQYXJhbXMgPSBleHBvcnRzLmlzU3RydWN0dXJlZFRvb2wgPSB2b2lkIDA7XG5leHBvcnRzLmNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uID0gY29udmVydFRvT3BlbkFJRnVuY3Rpb247XG5leHBvcnRzLmNvbnZlcnRUb09wZW5BSVRvb2wgPSBjb252ZXJ0VG9PcGVuQUlUb29sO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90b29scy90eXBlcy5janNcIik7XG5jb25zdCBqc29uX3NjaGVtYV9qc18xID0gcmVxdWlyZShcIi4vanNvbl9zY2hlbWEuY2pzXCIpO1xuLy8gVGhlc2UgdXRpbGl0eSBmdW5jdGlvbnMgd2VyZSBtb3ZlZCB0byBhIG1vcmUgYXBwcm9wcmlhdGUgbG9jYXRpb24sXG4vLyBidXQgd2Ugc3RpbGwgZXhwb3J0IHRoZW0gaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG52YXIgdHlwZXNfanNfMiA9IHJlcXVpcmUoXCIuLi90b29scy90eXBlcy5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cnVjdHVyZWRUb29sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18yLmlzU3RydWN0dXJlZFRvb2w7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cnVjdHVyZWRUb29sUGFyYW1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18yLmlzU3RydWN0dXJlZFRvb2xQYXJhbXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1J1bm5hYmxlVG9vbExpa2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzX2pzXzIuaXNSdW5uYWJsZVRvb2xMaWtlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMYW5nQ2hhaW5Ub29sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc19qc18yLmlzTGFuZ0NoYWluVG9vbDsgfSB9KTtcbi8qKlxuICogRm9ybWF0cyBhIGBTdHJ1Y3R1cmVkVG9vbGAgb3IgYFJ1bm5hYmxlVG9vbExpa2VgIGluc3RhbmNlIGludG8gYSBmb3JtYXRcbiAqIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIE9wZW5BSSBmdW5jdGlvbiBjYWxsaW5nLiBJZiBgU3RydWN0dXJlZFRvb2xgIG9yXG4gKiBgUnVubmFibGVUb29sTGlrZWAgaGFzIGEgem9kIHNjaGVtYSwgdGhlIG91dHB1dCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGFcbiAqIEpTT04gc2NoZW1hLCB3aGljaCBpcyB0aGVuIHVzZWQgYXMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBPcGVuQUkgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgUnVubmFibGVUb29sTGlrZX0gdG9vbCBUaGUgdG9vbCB0byBjb252ZXJ0IHRvIGFuIE9wZW5BSSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbkRlZmluaXRpb259IFRoZSBpbnB1dHRlZCB0b29sIGluIE9wZW5BSSBmdW5jdGlvbiBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uKHRvb2wsIGZpZWxkcykge1xuICAgIC8vIEBUT0RPIDAuMy4wIFJlbW92ZSB0aGUgYG51bWJlcmAgdHlwaW5nXG4gICAgY29uc3QgZmllbGRzQ29weSA9IHR5cGVvZiBmaWVsZHMgPT09IFwibnVtYmVyXCIgPyB1bmRlZmluZWQgOiBmaWVsZHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogKDAsIGpzb25fc2NoZW1hX2pzXzEudG9Kc29uU2NoZW1hKSh0b29sLnNjaGVtYSksXG4gICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHRoZSBgc3RyaWN0YCBmaWVsZCBpZiBpdCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgICAgLi4uKGZpZWxkc0NvcHk/LnN0cmljdCAhPT0gdW5kZWZpbmVkID8geyBzdHJpY3Q6IGZpZWxkc0NvcHkuc3RyaWN0IH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRm9ybWF0cyBhIGBTdHJ1Y3R1cmVkVG9vbGAgb3IgYFJ1bm5hYmxlVG9vbExpa2VgIGluc3RhbmNlIGludG8gYVxuICogZm9ybWF0IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIE9wZW5BSSB0b29sIGNhbGxpbmcuIElmIGBTdHJ1Y3R1cmVkVG9vbGAgb3JcbiAqIGBSdW5uYWJsZVRvb2xMaWtlYCBoYXMgYSB6b2Qgc2NoZW1hLCB0aGUgb3V0cHV0IHdpbGwgYmUgY29udmVydGVkIGludG8gYVxuICogSlNPTiBzY2hlbWEsIHdoaWNoIGlzIHRoZW4gdXNlZCBhcyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIE9wZW5BSSB0b29sLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0dXJlZFRvb2xJbnRlcmZhY2UgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgUnVubmFibGVUb29sTGlrZX0gdG9vbCBUaGUgdG9vbCB0byBjb252ZXJ0IHRvIGFuIE9wZW5BSSB0b29sLlxuICogQHJldHVybnMge1Rvb2xEZWZpbml0aW9ufSBUaGUgaW5wdXR0ZWQgdG9vbCBpbiBPcGVuQUkgdG9vbCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSVRvb2woXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudG9vbCwgZmllbGRzKSB7XG4gICAgLy8gQFRPRE8gMC4zLjAgUmVtb3ZlIHRoZSBgbnVtYmVyYCB0eXBpbmdcbiAgICBjb25zdCBmaWVsZHNDb3B5ID0gdHlwZW9mIGZpZWxkcyA9PT0gXCJudW1iZXJcIiA/IHVuZGVmaW5lZCA6IGZpZWxkcztcbiAgICBsZXQgdG9vbERlZjtcbiAgICBpZiAoKDAsIHR5cGVzX2pzXzEuaXNMYW5nQ2hhaW5Ub29sKSh0b29sKSkge1xuICAgICAgICB0b29sRGVmID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgZnVuY3Rpb246IGNvbnZlcnRUb09wZW5BSUZ1bmN0aW9uKHRvb2wpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdG9vbERlZiA9IHRvb2w7XG4gICAgfVxuICAgIGlmIChmaWVsZHNDb3B5Py5zdHJpY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0b29sRGVmLmZ1bmN0aW9uLnN0cmljdCA9IGZpZWxkc0NvcHkuc3RyaWN0O1xuICAgIH1cbiAgICByZXR1cm4gdG9vbERlZjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/hash.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha256 = exports.insecureHash = void 0;\nvar hash_js_1 = __webpack_require__(/*! ./js-sha1/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\");\nObject.defineProperty(exports, \"insecureHash\", ({ enumerable: true, get: function () { return hash_js_1.insecureHash; } }));\nvar hash_js_2 = __webpack_require__(/*! ./js-sha256/hash.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs\");\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return hash_js_2.sha256; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvaGFzaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLG9CQUFvQjtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDNUMsZ0RBQStDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3pILGdCQUFnQixtQkFBTyxDQUFDLGdHQUFzQjtBQUM5QywwQ0FBeUMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2hhc2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLmluc2VjdXJlSGFzaCA9IHZvaWQgMDtcbnZhciBoYXNoX2pzXzEgPSByZXF1aXJlKFwiLi9qcy1zaGExL2hhc2guY2pzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5zZWN1cmVIYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoX2pzXzEuaW5zZWN1cmVIYXNoOyB9IH0pO1xudmFyIGhhc2hfanNfMiA9IHJlcXVpcmUoXCIuL2pzLXNoYTI1Ni9oYXNoLmNqc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF9qc18yLnNoYTI1NjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/*\n * [js-sha1]{@link https://github.com/emn178/js-sha1}\n *\n * @version 0.6.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.insecureHash = void 0;\nvar root = typeof window === \"object\" ? window : {};\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha1(sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    this.h0 = 0x67452301;\n    this.h1 = 0xefcdab89;\n    this.h2 = 0x98badcfe;\n    this.h3 = 0x10325476;\n    this.h4 = 0xc3d2e1f0;\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n}\nSha1.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString = typeof message !== \"string\";\n    if (notString && message.constructor === root.ArrayBuffer) {\n        message = new Uint8Array(message);\n    }\n    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha1.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha1.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;\n    var f, j, t, blocks = this.blocks;\n    for (j = 16; j < 80; ++j) {\n        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];\n        blocks[j] = (t << 1) | (t >>> 31);\n    }\n    for (j = 0; j < 20; j += 5) {\n        f = (b & c) | (~b & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1518500249 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (~a & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1518500249 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (~e & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1518500249 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (~d & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1518500249 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (~c & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1518500249 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 40; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e + 1859775393 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d + 1859775393 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c + 1859775393 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b + 1859775393 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a + 1859775393 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 60; j += 5) {\n        f = (b & c) | (b & d) | (c & d);\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 1894007588 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = (a & b) | (a & c) | (b & c);\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 1894007588 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = (e & a) | (e & b) | (a & b);\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 1894007588 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = (d & e) | (d & a) | (e & a);\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 1894007588 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = (c & d) | (c & e) | (d & e);\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 1894007588 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    for (; j < 80; j += 5) {\n        f = b ^ c ^ d;\n        t = (a << 5) | (a >>> 27);\n        e = (t + f + e - 899497514 + blocks[j]) << 0;\n        b = (b << 30) | (b >>> 2);\n        f = a ^ b ^ c;\n        t = (e << 5) | (e >>> 27);\n        d = (t + f + d - 899497514 + blocks[j + 1]) << 0;\n        a = (a << 30) | (a >>> 2);\n        f = e ^ a ^ b;\n        t = (d << 5) | (d >>> 27);\n        c = (t + f + c - 899497514 + blocks[j + 2]) << 0;\n        e = (e << 30) | (e >>> 2);\n        f = d ^ e ^ a;\n        t = (c << 5) | (c >>> 27);\n        b = (t + f + b - 899497514 + blocks[j + 3]) << 0;\n        d = (d << 30) | (d >>> 2);\n        f = c ^ d ^ e;\n        t = (b << 5) | (b >>> 27);\n        a = (t + f + a - 899497514 + blocks[j + 4]) << 0;\n        c = (c << 30) | (c >>> 2);\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n};\nSha1.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return (HEX_CHARS[(h0 >> 28) & 0x0f] +\n        HEX_CHARS[(h0 >> 24) & 0x0f] +\n        HEX_CHARS[(h0 >> 20) & 0x0f] +\n        HEX_CHARS[(h0 >> 16) & 0x0f] +\n        HEX_CHARS[(h0 >> 12) & 0x0f] +\n        HEX_CHARS[(h0 >> 8) & 0x0f] +\n        HEX_CHARS[(h0 >> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >> 28) & 0x0f] +\n        HEX_CHARS[(h1 >> 24) & 0x0f] +\n        HEX_CHARS[(h1 >> 20) & 0x0f] +\n        HEX_CHARS[(h1 >> 16) & 0x0f] +\n        HEX_CHARS[(h1 >> 12) & 0x0f] +\n        HEX_CHARS[(h1 >> 8) & 0x0f] +\n        HEX_CHARS[(h1 >> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >> 28) & 0x0f] +\n        HEX_CHARS[(h2 >> 24) & 0x0f] +\n        HEX_CHARS[(h2 >> 20) & 0x0f] +\n        HEX_CHARS[(h2 >> 16) & 0x0f] +\n        HEX_CHARS[(h2 >> 12) & 0x0f] +\n        HEX_CHARS[(h2 >> 8) & 0x0f] +\n        HEX_CHARS[(h2 >> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >> 28) & 0x0f] +\n        HEX_CHARS[(h3 >> 24) & 0x0f] +\n        HEX_CHARS[(h3 >> 20) & 0x0f] +\n        HEX_CHARS[(h3 >> 16) & 0x0f] +\n        HEX_CHARS[(h3 >> 12) & 0x0f] +\n        HEX_CHARS[(h3 >> 8) & 0x0f] +\n        HEX_CHARS[(h3 >> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >> 28) & 0x0f] +\n        HEX_CHARS[(h4 >> 24) & 0x0f] +\n        HEX_CHARS[(h4 >> 20) & 0x0f] +\n        HEX_CHARS[(h4 >> 16) & 0x0f] +\n        HEX_CHARS[(h4 >> 12) & 0x0f] +\n        HEX_CHARS[(h4 >> 8) & 0x0f] +\n        HEX_CHARS[(h4 >> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f]);\n};\nSha1.prototype.toString = Sha1.prototype.hex;\nSha1.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;\n    return [\n        (h0 >> 24) & 0xff,\n        (h0 >> 16) & 0xff,\n        (h0 >> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >> 24) & 0xff,\n        (h1 >> 16) & 0xff,\n        (h1 >> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >> 24) & 0xff,\n        (h2 >> 16) & 0xff,\n        (h2 >> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >> 24) & 0xff,\n        (h3 >> 16) & 0xff,\n        (h3 >> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >> 24) & 0xff,\n        (h4 >> 16) & 0xff,\n        (h4 >> 8) & 0xff,\n        h4 & 0xff,\n    ];\n};\nSha1.prototype.array = Sha1.prototype.digest;\nSha1.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(20);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    return buffer;\n};\nlet hasLoggedWarning = false;\n/**\n * @deprecated Use `makeDefaultKeyEncoder()` to create a custom key encoder.\n * This function will be removed in a future version.\n */\nconst insecureHash = (message) => {\n    if (!hasLoggedWarning) {\n        console.warn([\n            `The default method for hashing keys is insecure and will be replaced in a future version,`,\n            `but hasn't been replaced yet as to not break existing caches. It's recommended that you use`,\n            `a more secure hashing algorithm to avoid cache poisoning.`,\n            ``,\n            `See this page for more information:`,\n            `|`,\n            `> https://js.langchain.com/docs/troubleshooting/warnings/insecure-cache-algorithm`,\n        ].join(\"\\n\"));\n        hasLoggedWarning = true;\n    }\n    return new Sha1(true).update(message)[\"hex\"]();\n};\nexports.insecureHash = insecureHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMS9oYXNoLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzLXNoYTEvaGFzaC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgdG8gZGVhbCB3aXRoIHBvcnRhYmlsaXR5IGlzc3VlcyB3aXRoIGltcG9ydGluZyBjcnlwdG8gbW9kdWxlXG4vKlxuICogW2pzLXNoYTFde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhMX1cbiAqXG4gKiBAdmVyc2lvbiAwLjYuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluc2VjdXJlSGFzaCA9IHZvaWQgMDtcbnZhciByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHt9O1xudmFyIEhFWF9DSEFSUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpO1xudmFyIEVYVFJBID0gWy0yMTQ3NDgzNjQ4LCA4Mzg4NjA4LCAzMjc2OCwgMTI4XTtcbnZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xudmFyIE9VVFBVVF9UWVBFUyA9IFtcImhleFwiLCBcImFycmF5XCIsIFwiZGlnZXN0XCIsIFwiYXJyYXlCdWZmZXJcIl07XG52YXIgYmxvY2tzID0gW107XG5mdW5jdGlvbiBTaGExKHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgICAgYmxvY2tzWzBdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgfVxuICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5O1xuICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlO1xuICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwO1xuICAgIHRoaXMuYmxvY2sgPSB0aGlzLnN0YXJ0ID0gdGhpcy5ieXRlcyA9IHRoaXMuaEJ5dGVzID0gMDtcbiAgICB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdCA9IHRydWU7XG59XG5TaGExLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIjtcbiAgICBpZiAobm90U3RyaW5nICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IHJvb3QuQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCB8fCAwLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIDB4MTAwMDAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5ieXRlcyArPSBpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHRoaXMuaEJ5dGVzICs9ICh0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NikgPDwgMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5TaGExLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4O1xuICAgIGJsb2Nrc1sxNl0gPSB0aGlzLmJsb2NrO1xuICAgIGJsb2Nrc1tpID4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSAodGhpcy5oQnl0ZXMgPDwgMykgfCAodGhpcy5ieXRlcyA+Pj4gMjkpO1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG59O1xuU2hhMS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IHRoaXMuaDAsIGIgPSB0aGlzLmgxLCBjID0gdGhpcy5oMiwgZCA9IHRoaXMuaDMsIGUgPSB0aGlzLmg0O1xuICAgIHZhciBmLCBqLCB0LCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICBmb3IgKGogPSAxNjsgaiA8IDgwOyArK2opIHtcbiAgICAgICAgdCA9IGJsb2Nrc1tqIC0gM10gXiBibG9ja3NbaiAtIDhdIF4gYmxvY2tzW2ogLSAxNF0gXiBibG9ja3NbaiAtIDE2XTtcbiAgICAgICAgYmxvY2tzW2pdID0gKHQgPDwgMSkgfCAodCA+Pj4gMzEpO1xuICAgIH1cbiAgICBmb3IgKGogPSAwOyBqIDwgMjA7IGogKz0gNSkge1xuICAgICAgICBmID0gKGIgJiBjKSB8ICh+YiAmIGQpO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSArIDE1MTg1MDAyNDkgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSAoYSAmIGIpIHwgKH5hICYgYyk7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZSAmIGEpIHwgKH5lICYgYik7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZCAmIGUpIHwgKH5kICYgYSk7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSAoYyAmIGQpIHwgKH5jICYgZSk7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgNDA7IGogKz0gNSkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSArIDE4NTk3NzUzOTMgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSBhIF4gYiBeIGM7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSBkIF4gZSBeIGE7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSBjIF4gZCBeIGU7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgNjA7IGogKz0gNSkge1xuICAgICAgICBmID0gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSAtIDE4OTQwMDc1ODggKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSAoYSAmIGIpIHwgKGEgJiBjKSB8IChiICYgYyk7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZSAmIGEpIHwgKGUgJiBiKSB8IChhICYgYik7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSAoZCAmIGUpIHwgKGQgJiBhKSB8IChlICYgYSk7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSAoYyAmIGQpIHwgKGMgJiBlKSB8IChkICYgZSk7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIGZvciAoOyBqIDwgODA7IGogKz0gNSkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICB0ID0gKGEgPDwgNSkgfCAoYSA+Pj4gMjcpO1xuICAgICAgICBlID0gKHQgKyBmICsgZSAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IGEgXiBiIF4gYztcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gZSBeIGEgXiBiO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMl0pIDw8IDA7XG4gICAgICAgIGUgPSAoZSA8PCAzMCkgfCAoZSA+Pj4gMik7XG4gICAgICAgIGYgPSBkIF4gZSBeIGE7XG4gICAgICAgIHQgPSAoYyA8PCA1KSB8IChjID4+PiAyNyk7XG4gICAgICAgIGIgPSAodCArIGYgKyBiIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IGMgXiBkIF4gZTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICB0aGlzLmgwID0gKHRoaXMuaDAgKyBhKSA8PCAwO1xuICAgIHRoaXMuaDEgPSAodGhpcy5oMSArIGIpIDw8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgPDwgMDtcbiAgICB0aGlzLmgzID0gKHRoaXMuaDMgKyBkKSA8PCAwO1xuICAgIHRoaXMuaDQgPSAodGhpcy5oNCArIGUpIDw8IDA7XG59O1xuU2hhMS5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQ7XG4gICAgcmV0dXJuIChIRVhfQ0hBUlNbKGgwID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMCAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDEgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gyICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMyAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDQgJiAweDBmXSk7XG59O1xuU2hhMS5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGExLnByb3RvdHlwZS5oZXg7XG5TaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNDtcbiAgICByZXR1cm4gW1xuICAgICAgICAoaDAgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgwID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgwICYgMHhmZixcbiAgICAgICAgKGgxID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDEgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDIgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgyID4+IDgpICYgMHhmZixcbiAgICAgICAgaDIgJiAweGZmLFxuICAgICAgICAoaDMgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgzID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgzICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDQgPj4gOCkgJiAweGZmLFxuICAgICAgICBoNCAmIDB4ZmYsXG4gICAgXTtcbn07XG5TaGExLnByb3RvdHlwZS5hcnJheSA9IFNoYTEucHJvdG90eXBlLmRpZ2VzdDtcblNoYTEucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIwKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5sZXQgaGFzTG9nZ2VkV2FybmluZyA9IGZhbHNlO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYG1ha2VEZWZhdWx0S2V5RW5jb2RlcigpYCB0byBjcmVhdGUgYSBjdXN0b20ga2V5IGVuY29kZXIuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICovXG5jb25zdCBpbnNlY3VyZUhhc2ggPSAobWVzc2FnZSkgPT4ge1xuICAgIGlmICghaGFzTG9nZ2VkV2FybmluZykge1xuICAgICAgICBjb25zb2xlLndhcm4oW1xuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgaGFzaGluZyBrZXlzIGlzIGluc2VjdXJlIGFuZCB3aWxsIGJlIHJlcGxhY2VkIGluIGEgZnV0dXJlIHZlcnNpb24sYCxcbiAgICAgICAgICAgIGBidXQgaGFzbid0IGJlZW4gcmVwbGFjZWQgeWV0IGFzIHRvIG5vdCBicmVhayBleGlzdGluZyBjYWNoZXMuIEl0J3MgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlYCxcbiAgICAgICAgICAgIGBhIG1vcmUgc2VjdXJlIGhhc2hpbmcgYWxnb3JpdGhtIHRvIGF2b2lkIGNhY2hlIHBvaXNvbmluZy5gLFxuICAgICAgICAgICAgYGAsXG4gICAgICAgICAgICBgU2VlIHRoaXMgcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbjpgLFxuICAgICAgICAgICAgYHxgLFxuICAgICAgICAgICAgYOKUlD4gaHR0cHM6Ly9qcy5sYW5nY2hhaW4uY29tL2RvY3MvdHJvdWJsZXNob290aW5nL3dhcm5pbmdzL2luc2VjdXJlLWNhY2hlLWFsZ29yaXRobWAsXG4gICAgICAgIF0uam9pbihcIlxcblwiKSk7XG4gICAgICAgIGhhc0xvZ2dlZFdhcm5pbmcgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNoYTEodHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW1wiaGV4XCJdKCk7XG59O1xuZXhwb3J0cy5pbnNlY3VyZUhhc2ggPSBpbnNlY3VyZUhhc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha1/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// @ts-nocheck\n// Inlined to deal with portability issues with importing crypto module\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha256 = void 0;\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\nvar blocks = [];\nfunction Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n        blocks[0] =\n            blocks[16] =\n                blocks[1] =\n                    blocks[2] =\n                        blocks[3] =\n                            blocks[4] =\n                                blocks[5] =\n                                    blocks[6] =\n                                        blocks[7] =\n                                            blocks[8] =\n                                                blocks[9] =\n                                                    blocks[10] =\n                                                        blocks[11] =\n                                                            blocks[12] =\n                                                                blocks[13] =\n                                                                    blocks[14] =\n                                                                        blocks[15] =\n                                                                            0;\n        this.blocks = blocks;\n    }\n    else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n    if (is224) {\n        this.h0 = 0xc1059ed8;\n        this.h1 = 0x367cd507;\n        this.h2 = 0x3070dd17;\n        this.h3 = 0xf70e5939;\n        this.h4 = 0xffc00b31;\n        this.h5 = 0x68581511;\n        this.h6 = 0x64f98fa7;\n        this.h7 = 0xbefa4fa4;\n    }\n    else {\n        // 256\n        this.h0 = 0x6a09e667;\n        this.h1 = 0xbb67ae85;\n        this.h2 = 0x3c6ef372;\n        this.h3 = 0xa54ff53a;\n        this.h4 = 0x510e527f;\n        this.h5 = 0x9b05688c;\n        this.h6 = 0x1f83d9ab;\n        this.h7 = 0x5be0cd19;\n    }\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n}\nSha256.prototype.update = function (message) {\n    if (this.finalized) {\n        return;\n    }\n    var notString, type = typeof message;\n    if (type !== \"string\") {\n        if (type === \"object\") {\n            if (message === null) {\n                throw new Error(ERROR);\n            }\n            else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n                message = new Uint8Array(message);\n            }\n            else if (!Array.isArray(message)) {\n                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n                    throw new Error(ERROR);\n                }\n            }\n        }\n        else {\n            throw new Error(ERROR);\n        }\n        notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    while (index < length) {\n        if (this.hashed) {\n            this.hashed = false;\n            blocks[0] = this.block;\n            this.block =\n                blocks[16] =\n                    blocks[1] =\n                        blocks[2] =\n                            blocks[3] =\n                                blocks[4] =\n                                    blocks[5] =\n                                        blocks[6] =\n                                            blocks[7] =\n                                                blocks[8] =\n                                                    blocks[9] =\n                                                        blocks[10] =\n                                                            blocks[11] =\n                                                                blocks[12] =\n                                                                    blocks[13] =\n                                                                        blocks[14] =\n                                                                            blocks[15] =\n                                                                                0;\n        }\n        if (notString) {\n            for (i = this.start; index < length && i < 64; ++index) {\n                blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n            }\n        }\n        else {\n            for (i = this.start; index < length && i < 64; ++index) {\n                code = message.charCodeAt(index);\n                if (code < 0x80) {\n                    blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n                }\n                else if (code < 0x800) {\n                    blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else if (code < 0xd800 || code >= 0xe000) {\n                    blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n                else {\n                    code =\n                        0x10000 +\n                            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n                    blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n                    blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n                }\n            }\n        }\n        this.lastByteIndex = i;\n        this.bytes += i - this.start;\n        if (i >= 64) {\n            this.block = blocks[16];\n            this.start = i - 64;\n            this.hash();\n            this.hashed = true;\n        }\n        else {\n            this.start = i;\n        }\n    }\n    if (this.bytes > 4294967295) {\n        this.hBytes += (this.bytes / 4294967296) << 0;\n        this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n};\nSha256.prototype.finalize = function () {\n    if (this.finalized) {\n        return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >>> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n        if (!this.hashed) {\n            this.hash();\n        }\n        blocks[0] = this.block;\n        blocks[16] =\n            blocks[1] =\n                blocks[2] =\n                    blocks[3] =\n                        blocks[4] =\n                            blocks[5] =\n                                blocks[6] =\n                                    blocks[7] =\n                                        blocks[8] =\n                                            blocks[9] =\n                                                blocks[10] =\n                                                    blocks[11] =\n                                                        blocks[12] =\n                                                            blocks[13] =\n                                                                blocks[14] =\n                                                                    blocks[15] =\n                                                                        0;\n    }\n    blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n    blocks[15] = this.bytes << 3;\n    this.hash();\n};\nSha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n    for (j = 16; j < 64; ++j) {\n        // rightrotate\n        t1 = blocks[j - 15];\n        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n        t1 = blocks[j - 2];\n        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n    }\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n        if (this.first) {\n            if (this.is224) {\n                ab = 300032;\n                t1 = blocks[0] - 1413257819;\n                h = (t1 - 150054599) << 0;\n                d = (t1 + 24177077) << 0;\n            }\n            else {\n                ab = 704751109;\n                t1 = blocks[0] - 210244248;\n                h = (t1 - 1521486534) << 0;\n                d = (t1 + 143694565) << 0;\n            }\n            this.first = false;\n        }\n        else {\n            s0 =\n                ((a >>> 2) | (a << 30)) ^\n                    ((a >>> 13) | (a << 19)) ^\n                    ((a >>> 22) | (a << 10));\n            s1 =\n                ((e >>> 6) | (e << 26)) ^\n                    ((e >>> 11) | (e << 21)) ^\n                    ((e >>> 25) | (e << 7));\n            ab = a & b;\n            maj = ab ^ (a & c) ^ bc;\n            ch = (e & f) ^ (~e & g);\n            t1 = h + s1 + ch + K[j] + blocks[j];\n            t2 = s0 + maj;\n            h = (d + t1) << 0;\n            d = (t1 + t2) << 0;\n        }\n        s0 =\n            ((d >>> 2) | (d << 30)) ^\n                ((d >>> 13) | (d << 19)) ^\n                ((d >>> 22) | (d << 10));\n        s1 =\n            ((h >>> 6) | (h << 26)) ^\n                ((h >>> 11) | (h << 21)) ^\n                ((h >>> 25) | (h << 7));\n        da = d & a;\n        maj = da ^ (d & b) ^ ab;\n        ch = (g & h) ^ (~g & e);\n        t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n        t2 = s0 + maj;\n        g = (c + t1) << 0;\n        c = (t1 + t2) << 0;\n        s0 =\n            ((c >>> 2) | (c << 30)) ^\n                ((c >>> 13) | (c << 19)) ^\n                ((c >>> 22) | (c << 10));\n        s1 =\n            ((g >>> 6) | (g << 26)) ^\n                ((g >>> 11) | (g << 21)) ^\n                ((g >>> 25) | (g << 7));\n        cd = c & d;\n        maj = cd ^ (c & a) ^ da;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n        t2 = s0 + maj;\n        f = (b + t1) << 0;\n        b = (t1 + t2) << 0;\n        s0 =\n            ((b >>> 2) | (b << 30)) ^\n                ((b >>> 13) | (b << 19)) ^\n                ((b >>> 22) | (b << 10));\n        s1 =\n            ((f >>> 6) | (f << 26)) ^\n                ((f >>> 11) | (f << 21)) ^\n                ((f >>> 25) | (f << 7));\n        bc = b & c;\n        maj = bc ^ (b & d) ^ cd;\n        ch = (f & g) ^ (~f & h);\n        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n        t2 = s0 + maj;\n        e = (a + t1) << 0;\n        a = (t1 + t2) << 0;\n        this.chromeBugWorkAround = true;\n    }\n    this.h0 = (this.h0 + a) << 0;\n    this.h1 = (this.h1 + b) << 0;\n    this.h2 = (this.h2 + c) << 0;\n    this.h3 = (this.h3 + d) << 0;\n    this.h4 = (this.h4 + e) << 0;\n    this.h5 = (this.h5 + f) << 0;\n    this.h6 = (this.h6 + g) << 0;\n    this.h7 = (this.h7 + h) << 0;\n};\nSha256.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var hex = HEX_CHARS[(h0 >>> 28) & 0x0f] +\n        HEX_CHARS[(h0 >>> 24) & 0x0f] +\n        HEX_CHARS[(h0 >>> 20) & 0x0f] +\n        HEX_CHARS[(h0 >>> 16) & 0x0f] +\n        HEX_CHARS[(h0 >>> 12) & 0x0f] +\n        HEX_CHARS[(h0 >>> 8) & 0x0f] +\n        HEX_CHARS[(h0 >>> 4) & 0x0f] +\n        HEX_CHARS[h0 & 0x0f] +\n        HEX_CHARS[(h1 >>> 28) & 0x0f] +\n        HEX_CHARS[(h1 >>> 24) & 0x0f] +\n        HEX_CHARS[(h1 >>> 20) & 0x0f] +\n        HEX_CHARS[(h1 >>> 16) & 0x0f] +\n        HEX_CHARS[(h1 >>> 12) & 0x0f] +\n        HEX_CHARS[(h1 >>> 8) & 0x0f] +\n        HEX_CHARS[(h1 >>> 4) & 0x0f] +\n        HEX_CHARS[h1 & 0x0f] +\n        HEX_CHARS[(h2 >>> 28) & 0x0f] +\n        HEX_CHARS[(h2 >>> 24) & 0x0f] +\n        HEX_CHARS[(h2 >>> 20) & 0x0f] +\n        HEX_CHARS[(h2 >>> 16) & 0x0f] +\n        HEX_CHARS[(h2 >>> 12) & 0x0f] +\n        HEX_CHARS[(h2 >>> 8) & 0x0f] +\n        HEX_CHARS[(h2 >>> 4) & 0x0f] +\n        HEX_CHARS[h2 & 0x0f] +\n        HEX_CHARS[(h3 >>> 28) & 0x0f] +\n        HEX_CHARS[(h3 >>> 24) & 0x0f] +\n        HEX_CHARS[(h3 >>> 20) & 0x0f] +\n        HEX_CHARS[(h3 >>> 16) & 0x0f] +\n        HEX_CHARS[(h3 >>> 12) & 0x0f] +\n        HEX_CHARS[(h3 >>> 8) & 0x0f] +\n        HEX_CHARS[(h3 >>> 4) & 0x0f] +\n        HEX_CHARS[h3 & 0x0f] +\n        HEX_CHARS[(h4 >>> 28) & 0x0f] +\n        HEX_CHARS[(h4 >>> 24) & 0x0f] +\n        HEX_CHARS[(h4 >>> 20) & 0x0f] +\n        HEX_CHARS[(h4 >>> 16) & 0x0f] +\n        HEX_CHARS[(h4 >>> 12) & 0x0f] +\n        HEX_CHARS[(h4 >>> 8) & 0x0f] +\n        HEX_CHARS[(h4 >>> 4) & 0x0f] +\n        HEX_CHARS[h4 & 0x0f] +\n        HEX_CHARS[(h5 >>> 28) & 0x0f] +\n        HEX_CHARS[(h5 >>> 24) & 0x0f] +\n        HEX_CHARS[(h5 >>> 20) & 0x0f] +\n        HEX_CHARS[(h5 >>> 16) & 0x0f] +\n        HEX_CHARS[(h5 >>> 12) & 0x0f] +\n        HEX_CHARS[(h5 >>> 8) & 0x0f] +\n        HEX_CHARS[(h5 >>> 4) & 0x0f] +\n        HEX_CHARS[h5 & 0x0f] +\n        HEX_CHARS[(h6 >>> 28) & 0x0f] +\n        HEX_CHARS[(h6 >>> 24) & 0x0f] +\n        HEX_CHARS[(h6 >>> 20) & 0x0f] +\n        HEX_CHARS[(h6 >>> 16) & 0x0f] +\n        HEX_CHARS[(h6 >>> 12) & 0x0f] +\n        HEX_CHARS[(h6 >>> 8) & 0x0f] +\n        HEX_CHARS[(h6 >>> 4) & 0x0f] +\n        HEX_CHARS[h6 & 0x0f];\n    if (!this.is224) {\n        hex +=\n            HEX_CHARS[(h7 >>> 28) & 0x0f] +\n                HEX_CHARS[(h7 >>> 24) & 0x0f] +\n                HEX_CHARS[(h7 >>> 20) & 0x0f] +\n                HEX_CHARS[(h7 >>> 16) & 0x0f] +\n                HEX_CHARS[(h7 >>> 12) & 0x0f] +\n                HEX_CHARS[(h7 >>> 8) & 0x0f] +\n                HEX_CHARS[(h7 >>> 4) & 0x0f] +\n                HEX_CHARS[h7 & 0x0f];\n    }\n    return hex;\n};\nSha256.prototype.toString = Sha256.prototype.hex;\nSha256.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;\n    var arr = [\n        (h0 >>> 24) & 0xff,\n        (h0 >>> 16) & 0xff,\n        (h0 >>> 8) & 0xff,\n        h0 & 0xff,\n        (h1 >>> 24) & 0xff,\n        (h1 >>> 16) & 0xff,\n        (h1 >>> 8) & 0xff,\n        h1 & 0xff,\n        (h2 >>> 24) & 0xff,\n        (h2 >>> 16) & 0xff,\n        (h2 >>> 8) & 0xff,\n        h2 & 0xff,\n        (h3 >>> 24) & 0xff,\n        (h3 >>> 16) & 0xff,\n        (h3 >>> 8) & 0xff,\n        h3 & 0xff,\n        (h4 >>> 24) & 0xff,\n        (h4 >>> 16) & 0xff,\n        (h4 >>> 8) & 0xff,\n        h4 & 0xff,\n        (h5 >>> 24) & 0xff,\n        (h5 >>> 16) & 0xff,\n        (h5 >>> 8) & 0xff,\n        h5 & 0xff,\n        (h6 >>> 24) & 0xff,\n        (h6 >>> 16) & 0xff,\n        (h6 >>> 8) & 0xff,\n        h6 & 0xff,\n    ];\n    if (!this.is224) {\n        arr.push((h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, h7 & 0xff);\n    }\n    return arr;\n};\nSha256.prototype.array = Sha256.prototype.digest;\nSha256.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n        dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n};\nconst sha256 = (...strings) => {\n    return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\nexports.sha256 = sha256;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMjU2L2hhc2guY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanMtc2hhMjU2L2hhc2guY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXMgd2l0aCBpbXBvcnRpbmcgY3J5cHRvIG1vZHVsZVxuLyoqXG4gKiBbanMtc2hhMjU2XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Nn1cbiAqXG4gKiBAdmVyc2lvbiAwLjExLjFcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAyNVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG52YXIgSEVYX0NIQVJTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCIuc3BsaXQoXCJcIik7XG52YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xudmFyIFNISUZUID0gWzI0LCAxNiwgOCwgMF07XG52YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLFxuICAgIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCwgMHhlNDliNjljMSwgMHhlZmJlNDc4NixcbiAgICAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsXG4gICAgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NywgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LCAweGEyYmZlOGExLCAweGE4MWE2NjRiLFxuICAgIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSxcbiAgICAweDViOWNjYTRmLCAweDY4MmU2ZmYzLCAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjIsXG5dO1xudmFyIE9VVFBVVF9UWVBFUyA9IFtcImhleFwiLCBcImFycmF5XCIsIFwiZGlnZXN0XCIsIFwiYXJyYXlCdWZmZXJcIl07XG52YXIgYmxvY2tzID0gW107XG5mdW5jdGlvbiBTaGEyNTYoaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgICAgYmxvY2tzWzBdID1cbiAgICAgICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgfVxuICAgIGlmIChpczIyNCkge1xuICAgICAgICB0aGlzLmgwID0gMHhjMTA1OWVkODtcbiAgICAgICAgdGhpcy5oMSA9IDB4MzY3Y2Q1MDc7XG4gICAgICAgIHRoaXMuaDIgPSAweDMwNzBkZDE3O1xuICAgICAgICB0aGlzLmgzID0gMHhmNzBlNTkzOTtcbiAgICAgICAgdGhpcy5oNCA9IDB4ZmZjMDBiMzE7XG4gICAgICAgIHRoaXMuaDUgPSAweDY4NTgxNTExO1xuICAgICAgICB0aGlzLmg2ID0gMHg2NGY5OGZhNztcbiAgICAgICAgdGhpcy5oNyA9IDB4YmVmYTRmYTQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyAyNTZcbiAgICAgICAgdGhpcy5oMCA9IDB4NmEwOWU2Njc7XG4gICAgICAgIHRoaXMuaDEgPSAweGJiNjdhZTg1O1xuICAgICAgICB0aGlzLmgyID0gMHgzYzZlZjM3MjtcbiAgICAgICAgdGhpcy5oMyA9IDB4YTU0ZmY1M2E7XG4gICAgICAgIHRoaXMuaDQgPSAweDUxMGU1MjdmO1xuICAgICAgICB0aGlzLmg1ID0gMHg5YjA1Njg4YztcbiAgICAgICAgdGhpcy5oNiA9IDB4MWY4M2Q5YWI7XG4gICAgICAgIHRoaXMuaDcgPSAweDViZTBjZDE5O1xuICAgIH1cbiAgICB0aGlzLmJsb2NrID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDA7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuaXMyMjQgPSBpczIyNDtcbn1cblNoYTI1Ni5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s3XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+Pj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAweDEwMDAwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+Pj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+Pj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+Pj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaSAtIDY0O1xuICAgICAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgdGhpcy5oQnl0ZXMgKz0gKHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2KSA8PCAwO1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMTZdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+Pj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICB9XG4gICAgYmxvY2tzWzE0XSA9ICh0aGlzLmhCeXRlcyA8PCAzKSB8ICh0aGlzLmJ5dGVzID4+PiAyOSk7XG4gICAgYmxvY2tzWzE1XSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbn07XG5TaGEyNTYucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmgwLCBiID0gdGhpcy5oMSwgYyA9IHRoaXMuaDIsIGQgPSB0aGlzLmgzLCBlID0gdGhpcy5oNCwgZiA9IHRoaXMuaDUsIGcgPSB0aGlzLmg2LCBoID0gdGhpcy5oNywgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGosIHMwLCBzMSwgbWFqLCB0MSwgdDIsIGNoLCBhYiwgZGEsIGNkLCBiYztcbiAgICBmb3IgKGogPSAxNjsgaiA8IDY0OyArK2opIHtcbiAgICAgICAgLy8gcmlnaHRyb3RhdGVcbiAgICAgICAgdDEgPSBibG9ja3NbaiAtIDE1XTtcbiAgICAgICAgczAgPSAoKHQxID4+PiA3KSB8ICh0MSA8PCAyNSkpIF4gKCh0MSA+Pj4gMTgpIHwgKHQxIDw8IDE0KSkgXiAodDEgPj4+IDMpO1xuICAgICAgICB0MSA9IGJsb2Nrc1tqIC0gMl07XG4gICAgICAgIHMxID0gKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXiAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeICh0MSA+Pj4gMTApO1xuICAgICAgICBibG9ja3Nbal0gPSAoYmxvY2tzW2ogLSAxNl0gKyBzMCArIGJsb2Nrc1tqIC0gN10gKyBzMSkgPDwgMDtcbiAgICB9XG4gICAgYmMgPSBiICYgYztcbiAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGogKz0gNCkge1xuICAgICAgICBpZiAodGhpcy5maXJzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMyMjQpIHtcbiAgICAgICAgICAgICAgICBhYiA9IDMwMDAzMjtcbiAgICAgICAgICAgICAgICB0MSA9IGJsb2Nrc1swXSAtIDE0MTMyNTc4MTk7XG4gICAgICAgICAgICAgICAgaCA9ICh0MSAtIDE1MDA1NDU5OSkgPDwgMDtcbiAgICAgICAgICAgICAgICBkID0gKHQxICsgMjQxNzcwNzcpIDw8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhYiA9IDcwNDc1MTEwOTtcbiAgICAgICAgICAgICAgICB0MSA9IGJsb2Nrc1swXSAtIDIxMDI0NDI0ODtcbiAgICAgICAgICAgICAgICBoID0gKHQxIC0gMTUyMTQ4NjUzNCkgPDwgMDtcbiAgICAgICAgICAgICAgICBkID0gKHQxICsgMTQzNjk0NTY1KSA8PCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczAgPVxuICAgICAgICAgICAgICAgICgoYSA+Pj4gMikgfCAoYSA8PCAzMCkpIF5cbiAgICAgICAgICAgICAgICAgICAgKChhID4+PiAxMykgfCAoYSA8PCAxOSkpIF5cbiAgICAgICAgICAgICAgICAgICAgKChhID4+PiAyMikgfCAoYSA8PCAxMCkpO1xuICAgICAgICAgICAgczEgPVxuICAgICAgICAgICAgICAgICgoZSA+Pj4gNikgfCAoZSA8PCAyNikpIF5cbiAgICAgICAgICAgICAgICAgICAgKChlID4+PiAxMSkgfCAoZSA8PCAyMSkpIF5cbiAgICAgICAgICAgICAgICAgICAgKChlID4+PiAyNSkgfCAoZSA8PCA3KSk7XG4gICAgICAgICAgICBhYiA9IGEgJiBiO1xuICAgICAgICAgICAgbWFqID0gYWIgXiAoYSAmIGMpIF4gYmM7XG4gICAgICAgICAgICBjaCA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgICAgICAgIHQxID0gaCArIHMxICsgY2ggKyBLW2pdICsgYmxvY2tzW2pdO1xuICAgICAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgICAgIGggPSAoZCArIHQxKSA8PCAwO1xuICAgICAgICAgICAgZCA9ICh0MSArIHQyKSA8PCAwO1xuICAgICAgICB9XG4gICAgICAgIHMwID1cbiAgICAgICAgICAgICgoZCA+Pj4gMikgfCAoZCA8PCAzMCkpIF5cbiAgICAgICAgICAgICAgICAoKGQgPj4+IDEzKSB8IChkIDw8IDE5KSkgXlxuICAgICAgICAgICAgICAgICgoZCA+Pj4gMjIpIHwgKGQgPDwgMTApKTtcbiAgICAgICAgczEgPVxuICAgICAgICAgICAgKChoID4+PiA2KSB8IChoIDw8IDI2KSkgXlxuICAgICAgICAgICAgICAgICgoaCA+Pj4gMTEpIHwgKGggPDwgMjEpKSBeXG4gICAgICAgICAgICAgICAgKChoID4+PiAyNSkgfCAoaCA8PCA3KSk7XG4gICAgICAgIGRhID0gZCAmIGE7XG4gICAgICAgIG1haiA9IGRhIF4gKGQgJiBiKSBeIGFiO1xuICAgICAgICBjaCA9IChnICYgaCkgXiAofmcgJiBlKTtcbiAgICAgICAgdDEgPSBmICsgczEgKyBjaCArIEtbaiArIDFdICsgYmxvY2tzW2ogKyAxXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgZyA9IChjICsgdDEpIDw8IDA7XG4gICAgICAgIGMgPSAodDEgKyB0MikgPDwgMDtcbiAgICAgICAgczAgPVxuICAgICAgICAgICAgKChjID4+PiAyKSB8IChjIDw8IDMwKSkgXlxuICAgICAgICAgICAgICAgICgoYyA+Pj4gMTMpIHwgKGMgPDwgMTkpKSBeXG4gICAgICAgICAgICAgICAgKChjID4+PiAyMikgfCAoYyA8PCAxMCkpO1xuICAgICAgICBzMSA9XG4gICAgICAgICAgICAoKGcgPj4+IDYpIHwgKGcgPDwgMjYpKSBeXG4gICAgICAgICAgICAgICAgKChnID4+PiAxMSkgfCAoZyA8PCAyMSkpIF5cbiAgICAgICAgICAgICAgICAoKGcgPj4+IDI1KSB8IChnIDw8IDcpKTtcbiAgICAgICAgY2QgPSBjICYgZDtcbiAgICAgICAgbWFqID0gY2QgXiAoYyAmIGEpIF4gZGE7XG4gICAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgICB0MSA9IGUgKyBzMSArIGNoICsgS1tqICsgMl0gKyBibG9ja3NbaiArIDJdO1xuICAgICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgICBmID0gKGIgKyB0MSkgPDwgMDtcbiAgICAgICAgYiA9ICh0MSArIHQyKSA8PCAwO1xuICAgICAgICBzMCA9XG4gICAgICAgICAgICAoKGIgPj4+IDIpIHwgKGIgPDwgMzApKSBeXG4gICAgICAgICAgICAgICAgKChiID4+PiAxMykgfCAoYiA8PCAxOSkpIF5cbiAgICAgICAgICAgICAgICAoKGIgPj4+IDIyKSB8IChiIDw8IDEwKSk7XG4gICAgICAgIHMxID1cbiAgICAgICAgICAgICgoZiA+Pj4gNikgfCAoZiA8PCAyNikpIF5cbiAgICAgICAgICAgICAgICAoKGYgPj4+IDExKSB8IChmIDw8IDIxKSkgXlxuICAgICAgICAgICAgICAgICgoZiA+Pj4gMjUpIHwgKGYgPDwgNykpO1xuICAgICAgICBiYyA9IGIgJiBjO1xuICAgICAgICBtYWogPSBiYyBeIChiICYgZCkgXiBjZDtcbiAgICAgICAgY2ggPSAoZiAmIGcpIF4gKH5mICYgaCk7XG4gICAgICAgIHQxID0gZSArIHMxICsgY2ggKyBLW2ogKyAzXSArIGJsb2Nrc1tqICsgM107XG4gICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgIGUgPSAoYSArIHQxKSA8PCAwO1xuICAgICAgICBhID0gKHQxICsgdDIpIDw8IDA7XG4gICAgICAgIHRoaXMuY2hyb21lQnVnV29ya0Fyb3VuZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaDAgPSAodGhpcy5oMCArIGEpIDw8IDA7XG4gICAgdGhpcy5oMSA9ICh0aGlzLmgxICsgYikgPDwgMDtcbiAgICB0aGlzLmgyID0gKHRoaXMuaDIgKyBjKSA8PCAwO1xuICAgIHRoaXMuaDMgPSAodGhpcy5oMyArIGQpIDw8IDA7XG4gICAgdGhpcy5oNCA9ICh0aGlzLmg0ICsgZSkgPDwgMDtcbiAgICB0aGlzLmg1ID0gKHRoaXMuaDUgKyBmKSA8PCAwO1xuICAgIHRoaXMuaDYgPSAodGhpcy5oNiArIGcpIDw8IDA7XG4gICAgdGhpcy5oNyA9ICh0aGlzLmg3ICsgaCkgPDwgMDtcbn07XG5TaGEyNTYucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuICAgIHZhciBoZXggPSBIRVhfQ0hBUlNbKGgwID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDAgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gyICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDMgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+Pj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toNCAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNSA+Pj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDUgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg1ID4+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2g1ICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg2ID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNiA+Pj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDYgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDYgJiAweDBmXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgICAgaGV4ICs9XG4gICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiAyOCkgJiAweDBmXSArXG4gICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMjQpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+PiAxNikgJiAweDBmXSArXG4gICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhoNyA+Pj4gMTIpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDgpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1soaDcgPj4+IDQpICYgMHgwZl0gK1xuICAgICAgICAgICAgICAgIEhFWF9DSEFSU1toNyAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufTtcblNoYTI1Ni5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGEyNTYucHJvdG90eXBlLmhleDtcblNoYTI1Ni5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSwgaDYgPSB0aGlzLmg2LCBoNyA9IHRoaXMuaDc7XG4gICAgdmFyIGFyciA9IFtcbiAgICAgICAgKGgwID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDAgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMCA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoMCAmIDB4ZmYsXG4gICAgICAgIChoMSA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgxID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDEgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDEgJiAweGZmLFxuICAgICAgICAoaDIgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgyID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgyICYgMHhmZixcbiAgICAgICAgKGgzID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDMgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoMyAmIDB4ZmYsXG4gICAgICAgIChoNCA+Pj4gMjQpICYgMHhmZixcbiAgICAgICAgKGg0ID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDQgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaDQgJiAweGZmLFxuICAgICAgICAoaDUgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoNSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGg1ID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGg1ICYgMHhmZixcbiAgICAgICAgKGg2ID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDYgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoNiA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoNiAmIDB4ZmYsXG4gICAgXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgICAgYXJyLnB1c2goKGg3ID4+PiAyNCkgJiAweGZmLCAoaDcgPj4+IDE2KSAmIDB4ZmYsIChoNyA+Pj4gOCkgJiAweGZmLCBoNyAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblNoYTI1Ni5wcm90b3R5cGUuYXJyYXkgPSBTaGEyNTYucHJvdG90eXBlLmRpZ2VzdDtcblNoYTI1Ni5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5pczIyNCA/IDI4IDogMzIpO1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMyk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjAsIHRoaXMuaDUpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigyNCwgdGhpcy5oNik7XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICAgIGRhdGFWaWV3LnNldFVpbnQzMigyOCwgdGhpcy5oNyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59O1xuY29uc3Qgc2hhMjU2ID0gKC4uLnN0cmluZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFNoYTI1NihmYWxzZSwgdHJ1ZSkudXBkYXRlKHN0cmluZ3Muam9pbihcIlwiKSkuaGV4KCk7XG59O1xuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/js-sha256/hash.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseJsonMarkdown = parseJsonMarkdown;\nexports.parsePartialJson = parsePartialJson;\nfunction parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const firstFenceIndex = s.indexOf(\"```\");\n    if (firstFenceIndex === -1) {\n        return parser(s);\n    }\n    let contentAfterFence = s.substring(firstFenceIndex + 3);\n    if (contentAfterFence.startsWith(\"json\\n\")) {\n        contentAfterFence = contentAfterFence.substring(5);\n    }\n    else if (contentAfterFence.startsWith(\"json\")) {\n        contentAfterFence = contentAfterFence.substring(4);\n    }\n    else if (contentAfterFence.startsWith(\"\\n\")) {\n        contentAfterFence = contentAfterFence.substring(1);\n    }\n    const closingFenceIndex = contentAfterFence.indexOf(\"```\");\n    let finalContent = contentAfterFence;\n    if (closingFenceIndex !== -1) {\n        finalContent = contentAfterFence.substring(0, closingFenceIndex);\n    }\n    return parser(finalContent.trim());\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nfunction parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2pzb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUpzb25NYXJrZG93biA9IHBhcnNlSnNvbk1hcmtkb3duO1xuZXhwb3J0cy5wYXJzZVBhcnRpYWxKc29uID0gcGFyc2VQYXJ0aWFsSnNvbjtcbmZ1bmN0aW9uIHBhcnNlSnNvbk1hcmtkb3duKHMsIHBhcnNlciA9IHBhcnNlUGFydGlhbEpzb24pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBzID0gcy50cmltKCk7XG4gICAgY29uc3QgZmlyc3RGZW5jZUluZGV4ID0gcy5pbmRleE9mKFwiYGBgXCIpO1xuICAgIGlmIChmaXJzdEZlbmNlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIocyk7XG4gICAgfVxuICAgIGxldCBjb250ZW50QWZ0ZXJGZW5jZSA9IHMuc3Vic3RyaW5nKGZpcnN0RmVuY2VJbmRleCArIDMpO1xuICAgIGlmIChjb250ZW50QWZ0ZXJGZW5jZS5zdGFydHNXaXRoKFwianNvblxcblwiKSkge1xuICAgICAgICBjb250ZW50QWZ0ZXJGZW5jZSA9IGNvbnRlbnRBZnRlckZlbmNlLnN1YnN0cmluZyg1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudEFmdGVyRmVuY2Uuc3RhcnRzV2l0aChcImpzb25cIikpIHtcbiAgICAgICAgY29udGVudEFmdGVyRmVuY2UgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnRBZnRlckZlbmNlLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgY29udGVudEFmdGVyRmVuY2UgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NpbmdGZW5jZUluZGV4ID0gY29udGVudEFmdGVyRmVuY2UuaW5kZXhPZihcImBgYFwiKTtcbiAgICBsZXQgZmluYWxDb250ZW50ID0gY29udGVudEFmdGVyRmVuY2U7XG4gICAgaWYgKGNsb3NpbmdGZW5jZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBmaW5hbENvbnRlbnQgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoMCwgY2xvc2luZ0ZlbmNlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyKGZpbmFsQ29udGVudC50cmltKCkpO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LaWxsaWFuTHVjYXMvb3Blbi1pbnRlcnByZXRlci9ibG9iL21haW4vaW50ZXJwcmV0ZXIvY29yZS9sbG0vdXRpbHMvcGFyc2VfcGFydGlhbF9qc29uLnB5XG4vLyBNSVQgTGljZW5zZVxuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihzKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCwgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgZmFpbHVyZS5cbiAgICBpZiAodHlwZW9mIHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIHN0cmluZyBhcy1pcy5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFBhc3NcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXG4gICAgbGV0IG5ld19zID0gXCJcIjtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgLy8gUHJvY2VzcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIG9uZSBhdCBhIHRpbWUuXG4gICAgZm9yIChsZXQgY2hhciBvZiBzKSB7XG4gICAgICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJcXG5cIiAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGNoYXIgPSBcIlxcXFxuXCI7IC8vIFJlcGxhY2UgdGhlIG5ld2xpbmUgY2hhcmFjdGVyIHdpdGggdGhlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBpc0luc2lkZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIn1cIiB8fCBjaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc21hdGNoZWQgY2xvc2luZyBjaGFyYWN0ZXI7IHRoZSBpbnB1dCBpcyBtYWxmb3JtZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgdGhlIHByb2Nlc3NlZCBjaGFyYWN0ZXIgdG8gdGhlIG5ldyBzdHJpbmcuXG4gICAgICAgIG5ld19zICs9IGNoYXI7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIHN0aWxsIGluc2lkZSBhIHN0cmluZyBhdCB0aGUgZW5kIG9mIHByb2Nlc3NpbmcsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9zZSB0aGUgc3RyaW5nLlxuICAgIGlmIChpc0luc2lkZVN0cmluZykge1xuICAgICAgICBuZXdfcyArPSAnXCInO1xuICAgIH1cbiAgICAvLyBDbG9zZSBhbnkgcmVtYWluaW5nIG9wZW4gc3RydWN0dXJlcyBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBvcGVuZWQuXG4gICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIG5ld19zICs9IHN0YWNrW2ldO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBtb2RpZmllZCBzdHJpbmcgYXMgSlNPTi5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShuZXdfcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBjYW4ndCBwYXJzZSB0aGUgc3RyaW5nIGFzIEpTT04sIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_patch.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.applyPatch = exports.compare = void 0;\nvar index_js_1 = __webpack_require__(/*! ./fast-json-patch/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/fast-json-patch/index.cjs\");\nObject.defineProperty(exports, \"compare\", ({ enumerable: true, get: function () { return index_js_1.compare; } }));\nObject.defineProperty(exports, \"applyPatch\", ({ enumerable: true, get: function () { return index_js_1.applyPatch; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9wYXRjaC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZUFBZTtBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDdEQsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9wYXRjaC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBleHBvcnRzLmNvbXBhcmUgPSB2b2lkIDA7XG52YXIgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuL2Zhc3QtanNvbi1wYXRjaC9pbmRleC5janNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wYXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmNvbXBhcmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcHBseVBhdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmFwcGx5UGF0Y2g7IH0gfSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_patch.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/json_schema.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = exports.deepCompareStrict = void 0;\nexports.toJsonSchema = toJsonSchema;\nexports.validatesOnlyStrings = validatesOnlyStrings;\nconst core_1 = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/index.cjs\");\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nconst json_schema_1 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nconst zod_js_1 = __webpack_require__(/*! ./types/zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\");\nvar json_schema_2 = __webpack_require__(/*! @cfworker/json-schema */ \"(rsc)/./node_modules/@cfworker/json-schema/dist/commonjs/index.js\");\nObject.defineProperty(exports, \"deepCompareStrict\", ({ enumerable: true, get: function () { return json_schema_2.deepCompareStrict; } }));\nObject.defineProperty(exports, \"Validator\", ({ enumerable: true, get: function () { return json_schema_2.Validator; } }));\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nfunction toJsonSchema(schema) {\n    if ((0, zod_js_1.isZodSchemaV4)(schema)) {\n        const inputSchema = (0, zod_js_1.interopZodTransformInputSchema)(schema, true);\n        if ((0, zod_js_1.isZodObjectV4)(inputSchema)) {\n            const strictSchema = (0, zod_js_1.interopZodObjectStrict)(inputSchema, true);\n            return (0, core_1.toJSONSchema)(strictSchema);\n        }\n        else {\n            return (0, core_1.toJSONSchema)(schema);\n        }\n    }\n    if ((0, zod_js_1.isZodSchemaV3)(schema)) {\n        return (0, zod_to_json_schema_1.zodToJsonSchema)(schema);\n    }\n    return schema;\n}\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nfunction validatesOnlyStrings(schema) {\n    // Null, undefined, or empty schema\n    if (!schema ||\n        typeof schema !== \"object\" ||\n        Object.keys(schema).length === 0 ||\n        Array.isArray(schema)) {\n        return false; // Validates anything, not just strings\n    }\n    // Explicit type constraint\n    if (\"type\" in schema) {\n        if (typeof schema.type === \"string\") {\n            return schema.type === \"string\";\n        }\n        if (Array.isArray(schema.type)) {\n            // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n            // \"string\", \"string\", ...]` but we're not here to judge\n            return schema.type.every((t) => t === \"string\");\n        }\n        return false; // Invalid or non-string type\n    }\n    // Enum with only string values\n    if (\"enum\" in schema) {\n        return (Array.isArray(schema.enum) &&\n            schema.enum.length > 0 &&\n            schema.enum.every((val) => typeof val === \"string\"));\n    }\n    // String constant\n    if (\"const\" in schema) {\n        return typeof schema.const === \"string\";\n    }\n    // Schema combinations\n    if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n        // If any subschema validates only strings, then the overall schema validates only strings\n        return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n    }\n    if ((\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n        (\"oneOf\" in schema && Array.isArray(schema.oneOf))) {\n        const subschemas = (\"anyOf\" in schema ? schema.anyOf : schema.oneOf);\n        // All subschemas must validate only strings\n        return (subschemas.length > 0 &&\n            subschemas.every((subschema) => validatesOnlyStrings(subschema)));\n    }\n    // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n    if (\"not\" in schema) {\n        return false; // The not case can validate non-strings\n    }\n    if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n        const ref = schema.$ref;\n        const resolved = (0, json_schema_1.dereference)(schema);\n        if (resolved[ref]) {\n            return validatesOnlyStrings(resolved[ref]);\n        }\n        return false;\n    }\n    // ignore recursive refs and other cases where type is omitted for now\n    // ignore other cases for now where type is omitted\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbl9zY2hlbWEuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHlCQUF5QjtBQUM3QyxvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHNGQUFpQjtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDbkQscURBQW9ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3ZJLDZDQUE0QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qc29uX3NjaGVtYS5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRvciA9IGV4cG9ydHMuZGVlcENvbXBhcmVTdHJpY3QgPSB2b2lkIDA7XG5leHBvcnRzLnRvSnNvblNjaGVtYSA9IHRvSnNvblNjaGVtYTtcbmV4cG9ydHMudmFsaWRhdGVzT25seVN0cmluZ3MgPSB2YWxpZGF0ZXNPbmx5U3RyaW5ncztcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJ6b2QvdjQvY29yZVwiKTtcbmNvbnN0IHpvZF90b19qc29uX3NjaGVtYV8xID0gcmVxdWlyZShcInpvZC10by1qc29uLXNjaGVtYVwiKTtcbmNvbnN0IGpzb25fc2NoZW1hXzEgPSByZXF1aXJlKFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCIpO1xuY29uc3Qgem9kX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlcy96b2QuY2pzXCIpO1xudmFyIGpzb25fc2NoZW1hXzIgPSByZXF1aXJlKFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVlcENvbXBhcmVTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fc2NoZW1hXzIuZGVlcENvbXBhcmVTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fc2NoZW1hXzIuVmFsaWRhdG9yOyB9IH0pO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFpvZCBzY2hlbWEgb3IgSlNPTiBzY2hlbWEgdG8gYSBKU09OIHNjaGVtYS5cbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHNjaGVtYS5cbiAqL1xuZnVuY3Rpb24gdG9Kc29uU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmICgoMCwgem9kX2pzXzEuaXNab2RTY2hlbWFWNCkoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBpbnB1dFNjaGVtYSA9ICgwLCB6b2RfanNfMS5pbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEpKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIGlmICgoMCwgem9kX2pzXzEuaXNab2RPYmplY3RWNCkoaW5wdXRTY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpY3RTY2hlbWEgPSAoMCwgem9kX2pzXzEuaW50ZXJvcFpvZE9iamVjdFN0cmljdCkoaW5wdXRTY2hlbWEsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlXzEudG9KU09OU2NoZW1hKShzdHJpY3RTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb3JlXzEudG9KU09OU2NoZW1hKShzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgoMCwgem9kX2pzXzEuaXNab2RTY2hlbWFWMykoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gKDAsIHpvZF90b19qc29uX3NjaGVtYV8xLnpvZFRvSnNvblNjaGVtYSkoc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGlmIGEgSlNPTiBzY2hlbWEgdmFsaWRhdGVzIG9ubHkgc3RyaW5ncy4gTWF5IHJldHVybiBmYWxzZSBuZWdhdGl2ZXMgaW4gc29tZSBlZGdlIGNhc2VzXG4gKiAobGlrZSByZWN1cnNpdmUgb3IgdW5yZXNvbHZhYmxlIHJlZnMpLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzY2hlbWEgdmFsaWRhdGVzIG9ubHkgc3RyaW5ncywgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlc09ubHlTdHJpbmdzKHNjaGVtYSkge1xuICAgIC8vIE51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHkgc2NoZW1hXG4gICAgaWYgKCFzY2hlbWEgfHxcbiAgICAgICAgdHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBWYWxpZGF0ZXMgYW55dGhpbmcsIG5vdCBqdXN0IHN0cmluZ3NcbiAgICB9XG4gICAgLy8gRXhwbGljaXQgdHlwZSBjb25zdHJhaW50XG4gICAgaWYgKFwidHlwZVwiIGluIHNjaGVtYSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyBub3Qgc3VyZSB3aHkgc29tZW9uZSB3b3VsZCBkbyBgXCJ0eXBlXCI6IFtcInN0cmluZ1wiXWAgb3IgZXNwZWNpYWxseSBgXCJ0eXBlXCI6IFtcInN0cmluZ1wiLFxuICAgICAgICAgICAgLy8gXCJzdHJpbmdcIiwgXCJzdHJpbmdcIiwgLi4uXWAgYnV0IHdlJ3JlIG5vdCBoZXJlIHRvIGp1ZGdlXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnR5cGUuZXZlcnkoKHQpID0+IHQgPT09IFwic3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBvciBub24tc3RyaW5nIHR5cGVcbiAgICB9XG4gICAgLy8gRW51bSB3aXRoIG9ubHkgc3RyaW5nIHZhbHVlc1xuICAgIGlmIChcImVudW1cIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSAmJlxuICAgICAgICAgICAgc2NoZW1hLmVudW0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgc2NoZW1hLmVudW0uZXZlcnkoKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikpO1xuICAgIH1cbiAgICAvLyBTdHJpbmcgY29uc3RhbnRcbiAgICBpZiAoXCJjb25zdFwiIGluIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgLy8gU2NoZW1hIGNvbWJpbmF0aW9uc1xuICAgIGlmIChcImFsbE9mXCIgaW4gc2NoZW1hICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICAvLyBJZiBhbnkgc3Vic2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MsIHRoZW4gdGhlIG92ZXJhbGwgc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5zb21lKChzdWJzY2hlbWEpID0+IHZhbGlkYXRlc09ubHlTdHJpbmdzKHN1YnNjaGVtYSkpO1xuICAgIH1cbiAgICBpZiAoKFwiYW55T2ZcIiBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB8fFxuICAgICAgICAoXCJvbmVPZlwiIGluIHNjaGVtYSAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYXMgPSAoXCJhbnlPZlwiIGluIHNjaGVtYSA/IHNjaGVtYS5hbnlPZiA6IHNjaGVtYS5vbmVPZik7XG4gICAgICAgIC8vIEFsbCBzdWJzY2hlbWFzIG11c3QgdmFsaWRhdGUgb25seSBzdHJpbmdzXG4gICAgICAgIHJldHVybiAoc3Vic2NoZW1hcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBzdWJzY2hlbWFzLmV2ZXJ5KChzdWJzY2hlbWEpID0+IHZhbGlkYXRlc09ubHlTdHJpbmdzKHN1YnNjaGVtYSkpKTtcbiAgICB9XG4gICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHRyeSBvbiB0aGlzIG9uZSwgaXQncyB0b28gY29tcGxleCAtIHdlIGp1c3QgYXNzdW1lIGlmIGl0IGhhcyBhIFwibm90XCIga2V5IGFuZCBoYXNuJ3QgbWF0Y2hlZCBvbmUgb2YgdGhlIGFib3ZlIGNoZWNrcywgaXQncyBub3QgYSBzdHJpbmcgc2NoZW1hLlxuICAgIGlmIChcIm5vdFwiIGluIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBub3QgY2FzZSBjYW4gdmFsaWRhdGUgbm9uLXN0cmluZ3NcbiAgICB9XG4gICAgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hLiRyZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRyZWY7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gKDAsIGpzb25fc2NoZW1hXzEuZGVyZWZlcmVuY2UpKHNjaGVtYSk7XG4gICAgICAgIGlmIChyZXNvbHZlZFtyZWZdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVzT25seVN0cmluZ3MocmVzb2x2ZWRbcmVmXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgcmVjdXJzaXZlIHJlZnMgYW5kIG90aGVyIGNhc2VzIHdoZXJlIHR5cGUgaXMgb21pdHRlZCBmb3Igbm93XG4gICAgLy8gaWdub3JlIG90aGVyIGNhc2VzIGZvciBub3cgd2hlcmUgdHlwZSBpcyBvbWl0dGVkXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sax = void 0;\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\nconst initializeSax = function () {\n    const sax = {};\n    sax.parser = function (strict, opt) {\n        return new SAXParser(strict, opt);\n    };\n    sax.SAXParser = SAXParser;\n    sax.SAXStream = SAXStream;\n    sax.createStream = createStream;\n    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n    // since that's the earliest that a buffer overrun could occur.  This way, checks are\n    // as rare as required, but as often as necessary to ensure never crossing this bound.\n    // Furthermore, buffers are only tested at most once per write(), so passing a very\n    // large string into write() might have undesirable effects, but this is manageable by\n    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n    // edge case, result in creating at most one complete copy of the string passed in.\n    // Set to Infinity to have unlimited buffers.\n    sax.MAX_BUFFER_LENGTH = 64 * 1024;\n    const buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\",\n    ];\n    sax.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\",\n    ];\n    function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n            return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities\n            ? Object.create(sax.XML_ENTITIES)\n            : Object.create(sax.ENTITIES);\n        parser.attribList = [];\n        // namespaces form a prototype chain.\n        // it always points at the current tag,\n        // which protos to its parent tag.\n        if (parser.opt.xmlns) {\n            parser.ns = Object.create(rootNS);\n        }\n        // mostly just for error reporting\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n            parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n    }\n    if (!Object.create) {\n        Object.create = function (o) {\n            function F() { }\n            F.prototype = o;\n            var newf = new F();\n            return newf;\n        };\n    }\n    if (!Object.keys) {\n        Object.keys = function (o) {\n            var a = [];\n            for (var i in o)\n                if (o.hasOwnProperty(i))\n                    a.push(i);\n            return a;\n        };\n    }\n    function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            var len = parser[buffers[i]].length;\n            if (len > maxAllowed) {\n                // Text/cdata nodes can get big, and since they're buffered,\n                // we can get here under normal conditions.\n                // Avoid issues by emitting the text node now,\n                // so at least it won't get any bigger.\n                switch (buffers[i]) {\n                    case \"textNode\":\n                        closeText(parser);\n                        break;\n                    case \"cdata\":\n                        emitNode(parser, \"oncdata\", parser.cdata);\n                        parser.cdata = \"\";\n                        break;\n                    case \"script\":\n                        emitNode(parser, \"onscript\", parser.script);\n                        parser.script = \"\";\n                        break;\n                    default:\n                        error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n                }\n            }\n            maxActual = Math.max(maxActual, len);\n        }\n        // schedule the next check for the earliest possible buffer overrun.\n        var m = sax.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n    }\n    function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n            parser[buffers[i]] = \"\";\n        }\n    }\n    function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n    }\n    SAXParser.prototype = {\n        end: function () {\n            end(this);\n        },\n        write: write,\n        resume: function () {\n            this.error = null;\n            return this;\n        },\n        close: function () {\n            return this.write(null);\n        },\n        flush: function () {\n            flushBuffers(this);\n        },\n    };\n    var Stream = ReadableStream;\n    if (!Stream)\n        Stream = function () { };\n    var streamWraps = sax.EVENTS.filter(function (ev) {\n        return ev !== \"error\" && ev !== \"end\";\n    });\n    function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n    }\n    function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n            return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function () {\n            me.emit(\"end\");\n        };\n        this._parser.onerror = function (er) {\n            me.emit(\"error\", er);\n            // if didn't throw, then means error was handled.\n            // go ahead and clear error, so we can write again.\n            me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function (ev) {\n            Object.defineProperty(me, \"on\" + ev, {\n                get: function () {\n                    return me._parser[\"on\" + ev];\n                },\n                set: function (h) {\n                    if (!h) {\n                        me.removeAllListeners(ev);\n                        me._parser[\"on\" + ev] = h;\n                        return h;\n                    }\n                    me.on(ev, h);\n                },\n                enumerable: true,\n                configurable: false,\n            });\n        });\n    }\n    SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n            value: SAXStream,\n        },\n    });\n    SAXStream.prototype.write = function (data) {\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n    };\n    SAXStream.prototype.end = function (chunk) {\n        if (chunk && chunk.length) {\n            this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n    };\n    SAXStream.prototype.on = function (ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n            me._parser[\"on\" + ev] = function () {\n                var args = arguments.length === 1\n                    ? [arguments[0]]\n                    : Array.apply(null, arguments);\n                args.splice(0, 0, ev);\n                me.emit.apply(me, args);\n            };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n    };\n    // this really needs to be replaced with character classes.\n    // XML allows all manner of ridiculous numbers and digits.\n    var CDATA = \"[CDATA[\";\n    var DOCTYPE = \"DOCTYPE\";\n    var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n    var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n    // This implementation works on strings, a single character at a time\n    // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n    // without a significant breaking change to either this  parser, or the\n    // JavaScript language.  Implementation of an emoji-capable xml parser\n    // is left as an exercise for the reader.\n    var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n    var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n    function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n    }\n    function isQuote(c) {\n        return c === '\"' || c === \"'\";\n    }\n    function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n    }\n    function isMatch(regex, c) {\n        return regex.test(c);\n    }\n    function notMatch(regex, c) {\n        return !isMatch(regex, c);\n    }\n    var S = 0;\n    sax.STATE = {\n        BEGIN: S++, // leading byte order mark or whitespace\n        BEGIN_WHITESPACE: S++, // leading whitespace\n        TEXT: S++, // general stuff\n        TEXT_ENTITY: S++, // &amp and such.\n        OPEN_WAKA: S++, // <\n        SGML_DECL: S++, // <!BLARG\n        SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n        DOCTYPE: S++, // <!DOCTYPE\n        DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n        DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n        DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n        COMMENT_STARTING: S++, // <!-\n        COMMENT: S++, // <!--\n        COMMENT_ENDING: S++, // <!-- blah -\n        COMMENT_ENDED: S++, // <!-- blah --\n        CDATA: S++, // <![CDATA[ something\n        CDATA_ENDING: S++, // ]\n        CDATA_ENDING_2: S++, // ]]\n        PROC_INST: S++, // <?hi\n        PROC_INST_BODY: S++, // <?hi there\n        PROC_INST_ENDING: S++, // <?hi \"there\" ?\n        OPEN_TAG: S++, // <strong\n        OPEN_TAG_SLASH: S++, // <strong /\n        ATTRIB: S++, // <a\n        ATTRIB_NAME: S++, // <a foo\n        ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n        ATTRIB_VALUE: S++, // <a foo=\n        ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n        ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n        ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n        ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n        ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n        CLOSE_TAG: S++, // </a\n        CLOSE_TAG_SAW_WHITE: S++, // </a   >\n        SCRIPT: S++, // <script> ...\n        SCRIPT_ENDING: S++, // <script> ... <\n    };\n    sax.XML_ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n    };\n    sax.ENTITIES = {\n        amp: \"&\",\n        gt: \">\",\n        lt: \"<\",\n        quot: '\"',\n        apos: \"'\",\n        AElig: 198,\n        Aacute: 193,\n        Acirc: 194,\n        Agrave: 192,\n        Aring: 197,\n        Atilde: 195,\n        Auml: 196,\n        Ccedil: 199,\n        ETH: 208,\n        Eacute: 201,\n        Ecirc: 202,\n        Egrave: 200,\n        Euml: 203,\n        Iacute: 205,\n        Icirc: 206,\n        Igrave: 204,\n        Iuml: 207,\n        Ntilde: 209,\n        Oacute: 211,\n        Ocirc: 212,\n        Ograve: 210,\n        Oslash: 216,\n        Otilde: 213,\n        Ouml: 214,\n        THORN: 222,\n        Uacute: 218,\n        Ucirc: 219,\n        Ugrave: 217,\n        Uuml: 220,\n        Yacute: 221,\n        aacute: 225,\n        acirc: 226,\n        aelig: 230,\n        agrave: 224,\n        aring: 229,\n        atilde: 227,\n        auml: 228,\n        ccedil: 231,\n        eacute: 233,\n        ecirc: 234,\n        egrave: 232,\n        eth: 240,\n        euml: 235,\n        iacute: 237,\n        icirc: 238,\n        igrave: 236,\n        iuml: 239,\n        ntilde: 241,\n        oacute: 243,\n        ocirc: 244,\n        ograve: 242,\n        oslash: 248,\n        otilde: 245,\n        ouml: 246,\n        szlig: 223,\n        thorn: 254,\n        uacute: 250,\n        ucirc: 251,\n        ugrave: 249,\n        uuml: 252,\n        yacute: 253,\n        yuml: 255,\n        copy: 169,\n        reg: 174,\n        nbsp: 160,\n        iexcl: 161,\n        cent: 162,\n        pound: 163,\n        curren: 164,\n        yen: 165,\n        brvbar: 166,\n        sect: 167,\n        uml: 168,\n        ordf: 170,\n        laquo: 171,\n        not: 172,\n        shy: 173,\n        macr: 175,\n        deg: 176,\n        plusmn: 177,\n        sup1: 185,\n        sup2: 178,\n        sup3: 179,\n        acute: 180,\n        micro: 181,\n        para: 182,\n        middot: 183,\n        cedil: 184,\n        ordm: 186,\n        raquo: 187,\n        frac14: 188,\n        frac12: 189,\n        frac34: 190,\n        iquest: 191,\n        times: 215,\n        divide: 247,\n        OElig: 338,\n        oelig: 339,\n        Scaron: 352,\n        scaron: 353,\n        Yuml: 376,\n        fnof: 402,\n        circ: 710,\n        tilde: 732,\n        Alpha: 913,\n        Beta: 914,\n        Gamma: 915,\n        Delta: 916,\n        Epsilon: 917,\n        Zeta: 918,\n        Eta: 919,\n        Theta: 920,\n        Iota: 921,\n        Kappa: 922,\n        Lambda: 923,\n        Mu: 924,\n        Nu: 925,\n        Xi: 926,\n        Omicron: 927,\n        Pi: 928,\n        Rho: 929,\n        Sigma: 931,\n        Tau: 932,\n        Upsilon: 933,\n        Phi: 934,\n        Chi: 935,\n        Psi: 936,\n        Omega: 937,\n        alpha: 945,\n        beta: 946,\n        gamma: 947,\n        delta: 948,\n        epsilon: 949,\n        zeta: 950,\n        eta: 951,\n        theta: 952,\n        iota: 953,\n        kappa: 954,\n        lambda: 955,\n        mu: 956,\n        nu: 957,\n        xi: 958,\n        omicron: 959,\n        pi: 960,\n        rho: 961,\n        sigmaf: 962,\n        sigma: 963,\n        tau: 964,\n        upsilon: 965,\n        phi: 966,\n        chi: 967,\n        psi: 968,\n        omega: 969,\n        thetasym: 977,\n        upsih: 978,\n        piv: 982,\n        ensp: 8194,\n        emsp: 8195,\n        thinsp: 8201,\n        zwnj: 8204,\n        zwj: 8205,\n        lrm: 8206,\n        rlm: 8207,\n        ndash: 8211,\n        mdash: 8212,\n        lsquo: 8216,\n        rsquo: 8217,\n        sbquo: 8218,\n        ldquo: 8220,\n        rdquo: 8221,\n        bdquo: 8222,\n        dagger: 8224,\n        Dagger: 8225,\n        bull: 8226,\n        hellip: 8230,\n        permil: 8240,\n        prime: 8242,\n        Prime: 8243,\n        lsaquo: 8249,\n        rsaquo: 8250,\n        oline: 8254,\n        frasl: 8260,\n        euro: 8364,\n        image: 8465,\n        weierp: 8472,\n        real: 8476,\n        trade: 8482,\n        alefsym: 8501,\n        larr: 8592,\n        uarr: 8593,\n        rarr: 8594,\n        darr: 8595,\n        harr: 8596,\n        crarr: 8629,\n        lArr: 8656,\n        uArr: 8657,\n        rArr: 8658,\n        dArr: 8659,\n        hArr: 8660,\n        forall: 8704,\n        part: 8706,\n        exist: 8707,\n        empty: 8709,\n        nabla: 8711,\n        isin: 8712,\n        notin: 8713,\n        ni: 8715,\n        prod: 8719,\n        sum: 8721,\n        minus: 8722,\n        lowast: 8727,\n        radic: 8730,\n        prop: 8733,\n        infin: 8734,\n        ang: 8736,\n        and: 8743,\n        or: 8744,\n        cap: 8745,\n        cup: 8746,\n        int: 8747,\n        there4: 8756,\n        sim: 8764,\n        cong: 8773,\n        asymp: 8776,\n        ne: 8800,\n        equiv: 8801,\n        le: 8804,\n        ge: 8805,\n        sub: 8834,\n        sup: 8835,\n        nsub: 8836,\n        sube: 8838,\n        supe: 8839,\n        oplus: 8853,\n        otimes: 8855,\n        perp: 8869,\n        sdot: 8901,\n        lceil: 8968,\n        rceil: 8969,\n        lfloor: 8970,\n        rfloor: 8971,\n        lang: 9001,\n        rang: 9002,\n        loz: 9674,\n        spades: 9824,\n        clubs: 9827,\n        hearts: 9829,\n        diams: 9830,\n    };\n    Object.keys(sax.ENTITIES).forEach(function (key) {\n        var e = sax.ENTITIES[key];\n        var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax.ENTITIES[key] = s;\n    });\n    for (var s in sax.STATE) {\n        sax.STATE[sax.STATE[s]] = s;\n    }\n    // shorthand\n    S = sax.STATE;\n    function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n    }\n    function emitNode(parser, nodeType, data) {\n        if (parser.textNode)\n            closeText(parser);\n        emit(parser, nodeType, data);\n    }\n    function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode)\n            emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n    }\n    function textopts(opt, text) {\n        if (opt.trim)\n            text = text.trim();\n        if (opt.normalize)\n            text = text.replace(/\\s+/g, \" \");\n        return text;\n    }\n    function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n            er +=\n                \"\\nLine: \" +\n                    parser.line +\n                    \"\\nColumn: \" +\n                    parser.column +\n                    \"\\nChar: \" +\n                    parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n    }\n    function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot)\n            strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN &&\n            parser.state !== S.BEGIN_WHITESPACE &&\n            parser.state !== S.TEXT) {\n            error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n    }\n    function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n            throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n            error(parser, message);\n        }\n    }\n    function newTag(parser) {\n        if (!parser.strict)\n            parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n        // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n        if (parser.opt.xmlns) {\n            tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n    }\n    function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        // <x \"xmlns\"=\"http://foo\">\n        if (attribute && name === \"xmlns\") {\n            prefix = \"xmlns\";\n            local = \"\";\n        }\n        return { prefix: prefix, local: local };\n    }\n    function attrib(parser) {\n        if (!parser.strict) {\n            parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n            parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n            parser.attribName = parser.attribValue = \"\";\n            return;\n        }\n        if (parser.opt.xmlns) {\n            var qn = qname(parser.attribName, true);\n            var prefix = qn.prefix;\n            var local = qn.local;\n            if (prefix === \"xmlns\") {\n                // namespace binding attribute. push the binding into scope\n                if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n                    strictFail(parser, \"xml: prefix must be bound to \" +\n                        XML_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else if (local === \"xmlns\" &&\n                    parser.attribValue !== XMLNS_NAMESPACE) {\n                    strictFail(parser, \"xmlns: prefix must be bound to \" +\n                        XMLNS_NAMESPACE +\n                        \"\\n\" +\n                        \"Actual: \" +\n                        parser.attribValue);\n                }\n                else {\n                    var tag = parser.tag;\n                    var parent = parser.tags[parser.tags.length - 1] || parser;\n                    if (tag.ns === parent.ns) {\n                        tag.ns = Object.create(parent.ns);\n                    }\n                    tag.ns[local] = parser.attribValue;\n                }\n            }\n            // defer onattribute events until all attributes have been seen\n            // so any new bindings can take effect. preserve attribute order\n            // so deferred events can be emitted in document order\n            parser.attribList.push([parser.attribName, parser.attribValue]);\n        }\n        else {\n            // in non-xmlns mode, we can emit the event right away\n            parser.tag.attributes[parser.attribName] = parser.attribValue;\n            emitNode(parser, \"onattribute\", {\n                name: parser.attribName,\n                value: parser.attribValue,\n            });\n        }\n        parser.attribName = parser.attribValue = \"\";\n    }\n    function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n            // emit namespace binding events\n            var tag = parser.tag;\n            // add namespace info to tag\n            var qn = qname(parser.tagName);\n            tag.prefix = qn.prefix;\n            tag.local = qn.local;\n            tag.uri = tag.ns[qn.prefix] || \"\";\n            if (tag.prefix && !tag.uri) {\n                strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n                tag.uri = qn.prefix;\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (tag.ns && parent.ns !== tag.ns) {\n                Object.keys(tag.ns).forEach(function (p) {\n                    emitNode(parser, \"onopennamespace\", {\n                        prefix: p,\n                        uri: tag.ns[p],\n                    });\n                });\n            }\n            // handle deferred onattribute events\n            // Note: do not apply default ns to attributes:\n            //   http://www.w3.org/TR/REC-xml-names/#defaulting\n            for (var i = 0, l = parser.attribList.length; i < l; i++) {\n                var nv = parser.attribList[i];\n                var name = nv[0];\n                var value = nv[1];\n                var qualName = qname(name, true);\n                var prefix = qualName.prefix;\n                var local = qualName.local;\n                var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n                var a = {\n                    name: name,\n                    value: value,\n                    prefix: prefix,\n                    local: local,\n                    uri: uri,\n                };\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (prefix && prefix !== \"xmlns\" && !uri) {\n                    strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n                    a.uri = prefix;\n                }\n                parser.tag.attributes[name] = a;\n                emitNode(parser, \"onattribute\", a);\n            }\n            parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        // process the tag\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n            // special case for <script> in non-strict mode.\n            if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n                parser.state = S.SCRIPT;\n            }\n            else {\n                parser.state = S.TEXT;\n            }\n            parser.tag = null;\n            parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n    }\n    function closeTag(parser) {\n        if (!parser.tagName) {\n            strictFail(parser, \"Weird empty close tag.\");\n            parser.textNode += \"</>\";\n            parser.state = S.TEXT;\n            return;\n        }\n        if (parser.script) {\n            if (parser.tagName !== \"script\") {\n                parser.script += \"</\" + parser.tagName + \">\";\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n                return;\n            }\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n        }\n        // first make sure that the closing tag actually exists.\n        // <a><b></c></b></a> will close everything, otherwise.\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n            tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n            var close = parser.tags[t];\n            if (close.name !== closeTo) {\n                // fail the first time in strict mode\n                strictFail(parser, \"Unexpected close tag\");\n            }\n            else {\n                break;\n            }\n        }\n        // didn't find it.  we already failed for strict, so just abort.\n        if (t < 0) {\n            strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n            parser.textNode += \"</\" + parser.tagName + \">\";\n            parser.state = S.TEXT;\n            return;\n        }\n        parser.tagName = tagName;\n        var s = parser.tags.length;\n        while (s-- > t) {\n            var tag = (parser.tag = parser.tags.pop());\n            parser.tagName = parser.tag.name;\n            emitNode(parser, \"onclosetag\", parser.tagName);\n            var x = {};\n            for (var i in tag.ns) {\n                x[i] = tag.ns[i];\n            }\n            var parent = parser.tags[parser.tags.length - 1] || parser;\n            if (parser.opt.xmlns && tag.ns !== parent.ns) {\n                // remove namespace bindings introduced by tag\n                Object.keys(tag.ns).forEach(function (p) {\n                    var n = tag.ns[p];\n                    emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n                });\n            }\n        }\n        if (t === 0)\n            parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n    }\n    function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n            return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n            return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n            if (entity.charAt(1) === \"x\") {\n                entity = entity.slice(2);\n                num = parseInt(entity, 16);\n                numStr = num.toString(16);\n            }\n            else {\n                entity = entity.slice(1);\n                num = parseInt(entity, 10);\n                numStr = num.toString(10);\n            }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity) {\n            strictFail(parser, \"Invalid character entity\");\n            return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n    }\n    function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n        }\n        else if (!isWhitespace(c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n        }\n    }\n    function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n            result = chunk.charAt(i);\n        }\n        return result;\n    }\n    function write(chunk) {\n        var parser = this;\n        if (this.error) {\n            throw this.error;\n        }\n        if (parser.closed) {\n            return error(parser, \"Cannot write after close. Assign an onready handler.\");\n        }\n        if (chunk === null) {\n            return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n            c = charAt(chunk, i++);\n            parser.c = c;\n            if (!c) {\n                break;\n            }\n            if (parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                    parser.line++;\n                    parser.column = 0;\n                }\n                else {\n                    parser.column++;\n                }\n            }\n            switch (parser.state) {\n                case S.BEGIN:\n                    parser.state = S.BEGIN_WHITESPACE;\n                    if (c === \"\\uFEFF\") {\n                        continue;\n                    }\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.BEGIN_WHITESPACE:\n                    beginWhiteSpace(parser, c);\n                    continue;\n                case S.TEXT:\n                    if (parser.sawRoot && !parser.closedRoot) {\n                        var starti = i - 1;\n                        while (c && c !== \"<\" && c !== \"&\") {\n                            c = charAt(chunk, i++);\n                            if (c && parser.trackPosition) {\n                                parser.position++;\n                                if (c === \"\\n\") {\n                                    parser.line++;\n                                    parser.column = 0;\n                                }\n                                else {\n                                    parser.column++;\n                                }\n                            }\n                        }\n                        parser.textNode += chunk.substring(starti, i - 1);\n                    }\n                    if (c === \"<\" &&\n                        !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                        parser.state = S.OPEN_WAKA;\n                        parser.startTagPosition = parser.position;\n                    }\n                    else {\n                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                            strictFail(parser, \"Text data outside of root node.\");\n                        }\n                        if (c === \"&\") {\n                            parser.state = S.TEXT_ENTITY;\n                        }\n                        else {\n                            parser.textNode += c;\n                        }\n                    }\n                    continue;\n                case S.SCRIPT:\n                    // only non-strict\n                    if (c === \"<\") {\n                        parser.state = S.SCRIPT_ENDING;\n                    }\n                    else {\n                        parser.script += c;\n                    }\n                    continue;\n                case S.SCRIPT_ENDING:\n                    if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                    }\n                    else {\n                        parser.script += \"<\" + c;\n                        parser.state = S.SCRIPT;\n                    }\n                    continue;\n                case S.OPEN_WAKA:\n                    // either a /, ?, !, or text is coming next.\n                    if (c === \"!\") {\n                        parser.state = S.SGML_DECL;\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (isWhitespace(c)) {\n                        // wait for it...\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.state = S.OPEN_TAG;\n                        parser.tagName = c;\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.CLOSE_TAG;\n                        parser.tagName = \"\";\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST;\n                        parser.procInstName = parser.procInstBody = \"\";\n                    }\n                    else {\n                        strictFail(parser, \"Unencoded <\");\n                        // if there was some whitespace, then add that in.\n                        if (parser.startTagPosition + 1 < parser.position) {\n                            var pad = parser.position - parser.startTagPosition;\n                            c = new Array(pad).join(\" \") + c;\n                        }\n                        parser.textNode += \"<\" + c;\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.SGML_DECL:\n                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                        emitNode(parser, \"onopencdata\");\n                        parser.state = S.CDATA;\n                        parser.sgmlDecl = \"\";\n                        parser.cdata = \"\";\n                    }\n                    else if (parser.sgmlDecl + c === \"--\") {\n                        parser.state = S.COMMENT;\n                        parser.comment = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                        parser.state = S.DOCTYPE;\n                        if (parser.doctype || parser.sawRoot) {\n                            strictFail(parser, \"Inappropriately located doctype declaration\");\n                        }\n                        parser.doctype = \"\";\n                        parser.sgmlDecl = \"\";\n                    }\n                    else if (c === \">\") {\n                        emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                        parser.sgmlDecl = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.SGML_DECL_QUOTED;\n                        parser.sgmlDecl += c;\n                    }\n                    else {\n                        parser.sgmlDecl += c;\n                    }\n                    continue;\n                case S.SGML_DECL_QUOTED:\n                    if (c === parser.q) {\n                        parser.state = S.SGML_DECL;\n                        parser.q = \"\";\n                    }\n                    parser.sgmlDecl += c;\n                    continue;\n                case S.DOCTYPE:\n                    if (c === \">\") {\n                        parser.state = S.TEXT;\n                        emitNode(parser, \"ondoctype\", parser.doctype);\n                        parser.doctype = true; // just remember that we saw it.\n                    }\n                    else {\n                        parser.doctype += c;\n                        if (c === \"[\") {\n                            parser.state = S.DOCTYPE_DTD;\n                        }\n                        else if (isQuote(c)) {\n                            parser.state = S.DOCTYPE_QUOTED;\n                            parser.q = c;\n                        }\n                    }\n                    continue;\n                case S.DOCTYPE_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.q = \"\";\n                        parser.state = S.DOCTYPE;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD:\n                    parser.doctype += c;\n                    if (c === \"]\") {\n                        parser.state = S.DOCTYPE;\n                    }\n                    else if (isQuote(c)) {\n                        parser.state = S.DOCTYPE_DTD_QUOTED;\n                        parser.q = c;\n                    }\n                    continue;\n                case S.DOCTYPE_DTD_QUOTED:\n                    parser.doctype += c;\n                    if (c === parser.q) {\n                        parser.state = S.DOCTYPE_DTD;\n                        parser.q = \"\";\n                    }\n                    continue;\n                case S.COMMENT:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDING;\n                    }\n                    else {\n                        parser.comment += c;\n                    }\n                    continue;\n                case S.COMMENT_ENDING:\n                    if (c === \"-\") {\n                        parser.state = S.COMMENT_ENDED;\n                        parser.comment = textopts(parser.opt, parser.comment);\n                        if (parser.comment) {\n                            emitNode(parser, \"oncomment\", parser.comment);\n                        }\n                        parser.comment = \"\";\n                    }\n                    else {\n                        parser.comment += \"-\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    continue;\n                case S.COMMENT_ENDED:\n                    if (c !== \">\") {\n                        strictFail(parser, \"Malformed comment\");\n                        // allow <!-- blah -- bloo --> in non-strict mode,\n                        // which is a comment of \" blah -- bloo \"\n                        parser.comment += \"--\" + c;\n                        parser.state = S.COMMENT;\n                    }\n                    else {\n                        parser.state = S.TEXT;\n                    }\n                    continue;\n                case S.CDATA:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING;\n                    }\n                    else {\n                        parser.cdata += c;\n                    }\n                    continue;\n                case S.CDATA_ENDING:\n                    if (c === \"]\") {\n                        parser.state = S.CDATA_ENDING_2;\n                    }\n                    else {\n                        parser.cdata += \"]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.CDATA_ENDING_2:\n                    if (c === \">\") {\n                        if (parser.cdata) {\n                            emitNode(parser, \"oncdata\", parser.cdata);\n                        }\n                        emitNode(parser, \"onclosecdata\");\n                        parser.cdata = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else if (c === \"]\") {\n                        parser.cdata += \"]\";\n                    }\n                    else {\n                        parser.cdata += \"]]\" + c;\n                        parser.state = S.CDATA;\n                    }\n                    continue;\n                case S.PROC_INST:\n                    if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    else {\n                        parser.procInstName += c;\n                    }\n                    continue;\n                case S.PROC_INST_BODY:\n                    if (!parser.procInstBody && isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \"?\") {\n                        parser.state = S.PROC_INST_ENDING;\n                    }\n                    else {\n                        parser.procInstBody += c;\n                    }\n                    continue;\n                case S.PROC_INST_ENDING:\n                    if (c === \">\") {\n                        emitNode(parser, \"onprocessinginstruction\", {\n                            name: parser.procInstName,\n                            body: parser.procInstBody,\n                        });\n                        parser.procInstName = parser.procInstBody = \"\";\n                        parser.state = S.TEXT;\n                    }\n                    else {\n                        parser.procInstBody += \"?\" + c;\n                        parser.state = S.PROC_INST_BODY;\n                    }\n                    continue;\n                case S.OPEN_TAG:\n                    if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else {\n                        newTag(parser);\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (c === \"/\") {\n                            parser.state = S.OPEN_TAG_SLASH;\n                        }\n                        else {\n                            if (!isWhitespace(c)) {\n                                strictFail(parser, \"Invalid character in tag name\");\n                            }\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.OPEN_TAG_SLASH:\n                    if (c === \">\") {\n                        openTag(parser, true);\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.ATTRIB:\n                    // haven't read the attribute name yet.\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (c === \">\") {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.attribValue = parser.attribName;\n                        attrib(parser);\n                        openTag(parser);\n                    }\n                    else if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB_NAME_SAW_WHITE;\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.attribName += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_NAME_SAW_WHITE:\n                    if (c === \"=\") {\n                        parser.state = S.ATTRIB_VALUE;\n                    }\n                    else if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else {\n                        strictFail(parser, \"Attribute without value\");\n                        parser.tag.attributes[parser.attribName] = \"\";\n                        parser.attribValue = \"\";\n                        emitNode(parser, \"onattribute\", {\n                            name: parser.attribName,\n                            value: \"\",\n                        });\n                        parser.attribName = \"\";\n                        if (c === \">\") {\n                            openTag(parser);\n                        }\n                        else if (isMatch(nameStart, c)) {\n                            parser.attribName = c;\n                            parser.state = S.ATTRIB_NAME;\n                        }\n                        else {\n                            strictFail(parser, \"Invalid attribute name\");\n                            parser.state = S.ATTRIB;\n                        }\n                    }\n                    continue;\n                case S.ATTRIB_VALUE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    else if (isQuote(c)) {\n                        parser.q = c;\n                        parser.state = S.ATTRIB_VALUE_QUOTED;\n                    }\n                    else {\n                        strictFail(parser, \"Unquoted attribute value\");\n                        parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                        parser.attribValue = c;\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_QUOTED:\n                    if (c !== parser.q) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    parser.q = \"\";\n                    parser.state = S.ATTRIB_VALUE_CLOSED;\n                    continue;\n                case S.ATTRIB_VALUE_CLOSED:\n                    if (isWhitespace(c)) {\n                        parser.state = S.ATTRIB;\n                    }\n                    else if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else if (c === \"/\") {\n                        parser.state = S.OPEN_TAG_SLASH;\n                    }\n                    else if (isMatch(nameStart, c)) {\n                        strictFail(parser, \"No whitespace between attributes\");\n                        parser.attribName = c;\n                        parser.attribValue = \"\";\n                        parser.state = S.ATTRIB_NAME;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid attribute name\");\n                    }\n                    continue;\n                case S.ATTRIB_VALUE_UNQUOTED:\n                    if (!isAttribEnd(c)) {\n                        if (c === \"&\") {\n                            parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                        }\n                        else {\n                            parser.attribValue += c;\n                        }\n                        continue;\n                    }\n                    attrib(parser);\n                    if (c === \">\") {\n                        openTag(parser);\n                    }\n                    else {\n                        parser.state = S.ATTRIB;\n                    }\n                    continue;\n                case S.CLOSE_TAG:\n                    if (!parser.tagName) {\n                        if (isWhitespace(c)) {\n                            continue;\n                        }\n                        else if (notMatch(nameStart, c)) {\n                            if (parser.script) {\n                                parser.script += \"</\" + c;\n                                parser.state = S.SCRIPT;\n                            }\n                            else {\n                                strictFail(parser, \"Invalid tagname in closing tag.\");\n                            }\n                        }\n                        else {\n                            parser.tagName = c;\n                        }\n                    }\n                    else if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else if (isMatch(nameBody, c)) {\n                        parser.tagName += c;\n                    }\n                    else if (parser.script) {\n                        parser.script += \"</\" + parser.tagName;\n                        parser.tagName = \"\";\n                        parser.state = S.SCRIPT;\n                    }\n                    else {\n                        if (!isWhitespace(c)) {\n                            strictFail(parser, \"Invalid tagname in closing tag\");\n                        }\n                        parser.state = S.CLOSE_TAG_SAW_WHITE;\n                    }\n                    continue;\n                case S.CLOSE_TAG_SAW_WHITE:\n                    if (isWhitespace(c)) {\n                        continue;\n                    }\n                    if (c === \">\") {\n                        closeTag(parser);\n                    }\n                    else {\n                        strictFail(parser, \"Invalid characters in closing tag\");\n                    }\n                    continue;\n                case S.TEXT_ENTITY:\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                case S.ATTRIB_VALUE_ENTITY_U:\n                    var returnState;\n                    var buffer;\n                    switch (parser.state) {\n                        case S.TEXT_ENTITY:\n                            returnState = S.TEXT;\n                            buffer = \"textNode\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_Q:\n                            returnState = S.ATTRIB_VALUE_QUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                        case S.ATTRIB_VALUE_ENTITY_U:\n                            returnState = S.ATTRIB_VALUE_UNQUOTED;\n                            buffer = \"attribValue\";\n                            break;\n                    }\n                    if (c === \";\") {\n                        if (parser.opt.unparsedEntities) {\n                            var parsedEntity = parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                            parser.write(parsedEntity);\n                        }\n                        else {\n                            parser[buffer] += parseEntity(parser);\n                            parser.entity = \"\";\n                            parser.state = returnState;\n                        }\n                    }\n                    else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                        parser.entity += c;\n                    }\n                    else {\n                        strictFail(parser, \"Invalid character in entity name\");\n                        parser[buffer] += \"&\" + parser.entity + c;\n                        parser.entity = \"\";\n                        parser.state = returnState;\n                    }\n                    continue;\n                default: /* istanbul ignore next */ {\n                    throw new Error(parser, \"Unknown state: \" + parser.state);\n                }\n            }\n        } // while\n        if (parser.position >= parser.bufferCheckPosition) {\n            checkBufferLength(parser);\n        }\n        return parser;\n    }\n    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n    /* istanbul ignore next */\n    if (!String.fromCodePoint) {\n        (function () {\n            var stringFromCharCode = String.fromCharCode;\n            var floor = Math.floor;\n            var fromCodePoint = function () {\n                var MAX_SIZE = 0x4000;\n                var codeUnits = [];\n                var highSurrogate;\n                var lowSurrogate;\n                var index = -1;\n                var length = arguments.length;\n                if (!length) {\n                    return \"\";\n                }\n                var result = \"\";\n                while (++index < length) {\n                    var codePoint = Number(arguments[index]);\n                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                        codePoint < 0 || // not a valid Unicode code point\n                        codePoint > 0x10ffff || // not a valid Unicode code point\n                        floor(codePoint) !== codePoint // not an integer\n                    ) {\n                        throw RangeError(\"Invalid code point: \" + codePoint);\n                    }\n                    if (codePoint <= 0xffff) {\n                        // BMP code point\n                        codeUnits.push(codePoint);\n                    }\n                    else {\n                        // Astral code point; split in surrogate halves\n                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                        codePoint -= 0x10000;\n                        highSurrogate = (codePoint >> 10) + 0xd800;\n                        lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                        codeUnits.push(highSurrogate, lowSurrogate);\n                    }\n                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                        result += stringFromCharCode.apply(null, codeUnits);\n                        codeUnits.length = 0;\n                    }\n                }\n                return result;\n            };\n            /* istanbul ignore next */\n            if (Object.defineProperty) {\n                Object.defineProperty(String, \"fromCodePoint\", {\n                    value: fromCodePoint,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n            else {\n                String.fromCodePoint = fromCodePoint;\n            }\n        })();\n    }\n    return sax;\n};\nconst sax = /** #__PURE__ */ initializeSax();\nexports.sax = sax;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2F4LWpzL3NheC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2F4LWpzL3NheC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAdHMtbm9jaGVja1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYXggPSB2b2lkIDA7XG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXNcbi8vIE9yaWdpbmFsbHkgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9zYXgtanNcbmNvbnN0IGluaXRpYWxpemVTYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2F4ID0ge307XG4gICAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkge1xuICAgICAgICByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCk7XG4gICAgfTtcbiAgICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyO1xuICAgIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW07XG4gICAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbTtcbiAgICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAgIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgICAvLyBzaW5jZSB0aGF0J3MgdGhlIGVhcmxpZXN0IHRoYXQgYSBidWZmZXIgb3ZlcnJ1biBjb3VsZCBvY2N1ci4gIFRoaXMgd2F5LCBjaGVja3MgYXJlXG4gICAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAgIC8vIGxhcmdlIHN0cmluZyBpbnRvIHdyaXRlKCkgbWlnaHQgaGF2ZSB1bmRlc2lyYWJsZSBlZmZlY3RzLCBidXQgdGhpcyBpcyBtYW5hZ2VhYmxlIGJ5XG4gICAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAgIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gICAgLy8gU2V0IHRvIEluZmluaXR5IHRvIGhhdmUgdW5saW1pdGVkIGJ1ZmZlcnMuXG4gICAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0O1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXG4gICAgICAgIFwiY29tbWVudFwiLFxuICAgICAgICBcInNnbWxEZWNsXCIsXG4gICAgICAgIFwidGV4dE5vZGVcIixcbiAgICAgICAgXCJ0YWdOYW1lXCIsXG4gICAgICAgIFwiZG9jdHlwZVwiLFxuICAgICAgICBcInByb2NJbnN0TmFtZVwiLFxuICAgICAgICBcInByb2NJbnN0Qm9keVwiLFxuICAgICAgICBcImVudGl0eVwiLFxuICAgICAgICBcImF0dHJpYk5hbWVcIixcbiAgICAgICAgXCJhdHRyaWJWYWx1ZVwiLFxuICAgICAgICBcImNkYXRhXCIsXG4gICAgICAgIFwic2NyaXB0XCIsXG4gICAgXTtcbiAgICBzYXguRVZFTlRTID0gW1xuICAgICAgICBcInRleHRcIixcbiAgICAgICAgXCJwcm9jZXNzaW5naW5zdHJ1Y3Rpb25cIixcbiAgICAgICAgXCJzZ21sZGVjbGFyYXRpb25cIixcbiAgICAgICAgXCJkb2N0eXBlXCIsXG4gICAgICAgIFwiY29tbWVudFwiLFxuICAgICAgICBcIm9wZW50YWdzdGFydFwiLFxuICAgICAgICBcImF0dHJpYnV0ZVwiLFxuICAgICAgICBcIm9wZW50YWdcIixcbiAgICAgICAgXCJjbG9zZXRhZ1wiLFxuICAgICAgICBcIm9wZW5jZGF0YVwiLFxuICAgICAgICBcImNkYXRhXCIsXG4gICAgICAgIFwiY2xvc2VjZGF0YVwiLFxuICAgICAgICBcImVycm9yXCIsXG4gICAgICAgIFwiZW5kXCIsXG4gICAgICAgIFwicmVhZHlcIixcbiAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgXCJvcGVubmFtZXNwYWNlXCIsXG4gICAgICAgIFwiY2xvc2VuYW1lc3BhY2VcIixcbiAgICBdO1xuICAgIGZ1bmN0aW9uIFNBWFBhcnNlcihzdHJpY3QsIG9wdCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzO1xuICAgICAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKTtcbiAgICAgICAgcGFyc2VyLnEgPSBwYXJzZXIuYyA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIO1xuICAgICAgICBwYXJzZXIub3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFncztcbiAgICAgICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gXCJ0b0xvd2VyQ2FzZVwiIDogXCJ0b1VwcGVyQ2FzZVwiO1xuICAgICAgICBwYXJzZXIudGFncyA9IFtdO1xuICAgICAgICBwYXJzZXIuY2xvc2VkID0gcGFyc2VyLmNsb3NlZFJvb3QgPSBwYXJzZXIuc2F3Um9vdCA9IGZhbHNlO1xuICAgICAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbDtcbiAgICAgICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0O1xuICAgICAgICBwYXJzZXIubm9zY3JpcHQgPSAhIShzdHJpY3QgfHwgcGFyc2VyLm9wdC5ub3NjcmlwdCk7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU47XG4gICAgICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXM7XG4gICAgICAgIHBhcnNlci5FTlRJVElFUyA9IHBhcnNlci5zdHJpY3RFbnRpdGllc1xuICAgICAgICAgICAgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpXG4gICAgICAgICAgICA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKTtcbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXTtcbiAgICAgICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAgICAgLy8gd2hpY2ggcHJvdG9zIHRvIGl0cyBwYXJlbnQgdGFnLlxuICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICAgICAgcGFyc2VyLnRyYWNrUG9zaXRpb24gPSBwYXJzZXIub3B0LnBvc2l0aW9uICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVtaXQocGFyc2VyLCBcIm9ucmVhZHlcIik7XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgICAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEYoKSB7IH1cbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gbztcbiAgICAgICAgICAgIHZhciBuZXdmID0gbmV3IEYoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdmO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5rZXlzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG8pXG4gICAgICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChpKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpIHtcbiAgICAgICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKTtcbiAgICAgICAgdmFyIG1heEFjdHVhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IG1heEFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgaXNzdWVzIGJ5IGVtaXR0aW5nIHRoZSB0ZXh0IG5vZGUgbm93LFxuICAgICAgICAgICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dE5vZGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2RhdGFcIiwgcGFyc2VyLmNkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2NyaXB0XCIsIHBhcnNlci5zY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKHBhcnNlciwgXCJNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogXCIgKyBidWZmZXJzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICAgICAgdmFyIG0gPSBzYXguTUFYX0JVRkZFUl9MRU5HVEggLSBtYXhBY3R1YWw7XG4gICAgICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzKHBhcnNlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyhwYXJzZXIpIHtcbiAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgIGlmIChwYXJzZXIuY2RhdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNkYXRhXCIsIHBhcnNlci5jZGF0YSk7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25zY3JpcHRcIiwgcGFyc2VyLnNjcmlwdCk7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVuZCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGU6IHdyaXRlLFxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZShudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZsdXNoQnVmZmVycyh0aGlzKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHZhciBTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbTtcbiAgICBpZiAoIVN0cmVhbSlcbiAgICAgICAgU3RyZWFtID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gZXYgIT09IFwiZXJyb3JcIiAmJiBldiAhPT0gXCJlbmRcIjtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0oc3RyaWN0LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBTdHJlYW0uYXBwbHkodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1lLmVtaXQoXCJlbmRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBtZS5lbWl0KFwiZXJyb3JcIiwgZXIpO1xuICAgICAgICAgICAgLy8gaWYgZGlkbid0IHRocm93LCB0aGVuIG1lYW5zIGVycm9yIHdhcyBoYW5kbGVkLlxuICAgICAgICAgICAgLy8gZ28gYWhlYWQgYW5kIGNsZWFyIGVycm9yLCBzbyB3ZSBjYW4gd3JpdGUgYWdhaW4uXG4gICAgICAgICAgICBtZS5fcGFyc2VyLmVycm9yID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVjb2RlciA9IG51bGw7XG4gICAgICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsIFwib25cIiArIGV2LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyW1wib25cIiArIGV2XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX3BhcnNlcltcIm9uXCIgKyBldl0gPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWUub24oZXYsIGgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogU0FYU3RyZWFtLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIFNBWFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJzZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU0FYU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgaGFuZGxlcikge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoIW1lLl9wYXJzZXJbXCJvblwiICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgICAgICAgbWUuX3BhcnNlcltcIm9uXCIgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gW2FyZ3VtZW50c1swXV1cbiAgICAgICAgICAgICAgICAgICAgOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDAsIGV2KTtcbiAgICAgICAgICAgICAgICBtZS5lbWl0LmFwcGx5KG1lLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLy8gdGhpcyByZWFsbHkgbmVlZHMgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAgICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gICAgdmFyIENEQVRBID0gXCJbQ0RBVEFbXCI7XG4gICAgdmFyIERPQ1RZUEUgPSBcIkRPQ1RZUEVcIjtcbiAgICB2YXIgWE1MX05BTUVTUEFDRSA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCI7XG4gICAgdmFyIFhNTE5TX05BTUVTUEFDRSA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIjtcbiAgICB2YXIgcm9vdE5TID0geyB4bWw6IFhNTF9OQU1FU1BBQ0UsIHhtbG5zOiBYTUxOU19OQU1FU1BBQ0UgfTtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBvbiBzdHJpbmdzLCBhIHNpbmdsZSBjaGFyYWN0ZXIgYXQgYSB0aW1lXG4gICAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gICAgLy8gd2l0aG91dCBhIHNpZ25pZmljYW50IGJyZWFraW5nIGNoYW5nZSB0byBlaXRoZXIgdGhpcyAgcGFyc2VyLCBvciB0aGVcbiAgICAvLyBKYXZhU2NyaXB0IGxhbmd1YWdlLiAgSW1wbGVtZW50YXRpb24gb2YgYW4gZW1vamktY2FwYWJsZSB4bWwgcGFyc2VyXG4gICAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgICB2YXIgbmFtZVN0YXJ0ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vO1xuICAgIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dLztcbiAgICB2YXIgZW50aXR5U3RhcnQgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vO1xuICAgIHZhciBlbnRpdHlCb2R5ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dLztcbiAgICBmdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiIHx8IGMgPT09IFwiXFx0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUXVvdGUoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBdHRyaWJFbmQoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gXCI+XCIgfHwgaXNXaGl0ZXNwYWNlKGMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc01hdGNoKHJlZ2V4LCBjKSB7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KGMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RNYXRjaChyZWdleCwgYykge1xuICAgICAgICByZXR1cm4gIWlzTWF0Y2gocmVnZXgsIGMpO1xuICAgIH1cbiAgICB2YXIgUyA9IDA7XG4gICAgc2F4LlNUQVRFID0ge1xuICAgICAgICBCRUdJTjogUysrLCAvLyBsZWFkaW5nIGJ5dGUgb3JkZXIgbWFyayBvciB3aGl0ZXNwYWNlXG4gICAgICAgIEJFR0lOX1dISVRFU1BBQ0U6IFMrKywgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgICAgICBURVhUX0VOVElUWTogUysrLCAvLyAmYW1wIGFuZCBzdWNoLlxuICAgICAgICBPUEVOX1dBS0E6IFMrKywgLy8gPFxuICAgICAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgICAgICBTR01MX0RFQ0xfUVVPVEVEOiBTKyssIC8vIDwhQkxBUkcgZm9vIFwiYmFyXG4gICAgICAgIERPQ1RZUEU6IFMrKywgLy8gPCFET0NUWVBFXG4gICAgICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgICAgICBET0NUWVBFX0RURDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIC4uLlxuICAgICAgICBET0NUWVBFX0RURF9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuICAgICAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgICAgICBDT01NRU5UOiBTKyssIC8vIDwhLS1cbiAgICAgICAgQ09NTUVOVF9FTkRJTkc6IFMrKywgLy8gPCEtLSBibGFoIC1cbiAgICAgICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICAgICAgQ0RBVEE6IFMrKywgLy8gPCFbQ0RBVEFbIHNvbWV0aGluZ1xuICAgICAgICBDREFUQV9FTkRJTkc6IFMrKywgLy8gXVxuICAgICAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgICAgICBQUk9DX0lOU1Q6IFMrKywgLy8gPD9oaVxuICAgICAgICBQUk9DX0lOU1RfQk9EWTogUysrLCAvLyA8P2hpIHRoZXJlXG4gICAgICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgICAgICBPUEVOX1RBRzogUysrLCAvLyA8c3Ryb25nXG4gICAgICAgIE9QRU5fVEFHX1NMQVNIOiBTKyssIC8vIDxzdHJvbmcgL1xuICAgICAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICAgICAgQVRUUklCX05BTUU6IFMrKywgLy8gPGEgZm9vXG4gICAgICAgIEFUVFJJQl9OQU1FX1NBV19XSElURTogUysrLCAvLyA8YSBmb28gX1xuICAgICAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgICAgICBBVFRSSUJfVkFMVUVfUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1cImJhclxuICAgICAgICBBVFRSSUJfVkFMVUVfQ0xPU0VEOiBTKyssIC8vIDxhIGZvbz1cImJhclwiXG4gICAgICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfUTogUysrLCAvLyA8Zm9vIGJhcj1cIiZxdW90O1wiXG4gICAgICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfVTogUysrLCAvLyA8Zm9vIGJhcj0mcXVvdFxuICAgICAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgICAgIENMT1NFX1RBR19TQVdfV0hJVEU6IFMrKywgLy8gPC9hICAgPlxuICAgICAgICBTQ1JJUFQ6IFMrKywgLy8gPHNjcmlwdD4gLi4uXG4gICAgICAgIFNDUklQVF9FTkRJTkc6IFMrKywgLy8gPHNjcmlwdD4gLi4uIDxcbiAgICB9O1xuICAgIHNheC5YTUxfRU5USVRJRVMgPSB7XG4gICAgICAgIGFtcDogXCImXCIsXG4gICAgICAgIGd0OiBcIj5cIixcbiAgICAgICAgbHQ6IFwiPFwiLFxuICAgICAgICBxdW90OiAnXCInLFxuICAgICAgICBhcG9zOiBcIidcIixcbiAgICB9O1xuICAgIHNheC5FTlRJVElFUyA9IHtcbiAgICAgICAgYW1wOiBcIiZcIixcbiAgICAgICAgZ3Q6IFwiPlwiLFxuICAgICAgICBsdDogXCI8XCIsXG4gICAgICAgIHF1b3Q6ICdcIicsXG4gICAgICAgIGFwb3M6IFwiJ1wiLFxuICAgICAgICBBRWxpZzogMTk4LFxuICAgICAgICBBYWN1dGU6IDE5MyxcbiAgICAgICAgQWNpcmM6IDE5NCxcbiAgICAgICAgQWdyYXZlOiAxOTIsXG4gICAgICAgIEFyaW5nOiAxOTcsXG4gICAgICAgIEF0aWxkZTogMTk1LFxuICAgICAgICBBdW1sOiAxOTYsXG4gICAgICAgIENjZWRpbDogMTk5LFxuICAgICAgICBFVEg6IDIwOCxcbiAgICAgICAgRWFjdXRlOiAyMDEsXG4gICAgICAgIEVjaXJjOiAyMDIsXG4gICAgICAgIEVncmF2ZTogMjAwLFxuICAgICAgICBFdW1sOiAyMDMsXG4gICAgICAgIElhY3V0ZTogMjA1LFxuICAgICAgICBJY2lyYzogMjA2LFxuICAgICAgICBJZ3JhdmU6IDIwNCxcbiAgICAgICAgSXVtbDogMjA3LFxuICAgICAgICBOdGlsZGU6IDIwOSxcbiAgICAgICAgT2FjdXRlOiAyMTEsXG4gICAgICAgIE9jaXJjOiAyMTIsXG4gICAgICAgIE9ncmF2ZTogMjEwLFxuICAgICAgICBPc2xhc2g6IDIxNixcbiAgICAgICAgT3RpbGRlOiAyMTMsXG4gICAgICAgIE91bWw6IDIxNCxcbiAgICAgICAgVEhPUk46IDIyMixcbiAgICAgICAgVWFjdXRlOiAyMTgsXG4gICAgICAgIFVjaXJjOiAyMTksXG4gICAgICAgIFVncmF2ZTogMjE3LFxuICAgICAgICBVdW1sOiAyMjAsXG4gICAgICAgIFlhY3V0ZTogMjIxLFxuICAgICAgICBhYWN1dGU6IDIyNSxcbiAgICAgICAgYWNpcmM6IDIyNixcbiAgICAgICAgYWVsaWc6IDIzMCxcbiAgICAgICAgYWdyYXZlOiAyMjQsXG4gICAgICAgIGFyaW5nOiAyMjksXG4gICAgICAgIGF0aWxkZTogMjI3LFxuICAgICAgICBhdW1sOiAyMjgsXG4gICAgICAgIGNjZWRpbDogMjMxLFxuICAgICAgICBlYWN1dGU6IDIzMyxcbiAgICAgICAgZWNpcmM6IDIzNCxcbiAgICAgICAgZWdyYXZlOiAyMzIsXG4gICAgICAgIGV0aDogMjQwLFxuICAgICAgICBldW1sOiAyMzUsXG4gICAgICAgIGlhY3V0ZTogMjM3LFxuICAgICAgICBpY2lyYzogMjM4LFxuICAgICAgICBpZ3JhdmU6IDIzNixcbiAgICAgICAgaXVtbDogMjM5LFxuICAgICAgICBudGlsZGU6IDI0MSxcbiAgICAgICAgb2FjdXRlOiAyNDMsXG4gICAgICAgIG9jaXJjOiAyNDQsXG4gICAgICAgIG9ncmF2ZTogMjQyLFxuICAgICAgICBvc2xhc2g6IDI0OCxcbiAgICAgICAgb3RpbGRlOiAyNDUsXG4gICAgICAgIG91bWw6IDI0NixcbiAgICAgICAgc3psaWc6IDIyMyxcbiAgICAgICAgdGhvcm46IDI1NCxcbiAgICAgICAgdWFjdXRlOiAyNTAsXG4gICAgICAgIHVjaXJjOiAyNTEsXG4gICAgICAgIHVncmF2ZTogMjQ5LFxuICAgICAgICB1dW1sOiAyNTIsXG4gICAgICAgIHlhY3V0ZTogMjUzLFxuICAgICAgICB5dW1sOiAyNTUsXG4gICAgICAgIGNvcHk6IDE2OSxcbiAgICAgICAgcmVnOiAxNzQsXG4gICAgICAgIG5ic3A6IDE2MCxcbiAgICAgICAgaWV4Y2w6IDE2MSxcbiAgICAgICAgY2VudDogMTYyLFxuICAgICAgICBwb3VuZDogMTYzLFxuICAgICAgICBjdXJyZW46IDE2NCxcbiAgICAgICAgeWVuOiAxNjUsXG4gICAgICAgIGJydmJhcjogMTY2LFxuICAgICAgICBzZWN0OiAxNjcsXG4gICAgICAgIHVtbDogMTY4LFxuICAgICAgICBvcmRmOiAxNzAsXG4gICAgICAgIGxhcXVvOiAxNzEsXG4gICAgICAgIG5vdDogMTcyLFxuICAgICAgICBzaHk6IDE3MyxcbiAgICAgICAgbWFjcjogMTc1LFxuICAgICAgICBkZWc6IDE3NixcbiAgICAgICAgcGx1c21uOiAxNzcsXG4gICAgICAgIHN1cDE6IDE4NSxcbiAgICAgICAgc3VwMjogMTc4LFxuICAgICAgICBzdXAzOiAxNzksXG4gICAgICAgIGFjdXRlOiAxODAsXG4gICAgICAgIG1pY3JvOiAxODEsXG4gICAgICAgIHBhcmE6IDE4MixcbiAgICAgICAgbWlkZG90OiAxODMsXG4gICAgICAgIGNlZGlsOiAxODQsXG4gICAgICAgIG9yZG06IDE4NixcbiAgICAgICAgcmFxdW86IDE4NyxcbiAgICAgICAgZnJhYzE0OiAxODgsXG4gICAgICAgIGZyYWMxMjogMTg5LFxuICAgICAgICBmcmFjMzQ6IDE5MCxcbiAgICAgICAgaXF1ZXN0OiAxOTEsXG4gICAgICAgIHRpbWVzOiAyMTUsXG4gICAgICAgIGRpdmlkZTogMjQ3LFxuICAgICAgICBPRWxpZzogMzM4LFxuICAgICAgICBvZWxpZzogMzM5LFxuICAgICAgICBTY2Fyb246IDM1MixcbiAgICAgICAgc2Nhcm9uOiAzNTMsXG4gICAgICAgIFl1bWw6IDM3NixcbiAgICAgICAgZm5vZjogNDAyLFxuICAgICAgICBjaXJjOiA3MTAsXG4gICAgICAgIHRpbGRlOiA3MzIsXG4gICAgICAgIEFscGhhOiA5MTMsXG4gICAgICAgIEJldGE6IDkxNCxcbiAgICAgICAgR2FtbWE6IDkxNSxcbiAgICAgICAgRGVsdGE6IDkxNixcbiAgICAgICAgRXBzaWxvbjogOTE3LFxuICAgICAgICBaZXRhOiA5MTgsXG4gICAgICAgIEV0YTogOTE5LFxuICAgICAgICBUaGV0YTogOTIwLFxuICAgICAgICBJb3RhOiA5MjEsXG4gICAgICAgIEthcHBhOiA5MjIsXG4gICAgICAgIExhbWJkYTogOTIzLFxuICAgICAgICBNdTogOTI0LFxuICAgICAgICBOdTogOTI1LFxuICAgICAgICBYaTogOTI2LFxuICAgICAgICBPbWljcm9uOiA5MjcsXG4gICAgICAgIFBpOiA5MjgsXG4gICAgICAgIFJobzogOTI5LFxuICAgICAgICBTaWdtYTogOTMxLFxuICAgICAgICBUYXU6IDkzMixcbiAgICAgICAgVXBzaWxvbjogOTMzLFxuICAgICAgICBQaGk6IDkzNCxcbiAgICAgICAgQ2hpOiA5MzUsXG4gICAgICAgIFBzaTogOTM2LFxuICAgICAgICBPbWVnYTogOTM3LFxuICAgICAgICBhbHBoYTogOTQ1LFxuICAgICAgICBiZXRhOiA5NDYsXG4gICAgICAgIGdhbW1hOiA5NDcsXG4gICAgICAgIGRlbHRhOiA5NDgsXG4gICAgICAgIGVwc2lsb246IDk0OSxcbiAgICAgICAgemV0YTogOTUwLFxuICAgICAgICBldGE6IDk1MSxcbiAgICAgICAgdGhldGE6IDk1MixcbiAgICAgICAgaW90YTogOTUzLFxuICAgICAgICBrYXBwYTogOTU0LFxuICAgICAgICBsYW1iZGE6IDk1NSxcbiAgICAgICAgbXU6IDk1NixcbiAgICAgICAgbnU6IDk1NyxcbiAgICAgICAgeGk6IDk1OCxcbiAgICAgICAgb21pY3JvbjogOTU5LFxuICAgICAgICBwaTogOTYwLFxuICAgICAgICByaG86IDk2MSxcbiAgICAgICAgc2lnbWFmOiA5NjIsXG4gICAgICAgIHNpZ21hOiA5NjMsXG4gICAgICAgIHRhdTogOTY0LFxuICAgICAgICB1cHNpbG9uOiA5NjUsXG4gICAgICAgIHBoaTogOTY2LFxuICAgICAgICBjaGk6IDk2NyxcbiAgICAgICAgcHNpOiA5NjgsXG4gICAgICAgIG9tZWdhOiA5NjksXG4gICAgICAgIHRoZXRhc3ltOiA5NzcsXG4gICAgICAgIHVwc2loOiA5NzgsXG4gICAgICAgIHBpdjogOTgyLFxuICAgICAgICBlbnNwOiA4MTk0LFxuICAgICAgICBlbXNwOiA4MTk1LFxuICAgICAgICB0aGluc3A6IDgyMDEsXG4gICAgICAgIHp3bmo6IDgyMDQsXG4gICAgICAgIHp3ajogODIwNSxcbiAgICAgICAgbHJtOiA4MjA2LFxuICAgICAgICBybG06IDgyMDcsXG4gICAgICAgIG5kYXNoOiA4MjExLFxuICAgICAgICBtZGFzaDogODIxMixcbiAgICAgICAgbHNxdW86IDgyMTYsXG4gICAgICAgIHJzcXVvOiA4MjE3LFxuICAgICAgICBzYnF1bzogODIxOCxcbiAgICAgICAgbGRxdW86IDgyMjAsXG4gICAgICAgIHJkcXVvOiA4MjIxLFxuICAgICAgICBiZHF1bzogODIyMixcbiAgICAgICAgZGFnZ2VyOiA4MjI0LFxuICAgICAgICBEYWdnZXI6IDgyMjUsXG4gICAgICAgIGJ1bGw6IDgyMjYsXG4gICAgICAgIGhlbGxpcDogODIzMCxcbiAgICAgICAgcGVybWlsOiA4MjQwLFxuICAgICAgICBwcmltZTogODI0MixcbiAgICAgICAgUHJpbWU6IDgyNDMsXG4gICAgICAgIGxzYXF1bzogODI0OSxcbiAgICAgICAgcnNhcXVvOiA4MjUwLFxuICAgICAgICBvbGluZTogODI1NCxcbiAgICAgICAgZnJhc2w6IDgyNjAsXG4gICAgICAgIGV1cm86IDgzNjQsXG4gICAgICAgIGltYWdlOiA4NDY1LFxuICAgICAgICB3ZWllcnA6IDg0NzIsXG4gICAgICAgIHJlYWw6IDg0NzYsXG4gICAgICAgIHRyYWRlOiA4NDgyLFxuICAgICAgICBhbGVmc3ltOiA4NTAxLFxuICAgICAgICBsYXJyOiA4NTkyLFxuICAgICAgICB1YXJyOiA4NTkzLFxuICAgICAgICByYXJyOiA4NTk0LFxuICAgICAgICBkYXJyOiA4NTk1LFxuICAgICAgICBoYXJyOiA4NTk2LFxuICAgICAgICBjcmFycjogODYyOSxcbiAgICAgICAgbEFycjogODY1NixcbiAgICAgICAgdUFycjogODY1NyxcbiAgICAgICAgckFycjogODY1OCxcbiAgICAgICAgZEFycjogODY1OSxcbiAgICAgICAgaEFycjogODY2MCxcbiAgICAgICAgZm9yYWxsOiA4NzA0LFxuICAgICAgICBwYXJ0OiA4NzA2LFxuICAgICAgICBleGlzdDogODcwNyxcbiAgICAgICAgZW1wdHk6IDg3MDksXG4gICAgICAgIG5hYmxhOiA4NzExLFxuICAgICAgICBpc2luOiA4NzEyLFxuICAgICAgICBub3RpbjogODcxMyxcbiAgICAgICAgbmk6IDg3MTUsXG4gICAgICAgIHByb2Q6IDg3MTksXG4gICAgICAgIHN1bTogODcyMSxcbiAgICAgICAgbWludXM6IDg3MjIsXG4gICAgICAgIGxvd2FzdDogODcyNyxcbiAgICAgICAgcmFkaWM6IDg3MzAsXG4gICAgICAgIHByb3A6IDg3MzMsXG4gICAgICAgIGluZmluOiA4NzM0LFxuICAgICAgICBhbmc6IDg3MzYsXG4gICAgICAgIGFuZDogODc0MyxcbiAgICAgICAgb3I6IDg3NDQsXG4gICAgICAgIGNhcDogODc0NSxcbiAgICAgICAgY3VwOiA4NzQ2LFxuICAgICAgICBpbnQ6IDg3NDcsXG4gICAgICAgIHRoZXJlNDogODc1NixcbiAgICAgICAgc2ltOiA4NzY0LFxuICAgICAgICBjb25nOiA4NzczLFxuICAgICAgICBhc3ltcDogODc3NixcbiAgICAgICAgbmU6IDg4MDAsXG4gICAgICAgIGVxdWl2OiA4ODAxLFxuICAgICAgICBsZTogODgwNCxcbiAgICAgICAgZ2U6IDg4MDUsXG4gICAgICAgIHN1YjogODgzNCxcbiAgICAgICAgc3VwOiA4ODM1LFxuICAgICAgICBuc3ViOiA4ODM2LFxuICAgICAgICBzdWJlOiA4ODM4LFxuICAgICAgICBzdXBlOiA4ODM5LFxuICAgICAgICBvcGx1czogODg1MyxcbiAgICAgICAgb3RpbWVzOiA4ODU1LFxuICAgICAgICBwZXJwOiA4ODY5LFxuICAgICAgICBzZG90OiA4OTAxLFxuICAgICAgICBsY2VpbDogODk2OCxcbiAgICAgICAgcmNlaWw6IDg5NjksXG4gICAgICAgIGxmbG9vcjogODk3MCxcbiAgICAgICAgcmZsb29yOiA4OTcxLFxuICAgICAgICBsYW5nOiA5MDAxLFxuICAgICAgICByYW5nOiA5MDAyLFxuICAgICAgICBsb3o6IDk2NzQsXG4gICAgICAgIHNwYWRlczogOTgyNCxcbiAgICAgICAgY2x1YnM6IDk4MjcsXG4gICAgICAgIGhlYXJ0czogOTgyOSxcbiAgICAgICAgZGlhbXM6IDk4MzAsXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgZSA9IHNheC5FTlRJVElFU1trZXldO1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiBlID09PSBcIm51bWJlclwiID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGU7XG4gICAgICAgIHNheC5FTlRJVElFU1trZXldID0gcztcbiAgICB9KTtcbiAgICBmb3IgKHZhciBzIGluIHNheC5TVEFURSkge1xuICAgICAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHM7XG4gICAgfVxuICAgIC8vIHNob3J0aGFuZFxuICAgIFMgPSBzYXguU1RBVEU7XG4gICAgZnVuY3Rpb24gZW1pdChwYXJzZXIsIGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdE5vZGUocGFyc2VyLCBub2RlVHlwZSwgZGF0YSkge1xuICAgICAgICBpZiAocGFyc2VyLnRleHROb2RlKVxuICAgICAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlVGV4dChwYXJzZXIpIHtcbiAgICAgICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKTtcbiAgICAgICAgaWYgKHBhcnNlci50ZXh0Tm9kZSlcbiAgICAgICAgICAgIGVtaXQocGFyc2VyLCBcIm9udGV4dFwiLCBwYXJzZXIudGV4dE5vZGUpO1xuICAgICAgICBwYXJzZXIudGV4dE5vZGUgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXh0b3B0cyhvcHQsIHRleHQpIHtcbiAgICAgICAgaWYgKG9wdC50cmltKVxuICAgICAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgICAgICBpZiAob3B0Lm5vcm1hbGl6ZSlcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyb3IocGFyc2VyLCBlcikge1xuICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICBlciArPVxuICAgICAgICAgICAgICAgIFwiXFxuTGluZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuQ29sdW1uOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gK1xuICAgICAgICAgICAgICAgICAgICBcIlxcbkNoYXI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmM7XG4gICAgICAgIH1cbiAgICAgICAgZXIgPSBuZXcgRXJyb3IoZXIpO1xuICAgICAgICBwYXJzZXIuZXJyb3IgPSBlcjtcbiAgICAgICAgZW1pdChwYXJzZXIsIFwib25lcnJvclwiLCBlcik7XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZChwYXJzZXIpIHtcbiAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdClcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuY2xvc2VkIHJvb3QgdGFnXCIpO1xuICAgICAgICBpZiAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOICYmXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU5fV0hJVEVTUEFDRSAmJlxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlICE9PSBTLlRFWFQpIHtcbiAgICAgICAgICAgIGVycm9yKHBhcnNlciwgXCJVbmV4cGVjdGVkIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgcGFyc2VyLmMgPSBcIlwiO1xuICAgICAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgZW1pdChwYXJzZXIsIFwib25lbmRcIik7XG4gICAgICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdCk7XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmljdEZhaWwocGFyc2VyLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSBcIm9iamVjdFwiIHx8ICEocGFyc2VyIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGNhbGwgdG8gc3RyaWN0RmFpbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuZXdUYWcocGFyc2VyKSB7XG4gICAgICAgIGlmICghcGFyc2VyLnN0cmljdClcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgdmFyIHRhZyA9IChwYXJzZXIudGFnID0geyBuYW1lOiBwYXJzZXIudGFnTmFtZSwgYXR0cmlidXRlczoge30gfSk7XG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0YWcgY29udGFpbHMgYW4geG1sbnM9XCJmb29cIiBvciB4bWxuczpmb289XCJiYXJcIlxuICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgICAgICAgdGFnLm5zID0gcGFyZW50Lm5zO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW50YWdzdGFydFwiLCB0YWcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxbmFtZShuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICB2YXIgcXVhbE5hbWUgPSBpIDwgMCA/IFtcIlwiLCBuYW1lXSA6IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF07XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lWzFdO1xuICAgICAgICAvLyA8eCBcInhtbG5zXCI9XCJodHRwOi8vZm9vXCI+XG4gICAgICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gXCJ4bWxuc1wiKSB7XG4gICAgICAgICAgICBwcmVmaXggPSBcInhtbG5zXCI7XG4gICAgICAgICAgICBsb2NhbCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIGxvY2FsOiBsb2NhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyaWIocGFyc2VyKSB7XG4gICAgICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLmF0dHJpYk5hbWUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeDtcbiAgICAgICAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJ4bWxuc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT09IFwieG1sXCIgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcInhtbDogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgWE1MX05BTUVTUEFDRSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQWN0dWFsOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhbCA9PT0gXCJ4bWxuc1wiICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcInhtbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBYTUxOU19OQU1FU1BBQ0UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkFjdHVhbDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZmVyIG9uYXR0cmlidXRlIGV2ZW50cyB1bnRpbCBhbGwgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2VlblxuICAgICAgICAgICAgLy8gc28gYW55IG5ldyBiaW5kaW5ncyBjYW4gdGFrZSBlZmZlY3QuIHByZXNlcnZlIGF0dHJpYnV0ZSBvcmRlclxuICAgICAgICAgICAgLy8gc28gZGVmZXJyZWQgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIGluIGRvY3VtZW50IG9yZGVyXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTGlzdC5wdXNoKFtwYXJzZXIuYXR0cmliTmFtZSwgcGFyc2VyLmF0dHJpYlZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWU7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25hdHRyaWJ1dGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZXIuYXR0cmliVmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5UYWcocGFyc2VyLCBzZWxmQ2xvc2luZykge1xuICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgICAgICAgLy8gZW1pdCBuYW1lc3BhY2UgYmluZGluZyBldmVudHNcbiAgICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnO1xuICAgICAgICAgICAgLy8gYWRkIG5hbWVzcGFjZSBpbmZvIHRvIHRhZ1xuICAgICAgICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLnRhZ05hbWUpO1xuICAgICAgICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeDtcbiAgICAgICAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsO1xuICAgICAgICAgICAgdGFnLnVyaSA9IHRhZy5uc1txbi5wcmVmaXhdIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogXCIgKyBKU09OLnN0cmluZ2lmeShwYXJzZXIudGFnTmFtZSkpO1xuICAgICAgICAgICAgICAgIHRhZy51cmkgPSBxbi5wcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICAgICAgaWYgKHRhZy5ucyAmJiBwYXJlbnQubnMgIT09IHRhZy5ucykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVubmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZlcnJlZCBvbmF0dHJpYnV0ZSBldmVudHNcbiAgICAgICAgICAgIC8vIE5vdGU6IGRvIG5vdCBhcHBseSBkZWZhdWx0IG5zIHRvIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAvLyAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwtbmFtZXMvI2RlZmF1bHRpbmdcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBudlswXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBudlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4O1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsO1xuICAgICAgICAgICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09IFwiXCIgPyBcIlwiIDogdGFnLm5zW3ByZWZpeF0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgICAgICAgICAgICB1cmk6IHVyaSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IGF0dHJpYnV0ZXMgd2l0aCBhbiB1bmRlZmluZWQgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ICYmIHByZWZpeCAhPT0gXCJ4bWxuc1wiICYmICF1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiBcIiArIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpO1xuICAgICAgICAgICAgICAgICAgICBhLnVyaSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW25hbWVdID0gYTtcbiAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25hdHRyaWJ1dGVcIiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWcuaXNTZWxmQ2xvc2luZyA9ICEhc2VsZkNsb3Npbmc7XG4gICAgICAgIC8vIHByb2Nlc3MgdGhlIHRhZ1xuICAgICAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWU7XG4gICAgICAgIHBhcnNlci50YWdzLnB1c2gocGFyc2VyLnRhZyk7XG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW50YWdcIiwgcGFyc2VyLnRhZyk7XG4gICAgICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPHNjcmlwdD4gaW4gbm9uLXN0cmljdCBtb2RlLlxuICAgICAgICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRhZyA9IG51bGw7XG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBcIlwiO1xuICAgICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZVRhZyhwYXJzZXIpIHtcbiAgICAgICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiV2VpcmQgZW1wdHkgY2xvc2UgdGFnLlwiKTtcbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBcIjwvPlwiO1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLnRhZ05hbWUgIT09IFwic2NyaXB0XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnNjcmlwdFwiLCBwYXJzZXIuc2NyaXB0KTtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zaW5nIHRhZyBhY3R1YWxseSBleGlzdHMuXG4gICAgICAgIC8vIDxhPjxiPjwvYz48L2I+PC9hPiB3aWxsIGNsb3NlIGV2ZXJ5dGhpbmcsIG90aGVyd2lzZS5cbiAgICAgICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGg7XG4gICAgICAgIHZhciB0YWdOYW1lID0gcGFyc2VyLnRhZ05hbWU7XG4gICAgICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvc2VUbyA9IHRhZ05hbWU7XG4gICAgICAgIHdoaWxlICh0LS0pIHtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdO1xuICAgICAgICAgICAgaWYgKGNsb3NlLm5hbWUgIT09IGNsb3NlVG8pIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5leHBlY3RlZCBjbG9zZSB0YWdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5tYXRjaGVkIGNsb3NpbmcgdGFnOiBcIiArIHBhcnNlci50YWdOYW1lKTtcbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBcIjwvXCIgKyBwYXJzZXIudGFnTmFtZSArIFwiPlwiO1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gdGFnTmFtZTtcbiAgICAgICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChzLS0gPiB0KSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gKHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKSk7XG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZTtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNsb3NldGFnXCIsIHBhcnNlci50YWdOYW1lKTtcbiAgICAgICAgICAgIHZhciB4ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICAgICAgICAgIHhbaV0gPSB0YWcubnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMgJiYgdGFnLm5zICE9PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdO1xuICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jbG9zZW5hbWVzcGFjZVwiLCB7IHByZWZpeDogcCwgdXJpOiBuIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ID09PSAwKVxuICAgICAgICAgICAgcGFyc2VyLmNsb3NlZFJvb3QgPSB0cnVlO1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUVudGl0eShwYXJzZXIpIHtcbiAgICAgICAgdmFyIGVudGl0eSA9IHBhcnNlci5lbnRpdHk7XG4gICAgICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgbnVtO1xuICAgICAgICB2YXIgbnVtU3RyID0gXCJcIjtcbiAgICAgICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdO1xuICAgICAgICB9XG4gICAgICAgIGVudGl0eSA9IGVudGl0eUxDO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDEpID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KTtcbiAgICAgICAgICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApO1xuICAgICAgICAgICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sIFwiXCIpO1xuICAgICAgICBpZiAoaXNOYU4obnVtKSB8fCBudW1TdHIudG9Mb3dlckNhc2UoKSAhPT0gZW50aXR5KSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHlcIik7XG4gICAgICAgICAgICByZXR1cm4gXCImXCIgKyBwYXJzZXIuZW50aXR5ICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQTtcbiAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIGhhdmUgdG8gcHJvY2VzcyB0aGlzIGFzIGEgdGV4dCBub2RlLlxuICAgICAgICAgICAgLy8gd2VpcmQsIGJ1dCBoYXBwZW5zLlxuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy5cIik7XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgPSBjO1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYXJBdChjaHVuaywgaSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGkgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNodW5rLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZShjaHVuaykge1xuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihwYXJzZXIsIFwiQ2Fubm90IHdyaXRlIGFmdGVyIGNsb3NlLiBBc3NpZ24gYW4gb25yZWFkeSBoYW5kbGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQocGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYyA9IFwiXCI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspO1xuICAgICAgICAgICAgcGFyc2VyLmMgPSBjO1xuICAgICAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUy5CRUdJTjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXHVGRUZGXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5URVhUOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSBcIjxcIiAmJiBjICE9PSBcIiZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlRleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlNDUklQVDpcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBcIjxcIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgYSAvLCA/LCAhLCBvciB0ZXh0IGlzIGNvbWluZyBuZXh0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBRztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmVuY29kZWQgPFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZCA9IHBhcnNlci5wb3NpdGlvbiAtIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgQXJyYXkocGFkKS5qb2luKFwiIFwiKSArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gXCI8XCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gQ0RBVEEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW5jZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSBcIi0tXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IERPQ1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuZG9jdHlwZSB8fCBwYXJzZXIuc2F3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkluYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25zZ21sZGVjbGFyYXRpb25cIiwgcGFyc2VyLnNnbWxEZWNsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uZG9jdHlwZVwiLCBwYXJzZXIuZG9jdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9IHRydWU7IC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5xID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuRE9DVFlQRV9RVU9URUQ6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREX1FVT1RFRDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci5jb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNvbW1lbnRcIiwgcGFyc2VyLmNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gXCItXCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIk1hbGZvcm1lZCBjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IFwiLS1cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IFwiXVwiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jZGF0YVwiLCBwYXJzZXIuY2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2xvc2VjZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBcIl1dXCIgKyBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuUFJPQ19JTlNUOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9CT0RZOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfRU5ESU5HOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnByb2Nlc3NpbmdpbnN0cnVjdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLnByb2NJbnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJzZXIucHJvY0luc3RCb2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9IFwiP1wiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgY2hhcmFjdGVyIGluIHRhZyBuYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuT1BFTl9UQUdfU0xBU0g6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkZvcndhcmQtc2xhc2ggaW4gb3BlbmluZyB0YWcgbm90IGZvbGxvd2VkIGJ5ID5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCOlxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlbid0IHJlYWQgdGhlIGF0dHJpYnV0ZSBuYW1lIHlldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkF0dHJpYnV0ZSB3aXRob3V0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVfU0FXX1dISVRFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX05BTUVfU0FXX1dISVRFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmF0dHJpYnV0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9RVU9URUQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXR0cmliRW5kKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXR0cmliKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm90TWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gXCI8L1wiICsgYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHX1NBV19XSElURTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5TdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBcInRleHROb2RlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiYXR0cmliVmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBcImF0dHJpYlZhbHVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLm9wdC51bnBhcnNlZEVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZEVudGl0eSA9IHBhcnNlRW50aXR5KHBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLndyaXRlKHBhcnNlZEVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTWF0Y2gocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZW50aXR5ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBlbnRpdHkgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9IFwiJlwiICsgcGFyc2VyLmVudGl0eSArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgXCJVbmtub3duIHN0YXRlOiBcIiArIHBhcnNlci5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIHdoaWxlXG4gICAgICAgIGlmIChwYXJzZXIucG9zaXRpb24gPj0gcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNoZWNrQnVmZmVyTGVuZ3RoKHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMS4wIGJ5IEBtYXRoaWFzICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICAgICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgTUFYX1NJWkUgPSAweDQwMDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgICAgICAgICAgIHZhciBsb3dTdXJyb2dhdGU7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMGZmZmYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50OiBcIiArIGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweGRjMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCBcImZyb21Db2RlUG9pbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNheDtcbn07XG5jb25zdCBzYXggPSAvKiogI19fUFVSRV9fICovIGluaXRpYWxpemVTYXgoKTtcbmV4cG9ydHMuc2F4ID0gc2F4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/sax-js/sax.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/signal.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raceWithSignal = raceWithSignal;\nasync function raceWithSignal(promise, signal) {\n    if (signal === undefined) {\n        return promise;\n    }\n    let listener;\n    return Promise.race([\n        promise.catch((err) => {\n            if (!signal?.aborted) {\n                throw err;\n            }\n            else {\n                return undefined;\n            }\n        }),\n        new Promise((_, reject) => {\n            listener = () => {\n                reject(new Error(\"Aborted\"));\n            };\n            signal.addEventListener(\"abort\", listener);\n            // Must be here inside the promise to avoid a race condition\n            if (signal.aborted) {\n                reject(new Error(\"Aborted\"));\n            }\n        }),\n    ]).finally(() => signal.removeEventListener(\"abort\", listener));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3NpZ25hbC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhY2VXaXRoU2lnbmFsID0gcmFjZVdpdGhTaWduYWw7XG5hc3luYyBmdW5jdGlvbiByYWNlV2l0aFNpZ25hbChwcm9taXNlLCBzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGxldCBsaXN0ZW5lcjtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRlZFwiKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGhlcmUgaW5zaWRlIHRoZSBwcm9taXNlIHRvIGF2b2lkIGEgcmFjZSBjb25kaXRpb25cbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgXSkuZmluYWxseSgoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/stream.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncGeneratorWithSetup = exports.IterableReadableStream = void 0;\nexports.atee = atee;\nexports.concat = concat;\nexports.pipeGeneratorWithSetup = pipeGeneratorWithSetup;\nconst config_js_1 = __webpack_require__(/*! ../runnables/config.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/config.cjs\");\nconst index_js_1 = __webpack_require__(/*! ../singletons/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/singletons/index.cjs\");\nconst signal_js_1 = __webpack_require__(/*! ./signal.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/signal.cjs\");\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\nexports.IterableReadableStream = IterableReadableStream;\nfunction atee(iter, length = 2) {\n    const buffers = Array.from({ length }, () => []);\n    return buffers.map(async function* makeIter(buffer) {\n        while (true) {\n            if (buffer.length === 0) {\n                const result = await iter.next();\n                for (const buffer of buffers) {\n                    buffer.push(result);\n                }\n            }\n            else if (buffer[0].done) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                yield buffer.shift().value;\n            }\n        }\n    });\n}\nfunction concat(first, second) {\n    if (Array.isArray(first) && Array.isArray(second)) {\n        return first.concat(second);\n    }\n    else if (typeof first === \"string\" && typeof second === \"string\") {\n        return (first + second);\n    }\n    else if (typeof first === \"number\" && typeof second === \"number\") {\n        return (first + second);\n    }\n    else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in first &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof first.concat === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return first.concat(second);\n    }\n    else if (typeof first === \"object\" && typeof second === \"object\") {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const chunk = { ...first };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        for (const [key, value] of Object.entries(second)) {\n            if (key in chunk && !Array.isArray(chunk[key])) {\n                chunk[key] = concat(chunk[key], value);\n            }\n            else {\n                chunk[key] = value;\n            }\n        }\n        return chunk;\n    }\n    else {\n        throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n    }\n}\nclass AsyncGeneratorWithSetup {\n    constructor(params) {\n        Object.defineProperty(this, \"generator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"setup\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"signal\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResult\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"firstResultUsed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.generator = params.generator;\n        this.config = params.config;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.signal = params.signal ?? this.config?.signal;\n        // setup is a promise that resolves only after the first iterator value\n        // is available. this is useful when setup of several piped generators\n        // needs to happen in logical order, ie. in the order in which input to\n        // to each generator is available.\n        this.setup = new Promise((resolve, reject) => {\n            void index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(params.config), async () => {\n                this.firstResult = params.generator.next();\n                if (params.startSetup) {\n                    this.firstResult.then(params.startSetup).then(resolve, reject);\n                }\n                else {\n                    this.firstResult.then((_result) => resolve(undefined), reject);\n                }\n            }, true);\n        });\n    }\n    async next(...args) {\n        this.signal?.throwIfAborted();\n        if (!this.firstResultUsed) {\n            this.firstResultUsed = true;\n            return this.firstResult;\n        }\n        return index_js_1.AsyncLocalStorageProviderSingleton.runWithConfig((0, config_js_1.pickRunnableConfigKeys)(this.config), this.signal\n            ? async () => {\n                return (0, signal_js_1.raceWithSignal)(this.generator.next(...args), this.signal);\n            }\n            : async () => {\n                return this.generator.next(...args);\n            }, true);\n    }\n    async return(value) {\n        return this.generator.return(value);\n    }\n    async throw(e) {\n        return this.generator.throw(e);\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n}\nexports.AsyncGeneratorWithSetup = AsyncGeneratorWithSetup;\nasync function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {\n    const gen = new AsyncGeneratorWithSetup({\n        generator,\n        startSetup,\n        signal,\n    });\n    const setup = await gen.setup;\n    return { output: to(gen, setup, ...args), setup };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyw4QkFBOEI7QUFDaEUsWUFBWTtBQUNaLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsTUFBTSxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAgPSBleHBvcnRzLkl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gPSB2b2lkIDA7XG5leHBvcnRzLmF0ZWUgPSBhdGVlO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5leHBvcnRzLnBpcGVHZW5lcmF0b3JXaXRoU2V0dXAgPSBwaXBlR2VuZXJhdG9yV2l0aFNldHVwO1xuY29uc3QgY29uZmlnX2pzXzEgPSByZXF1aXJlKFwiLi4vcnVubmFibGVzL2NvbmZpZy5janNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3NpbmdsZXRvbnMvaW5kZXguY2pzXCIpO1xuY29uc3Qgc2lnbmFsX2pzXzEgPSByZXF1aXJlKFwiLi9zaWduYWwuY2pzXCIpO1xuLypcbiAqIFN1cHBvcnQgYXN5bmMgaXRlcmF0b3Igc3ludGF4IGZvciBSZWFkYWJsZVN0cmVhbXMgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL01hdHRpYXNCdWVsZW5zL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3B1bGwvMTIyI2lzc3VlY29tbWVudC0xNjI3MzU0NDkwXG4gKi9cbmNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlIE5vdCBwcmVzZW50IGluIE5vZGUgMTggdHlwZXMsIHJlcXVpcmVkIGluIGxhdGVzdCBOb2RlIDIyXG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJldHVybigpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JdGVyYWJsZVJlYWRhYmxlU3RyZWFtID0gSXRlcmFibGVSZWFkYWJsZVN0cmVhbTtcbmZ1bmN0aW9uIGF0ZWUoaXRlciwgbGVuZ3RoID0gMikge1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IFtdKTtcbiAgICByZXR1cm4gYnVmZmVycy5tYXAoYXN5bmMgZnVuY3Rpb24qIG1ha2VJdGVyKGJ1ZmZlcikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnVmZmVyWzBdLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIHlpZWxkIGJ1ZmZlci5zaGlmdCgpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjb25jYXQoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSAmJiBBcnJheS5pc0FycmF5KHNlY29uZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKGZpcnN0ICsgc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgXCJjb25jYXRcIiBpbiBmaXJzdCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0eXBlb2YgZmlyc3QuY29uY2F0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjaHVuayA9IHsgLi4uZmlyc3QgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vjb25kKSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBjaHVuayAmJiAhQXJyYXkuaXNBcnJheShjaHVua1trZXldKSkge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSBjb25jYXQoY2h1bmtba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmNhdCAke3R5cGVvZiBmaXJzdH0gYW5kICR7dHlwZW9mIHNlY29uZH1gKTtcbiAgICB9XG59XG5jbGFzcyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR1cFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnbmFsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0UmVzdWx0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0UmVzdWx0VXNlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gcGFyYW1zLmdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBwYXJhbXMuY29uZmlnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnNpZ25hbCA9IHBhcmFtcy5zaWduYWwgPz8gdGhpcy5jb25maWc/LnNpZ25hbDtcbiAgICAgICAgLy8gc2V0dXAgaXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25seSBhZnRlciB0aGUgZmlyc3QgaXRlcmF0b3IgdmFsdWVcbiAgICAgICAgLy8gaXMgYXZhaWxhYmxlLiB0aGlzIGlzIHVzZWZ1bCB3aGVuIHNldHVwIG9mIHNldmVyYWwgcGlwZWQgZ2VuZXJhdG9yc1xuICAgICAgICAvLyBuZWVkcyB0byBoYXBwZW4gaW4gbG9naWNhbCBvcmRlciwgaWUuIGluIHRoZSBvcmRlciBpbiB3aGljaCBpbnB1dCB0b1xuICAgICAgICAvLyB0byBlYWNoIGdlbmVyYXRvciBpcyBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2V0dXAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKCgwLCBjb25maWdfanNfMS5waWNrUnVubmFibGVDb25maWdLZXlzKShwYXJhbXMuY29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQgPSBwYXJhbXMuZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnN0YXJ0U2V0dXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKHBhcmFtcy5zdGFydFNldHVwKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0LnRoZW4oKF9yZXN1bHQpID0+IHJlc29sdmUodW5kZWZpbmVkKSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIG5leHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UmVzdWx0VXNlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4X2pzXzEuQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKCgwLCBjb25maWdfanNfMS5waWNrUnVubmFibGVDb25maWdLZXlzKSh0aGlzLmNvbmZpZyksIHRoaXMuc2lnbmFsXG4gICAgICAgICAgICA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHNpZ25hbF9qc18xLnJhY2VXaXRoU2lnbmFsKSh0aGlzLmdlbmVyYXRvci5uZXh0KC4uLmFyZ3MpLCB0aGlzLnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnJldHVybih2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHRocm93KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnRocm93KGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgTm90IHByZXNlbnQgaW4gTm9kZSAxOCB0eXBlcywgcmVxdWlyZWQgaW4gbGF0ZXN0IE5vZGUgMjJcbiAgICBhc3luYyBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmV0dXJuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY0dlbmVyYXRvcldpdGhTZXR1cCA9IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwO1xuYXN5bmMgZnVuY3Rpb24gcGlwZUdlbmVyYXRvcldpdGhTZXR1cCh0bywgZ2VuZXJhdG9yLCBzdGFydFNldHVwLCBzaWduYWwsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBnZW4gPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICBnZW5lcmF0b3IsXG4gICAgICAgIHN0YXJ0U2V0dXAsXG4gICAgICAgIHNpZ25hbCxcbiAgICB9KTtcbiAgICBjb25zdCBzZXR1cCA9IGF3YWl0IGdlbi5zZXR1cDtcbiAgICByZXR1cm4geyBvdXRwdXQ6IHRvKGdlbiwgc2V0dXAsIC4uLmFyZ3MpLCBzZXR1cCB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/tiktoken.cjs ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncoding = getEncoding;\nexports.encodingForModel = encodingForModel;\nconst lite_1 = __webpack_require__(/*! js-tiktoken/lite */ \"(rsc)/./node_modules/js-tiktoken/dist/lite.cjs\");\nconst async_caller_js_1 = __webpack_require__(/*! ./async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");\nconst cache = {};\nconst caller = /* #__PURE__ */ new async_caller_js_1.AsyncCaller({});\nasync function getEncoding(encoding) {\n    if (!(encoding in cache)) {\n        cache[encoding] = caller\n            .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n            .then((res) => res.json())\n            .then((data) => new lite_1.Tiktoken(data))\n            .catch((e) => {\n            delete cache[encoding];\n            throw e;\n        });\n    }\n    return await cache[encoding];\n}\nasync function encodingForModel(model) {\n    return getEncoding((0, lite_1.getEncodingNameForModel)(model));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdGlrdG9rZW4uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDdEQ7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3Rpa3Rva2VuLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW5jb2RpbmcgPSBnZXRFbmNvZGluZztcbmV4cG9ydHMuZW5jb2RpbmdGb3JNb2RlbCA9IGVuY29kaW5nRm9yTW9kZWw7XG5jb25zdCBsaXRlXzEgPSByZXF1aXJlKFwianMtdGlrdG9rZW4vbGl0ZVwiKTtcbmNvbnN0IGFzeW5jX2NhbGxlcl9qc18xID0gcmVxdWlyZShcIi4vYXN5bmNfY2FsbGVyLmNqc1wiKTtcbmNvbnN0IGNhY2hlID0ge307XG5jb25zdCBjYWxsZXIgPSAvKiAjX19QVVJFX18gKi8gbmV3IGFzeW5jX2NhbGxlcl9qc18xLkFzeW5jQ2FsbGVyKHt9KTtcbmFzeW5jIGZ1bmN0aW9uIGdldEVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKCEoZW5jb2RpbmcgaW4gY2FjaGUpKSB7XG4gICAgICAgIGNhY2hlW2VuY29kaW5nXSA9IGNhbGxlclxuICAgICAgICAgICAgLmZldGNoKGBodHRwczovL3Rpa3Rva2VuLnBhZ2VzLmRldi9qcy8ke2VuY29kaW5nfS5qc29uYClcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4gbmV3IGxpdGVfMS5UaWt0b2tlbihkYXRhKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2VuY29kaW5nXTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY2FjaGVbZW5jb2RpbmddO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jb2RpbmdGb3JNb2RlbChtb2RlbCkge1xuICAgIHJldHVybiBnZXRFbmNvZGluZygoMCwgbGl0ZV8xLmdldEVuY29kaW5nTmFtZUZvck1vZGVsKShtb2RlbCkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/tiktoken.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/index.cjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./zod.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnRkFBVyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vem9kLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/dist/utils/types/zod.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isZodSchemaV4 = isZodSchemaV4;\nexports.isZodSchemaV3 = isZodSchemaV3;\nexports.isZodSchema = isZodSchema;\nexports.isInteropZodSchema = isInteropZodSchema;\nexports.interopSafeParseAsync = interopSafeParseAsync;\nexports.interopParseAsync = interopParseAsync;\nexports.interopSafeParse = interopSafeParse;\nexports.interopParse = interopParse;\nexports.getSchemaDescription = getSchemaDescription;\nexports.isShapelessZodSchema = isShapelessZodSchema;\nexports.isSimpleStringZodSchema = isSimpleStringZodSchema;\nexports.isZodObjectV3 = isZodObjectV3;\nexports.isZodObjectV4 = isZodObjectV4;\nexports.isZodArrayV4 = isZodArrayV4;\nexports.isInteropZodObject = isInteropZodObject;\nexports.getInteropZodObjectShape = getInteropZodObjectShape;\nexports.extendInteropZodObject = extendInteropZodObject;\nexports.interopZodObjectPartial = interopZodObjectPartial;\nexports.interopZodObjectStrict = interopZodObjectStrict;\nexports.interopZodObjectPassthrough = interopZodObjectPassthrough;\nexports.getInteropZodDefaultGetter = getInteropZodDefaultGetter;\nexports.interopZodTransformInputSchema = interopZodTransformInputSchema;\nconst core_1 = __webpack_require__(/*! zod/v4/core */ \"(rsc)/./node_modules/zod/v4/core/index.cjs\");\nfunction isZodSchemaV4(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_zod\" in obj)) {\n        return false;\n    }\n    const zod = obj._zod;\n    return (typeof zod === \"object\" &&\n        zod !== null &&\n        \"def\" in zod);\n}\nfunction isZodSchemaV3(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_def\" in obj) || \"_zod\" in obj) {\n        return false;\n    }\n    const def = obj._def;\n    return (typeof def === \"object\" &&\n        def != null &&\n        \"typeName\" in def);\n}\n/** Backward compatible isZodSchema for Zod 3 */\nfunction isZodSchema(schema) {\n    if (isZodSchemaV4(schema)) {\n        console.warn(\"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\");\n    }\n    return isZodSchemaV3(schema);\n}\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nfunction isInteropZodSchema(input) {\n    if (!input) {\n        return false;\n    }\n    if (typeof input !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(input)) {\n        return false;\n    }\n    if (isZodSchemaV4(input) ||\n        isZodSchemaV3(input)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopSafeParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = await (0, core_1.parseAsync)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nasync function interopParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0, core_1.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopSafeParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = (0, core_1.parse)(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nfunction interopParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return (0, core_1.parse)(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nfunction getSchemaDescription(schema) {\n    if (isZodSchemaV4(schema)) {\n        return core_1.globalRegistry.get(schema)?.description;\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.description;\n    }\n    if (\"description\" in schema && typeof schema.description === \"string\") {\n        return schema.description;\n    }\n    return undefined;\n}\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nfunction isShapelessZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // Check for v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // ZodObject is only shaped if it has actual shape keys\n        if (def.typeName === \"ZodObject\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // ZodRecord is shapeless (dynamic key-value mapping)\n        if (def.typeName === \"ZodRecord\") {\n            return true;\n        }\n    }\n    // Check for v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Object type is only shaped if it has actual shape keys\n        if (def.type === \"object\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // Record type is shapeless (dynamic key-value mapping)\n        if (def.type === \"record\") {\n            return true;\n        }\n    }\n    // For other schemas, check if they have a `shape` property\n    // If they don't have shape, they're likely shapeless\n    if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nfunction isSimpleStringZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // For v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // Only accept basic ZodString\n        return def.typeName === \"ZodString\";\n    }\n    // For v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Only accept basic string type\n        return def.type === \"string\";\n    }\n    return false;\n}\nfunction isZodObjectV3(obj) {\n    // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_def\" in obj &&\n        typeof obj._def === \"object\" &&\n        obj._def !== null &&\n        \"typeName\" in obj._def &&\n        obj._def.typeName === \"ZodObject\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodObjectV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 object schemas have _zod.def.type === \"object\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"object\") {\n        return true;\n    }\n    return false;\n}\nfunction isZodArrayV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 array schemas have _zod.def.type === \"array\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"array\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nfunction isInteropZodObject(obj) {\n    if (isZodObjectV3(obj))\n        return true;\n    if (isZodObjectV4(obj))\n        return true;\n    return false;\n}\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction getInteropZodObjectShape(schema) {\n    if (isZodSchemaV3(schema)) {\n        return schema.shape;\n    }\n    if (isZodSchemaV4(schema)) {\n        return schema._zod.def.shape;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction extendInteropZodObject(schema, extension) {\n    if (isZodSchemaV3(schema)) {\n        return schema.extend(extension);\n    }\n    if (isZodSchemaV4(schema)) {\n        return core_1.util.extend(schema, extension);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPartial(schema) {\n    if (isZodSchemaV3(schema)) {\n        // z3: .partial() exists and works as expected\n        return schema.partial();\n    }\n    if (isZodSchemaV4(schema)) {\n        // z4: util.partial exists and works as expected\n        return core_1.util.partial(core_1.$ZodOptional, schema, undefined);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectStrict(schema, recursive = false) {\n    if (isZodSchemaV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.strict();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it strict\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectStrict(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema strict if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectStrict(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0, core_1.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = core_1.globalRegistry.get(keySchema);\n                if (meta)\n                    core_1.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0, core_1.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0, core_1._never)(core_1.$ZodNever),\n        });\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nfunction interopZodObjectPassthrough(schema, recursive = false) {\n    if (isZodObjectV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.passthrough();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it passthrough\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectPassthrough(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema passthrough if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectPassthrough(elementSchema, recursive);\n                    }\n                    outputShape[key] = (0, core_1.clone)(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = core_1.globalRegistry.get(keySchema);\n                if (meta)\n                    core_1.globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = (0, core_1.clone)(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: (0, core_1._unknown)(core_1.$ZodUnknown),\n        });\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nfunction getInteropZodDefaultGetter(schema) {\n    if (isZodSchemaV3(schema)) {\n        try {\n            const defaultValue = schema.parse(undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    if (isZodSchemaV4(schema)) {\n        try {\n            const defaultValue = (0, core_1.parse)(schema, undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return undefined;\n}\nfunction isZodTransformV3(schema) {\n    return (isZodSchemaV3(schema) &&\n        \"typeName\" in schema._def &&\n        schema._def.typeName === \"ZodEffects\");\n}\nfunction isZodTransformV4(schema) {\n    return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nfunction interopZodTransformInputSchema(schema, recursive = false) {\n    // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n    if (isZodSchemaV3(schema)) {\n        if (isZodTransformV3(schema)) {\n            return interopZodTransformInputSchema(schema._def.schema, recursive);\n        }\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema;\n    }\n    // Zod v4: _def.type is the input schema for ZodEffects (transform)\n    if (isZodSchemaV4(schema)) {\n        let outputSchema = schema;\n        if (isZodTransformV4(schema)) {\n            outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);\n        }\n        if (recursive) {\n            // Handle nested object schemas\n            if (isZodObjectV4(outputSchema)) {\n                const outputShape = outputSchema._zod.def.shape;\n                for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) {\n                    outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);\n                }\n                outputSchema = (0, core_1.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    shape: outputShape,\n                });\n            }\n            // Handle nested array schemas\n            else if (isZodArrayV4(outputSchema)) {\n                const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);\n                outputSchema = (0, core_1.clone)(outputSchema, {\n                    ...outputSchema._zod.def,\n                    element: elementSchema,\n                });\n            }\n        }\n        const meta = core_1.globalRegistry.get(schema);\n        if (meta)\n            core_1.globalRegistry.add(outputSchema, meta);\n        return outputSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvem9kLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQyxzQ0FBc0M7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSx1Q0FBdUM7QUFDcEQsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQixhQUFhLDhCQUE4QjtBQUMzQztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxHQUFHO0FBQ2hCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSwwQkFBMEI7QUFDdkMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLGtCQUFrQjtBQUMvQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhLGtCQUFrQjtBQUMvQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxrQkFBa0I7QUFDL0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy90eXBlcy96b2QuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1pvZFNjaGVtYVY0ID0gaXNab2RTY2hlbWFWNDtcbmV4cG9ydHMuaXNab2RTY2hlbWFWMyA9IGlzWm9kU2NoZW1hVjM7XG5leHBvcnRzLmlzWm9kU2NoZW1hID0gaXNab2RTY2hlbWE7XG5leHBvcnRzLmlzSW50ZXJvcFpvZFNjaGVtYSA9IGlzSW50ZXJvcFpvZFNjaGVtYTtcbmV4cG9ydHMuaW50ZXJvcFNhZmVQYXJzZUFzeW5jID0gaW50ZXJvcFNhZmVQYXJzZUFzeW5jO1xuZXhwb3J0cy5pbnRlcm9wUGFyc2VBc3luYyA9IGludGVyb3BQYXJzZUFzeW5jO1xuZXhwb3J0cy5pbnRlcm9wU2FmZVBhcnNlID0gaW50ZXJvcFNhZmVQYXJzZTtcbmV4cG9ydHMuaW50ZXJvcFBhcnNlID0gaW50ZXJvcFBhcnNlO1xuZXhwb3J0cy5nZXRTY2hlbWFEZXNjcmlwdGlvbiA9IGdldFNjaGVtYURlc2NyaXB0aW9uO1xuZXhwb3J0cy5pc1NoYXBlbGVzc1pvZFNjaGVtYSA9IGlzU2hhcGVsZXNzWm9kU2NoZW1hO1xuZXhwb3J0cy5pc1NpbXBsZVN0cmluZ1pvZFNjaGVtYSA9IGlzU2ltcGxlU3RyaW5nWm9kU2NoZW1hO1xuZXhwb3J0cy5pc1pvZE9iamVjdFYzID0gaXNab2RPYmplY3RWMztcbmV4cG9ydHMuaXNab2RPYmplY3RWNCA9IGlzWm9kT2JqZWN0VjQ7XG5leHBvcnRzLmlzWm9kQXJyYXlWNCA9IGlzWm9kQXJyYXlWNDtcbmV4cG9ydHMuaXNJbnRlcm9wWm9kT2JqZWN0ID0gaXNJbnRlcm9wWm9kT2JqZWN0O1xuZXhwb3J0cy5nZXRJbnRlcm9wWm9kT2JqZWN0U2hhcGUgPSBnZXRJbnRlcm9wWm9kT2JqZWN0U2hhcGU7XG5leHBvcnRzLmV4dGVuZEludGVyb3Bab2RPYmplY3QgPSBleHRlbmRJbnRlcm9wWm9kT2JqZWN0O1xuZXhwb3J0cy5pbnRlcm9wWm9kT2JqZWN0UGFydGlhbCA9IGludGVyb3Bab2RPYmplY3RQYXJ0aWFsO1xuZXhwb3J0cy5pbnRlcm9wWm9kT2JqZWN0U3RyaWN0ID0gaW50ZXJvcFpvZE9iamVjdFN0cmljdDtcbmV4cG9ydHMuaW50ZXJvcFpvZE9iamVjdFBhc3N0aHJvdWdoID0gaW50ZXJvcFpvZE9iamVjdFBhc3N0aHJvdWdoO1xuZXhwb3J0cy5nZXRJbnRlcm9wWm9kRGVmYXVsdEdldHRlciA9IGdldEludGVyb3Bab2REZWZhdWx0R2V0dGVyO1xuZXhwb3J0cy5pbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEgPSBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWE7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiem9kL3Y0L2NvcmVcIik7XG5mdW5jdGlvbiBpc1pvZFNjaGVtYVY0KHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiIHx8IHNjaGVtYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHNjaGVtYTtcbiAgICBpZiAoIShcIl96b2RcIiBpbiBvYmopKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgem9kID0gb2JqLl96b2Q7XG4gICAgcmV0dXJuICh0eXBlb2Ygem9kID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHpvZCAhPT0gbnVsbCAmJlxuICAgICAgICBcImRlZlwiIGluIHpvZCk7XG59XG5mdW5jdGlvbiBpc1pvZFNjaGVtYVYzKHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSBcIm9iamVjdFwiIHx8IHNjaGVtYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHNjaGVtYTtcbiAgICBpZiAoIShcIl9kZWZcIiBpbiBvYmopIHx8IFwiX3pvZFwiIGluIG9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG9iai5fZGVmO1xuICAgIHJldHVybiAodHlwZW9mIGRlZiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBkZWYgIT0gbnVsbCAmJlxuICAgICAgICBcInR5cGVOYW1lXCIgaW4gZGVmKTtcbn1cbi8qKiBCYWNrd2FyZCBjb21wYXRpYmxlIGlzWm9kU2NoZW1hIGZvciBab2QgMyAqL1xuZnVuY3Rpb24gaXNab2RTY2hlbWEoc2NoZW1hKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gQXR0ZW1wdGluZyB0byB1c2UgWm9kIDQgc2NoZW1hIGluIGEgY29udGV4dCB3aGVyZSBab2QgMyBzY2hlbWEgaXMgZXhwZWN0ZWQuIFRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaXNab2RTY2hlbWFWMyhzY2hlbWEpO1xufVxuLyoqXG4gKiBHaXZlbiBlaXRoZXIgYSBab2Qgc2NoZW1hLCBvciBwbGFpbiBvYmplY3QsIGRldGVybWluZSBpZiB0aGUgaW5wdXQgaXMgYSBab2Qgc2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXRcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaW5wdXQgaXMgYSBab2Qgc2NoZW1hLlxuICovXG5mdW5jdGlvbiBpc0ludGVyb3Bab2RTY2hlbWEoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KGlucHV0KSB8fFxuICAgICAgICBpc1pvZFNjaGVtYVYzKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBwYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgYSBzYWZlIHBhcnNlIHJlc3VsdC5cbiAqIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyBib3RoIFpvZCB2MyBhbmQgdjQgc2NoZW1hcywgcmV0dXJuaW5nIGEgcmVzdWx0IG9iamVjdCBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBleHBlY3RlZCBvdXRwdXQgdHlwZSBvZiB0aGUgc2NoZW1hLlxuICogQHBhcmFtIHtJbnRlcm9wWm9kVHlwZTxUPn0gc2NoZW1hIC0gVGhlIFpvZCBzY2hlbWEgKHYzIG9yIHY0KSB0byB1c2UgZm9yIHBhcnNpbmcuXG4gKiBAcGFyYW0ge3Vua25vd259IGlucHV0IC0gVGhlIGlucHV0IHZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMge1Byb21pc2U8SW50ZXJvcFpvZFNhZmVQYXJzZVJlc3VsdDxUPj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc2FmZSBwYXJzZSByZXN1bHQgb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5hc3luYyBmdW5jdGlvbiBpbnRlcm9wU2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCAoMCwgY29yZV8xLnBhcnNlQXN5bmMpKHNjaGVtYSwgaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zYWZlUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RUeXBlIG9yIHo0LiRab2RUeXBlXCIpO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBwYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBwYXJzaW5nIGZhaWxzIG9yIGlmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIGV4cGVjdGVkIG91dHB1dCB0eXBlIG9mIHRoZSBzY2hlbWEuXG4gKiBAcGFyYW0ge0ludGVyb3Bab2RUeXBlPFQ+fSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSAodjMgb3IgdjQpIHRvIHVzZSBmb3IgcGFyc2luZy5cbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXQgLSBUaGUgaW5wdXQgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhcnNlZCB2YWx1ZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwYXJzaW5nIGZhaWxzIG9yIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5hc3luYyBmdW5jdGlvbiBpbnRlcm9wUGFyc2VBc3luYyhzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gKDAsIGNvcmVfMS5wYXJzZSkoc2NoZW1hLCBpbnB1dCk7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4vKipcbiAqIFNhZmVseSBwYXJzZXMgdGhlIGlucHV0IHVzaW5nIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hICh2MyBvciB2NCkgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0XG4gKiBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZS4gVGhpcyBmdW5jdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kU2FmZVBhcnNlUmVzdWx0PFQ+fSBBbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHBhcnNlZCBkYXRhIChvbiBzdWNjZXNzKVxuICogICBvciB0aGUgZXJyb3IgKG9uIGZhaWx1cmUpLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgcmVjb2duaXplZCBab2QgdjMgb3IgdjQgc2NoZW1hLlxuICovXG5mdW5jdGlvbiBpbnRlcm9wU2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIGNvcmVfMS5wYXJzZSkoc2NoZW1hLCBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnNhZmVQYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgaW5wdXQgdXNpbmcgdGhlIHByb3ZpZGVkIFpvZCBzY2hlbWEgKHYzIG9yIHY0KSBhbmQgcmV0dXJucyB0aGUgcGFyc2VkIHZhbHVlLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHBhcnNpbmcgZmFpbHMgb3IgaWYgdGhlIHNjaGVtYSBpcyBub3QgYSByZWNvZ25pemVkIFpvZCB2MyBvciB2NCBzY2hlbWEuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgb3V0cHV0IHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSB7SW50ZXJvcFpvZFR5cGU8VD59IHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hICh2MyBvciB2NCkgdG8gdXNlIGZvciBwYXJzaW5nLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dCAtIFRoZSBpbnB1dCB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIHtUfSBUaGUgcGFyc2VkIHZhbHVlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHBhcnNpbmcgZmFpbHMgb3IgdGhlIHNjaGVtYSBpcyBub3QgYSByZWNvZ25pemVkIFpvZCB2MyBvciB2NCBzY2hlbWEuXG4gKi9cbmZ1bmN0aW9uIGludGVyb3BQYXJzZShzY2hlbWEsIGlucHV0KSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gKDAsIGNvcmVfMS5wYXJzZSkoc2NoZW1hLCBpbnB1dCk7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZGVzY3JpcHRpb24gZnJvbSBhIHNjaGVtYSBkZWZpbml0aW9uICh2MywgdjQsIG9yIHBsYWluIG9iamVjdCksIGlmIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gZXh0cmFjdCB0aGUgZGVzY3JpcHRpb24gZnJvbS5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgc2NoZW1hLCBvciB1bmRlZmluZWQgaWYgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYURlc2NyaXB0aW9uKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5nZXQoc2NoZW1hKT8uZGVzY3JpcHRpb247XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgaWYgKFwiZGVzY3JpcHRpb25cIiBpbiBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYS5kZXNjcmlwdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hIGlzIFwic2hhcGVsZXNzXCIuXG4gKiBBIHNoYXBlbGVzcyBzY2hlbWEgaXMgb25lIHRoYXQgZG9lcyBub3QgZGVmaW5lIGFueSBvYmplY3Qgc2hhcGUsXG4gKiBzdWNoIGFzIFpvZFN0cmluZywgWm9kTnVtYmVyLCBab2RCb29sZWFuLCBab2RBbnksIGV0Yy5cbiAqIEZvciBab2RPYmplY3QsIGl0IG11c3QgaGF2ZSBubyBzaGFwZSBrZXlzIHRvIGJlIGNvbnNpZGVyZWQgc2hhcGVsZXNzLlxuICogWm9kUmVjb3JkIHNjaGVtYXMgYXJlIGNvbnNpZGVyZWQgc2hhcGVsZXNzIHNpbmNlIHRoZXkgZGVmaW5lIGR5bmFtaWNcbiAqIGtleS12YWx1ZSBtYXBwaW5ncyB3aXRob3V0IGZpeGVkIGtleXMuXG4gKlxuICogQHBhcmFtIHNjaGVtYSBUaGUgWm9kIHNjaGVtYSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzY2hlbWEgaXMgc2hhcGVsZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzU2hhcGVsZXNzWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmICghaXNJbnRlcm9wWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgdjMgc2NoZW1hc1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHpvZCB2MyB0eXBlcyBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCB6b2QgdjQgdHlwZXNcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgICAgIC8vIFpvZE9iamVjdCBpcyBvbmx5IHNoYXBlZCBpZiBpdCBoYXMgYWN0dWFsIHNoYXBlIGtleXNcbiAgICAgICAgaWYgKGRlZi50eXBlTmFtZSA9PT0gXCJab2RPYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuICFvYmouc2hhcGUgfHwgT2JqZWN0LmtleXMob2JqLnNoYXBlKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gWm9kUmVjb3JkIGlzIHNoYXBlbGVzcyAoZHluYW1pYyBrZXktdmFsdWUgbWFwcGluZylcbiAgICAgICAgaWYgKGRlZi50eXBlTmFtZSA9PT0gXCJab2RSZWNvcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHY0IHNjaGVtYXNcbiAgICBpZiAoaXNab2RTY2hlbWFWNChzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAgICAgLy8gT2JqZWN0IHR5cGUgaXMgb25seSBzaGFwZWQgaWYgaXQgaGFzIGFjdHVhbCBzaGFwZSBrZXlzXG4gICAgICAgIGlmIChkZWYudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuICFvYmouc2hhcGUgfHwgT2JqZWN0LmtleXMob2JqLnNoYXBlKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjb3JkIHR5cGUgaXMgc2hhcGVsZXNzIChkeW5hbWljIGtleS12YWx1ZSBtYXBwaW5nKVxuICAgICAgICBpZiAoZGVmLnR5cGUgPT09IFwicmVjb3JkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvciBvdGhlciBzY2hlbWFzLCBjaGVjayBpZiB0aGV5IGhhdmUgYSBgc2hhcGVgIHByb3BlcnR5XG4gICAgLy8gSWYgdGhleSBkb24ndCBoYXZlIHNoYXBlLCB0aGV5J3JlIGxpa2VseSBzaGFwZWxlc3NcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWEgIT09IG51bGwgJiYgIShcInNoYXBlXCIgaW4gc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBab2Qgc2NoZW1hIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc2ltcGxlIHN0cmluZyBzY2hlbWFcbiAqIHRoYXQgbWFwcyB0byBEeW5hbWljVG9vbC4gVGhpcyBhbGlnbnMgd2l0aCB0aGUgdHlwZS1sZXZlbCBjb25zdHJhaW50IG9mXG4gKiBJbnRlcm9wWm9kVHlwZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHdoaWNoIG9ubHkgbWF0Y2hlcyBiYXNpYyBzdHJpbmcgc2NoZW1hcy5cbiAqIElmIHRoZSBwcm92aWRlZCBzY2hlbWEgaXMganVzdCB6LnN0cmluZygpLCB3ZSBjYW4gbWFrZSB0aGUgZGV0ZXJtaW5hdGlvbiB0aGF0XG4gKiB0aGUgdG9vbCBpcyBqdXN0IGEgZ2VuZXJpYyBzdHJpbmcgdG9vbCB0aGF0IGRvZXNuJ3QgcmVxdWlyZSBhbnkgaW5wdXQgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyB0cnVlIGZvciBiYXNpYyBab2RTdHJpbmcgc2NoZW1hcywgaW5jbHVkaW5nOlxuICogLSBCYXNpYyBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKSlcbiAqIC0gU3RyaW5nIHNjaGVtYXMgd2l0aCB2YWxpZGF0aW9ucyAoei5zdHJpbmcoKS5taW4oMSksIHouc3RyaW5nKCkuZW1haWwoKSwgZXRjLilcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UgZm9yIGV2ZXJ5dGhpbmcgZWxzZSwgaW5jbHVkaW5nOlxuICogLSBTdHJpbmcgc2NoZW1hcyB3aXRoIGRlZmF1bHRzICh6LnN0cmluZygpLmRlZmF1bHQoXCJ2YWx1ZVwiKSlcbiAqIC0gQnJhbmRlZCBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKS5icmFuZDxcIlVzZXJJZFwiPigpKVxuICogLSBTdHJpbmcgc2NoZW1hcyB3aXRoIGNhdGNoIG9wZXJhdGlvbnMgKHouc3RyaW5nKCkuY2F0Y2goXCJkZWZhdWx0XCIpKVxuICogLSBPcHRpb25hbC9udWxsYWJsZSBzdHJpbmcgc2NoZW1hcyAoei5zdHJpbmcoKS5vcHRpb25hbCgpKVxuICogLSBUcmFuc2Zvcm1lZCBzY2hlbWFzICh6LnN0cmluZygpLnRyYW5zZm9ybSgpIG9yIHoub2JqZWN0KCkudHJhbnNmb3JtKCkpXG4gKiAtIE9iamVjdCBvciByZWNvcmQgc2NoZW1hcywgZXZlbiBpZiB0aGV5J3JlIGVtcHR5XG4gKiAtIEFueSBvdGhlciBzY2hlbWEgdHlwZVxuICpcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFpvZCBzY2hlbWEgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2NoZW1hIGlzIGEgYmFzaWMgWm9kU3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzU2ltcGxlU3RyaW5nWm9kU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmICghaXNJbnRlcm9wWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGb3IgdjMgc2NoZW1hc1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHpvZCB2MyB0eXBlcyBhcmUgbm90IGNvbXBhdGlibGUgd2l0aCB6b2QgdjQgdHlwZXNcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWY7XG4gICAgICAgIC8vIE9ubHkgYWNjZXB0IGJhc2ljIFpvZFN0cmluZ1xuICAgICAgICByZXR1cm4gZGVmLnR5cGVOYW1lID09PSBcIlpvZFN0cmluZ1wiO1xuICAgIH1cbiAgICAvLyBGb3IgdjQgc2NoZW1hc1xuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgICAgICAvLyBPbmx5IGFjY2VwdCBiYXNpYyBzdHJpbmcgdHlwZVxuICAgICAgICByZXR1cm4gZGVmLnR5cGUgPT09IFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzWm9kT2JqZWN0VjMob2JqKSB7XG4gICAgLy8gWm9kIHYzIG9iamVjdCBzY2hlbWFzIGhhdmUgX2RlZi50eXBlTmFtZSA9PT0gXCJab2RPYmplY3RcIlxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICBcIl9kZWZcIiBpbiBvYmogJiZcbiAgICAgICAgdHlwZW9mIG9iai5fZGVmID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9iai5fZGVmICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZU5hbWVcIiBpbiBvYmouX2RlZiAmJlxuICAgICAgICBvYmouX2RlZi50eXBlTmFtZSA9PT0gXCJab2RPYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNab2RPYmplY3RWNChvYmopIHtcbiAgICBpZiAoIWlzWm9kU2NoZW1hVjQob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFpvZCB2NCBvYmplY3Qgc2NoZW1hcyBoYXZlIF96b2QuZGVmLnR5cGUgPT09IFwib2JqZWN0XCJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJfem9kXCIgaW4gb2JqICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmouX3pvZCAhPT0gbnVsbCAmJlxuICAgICAgICBcImRlZlwiIGluIG9iai5fem9kICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZC5kZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIG9iai5fem9kLmRlZiAmJlxuICAgICAgICBvYmouX3pvZC5kZWYudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNab2RBcnJheVY0KG9iaikge1xuICAgIGlmICghaXNab2RTY2hlbWFWNChvYmopKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gWm9kIHY0IGFycmF5IHNjaGVtYXMgaGF2ZSBfem9kLmRlZi50eXBlID09PSBcImFycmF5XCJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmogIT09IG51bGwgJiZcbiAgICAgICAgXCJfem9kXCIgaW4gb2JqICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBvYmouX3pvZCAhPT0gbnVsbCAmJlxuICAgICAgICBcImRlZlwiIGluIG9iai5fem9kICYmXG4gICAgICAgIHR5cGVvZiBvYmouX3pvZC5kZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgb2JqLl96b2QuZGVmICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIG9iai5fem9kLmRlZiAmJlxuICAgICAgICBvYmouX3pvZC5kZWYudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIEludGVyb3Bab2RPYmplY3QgKFpvZCB2MyBvciB2NCBvYmplY3Qgc2NoZW1hKS5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIFpvZCB2MyBvciB2NCBvYmplY3Qgc2NoZW1hLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJvcFpvZE9iamVjdChvYmopIHtcbiAgICBpZiAoaXNab2RPYmplY3RWMyhvYmopKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNab2RPYmplY3RWNChvYmopKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2hhcGUgKGZpZWxkcykgb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgc3VwcG9ydGluZyBib3RoIFpvZCB2MyBhbmQgdjQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0U2hhcGU8VD59IFRoZSBzaGFwZSBvZiB0aGUgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyb3Bab2RPYmplY3RTaGFwZShzY2hlbWEpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuc2hhcGU7XG4gICAgfVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kT2JqZWN0IG9yIHo0LiRab2RPYmplY3RcIik7XG59XG4vKipcbiAqIEV4dGVuZHMgYSBab2Qgb2JqZWN0IHNjaGVtYSB3aXRoIGFkZGl0aW9uYWwgZmllbGRzLCBzdXBwb3J0aW5nIGJvdGggWm9kIHYzIGFuZCB2NC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hIGluc3RhbmNlIChlaXRoZXIgdjMgb3IgdjQpLlxuICogQHBhcmFtIHtJbnRlcm9wWm9kT2JqZWN0U2hhcGV9IGV4dGVuc2lvbiAtIFRoZSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEuXG4gKiBAcmV0dXJucyB7SW50ZXJvcFpvZE9iamVjdH0gVGhlIGV4dGVuZGVkIFpvZCBvYmplY3Qgc2NoZW1hLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzY2hlbWEgaXMgbm90IGEgWm9kIHYzIG9yIHY0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kSW50ZXJvcFpvZE9iamVjdChzY2hlbWEsIGV4dGVuc2lvbikge1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5leHRlbmQoZXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gY29yZV8xLnV0aWwuZXh0ZW5kKHNjaGVtYSwgZXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgejMuWm9kT2JqZWN0IG9yIHo0LiRab2RPYmplY3RcIik7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIHZlcnNpb24gb2YgYSBab2Qgb2JqZWN0IHNjaGVtYSwgbWFraW5nIGFsbCBmaWVsZHMgb3B0aW9uYWwuXG4gKiBTdXBwb3J0cyBib3RoIFpvZCB2MyBhbmQgdjQuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEByZXR1cm5zIHtJbnRlcm9wWm9kT2JqZWN0fSBUaGUgcGFydGlhbCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGludGVyb3Bab2RPYmplY3RQYXJ0aWFsKHNjaGVtYSkge1xuICAgIGlmIChpc1pvZFNjaGVtYVYzKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gejM6IC5wYXJ0aWFsKCkgZXhpc3RzIGFuZCB3b3JrcyBhcyBleHBlY3RlZFxuICAgICAgICByZXR1cm4gc2NoZW1hLnBhcnRpYWwoKTtcbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICAvLyB6NDogdXRpbC5wYXJ0aWFsIGV4aXN0cyBhbmQgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICAgICAgcmV0dXJuIGNvcmVfMS51dGlsLnBhcnRpYWwoY29yZV8xLiRab2RPcHRpb25hbCwgc2NoZW1hLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB6My5ab2RPYmplY3Qgb3IgejQuJFpvZE9iamVjdFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmljdCB2ZXJzaW9uIG9mIGEgWm9kIG9iamVjdCBzY2hlbWEsIGRpc2FsbG93aW5nIHVua25vd24ga2V5cy5cbiAqIFN1cHBvcnRzIGJvdGggWm9kIHYzIGFuZCB2NCBvYmplY3Qgc2NoZW1hcy4gSWYgYHJlY3Vyc2l2ZWAgaXMgdHJ1ZSwgYXBwbGllcyBzdHJpY3RuZXNzXG4gKiByZWN1cnNpdmVseSB0byBhbGwgbmVzdGVkIG9iamVjdCBzY2hlbWFzIGFuZCBhcnJheXMgb2Ygb2JqZWN0IHNjaGVtYXMuXG4gKlxuICogQHRlbXBsYXRlIFQgLSBUaGUgdHlwZSBvZiB0aGUgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAcGFyYW0ge1R9IHNjaGVtYSAtIFRoZSBab2Qgb2JqZWN0IHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIGFwcGx5IHN0cmljdG5lc3MgcmVjdXJzaXZlbHkgdG8gbmVzdGVkIG9iamVjdHMvYXJyYXlzLlxuICogQHJldHVybnMge0ludGVyb3Bab2RPYmplY3R9IFRoZSBzdHJpY3QgWm9kIG9iamVjdCBzY2hlbWEuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNjaGVtYSBpcyBub3QgYSBab2QgdjMgb3IgdjQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpbnRlcm9wWm9kT2JqZWN0U3RyaWN0KHNjaGVtYSwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIFRPRE86IHYzIHNjaGVtYXMgYXJlbid0IHJlY3Vyc2l2ZWx5IGhhbmRsZWQgaGVyZVxuICAgICAgICAvLyAoY3VycmVudGx5IG5vdCBuZWNlc3Nhcnkgc2luY2Ugem9kVG9Kc29uU2NoZW1hIGhhbmRsZXMgdGhpcylcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zdHJpY3QoKTtcbiAgICB9XG4gICAgaWYgKGlzWm9kT2JqZWN0VjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBrZXlTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5fem9kLmRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUga2V5IGlzIGEgdjQgb2JqZWN0IHNjaGVtYSwgd2UgbmVlZCB0byBtYWtlIGl0IHN0cmljdFxuICAgICAgICAgICAgICAgIGlmIChpc1pvZE9iamVjdFY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2NoZW1hID0gaW50ZXJvcFpvZE9iamVjdFN0cmljdChrZXlTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBvdXRwdXRTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZSBrZXkgaXMgYSB2NCBhcnJheSBzY2hlbWEsIHdlIG5lZWQgdG8gbWFrZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHNjaGVtYSBzdHJpY3QgaWYgaXQncyBhbiBvYmplY3Qgc2NoZW1hXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNab2RBcnJheVY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRTY2hlbWEgPSBrZXlTY2hlbWEuX3pvZC5kZWYuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWm9kT2JqZWN0VjQoZWxlbWVudFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY2hlbWEgPSBpbnRlcm9wWm9kT2JqZWN0U3RyaWN0KGVsZW1lbnRTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9ICgwLCBjb3JlXzEuY2xvbmUpKGtleVNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5U2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0ga2V5U2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gbWV0YSBmaWVsZHMgdG8gdGhlIGtleVNjaGVtYVxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuZ2V0KGtleVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5hZGQob3V0cHV0U2hhcGVba2V5XSwgbWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kaWZpZWRTY2hlbWEgPSAoMCwgY29yZV8xLmNsb25lKShzY2hlbWEsIHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICAgICAgICAgIHNoYXBlOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgIGNhdGNoYWxsOiAoMCwgY29yZV8xLl9uZXZlcikoY29yZV8xLiRab2ROZXZlciksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhID0gY29yZV8xLmdsb2JhbFJlZ2lzdHJ5LmdldChzY2hlbWEpO1xuICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgIGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5hZGQobW9kaWZpZWRTY2hlbWEsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTY2hlbWE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcGFzc3Rocm91Z2ggdmVyc2lvbiBvZiBhIFpvZCBvYmplY3Qgc2NoZW1hLCBhbGxvd2luZyB1bmtub3duIGtleXMuXG4gKiBTdXBwb3J0cyBib3RoIFpvZCB2MyBhbmQgdjQgb2JqZWN0IHNjaGVtYXMuIElmIGByZWN1cnNpdmVgIGlzIHRydWUsIGFwcGxpZXMgcGFzc3Rocm91Z2hcbiAqIHJlY3Vyc2l2ZWx5IHRvIGFsbCBuZXN0ZWQgb2JqZWN0IHNjaGVtYXMgYW5kIGFycmF5cyBvZiBvYmplY3Qgc2NoZW1hcy5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEBwYXJhbSB7VH0gc2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hIGluc3RhbmNlIChlaXRoZXIgdjMgb3IgdjQpLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gYXBwbHkgcGFzc3Rocm91Z2ggcmVjdXJzaXZlbHkgdG8gbmVzdGVkIG9iamVjdHMvYXJyYXlzLlxuICogQHJldHVybnMge0ludGVyb3Bab2RPYmplY3R9IFRoZSBwYXNzdGhyb3VnaCBab2Qgb2JqZWN0IHNjaGVtYS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIFpvZCB2MyBvciB2NCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGludGVyb3Bab2RPYmplY3RQYXNzdGhyb3VnaChzY2hlbWEsIHJlY3Vyc2l2ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGlzWm9kT2JqZWN0VjMoc2NoZW1hKSkge1xuICAgICAgICAvLyBUT0RPOiB2MyBzY2hlbWFzIGFyZW4ndCByZWN1cnNpdmVseSBoYW5kbGVkIGhlcmVcbiAgICAgICAgLy8gKGN1cnJlbnRseSBub3QgbmVjZXNzYXJ5IHNpbmNlIHpvZFRvSnNvblNjaGVtYSBoYW5kbGVzIHRoaXMpXG4gICAgICAgIHJldHVybiBzY2hlbWEucGFzc3Rocm91Z2goKTtcbiAgICB9XG4gICAgaWYgKGlzWm9kT2JqZWN0VjQoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBrZXlTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5fem9kLmRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUga2V5IGlzIGEgdjQgb2JqZWN0IHNjaGVtYSwgd2UgbmVlZCB0byBtYWtlIGl0IHBhc3N0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKGlzWm9kT2JqZWN0VjQoa2V5U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRTY2hlbWEgPSBpbnRlcm9wWm9kT2JqZWN0UGFzc3Rocm91Z2goa2V5U2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGUga2V5IGlzIGEgdjQgYXJyYXkgc2NoZW1hLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzY2hlbWEgcGFzc3Rocm91Z2ggaWYgaXQncyBhbiBvYmplY3Qgc2NoZW1hXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNab2RBcnJheVY0KGtleVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRTY2hlbWEgPSBrZXlTY2hlbWEuX3pvZC5kZWYuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWm9kT2JqZWN0VjQoZWxlbWVudFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY2hlbWEgPSBpbnRlcm9wWm9kT2JqZWN0UGFzc3Rocm91Z2goZWxlbWVudFNjaGVtYSwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZVtrZXldID0gKDAsIGNvcmVfMS5jbG9uZSkoa2V5U2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5rZXlTY2hlbWEuX3pvZC5kZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50U2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHVzZSB0aGUga2V5U2NoZW1hXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlW2tleV0gPSBrZXlTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBtZXRhIGZpZWxkcyB0byB0aGUga2V5U2NoZW1hXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5nZXQoa2V5U2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLmdsb2JhbFJlZ2lzdHJ5LmFkZChvdXRwdXRTaGFwZVtrZXldLCBtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RpZmllZFNjaGVtYSA9ICgwLCBjb3JlXzEuY2xvbmUpKHNjaGVtYSwge1xuICAgICAgICAgICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgICAgICAgICAgc2hhcGU6IG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgY2F0Y2hhbGw6ICgwLCBjb3JlXzEuX3Vua25vd24pKGNvcmVfMS4kWm9kVW5rbm93biksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhID0gY29yZV8xLmdsb2JhbFJlZ2lzdHJ5LmdldChzY2hlbWEpO1xuICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgIGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5hZGQobW9kaWZpZWRTY2hlbWEsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTY2hlbWE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZE9iamVjdCBvciB6NC4kWm9kT2JqZWN0XCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIFpvZCBzY2hlbWEsIGlmIG9uZSBpcyBkZWZpbmVkLlxuICogU3VwcG9ydHMgYm90aCBab2QgdjMgYW5kIHY0IHNjaGVtYXMuIElmIHRoZSBzY2hlbWEgaGFzIGEgZGVmYXVsdCB2YWx1ZSxcbiAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGF0IHZhbHVlIHdoZW4gY2FsbGVkLiBJZiBubyBkZWZhdWx0IGlzIGRlZmluZWQsXG4gKiByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSBab2Qgc2NoZW1hLlxuICogQHBhcmFtIHtUfSBzY2hlbWEgLSBUaGUgWm9kIHNjaGVtYSBpbnN0YW5jZSAoZWl0aGVyIHYzIG9yIHY0KS5cbiAqIEByZXR1cm5zIHsoKCkgPT4gSW5mZXJJbnRlcm9wWm9kT3V0cHV0PFQ+KSB8IHVuZGVmaW5lZH0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiBubyBkZWZhdWx0IGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJvcFpvZERlZmF1bHRHZXR0ZXIoc2NoZW1hKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hVjMoc2NoZW1hKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gc2NoZW1hLnBhcnNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzWm9kU2NoZW1hVjQoc2NoZW1hKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gKDAsIGNvcmVfMS5wYXJzZSkoc2NoZW1hLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1pvZFRyYW5zZm9ybVYzKHNjaGVtYSkge1xuICAgIHJldHVybiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpICYmXG4gICAgICAgIFwidHlwZU5hbWVcIiBpbiBzY2hlbWEuX2RlZiAmJlxuICAgICAgICBzY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gXCJab2RFZmZlY3RzXCIpO1xufVxuZnVuY3Rpb24gaXNab2RUcmFuc2Zvcm1WNChzY2hlbWEpIHtcbiAgICByZXR1cm4gaXNab2RTY2hlbWFWNChzY2hlbWEpICYmIHNjaGVtYS5fem9kLmRlZi50eXBlID09PSBcInBpcGVcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW5wdXQgdHlwZSBvZiBhIFpvZCB0cmFuc2Zvcm0gc2NoZW1hLCBmb3IgYm90aCB2MyBhbmQgdjQuXG4gKiBJZiB0aGUgc2NoZW1hIGlzIG5vdCBhIHRyYW5zZm9ybSwgcmV0dXJucyB1bmRlZmluZWQuIElmIGByZWN1cnNpdmVgIGlzIHRydWUsXG4gKiByZWN1cnNpdmVseSBwcm9jZXNzZXMgbmVzdGVkIG9iamVjdCBzY2hlbWFzIGFuZCBhcnJheXMgb2Ygb2JqZWN0IHNjaGVtYXMuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBab2Qgc2NoZW1hIGluc3RhbmNlICh2MyBvciB2NClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgbmVzdGVkIG9iamVjdHMvYXJyYXlzLlxuICogQHJldHVybnMgVGhlIGlucHV0IFpvZCBzY2hlbWEgb2YgdGhlIHRyYW5zZm9ybSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBhIHRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEoc2NoZW1hLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgIC8vIFpvZCB2MzogLl9kZWYuc2NoZW1hIGlzIHRoZSBpbnB1dCBzY2hlbWEgZm9yIFpvZEVmZmVjdHMgKHRyYW5zZm9ybSlcbiAgICBpZiAoaXNab2RTY2hlbWFWMyhzY2hlbWEpKSB7XG4gICAgICAgIGlmIChpc1pvZFRyYW5zZm9ybVYzKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm9wWm9kVHJhbnNmb3JtSW5wdXRTY2hlbWEoc2NoZW1hLl9kZWYuc2NoZW1hLCByZWN1cnNpdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHYzIHNjaGVtYXMgYXJlbid0IHJlY3Vyc2l2ZWx5IGhhbmRsZWQgaGVyZVxuICAgICAgICAvLyAoY3VycmVudGx5IG5vdCBuZWNlc3Nhcnkgc2luY2Ugem9kVG9Kc29uU2NoZW1hIGhhbmRsZXMgdGhpcylcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgLy8gWm9kIHY0OiBfZGVmLnR5cGUgaXMgdGhlIGlucHV0IHNjaGVtYSBmb3IgWm9kRWZmZWN0cyAodHJhbnNmb3JtKVxuICAgIGlmIChpc1pvZFNjaGVtYVY0KHNjaGVtYSkpIHtcbiAgICAgICAgbGV0IG91dHB1dFNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgaWYgKGlzWm9kVHJhbnNmb3JtVjQoc2NoZW1hKSkge1xuICAgICAgICAgICAgb3V0cHV0U2NoZW1hID0gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKHNjaGVtYS5fem9kLmRlZi5pbiwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIG9iamVjdCBzY2hlbWFzXG4gICAgICAgICAgICBpZiAoaXNab2RPYmplY3RWNChvdXRwdXRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBvdXRwdXRTY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBrZXlTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKG91dHB1dFNjaGVtYS5fem9kLmRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVba2V5XSA9IGludGVyb3Bab2RUcmFuc2Zvcm1JbnB1dFNjaGVtYShrZXlTY2hlbWEsIHJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFNjaGVtYSA9ICgwLCBjb3JlXzEuY2xvbmUpKG91dHB1dFNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vdXRwdXRTY2hlbWEuX3pvZC5kZWYsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgYXJyYXkgc2NoZW1hc1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNab2RBcnJheVY0KG91dHB1dFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50U2NoZW1hID0gaW50ZXJvcFpvZFRyYW5zZm9ybUlucHV0U2NoZW1hKG91dHB1dFNjaGVtYS5fem9kLmRlZi5lbGVtZW50LCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgIG91dHB1dFNjaGVtYSA9ICgwLCBjb3JlXzEuY2xvbmUpKG91dHB1dFNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vdXRwdXRTY2hlbWEuX3pvZC5kZWYsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRTY2hlbWEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IGNvcmVfMS5nbG9iYWxSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKG1ldGEpXG4gICAgICAgICAgICBjb3JlXzEuZ2xvYmFsUmVnaXN0cnkuYWRkKG91dHB1dFNjaGVtYSwgbWV0YSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRTY2hlbWE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHozLlpvZFR5cGUgb3IgejQuJFpvZFR5cGVcIik7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/dist/utils/types/zod.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/documents.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/documents.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/documents/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/documents/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2RvY3VtZW50cy5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUlBQXNEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZG9jdW1lbnRzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9kb2N1bWVudHMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/documents.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/embeddings.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/embeddings.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/embeddings.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/embeddings.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3MuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDZIQUFpRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2VtYmVkZGluZ3MuY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/base.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/base.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/base.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/base.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvYmFzZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2xhbmd1YWdlX21vZGVscy9iYXNlLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/base.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/chat_models.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/chat_models.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/chat_models.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQUEsZ0tBQW1FIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/language_models/llms.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@langchain/core/language_models/llms.cjs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/language_models/llms.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/language_models/llms.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBNEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvbGxtcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2xhbmd1YWdlX21vZGVscy9sbG1zLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/load/serializable.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/load/serializable.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/load/serializable.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/load/serializable.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2xvYWQvc2VyaWFsaXphYmxlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9sb2FkL3NlcmlhbGl6YWJsZS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L2xvYWQvc2VyaWFsaXphYmxlLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/load/serializable.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/messages.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@langchain/core/messages.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/messages/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/messages/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxxSUFBcUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9tZXNzYWdlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvbWVzc2FnZXMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/messages.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/ansi-styles/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nconst ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\toverline: [53, 55],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tObject.defineProperties(styles, {\n\t\trgbToAnsi256: {\n\t\t\tvalue: (red, green, blue) => {\n\t\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\t\tif (red === green && green === blue) {\n\t\t\t\t\tif (red < 8) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (red > 248) {\n\t\t\t\t\t\treturn 231;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t\t\t}\n\n\t\t\t\treturn 16 +\n\t\t\t\t\t(36 * Math.round(red / 255 * 5)) +\n\t\t\t\t\t(6 * Math.round(green / 255 * 5)) +\n\t\t\t\t\tMath.round(blue / 255 * 5);\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToRgb: {\n\t\t\tvalue: hex => {\n\t\t\t\tconst matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tlet {colorString} = matches.groups;\n\n\t\t\t\tif (colorString.length === 3) {\n\t\t\t\t\tcolorString = colorString.split('').map(character => character + character).join('');\n\t\t\t\t}\n\n\t\t\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\t\t\treturn [\n\t\t\t\t\t(integer >> 16) & 0xFF,\n\t\t\t\t\t(integer >> 8) & 0xFF,\n\t\t\t\t\tinteger & 0xFF\n\t\t\t\t];\n\t\t\t},\n\t\t\tenumerable: false\n\t\t},\n\t\thexToAnsi256: {\n\t\t\tvalue: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n\t\t\tenumerable: false\n\t\t}\n\t});\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWI7O0FBRUEsc0RBQXNELGFBQWEsRUFBRSxFQUFFLEtBQUs7O0FBRTVFLG9FQUFvRSxhQUFhLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUs7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHFCQUFxQixTQUFTO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNENBQTRDLEVBQUUsU0FBUyxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGFBQWE7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFOU0lfQkFDS0dST1VORF9PRkZTRVQgPSAxMDtcblxuY29uc3Qgd3JhcEFuc2kyNTYgPSAob2Zmc2V0ID0gMCkgPT4gY29kZSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcblxuY29uc3Qgd3JhcEFuc2kxNm0gPSAob2Zmc2V0ID0gMCkgPT4gKHJlZCwgZ3JlZW4sIGJsdWUpID0+IGBcXHUwMDFCWyR7MzggKyBvZmZzZXR9OzI7JHtyZWR9OyR7Z3JlZW59OyR7Ymx1ZX1tYDtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0b3ZlcmxpbmU6IFs1MywgNTVdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRibGFja0JyaWdodDogWzkwLCAzOV0sXG5cdFx0XHRyZWRCcmlnaHQ6IFs5MSwgMzldLFxuXHRcdFx0Z3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuXHRcdFx0eWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcblx0XHRcdGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuXHRcdFx0bWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG5cdFx0XHRjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcblx0XHRcdHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcjoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcblx0XHRcdGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG5cdFx0XHRiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuXHRcdFx0YmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcblx0XHRcdGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuXHRcdFx0YmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsaWFzIGJyaWdodCBibGFjayBhcyBncmF5IChhbmQgZ3JleSlcblx0c3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXG5cdGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcblx0XHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhncm91cCkpIHtcblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0dmFsdWU6IGNvZGVzLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXG5cdHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG5cdHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcblxuXHRzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KCk7XG5cdHN0eWxlcy5jb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXHRzdHlsZXMuYmdDb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7XG5cblx0Ly8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qc1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHlsZXMsIHtcblx0XHRyZ2JUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4ge1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHRcdFx0XHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0XHRcdFx0aWYgKHJlZCA9PT0gZ3JlZW4gJiYgZ3JlZW4gPT09IGJsdWUpIHtcblx0XHRcdFx0XHRpZiAocmVkIDwgOCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDE2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZWQgPiAyNDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAyMzE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMTYgK1xuXHRcdFx0XHRcdCgzNiAqIE1hdGgucm91bmQocmVkIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHQoNiAqIE1hdGgucm91bmQoZ3JlZW4gLyAyNTUgKiA1KSkgK1xuXHRcdFx0XHRcdE1hdGgucm91bmQoYmx1ZSAvIDI1NSAqIDUpO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb1JnYjoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxcZF17Nn18W2EtZlxcZF17M30pL2kuZXhlYyhoZXgudG9TdHJpbmcoMTYpKTtcblx0XHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB7Y29sb3JTdHJpbmd9ID0gbWF0Y2hlcy5ncm91cHM7XG5cblx0XHRcdFx0aWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyICsgY2hhcmFjdGVyKS5qb2luKCcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGludGVnZXIgPSBOdW1iZXIucGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDE2KSAmIDB4RkYsXG5cdFx0XHRcdFx0KGludGVnZXIgPj4gOCkgJiAweEZGLFxuXHRcdFx0XHRcdGludGVnZXIgJiAweEZGXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGhleFRvQW5zaTI1Njoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiBzdHlsZXMucmdiVG9BbnNpMjU2KC4uLnN0eWxlcy5oZXhUb1JnYihoZXgpKSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG4vLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/ansi-styles/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js\");\n/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0k7QUFDUTtBQUNkO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNRO0FBQ1I7QUFDWSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBNQVggfSBmcm9tICcuL21heC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MVRvVjYgfSBmcm9tICcuL3YxVG9WNi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2IH0gZnJvbSAnLi92Ni5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2VG9WMSB9IGZyb20gJy4vdjZUb1YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjcgfSBmcm9tICcuL3Y3LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21heC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/max.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsNkRBQWlCO0FBQzFCO0FBQ0EsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIC8vXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cbiAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxubGV0IF9ub2RlSWQ7XG5sZXQgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcTtcblxuICAvLyB2MSBvbmx5OiBVc2UgY2FjaGVkIGBub2RlYCBhbmQgYGNsb2Nrc2VxYCB2YWx1ZXNcbiAgaWYgKCFvcHRpb25zLl92Nikge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IF9ub2RlSWQ7XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgd2UgbmVlZCBlbnRyb3B5LiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzXG4gIC8vIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50IHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIC8vIFJhbmRvbWl6ZSBub2RlXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IFtzZWVkQnl0ZXNbMF0sIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcblxuICAgICAgLy8gdjEgb25seTogY2FjaGUgbm9kZSB2YWx1ZSBmb3IgcmV1c2VcbiAgICAgIGlmICghX25vZGVJZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgLy8gcGVyIFJGQzQxMjIgNC41OiBTZXQgTUFDIG11bHRpY2FzdCBiaXQgKHYxIG9ubHkpXG4gICAgICAgIG5vZGVbMF0gfD0gMHgwMTsgLy8gU2V0IG11bHRpY2FzdCBiaXRcblxuICAgICAgICBfbm9kZUlkID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSYW5kb21pemUgY2xvY2tzZXFcbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICAgIGlmIChfY2xvY2tzZXEgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdjEgJiB2NiB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc28gdGltZSBpc1xuICAvLyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MVRvVjYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2MSBVVUlEIHRvIGEgdjYgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjEgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2NiBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjFUb1Y2KHV1aWQpIHtcbiAgY29uc3QgdjFCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjZCeXRlcyA9IF92MVRvVjYodjFCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjZCeXRlcykgOiB2NkJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2MSAtPiB2NlxuZnVuY3Rpb24gX3YxVG9WNih2MUJ5dGVzLCByYW5kb21pemUgPSBmYWxzZSkge1xuICByZXR1cm4gVWludDhBcnJheS5vZigodjFCeXRlc1s2XSAmIDB4MGYpIDw8IDQgfCB2MUJ5dGVzWzddID4+IDQgJiAweDBmLCAodjFCeXRlc1s3XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s0XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1sxXSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgMHg2MCB8IHYxQnl0ZXNbMl0gJiAweDBmLCB2MUJ5dGVzWzNdLCB2MUJ5dGVzWzhdLCB2MUJ5dGVzWzldLCB2MUJ5dGVzWzEwXSwgdjFCeXRlc1sxMV0sIHYxQnl0ZXNbMTJdLCB2MUJ5dGVzWzEzXSwgdjFCeXRlc1sxNF0sIHYxQnl0ZXNbMTVdKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIF9uYW1lc3BhY2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUN4QjtBQUNROztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxzREFBTTs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHYxIGZyb20gJy4vdjEuanMnO1xuaW1wb3J0IHYxVG9WNiBmcm9tICcuL3YxVG9WNi5qcyc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXk9fSBidWZcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2NihvcHRpb25zID0ge30sIGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAvLyB2NiBpcyB2MSB3aXRoIGRpZmZlcmVudCBmaWVsZCBsYXlvdXQsIHNvIHdlIHN0YXJ0IHdpdGggYSB2MSBVVUlELCBhbGJlaXRcbiAgLy8gd2l0aCBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgYXJvdW5kIGhvdyB0aGUgY2xvY2tfc2VxIGFuZCBub2RlIGZpZWxkc1xuICAvLyBhcmUgcmFuZG9taXplZCwgd2hpY2ggaXMgd2h5IHdlIGNhbGwgdjEgd2l0aCBfdjY6IHRydWUuXG4gIGxldCBieXRlcyA9IHYxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIF92NjogdHJ1ZVxuICB9LCBuZXcgVWludDhBcnJheSgxNikpO1xuXG4gIC8vIFJlb3JkZXIgdGhlIGZpZWxkcyB0byB2NiBsYXlvdXQuXG4gIGJ5dGVzID0gdjFUb1Y2KGJ5dGVzKTtcblxuICAvLyBSZXR1cm4gYXMgYSBieXRlIGFycmF5IGlmIHJlcXVlc3RlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6ToV1)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NlRvVjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2NiBVVUlEIHRvIGEgdjEgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjYgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2MSBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjZUb1YxKHV1aWQpIHtcbiAgY29uc3QgdjZCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjFCeXRlcyA9IF92NlRvVjEodjZCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjFCeXRlcykgOiB2MUJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2NiAtPiB2MVxuZnVuY3Rpb24gX3Y2VG9WMSh2NkJ5dGVzKSB7XG4gIHJldHVybiBVaW50OEFycmF5Lm9mKCh2NkJ5dGVzWzNdICYgMHgwZikgPDwgNCB8IHY2Qnl0ZXNbNF0gPj4gNCAmIDB4MGYsICh2NkJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgdjZCeXRlc1s2XSAmIDB4MGYsIHY2Qnl0ZXNbN10sICh2NkJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbMl0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbM10gJiAweGYwKSA+PiA0LCAweDEwIHwgKHY2Qnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjZCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1sxXSAmIDB4ZjApID4+IDQsIHY2Qnl0ZXNbOF0sIHY2Qnl0ZXNbOV0sIHY2Qnl0ZXNbMTBdLCB2NkJ5dGVzWzExXSwgdjZCeXRlc1sxMl0sIHY2Qnl0ZXNbMTNdLCB2NkJ5dGVzWzE0XSwgdjZCeXRlc1sxNV0pO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v6ToV1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIFVVSUQgVjcgLSBVbml4IEVwb2NoIHRpbWUtYmFzZWQgVVVJRFxuICpcbiAqIFRoZSBJRVRGIGhhcyBwdWJsaXNoZWQgUkZDOTU2MiwgaW50cm9kdWNpbmcgMyBuZXcgVVVJRCB2ZXJzaW9ucyAoNiw3LDgpLiBUaGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBWNyBpcyBiYXNlZCBvbiB0aGUgYWNjZXB0ZWQsIHRob3VnaCBub3QgeWV0IGFwcHJvdmVkLFxuICogcmV2aXNpb25zLlxuICpcbiAqIFJGQyA5NTYyOmh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwgVW5pdmVyc2FsbHkgVW5pcXVlXG4gKiBJRGVudGlmaWVycyAoVVVJRHMpXG5cbiAqXG4gKiBTYW1wbGUgVjcgdmFsdWU6XG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI25hbWUtZXhhbXBsZS1vZi1hLXV1aWR2Ny12YWx1ZVxuICpcbiAqIE1vbm90b25pYyBCaXQgTGF5b3V0OiBSRkMgcmZjOTU2Mi42LjIgTWV0aG9kIDEsIERlZGljYXRlZCBDb3VudGVyIEJpdHMgcmVmOlxuICogICAgIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwjc2VjdGlvbi02LjItNS4xXG4gKlxuICogICAwICAgICAgICAgICAgICAgICAgIDEgICAgICAgICAgICAgICAgICAgMiAgICAgICAgICAgICAgICAgICAzIDAgMSAyIDMgNCA1IDZcbiAqICAgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDEgMiAzIDQgNSA2IDcgOCA5IDAgMVxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgfCAgdmVyICB8ICAgICAgICBzZXFfaGkgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8dmFyfCAgICAgICAgICAgICAgIHNlcV9sb3cgICAgICAgICAgICAgICB8ICAgICAgICByYW5kICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICpcbiAqIHNlcSBpcyBhIDMxIGJpdCBzZXJpYWxpemVkIGNvdW50ZXI7IGNvbXByaXNlZCBvZiAxMiBiaXQgc2VxX2hpIGFuZCAxOSBiaXRcbiAqIHNlcV9sb3csIGFuZCByYW5kb21seSBpbml0aWFsaXplZCB1cG9uIHRpbWVzdGFtcCBjaGFuZ2UuIDMxIGJpdCBjb3VudGVyIHNpemVcbiAqIHdhcyBzZWxlY3RlZCBhcyBhbnkgYml0d2lzZSBvcGVyYXRpb25zIGluIG5vZGUgYXJlIGRvbmUgYXMgX3NpZ25lZF8gMzIgYml0XG4gKiBpbnRzLiB3ZSBleGNsdWRlIHRoZSBzaWduIGJpdC5cbiAqL1xuXG5sZXQgX3NlcUxvdyA9IG51bGw7XG5sZXQgX3NlcUhpZ2ggPSBudWxsO1xubGV0IF9tc2VjcyA9IDA7XG5mdW5jdGlvbiB2NyhvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBpbml0aWFsaXplIGJ1ZmZlciBhbmQgcG9pbnRlclxuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gcm5kcyBpcyBVaW50OEFycmF5KDE2KSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXNcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gbWlsbGlzZWNvbmRzIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDBcbiAgY29uc3QgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBzZXEgaXMgdXNlciBwcm92aWRlZCAzMSBiaXQgY291bnRlclxuICBsZXQgc2VxID0gb3B0aW9ucy5zZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2VxIDogbnVsbDtcblxuICAvLyBpbml0aWFsaXplIGxvY2FsIHNlcSBoaWdoL2xvdyBwYXJ0c1xuICBsZXQgc2VxSGlnaCA9IF9zZXFIaWdoO1xuICBsZXQgc2VxTG93ID0gX3NlcUxvdztcblxuICAvLyBjaGVjayBpZiBjbG9jayBoYXMgYWR2YW5jZWQgYW5kIHVzZXIgaGFzIG5vdCBwcm92aWRlZCBtc2Vjc1xuICBpZiAobXNlY3MgPiBfbXNlY3MgJiYgb3B0aW9ucy5tc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgX21zZWNzID0gbXNlY3M7XG5cbiAgICAvLyB1bmxlc3MgdXNlciBwcm92aWRlZCBzZXEsIHJlc2V0IHNlcSBwYXJ0c1xuICAgIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAgIHNlcUhpZ2ggPSBudWxsO1xuICAgICAgc2VxTG93ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgdXNlciBwcm92aWRlZCBzZXFcbiAgaWYgKHNlcSAhPT0gbnVsbCkge1xuICAgIC8vIHRyaW0gcHJvdmlkZWQgc2VxIHRvIDMxIGJpdHMgb2YgdmFsdWUsIGF2b2lkaW5nIG92ZXJmbG93XG4gICAgaWYgKHNlcSA+IDB4N2ZmZmZmZmYpIHtcbiAgICAgIHNlcSA9IDB4N2ZmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgcHJvdmlkZWQgc2VxIGludG8gaGlnaC9sb3cgcGFydHNcbiAgICBzZXFIaWdoID0gc2VxID4+PiAxOSAmIDB4ZmZmO1xuICAgIHNlcUxvdyA9IHNlcSAmIDB4N2ZmZmY7XG4gIH1cblxuICAvLyByYW5kb21seSBpbml0aWFsaXplIHNlcVxuICBpZiAoc2VxSGlnaCA9PT0gbnVsbCB8fCBzZXFMb3cgPT09IG51bGwpIHtcbiAgICBzZXFIaWdoID0gcm5kc1s2XSAmIDB4N2Y7XG4gICAgc2VxSGlnaCA9IHNlcUhpZ2ggPDwgOCB8IHJuZHNbN107XG4gICAgc2VxTG93ID0gcm5kc1s4XSAmIDB4M2Y7IC8vIHBhZCBmb3IgdmFyXG4gICAgc2VxTG93ID0gc2VxTG93IDw8IDggfCBybmRzWzldO1xuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA1IHwgcm5kc1sxMF0gPj4+IDM7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgc2VxIGlmIHdpdGhpbiBtc2VjcyB3aW5kb3dcbiAgaWYgKG1zZWNzICsgMTAwMDAgPiBfbXNlY3MgJiYgc2VxID09PSBudWxsKSB7XG4gICAgaWYgKCsrc2VxTG93ID4gMHg3ZmZmZikge1xuICAgICAgc2VxTG93ID0gMDtcbiAgICAgIGlmICgrK3NlcUhpZ2ggPiAweGZmZikge1xuICAgICAgICBzZXFIaWdoID0gMDtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgaW50ZXJuYWwgX21zZWNzLiB0aGlzIGFsbG93cyB1cyB0byBjb250aW51ZSBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gd2hpbGUgc3RheWluZyBtb25vdG9uaWMuIE5vdGUsIG9uY2Ugd2UgaGl0IDEwayBtaWxsaXNlY29uZHMgYmV5b25kIHN5c3RlbVxuICAgICAgICAvLyBjbG9jaywgd2Ugd2lsbCByZXNldCBicmVha2luZyBtb25vdG9uaWNpdHkgKGFmdGVyICgyXjMxKSoxMDAwMCBnZW5lcmF0aW9ucylcbiAgICAgICAgX21zZWNzKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0dGluZzsgd2UgaGF2ZSBhZHZhbmNlZCBtb3JlIHRoYW5cbiAgICAvLyAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW0gY2xvY2tcbiAgICBfbXNlY3MgPSBtc2VjcztcbiAgfVxuICBfc2VxSGlnaCA9IHNlcUhpZ2g7XG4gIF9zZXFMb3cgPSBzZXFMb3c7XG5cbiAgLy8gW2J5dGVzIDAtNV0gNDggYml0cyBvZiBsb2NhbCB0aW1lc3RhbXBcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzICYgMHhmZjtcblxuICAvLyBbYnl0ZSA2XSAtIHNldCA0IGJpdHMgb2YgdmVyc2lvbiAoNykgd2l0aCBmaXJzdCA0IGJpdHMgc2VxX2hpXG4gIGJbaSsrXSA9IHNlcUhpZ2ggPj4+IDQgJiAweDBmIHwgMHg3MDtcblxuICAvLyBbYnl0ZSA3XSByZW1haW5pbmcgOCBiaXRzIG9mIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoICYgMHhmZjtcblxuICAvLyBbYnl0ZSA4XSAtIHZhcmlhbnQgKDIgYml0cyksIGZpcnN0IDYgYml0cyBzZXFfbG93XG4gIGJbaSsrXSA9IHNlcUxvdyA+Pj4gMTMgJiAweDNmIHwgMHg4MDtcblxuICAvLyBbYnl0ZSA5XSA4IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDUgJiAweGZmO1xuXG4gIC8vIFtieXRlIDEwXSByZW1haW5pbmcgNSBiaXRzIHNlcV9sb3csIDMgYml0cyByYW5kb21cbiAgYltpKytdID0gc2VxTG93IDw8IDMgJiAweGZmIHwgcm5kc1sxMF0gJiAweDA3O1xuXG4gIC8vIFtieXRlcyAxMS0xNV0gYWx3YXlzIHJhbmRvbVxuICBiW2krK10gPSBybmRzWzExXTtcbiAgYltpKytdID0gcm5kc1sxMl07XG4gIGJbaSsrXSA9IHJuZHNbMTNdO1xuICBiW2krK10gPSBybmRzWzE0XTtcbiAgYltpKytdID0gcm5kc1sxNV07XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/output_parsers.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/core/output_parsers.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/output_parsers/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSxpSkFBMkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9vdXRwdXRfcGFyc2Vycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/output_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/core/output_parsers/openai_tools.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/output_parsers/openai_tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/output_parsers/openai_tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dF9wYXJzZXJzL29wZW5haV90b29scy5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEtBQXlFIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/outputs.cjs":
/*!**************************************************!*\
  !*** ./node_modules/@langchain/core/outputs.cjs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/outputs.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/outputs.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dHMuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHVIQUE4QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL291dHB1dHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L291dHB1dHMuY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/outputs.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/retrievers.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@langchain/core/retrievers.cjs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/retrievers/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/retrievers/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3JldHJpZXZlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHlJQUF1RCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3JldHJpZXZlcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JldHJpZXZlcnMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/retrievers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/runnables.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/runnables/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUlBQXNEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9ydW5uYWJsZXMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/runnables/remote.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@langchain/core/runnables/remote.cjs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/runnables/remote.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/runnables/remote.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy9yZW1vdGUuY2pzIiwibWFwcGluZ3MiOiJBQUFBLDBJQUF3RCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlcy9yZW1vdGUuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC9ydW5uYWJsZXMvcmVtb3RlLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/runnables/remote.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/stores.cjs":
/*!*************************************************!*\
  !*** ./node_modules/@langchain/core/stores.cjs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/stores.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/stores.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3N0b3Jlcy5janMiLCJtYXBwaW5ncyI6IkFBQUEscUhBQTZDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvc3RvcmVzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9zdG9yZXMuY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/stores.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/tools.cjs":
/*!************************************************!*\
  !*** ./node_modules/@langchain/core/tools.cjs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/tools/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/tools/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3Rvb2xzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSwrSEFBa0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS90b29scy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvdG9vbHMvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/tools.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/async_caller.cjs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/async_caller.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/async_caller.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2FzeW5jX2NhbGxlci5janMiLCJtYXBwaW5ncyI6IkFBQUEsOElBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/chunk_array.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/chunk_array.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/chunk_array.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2NodW5rX2FycmF5LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9jaHVua19hcnJheS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2NodW5rX2FycmF5LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/env.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@langchain/core/utils/env.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/env.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/env.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Vudi5janMiLCJtYXBwaW5ncyI6IkFBQUEsNEhBQWlEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvdXRpbHMvZW52LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/env.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/function_calling.cjs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/function_calling.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/function_calling.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmcuY2pzIiwibWFwcGluZ3MiOiJBQUFBLHNKQUE4RCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmcuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vZGlzdC91dGlscy9mdW5jdGlvbl9jYWxsaW5nLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/core/utils/json_schema.cjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/json_schema.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/json_schema.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2pzb25fc2NoZW1hLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy9qc29uX3NjaGVtYS5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL2pzb25fc2NoZW1hLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/json_schema.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/stream.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/stream.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/stream.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbS5janMiLCJtYXBwaW5ncyI6IkFBQUEsa0lBQW9EIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvdXRpbHMvc3RyZWFtLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/core/utils/types.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@langchain/core/utils/types.cjs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/utils/types/index.cjs */ \"(rsc)/./node_modules/@langchain/core/dist/utils/types/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3R5cGVzLmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SUFBeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS91dGlscy90eXBlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9kaXN0L3V0aWxzL3R5cGVzL2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/core/utils/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/auth.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureAuthOptionScopes = exports.aiPlatformScope = exports.ApiKeyGoogleAuth = exports.GoogleAbstractedFetchClient = void 0;\nconst stream_js_1 = __webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\");\nclass GoogleAbstractedFetchClient {\n    async _buildData(res, opts) {\n        switch (opts.responseType) {\n            case \"json\":\n                return res.json();\n            case \"stream\":\n                return new stream_js_1.ReadableJsonStream(res.body);\n            default:\n                return res.blob();\n        }\n    }\n    async _request(url, opts, additionalHeaders) {\n        if (url == null)\n            throw new Error(\"Missing URL\");\n        const fetchOptions = {\n            method: opts.method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...(opts.headers ?? {}),\n                ...(additionalHeaders ?? {}),\n            },\n        };\n        if (opts.data !== undefined) {\n            if (typeof opts.data === \"string\") {\n                fetchOptions.body = opts.data;\n            }\n            else {\n                fetchOptions.body = JSON.stringify(opts.data);\n            }\n        }\n        const res = await fetch(url, fetchOptions);\n        if (!res.ok) {\n            const resText = await res.text();\n            const error = new Error(`Google request failed with status code ${res.status}: ${resText}`);\n            /* eslint-disable @typescript-eslint/no-explicit-any */\n            error.response = res;\n            error.details = {\n                url,\n                opts,\n                fetchOptions,\n                result: res,\n            };\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            throw error;\n        }\n        const data = await this._buildData(res, opts);\n        return {\n            data,\n            config: {},\n            status: res.status,\n            statusText: res.statusText,\n            headers: res.headers,\n            request: { responseURL: res.url },\n        };\n    }\n}\nexports.GoogleAbstractedFetchClient = GoogleAbstractedFetchClient;\nclass ApiKeyGoogleAuth extends GoogleAbstractedFetchClient {\n    constructor(apiKey) {\n        super();\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.apiKey = apiKey;\n    }\n    get clientType() {\n        return \"apiKey\";\n    }\n    getProjectId() {\n        throw new Error(\"APIs that require a project ID cannot use an API key\");\n        // Perhaps we could implement this if needed:\n        // https://cloud.google.com/docs/authentication/api-keys#get-info\n    }\n    request(opts) {\n        const authHeader = {\n            \"X-Goog-Api-Key\": this.apiKey,\n        };\n        return this._request(opts.url, opts, authHeader);\n    }\n}\nexports.ApiKeyGoogleAuth = ApiKeyGoogleAuth;\nfunction aiPlatformScope(platform) {\n    switch (platform) {\n        case \"gai\":\n            return [\"https://www.googleapis.com/auth/generative-language\"];\n        default:\n            return [\"https://www.googleapis.com/auth/cloud-platform\"];\n    }\n}\nexports.aiPlatformScope = aiPlatformScope;\nfunction ensureAuthOptionScopes(authOption, scopeProperty, scopesOrPlatform) {\n    // If the property is already set, return it\n    if (authOption && Object.hasOwn(authOption, scopeProperty)) {\n        return authOption;\n    }\n    // Otherwise add it\n    const scopes = Array.isArray(scopesOrPlatform)\n        ? scopesOrPlatform\n        : aiPlatformScope(scopesOrPlatform ?? \"gcp\");\n    return {\n        [scopeProperty]: scopes,\n        ...(authOption ?? {}),\n    };\n}\nexports.ensureAuthOptionScopes = ensureAuthOptionScopes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvYXV0aC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsbUNBQW1DO0FBQ3pILG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVyxJQUFJLFFBQVE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L2F1dGguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnN1cmVBdXRoT3B0aW9uU2NvcGVzID0gZXhwb3J0cy5haVBsYXRmb3JtU2NvcGUgPSBleHBvcnRzLkFwaUtleUdvb2dsZUF1dGggPSBleHBvcnRzLkdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvc3RyZWFtLmNqc1wiKTtcbmNsYXNzIEdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudCB7XG4gICAgYXN5bmMgX2J1aWxkRGF0YShyZXMsIG9wdHMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJlYW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmVhbV9qc18xLlJlYWRhYmxlSnNvblN0cmVhbShyZXMuYm9keSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuYmxvYigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0KHVybCwgb3B0cywgYWRkaXRpb25hbEhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBVUkxcIik7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4uKG9wdHMuaGVhZGVycyA/PyB7fSksXG4gICAgICAgICAgICAgICAgLi4uKGFkZGl0aW9uYWxIZWFkZXJzID8/IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMuYm9keSA9IG9wdHMuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0cy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXNUZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBHb29nbGUgcmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke3Jlcy5zdGF0dXN9OiAke3Jlc1RleHR9YCk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgICAgIGVycm9yLmRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2J1aWxkRGF0YShyZXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICAgICAgcmVxdWVzdDogeyByZXNwb25zZVVSTDogcmVzLnVybCB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQWJzdHJhY3RlZEZldGNoQ2xpZW50ID0gR29vZ2xlQWJzdHJhY3RlZEZldGNoQ2xpZW50O1xuY2xhc3MgQXBpS2V5R29vZ2xlQXV0aCBleHRlbmRzIEdvb2dsZUFic3RyYWN0ZWRGZXRjaENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgZ2V0IGNsaWVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFwaUtleVwiO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0SWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFQSXMgdGhhdCByZXF1aXJlIGEgcHJvamVjdCBJRCBjYW5ub3QgdXNlIGFuIEFQSSBrZXlcIik7XG4gICAgICAgIC8vIFBlcmhhcHMgd2UgY291bGQgaW1wbGVtZW50IHRoaXMgaWYgbmVlZGVkOlxuICAgICAgICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9hcGkta2V5cyNnZXQtaW5mb1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlciA9IHtcbiAgICAgICAgICAgIFwiWC1Hb29nLUFwaS1LZXlcIjogdGhpcy5hcGlLZXksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KG9wdHMudXJsLCBvcHRzLCBhdXRoSGVhZGVyKTtcbiAgICB9XG59XG5leHBvcnRzLkFwaUtleUdvb2dsZUF1dGggPSBBcGlLZXlHb29nbGVBdXRoO1xuZnVuY3Rpb24gYWlQbGF0Zm9ybVNjb3BlKHBsYXRmb3JtKSB7XG4gICAgc3dpdGNoIChwbGF0Zm9ybSkge1xuICAgICAgICBjYXNlIFwiZ2FpXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9nZW5lcmF0aXZlLWxhbmd1YWdlXCJdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm1cIl07XG4gICAgfVxufVxuZXhwb3J0cy5haVBsYXRmb3JtU2NvcGUgPSBhaVBsYXRmb3JtU2NvcGU7XG5mdW5jdGlvbiBlbnN1cmVBdXRoT3B0aW9uU2NvcGVzKGF1dGhPcHRpb24sIHNjb3BlUHJvcGVydHksIHNjb3Blc09yUGxhdGZvcm0pIHtcbiAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWxyZWFkeSBzZXQsIHJldHVybiBpdFxuICAgIGlmIChhdXRoT3B0aW9uICYmIE9iamVjdC5oYXNPd24oYXV0aE9wdGlvbiwgc2NvcGVQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIGF1dGhPcHRpb247XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSBhZGQgaXRcbiAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3Blc09yUGxhdGZvcm0pXG4gICAgICAgID8gc2NvcGVzT3JQbGF0Zm9ybVxuICAgICAgICA6IGFpUGxhdGZvcm1TY29wZShzY29wZXNPclBsYXRmb3JtID8/IFwiZ2NwXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtzY29wZVByb3BlcnR5XTogc2NvcGVzLFxuICAgICAgICAuLi4oYXV0aE9wdGlvbiA/PyB7fSksXG4gICAgfTtcbn1cbmV4cG9ydHMuZW5zdXJlQXV0aE9wdGlvblNjb3BlcyA9IGVuc3VyZUF1dGhPcHRpb25TY29wZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/chat_models.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogleBase = exports.ChatConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst chat_models_1 = __webpack_require__(/*! @langchain/core/language_models/chat_models */ \"(rsc)/./node_modules/@langchain/core/language_models/chat_models.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst runnables_1 = __webpack_require__(/*! @langchain/core/runnables */ \"(rsc)/./node_modules/@langchain/core/runnables.cjs\");\nconst openai_tools_1 = __webpack_require__(/*! @langchain/core/output_parsers/openai_tools */ \"(rsc)/./node_modules/@langchain/core/output_parsers/openai_tools.cjs\");\nconst stream_1 = __webpack_require__(/*! @langchain/core/utils/stream */ \"(rsc)/./node_modules/@langchain/core/utils/stream.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nclass ChatConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.convertSystemMessageToHumanContent =\n            fields?.convertSystemMessageToHumanContent;\n    }\n    get useSystemInstruction() {\n        return typeof this.convertSystemMessageToHumanContent === \"boolean\"\n            ? !this.convertSystemMessageToHumanContent\n            : this.computeUseSystemInstruction;\n    }\n    get computeUseSystemInstruction() {\n        // This works on models from April 2024 and later\n        //   Vertex AI: gemini-1.5-pro and gemini-1.0-002 and later\n        //   AI Studio: gemini-1.5-pro-latest\n        if (this.modelFamily === \"palm\") {\n            return false;\n        }\n        else if (this.modelName === \"gemini-1.0-pro-001\") {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName.startsWith(\"gemini-1.0-pro-vision\")) {\n            return false;\n        }\n        else if (this.modelName === \"gemini-pro\" && this.platform === \"gai\") {\n            // on AI Studio gemini-pro is still pointing at gemini-1.0-pro-001\n            return false;\n        }\n        return true;\n    }\n    computeGoogleSearchToolAdjustmentFromModel() {\n        if (this.modelName.startsWith(\"gemini-1.0\")) {\n            return \"googleSearchRetrieval\";\n        }\n        else if (this.modelName.startsWith(\"gemini-1.5\")) {\n            return \"googleSearchRetrieval\";\n        }\n        else {\n            return \"googleSearch\";\n        }\n    }\n    computeGoogleSearchToolAdjustment(apiConfig) {\n        const adj = apiConfig.googleSearchToolAdjustment;\n        if (adj === undefined || adj === true) {\n            return this.computeGoogleSearchToolAdjustmentFromModel();\n        }\n        else {\n            return adj;\n        }\n    }\n    buildGeminiAPI() {\n        const apiConfig = this.apiConfig ?? {};\n        const googleSearchToolAdjustment = this.computeGoogleSearchToolAdjustment(apiConfig);\n        const geminiConfig = {\n            useSystemInstruction: this.useSystemInstruction,\n            googleSearchToolAdjustment,\n            ...apiConfig,\n        };\n        return (0, gemini_js_1.getGeminiAPI)(geminiConfig);\n    }\n    get api() {\n        switch (this.apiName) {\n            case \"google\":\n                return this.buildGeminiAPI();\n            default:\n                return super.api;\n        }\n    }\n}\nexports.ChatConnection = ChatConnection;\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogleBase extends chat_models_1.BaseChatModel {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set based on modelName\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"presencePenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"frequencyPenalty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"logprobs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"topLogprobs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // May intentionally be undefined, meaning to compute this.\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamUsage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        this.streamUsage = fields?.streamUsage ?? this.streamUsage;\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    getLsParams(options) {\n        const params = this.invocationParams(options);\n        return {\n            ls_provider: \"google_vertexai\",\n            ls_model_name: this.model,\n            ls_model_type: \"chat\",\n            ls_temperature: params.temperature ?? undefined,\n            ls_max_tokens: params.maxOutputTokens ?? undefined,\n            ls_stop: options.stop,\n        };\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        if (fields?.platformType !== \"gcp\") {\n            return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n        }\n        else {\n            // GCP doesn't support API Keys\n            return undefined;\n        }\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new ChatConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new ChatConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    bindTools(tools, kwargs) {\n        return this.bind({ tools: (0, common_js_1.convertToGeminiTools)(tools), ...kwargs });\n    }\n    // Replace\n    _llmType() {\n        return \"chat_integration\";\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    invocationParams(options) {\n        return (0, common_js_1.copyAIModelParams)(this, options);\n    }\n    async _generate(messages, options, runManager) {\n        const parameters = this.invocationParams(options);\n        if (this.streaming) {\n            const stream = this._streamResponseChunks(messages, options, runManager);\n            let finalChunk = null;\n            for await (const chunk of stream) {\n                finalChunk = !finalChunk ? chunk : (0, stream_1.concat)(finalChunk, chunk);\n            }\n            if (!finalChunk) {\n                throw new Error(\"No chunks were returned from the stream.\");\n            }\n            return {\n                generations: [finalChunk],\n            };\n        }\n        const response = await this.connection.request(messages, parameters, options, runManager);\n        const ret = this.connection.api.responseToChatResult(response);\n        const chunk = ret?.generations?.[0];\n        if (chunk) {\n            await runManager?.handleLLMNewToken(chunk.text || \"\");\n        }\n        return ret;\n    }\n    async *_streamResponseChunks(_messages, options, runManager) {\n        // Make the call as a streaming request\n        const parameters = this.invocationParams(options);\n        const response = await this.streamedConnection.request(_messages, parameters, options, runManager);\n        // Get the streaming parser of the response\n        const stream = response.data;\n        let usageMetadata;\n        // Loop until the end of the stream\n        // During the loop, yield each time we get a chunk from the streaming parser\n        // that is either available or added to the queue\n        while (!stream.streamDone) {\n            const output = await stream.nextChunk();\n            await runManager?.handleCustomEvent(`google-chunk-${this.constructor.name}`, {\n                output,\n            });\n            if (output &&\n                output.usageMetadata &&\n                this.streamUsage !== false &&\n                options.streamUsage !== false) {\n                usageMetadata = {\n                    input_tokens: output.usageMetadata.promptTokenCount,\n                    output_tokens: output.usageMetadata.candidatesTokenCount,\n                    total_tokens: output.usageMetadata.totalTokenCount,\n                };\n            }\n            const chunk = output !== null\n                ? this.connection.api.responseToChatGeneration({ data: output })\n                : new outputs_1.ChatGenerationChunk({\n                    text: \"\",\n                    generationInfo: { finishReason: \"stop\" },\n                    message: new messages_1.AIMessageChunk({\n                        content: \"\",\n                        usage_metadata: usageMetadata,\n                    }),\n                });\n            if (chunk) {\n                yield chunk;\n                await runManager?.handleLLMNewToken(chunk.text ?? \"\", undefined, undefined, undefined, undefined, { chunk });\n            }\n        }\n    }\n    /** @ignore */\n    _combineLLMOutput() {\n        return [];\n    }\n    withStructuredOutput(outputSchema, config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const schema = outputSchema;\n        const name = config?.name;\n        const method = config?.method;\n        const includeRaw = config?.includeRaw;\n        if (method === \"jsonMode\") {\n            throw new Error(`Google only supports \"functionCalling\" as a method.`);\n        }\n        let functionName = name ?? \"extract\";\n        let outputParser;\n        let tools;\n        if (isZodSchema(schema)) {\n            const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(schema);\n            tools = [\n                {\n                    functionDeclarations: [\n                        {\n                            name: functionName,\n                            description: jsonSchema.description ?? \"A function available to call.\",\n                            parameters: jsonSchema,\n                        },\n                    ],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n                zodSchema: schema,\n            });\n        }\n        else {\n            let geminiFunctionDefinition;\n            if (typeof schema.name === \"string\" &&\n                typeof schema.parameters === \"object\" &&\n                schema.parameters != null) {\n                geminiFunctionDefinition = schema;\n                functionName = schema.name;\n            }\n            else {\n                geminiFunctionDefinition = {\n                    name: functionName,\n                    description: schema.description ?? \"\",\n                    parameters: schema,\n                };\n            }\n            tools = [\n                {\n                    functionDeclarations: [geminiFunctionDefinition],\n                },\n            ];\n            outputParser = new openai_tools_1.JsonOutputKeyToolsParser({\n                returnSingle: true,\n                keyName: functionName,\n            });\n        }\n        const llm = this.bind({\n            tools,\n            tool_choice: functionName,\n        });\n        if (!includeRaw) {\n            return llm.pipe(outputParser).withConfig({\n                runName: \"ChatGoogleStructuredOutput\",\n            });\n        }\n        const parserAssign = runnables_1.RunnablePassthrough.assign({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            parsed: (input, config) => outputParser.invoke(input.raw, config),\n        });\n        const parserNone = runnables_1.RunnablePassthrough.assign({\n            parsed: () => null,\n        });\n        const parsedWithFallback = parserAssign.withFallbacks({\n            fallbacks: [parserNone],\n        });\n        return runnables_1.RunnableSequence.from([\n            {\n                raw: llm,\n            },\n            parsedWithFallback,\n        ]).withConfig({\n            runName: \"StructuredOutputRunnable\",\n        });\n    }\n}\nexports.ChatGoogleBase = ChatGoogleBase;\nfunction isZodSchema(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninput) {\n    // Check for a characteristic method of Zod schemas\n    return typeof input?.parse === \"function\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHlIQUE2QztBQUMzRSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQTBCO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLHFGQUEyQjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyx5SEFBNkM7QUFDNUUsaUJBQWlCLG1CQUFPLENBQUMsMkZBQThCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFvQjtBQUNoRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSxzQ0FBc0MsbUJBQU8sQ0FBQyxtSUFBc0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkUsdURBQXVELG9CQUFvQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFnRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9IQUFvSCxPQUFPO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9jaGF0X21vZGVscy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRHb29nbGVCYXNlID0gZXhwb3J0cy5DaGF0Q29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBjaGF0X21vZGVsc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9sYW5ndWFnZV9tb2RlbHMvY2hhdF9tb2RlbHNcIik7XG5jb25zdCBvdXRwdXRzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL291dHB1dHNcIik7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmNvbnN0IHJ1bm5hYmxlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIik7XG5jb25zdCBvcGVuYWlfdG9vbHNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0X3BhcnNlcnMvb3BlbmFpX3Rvb2xzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3N0cmVhbVwiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvY29tbW9uLmNqc1wiKTtcbmNvbnN0IGNvbm5lY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24uY2pzXCIpO1xuY29uc3QgZ2VtaW5pX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9nZW1pbmkuY2pzXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4vYXV0aC5janNcIik7XG5jb25zdCBmYWlsZWRfaGFuZGxlcl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzXCIpO1xuY29uc3Qgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzXCIpO1xuY2xhc3MgQ2hhdENvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPVxuICAgICAgICAgICAgZmllbGRzPy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50O1xuICAgIH1cbiAgICBnZXQgdXNlU3lzdGVtSW5zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50ID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgPyAhdGhpcy5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50XG4gICAgICAgICAgICA6IHRoaXMuY29tcHV0ZVVzZVN5c3RlbUluc3RydWN0aW9uO1xuICAgIH1cbiAgICBnZXQgY29tcHV0ZVVzZVN5c3RlbUluc3RydWN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIHdvcmtzIG9uIG1vZGVscyBmcm9tIEFwcmlsIDIwMjQgYW5kIGxhdGVyXG4gICAgICAgIC8vICAgVmVydGV4IEFJOiBnZW1pbmktMS41LXBybyBhbmQgZ2VtaW5pLTEuMC0wMDIgYW5kIGxhdGVyXG4gICAgICAgIC8vICAgQUkgU3R1ZGlvOiBnZW1pbmktMS41LXByby1sYXRlc3RcbiAgICAgICAgaWYgKHRoaXMubW9kZWxGYW1pbHkgPT09IFwicGFsbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUgPT09IFwiZ2VtaW5pLTEuMC1wcm8tMDAxXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ2VtaW5pLXByby12aXNpb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ2VtaW5pLTEuMC1wcm8tdmlzaW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUgPT09IFwiZ2VtaW5pLXByb1wiICYmIHRoaXMucGxhdGZvcm0gPT09IFwiZ2FpXCIpIHtcbiAgICAgICAgICAgIC8vIG9uIEFJIFN0dWRpbyBnZW1pbmktcHJvIGlzIHN0aWxsIHBvaW50aW5nIGF0IGdlbWluaS0xLjAtcHJvLTAwMVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb21wdXRlR29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnRGcm9tTW9kZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ2VtaW5pLTEuMFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlbE5hbWUuc3RhcnRzV2l0aChcImdlbWluaS0xLjVcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBcImdvb2dsZVNlYXJjaFJldHJpZXZhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZ29vZ2xlU2VhcmNoXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50KGFwaUNvbmZpZykge1xuICAgICAgICBjb25zdCBhZGogPSBhcGlDb25maWcuZ29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnQ7XG4gICAgICAgIGlmIChhZGogPT09IHVuZGVmaW5lZCB8fCBhZGogPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVHb29nbGVTZWFyY2hUb29sQWRqdXN0bWVudEZyb21Nb2RlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFkajtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZEdlbWluaUFQSSgpIHtcbiAgICAgICAgY29uc3QgYXBpQ29uZmlnID0gdGhpcy5hcGlDb25maWcgPz8ge307XG4gICAgICAgIGNvbnN0IGdvb2dsZVNlYXJjaFRvb2xBZGp1c3RtZW50ID0gdGhpcy5jb21wdXRlR29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnQoYXBpQ29uZmlnKTtcbiAgICAgICAgY29uc3QgZ2VtaW5pQ29uZmlnID0ge1xuICAgICAgICAgICAgdXNlU3lzdGVtSW5zdHJ1Y3Rpb246IHRoaXMudXNlU3lzdGVtSW5zdHJ1Y3Rpb24sXG4gICAgICAgICAgICBnb29nbGVTZWFyY2hUb29sQWRqdXN0bWVudCxcbiAgICAgICAgICAgIC4uLmFwaUNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICgwLCBnZW1pbmlfanNfMS5nZXRHZW1pbmlBUEkpKGdlbWluaUNvbmZpZyk7XG4gICAgfVxuICAgIGdldCBhcGkoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hcGlOYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ29vZ2xlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRHZW1pbmlBUEkoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFwaTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdENvbm5lY3Rpb24gPSBDaGF0Q29ubmVjdGlvbjtcbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhIEdvb2dsZSBjaGF0IG1vZGVsLlxuICovXG5jbGFzcyBDaGF0R29vZ2xlQmFzZSBleHRlbmRzIGNoYXRfbW9kZWxzXzEuQmFzZUNoYXRNb2RlbCB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0R29vZ2xlXCI7XG4gICAgfVxuICAgIGdldCBsY19zZWNyZXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0aE9wdGlvbnM6IFwiR09PR0xFX0FVVEhfT1BUSU9OU1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKDAsIGZhaWxlZF9oYW5kbGVyX2pzXzEuZW5zdXJlUGFyYW1zKShmaWVsZHMpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgYmFzZWQgb24gbW9kZWxOYW1lXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJnZW1pbmktcHJvXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBlcmF0dXJlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwLjdcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heE91dHB1dFRva2Vuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTAyNFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wUFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMC44XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BLXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA0MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJlc2VuY2VQZW5hbHR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyZXF1ZW5jeVBlbmFsdHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcFNlcXVlbmNlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvZ3Byb2JzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcExvZ3Byb2JzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYWZldHlTZXR0aW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1heSBpbnRlbnRpb25hbGx5IGJlIHVuZGVmaW5lZCwgbWVhbmluZyB0byBjb21wdXRlIHRoaXMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FmZXR5SGFuZGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1Vc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29ubmVjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJlYW1lZENvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGNvbW1vbl9qc18xLmNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50bykoZmllbGRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZldHlIYW5kbGVyID1cbiAgICAgICAgICAgIGZpZWxkcz8uc2FmZXR5SGFuZGxlciA/PyBuZXcgZ2VtaW5pX2pzXzEuRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Vc2FnZSA9IGZpZWxkcz8uc3RyZWFtVXNhZ2UgPz8gdGhpcy5zdHJlYW1Vc2FnZTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5idWlsZENsaWVudChmaWVsZHMpO1xuICAgICAgICB0aGlzLmJ1aWxkQ29ubmVjdGlvbihmaWVsZHMgPz8ge30sIGNsaWVudCk7XG4gICAgfVxuICAgIGdldExzUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5pbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbHNfcHJvdmlkZXI6IFwiZ29vZ2xlX3ZlcnRleGFpXCIsXG4gICAgICAgICAgICBsc19tb2RlbF9uYW1lOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgbHNfbW9kZWxfdHlwZTogXCJjaGF0XCIsXG4gICAgICAgICAgICBsc190ZW1wZXJhdHVyZTogcGFyYW1zLnRlbXBlcmF0dXJlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxzX21heF90b2tlbnM6IHBhcmFtcy5tYXhPdXRwdXRUb2tlbnMgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgbHNfc3RvcDogb3B0aW9ucy5zdG9wLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEFwaUtleUNsaWVudChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuQXBpS2V5R29vZ2xlQXV0aChhcGlLZXkpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleShmaWVsZHMpIHtcbiAgICAgICAgaWYgKGZpZWxkcz8ucGxhdGZvcm1UeXBlICE9PSBcImdjcFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzPy5hcGlLZXkgPz8gKDAsIGVudl8xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiR09PR0xFX0FQSV9LRVlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHQ1AgZG9lc24ndCBzdXBwb3J0IEFQSSBLZXlzXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmJ1aWxkQXBpS2V5KGZpZWxkcyk7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQXBpS2V5Q2xpZW50KGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFic3RyYWN0ZWRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZENvbm5lY3Rpb24oZmllbGRzLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENoYXRDb25uZWN0aW9uKHsgLi4uZmllbGRzLCAuLi50aGlzIH0sIHRoaXMuY2FsbGVyLCBjbGllbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdHJlYW1lZENvbm5lY3Rpb24gPSBuZXcgQ2hhdENvbm5lY3Rpb24oeyAuLi5maWVsZHMsIC4uLnRoaXMgfSwgdGhpcy5jYWxsZXIsIGNsaWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGdldCBwbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5wbGF0Zm9ybTtcbiAgICB9XG4gICAgYmluZFRvb2xzKHRvb2xzLCBrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZCh7IHRvb2xzOiAoMCwgY29tbW9uX2pzXzEuY29udmVydFRvR2VtaW5pVG9vbHMpKHRvb2xzKSwgLi4ua3dhcmdzIH0pO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlXG4gICAgX2xsbVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImNoYXRfaW50ZWdyYXRpb25cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gaW52b2tlIHRoZSBtb2RlbFxuICAgICAqL1xuICAgIGludm9jYXRpb25QYXJhbXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGNvbW1vbl9qc18xLmNvcHlBSU1vZGVsUGFyYW1zKSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2dlbmVyYXRlKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmludm9jYXRpb25QYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpO1xuICAgICAgICAgICAgbGV0IGZpbmFsQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gIWZpbmFsQ2h1bmsgPyBjaHVuayA6ICgwLCBzdHJlYW1fMS5jb25jYXQpKGZpbmFsQ2h1bmssIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmluYWxDaHVuaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNodW5rcyB3ZXJlIHJldHVybmVkIGZyb20gdGhlIHN0cmVhbS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbZmluYWxDaHVua10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QobWVzc2FnZXMsIHBhcmFtZXRlcnMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLmNvbm5lY3Rpb24uYXBpLnJlc3BvbnNlVG9DaGF0UmVzdWx0KHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSByZXQ/LmdlbmVyYXRpb25zPy5bMF07XG4gICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4oY2h1bmsudGV4dCB8fCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKF9tZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICAvLyBNYWtlIHRoZSBjYWxsIGFzIGEgc3RyZWFtaW5nIHJlcXVlc3RcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbWVkQ29ubmVjdGlvbi5yZXF1ZXN0KF9tZXNzYWdlcywgcGFyYW1ldGVycywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgIC8vIEdldCB0aGUgc3RyZWFtaW5nIHBhcnNlciBvZiB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgbGV0IHVzYWdlTWV0YWRhdGE7XG4gICAgICAgIC8vIExvb3AgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyZWFtXG4gICAgICAgIC8vIER1cmluZyB0aGUgbG9vcCwgeWllbGQgZWFjaCB0aW1lIHdlIGdldCBhIGNodW5rIGZyb20gdGhlIHN0cmVhbWluZyBwYXJzZXJcbiAgICAgICAgLy8gdGhhdCBpcyBlaXRoZXIgYXZhaWxhYmxlIG9yIGFkZGVkIHRvIHRoZSBxdWV1ZVxuICAgICAgICB3aGlsZSAoIXN0cmVhbS5zdHJlYW1Eb25lKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBzdHJlYW0ubmV4dENodW5rKCk7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDdXN0b21FdmVudChgZ29vZ2xlLWNodW5rLSR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICBvdXRwdXQudXNhZ2VNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVXNhZ2UgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJlYW1Vc2FnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB1c2FnZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLnByb21wdFRva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLmNhbmRpZGF0ZXNUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IG91dHB1dC51c2FnZU1ldGFkYXRhLnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBvdXRwdXQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29ubmVjdGlvbi5hcGkucmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKHsgZGF0YTogb3V0cHV0IH0pXG4gICAgICAgICAgICAgICAgOiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogeyBmaW5pc2hSZWFzb246IFwic3RvcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihjaHVuay50ZXh0ID8/IFwiXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBjaHVuayB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIF9jb21iaW5lTExNT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHdpdGhTdHJ1Y3R1cmVkT3V0cHV0KG91dHB1dFNjaGVtYSwgY29uZmlnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG91dHB1dFNjaGVtYTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvbmZpZz8ubmFtZTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY29uZmlnPy5tZXRob2Q7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVSYXcgPSBjb25maWc/LmluY2x1ZGVSYXc7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwianNvbk1vZGVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb29nbGUgb25seSBzdXBwb3J0cyBcImZ1bmN0aW9uQ2FsbGluZ1wiIGFzIGEgbWV0aG9kLmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSBuYW1lID8/IFwiZXh0cmFjdFwiO1xuICAgICAgICBsZXQgb3V0cHV0UGFyc2VyO1xuICAgICAgICBsZXQgdG9vbHM7XG4gICAgICAgIGlmIChpc1pvZFNjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uU2NoZW1hID0gKDAsIHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xLnpvZFRvR2VtaW5pUGFyYW1ldGVycykoc2NoZW1hKTtcbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGpzb25TY2hlbWEuZGVzY3JpcHRpb24gPz8gXCJBIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb3V0cHV0UGFyc2VyID0gbmV3IG9wZW5haV90b29sc18xLkpzb25PdXRwdXRLZXlUb29sc1BhcnNlcih7XG4gICAgICAgICAgICAgICAgcmV0dXJuU2luZ2xlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleU5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGdlbWluaUZ1bmN0aW9uRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2NoZW1hLnBhcmFtZXRlcnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBzY2hlbWEucGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2VtaW5pRnVuY3Rpb25EZWZpbml0aW9uID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9IHNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VtaW5pRnVuY3Rpb25EZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWEuZGVzY3JpcHRpb24gPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogc2NoZW1hLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29scyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbZ2VtaW5pRnVuY3Rpb25EZWZpbml0aW9uXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG91dHB1dFBhcnNlciA9IG5ldyBvcGVuYWlfdG9vbHNfMS5Kc29uT3V0cHV0S2V5VG9vbHNQYXJzZXIoe1xuICAgICAgICAgICAgICAgIHJldHVyblNpbmdsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXlOYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsbG0gPSB0aGlzLmJpbmQoe1xuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0b29sX2Nob2ljZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpbmNsdWRlUmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gbGxtLnBpcGUob3V0cHV0UGFyc2VyKS53aXRoQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBcIkNoYXRHb29nbGVTdHJ1Y3R1cmVkT3V0cHV0XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZXJBc3NpZ24gPSBydW5uYWJsZXNfMS5SdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcGFyc2VkOiAoaW5wdXQsIGNvbmZpZykgPT4gb3V0cHV0UGFyc2VyLmludm9rZShpbnB1dC5yYXcsIGNvbmZpZyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZXJOb25lID0gcnVubmFibGVzXzEuUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgcGFyc2VkOiAoKSA9PiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VkV2l0aEZhbGxiYWNrID0gcGFyc2VyQXNzaWduLndpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgZmFsbGJhY2tzOiBbcGFyc2VyTm9uZV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVubmFibGVzXzEuUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByYXc6IGxsbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZWRXaXRoRmFsbGJhY2ssXG4gICAgICAgIF0pLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0UnVubmFibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGF0R29vZ2xlQmFzZSA9IENoYXRHb29nbGVCYXNlO1xuZnVuY3Rpb24gaXNab2RTY2hlbWEoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuaW5wdXQpIHtcbiAgICAvLyBDaGVjayBmb3IgYSBjaGFyYWN0ZXJpc3RpYyBtZXRob2Qgb2YgWm9kIHNjaGVtYXNcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0Py5wYXJzZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/connection.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleRequestRecorder = exports.GoogleRequestLogger = exports.GoogleRequestCallbackHandler = exports.AbstractGoogleLLMConnection = exports.GoogleAIConnection = exports.GoogleRawConnection = exports.GoogleHostConnection = exports.GoogleConnection = void 0;\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst base_1 = __webpack_require__(/*! @langchain/core/callbacks/base */ \"(rsc)/./node_modules/@langchain/core/callbacks/base.cjs\");\nconst index_js_1 = __webpack_require__(/*! ./utils/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\");\nconst anthropic_js_1 = __webpack_require__(/*! ./utils/anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\");\nclass GoogleConnection {\n    constructor(caller, client, streaming) {\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = caller;\n        this.client = client;\n        this.streaming = streaming ?? false;\n    }\n    async _clientInfoHeaders() {\n        const { userAgent, clientLibraryVersion } = await this._getClientInfo();\n        return {\n            \"User-Agent\": userAgent,\n            \"Client-Info\": clientLibraryVersion,\n        };\n    }\n    async _getClientInfo() {\n        const env = await (0, env_1.getRuntimeEnvironment)();\n        const langchain = env?.library ?? \"langchain-js\";\n        // TODO: Add an API for getting the current LangChain version\n        const langchainVersion = \"0\";\n        const moduleName = await this._moduleName();\n        let clientLibraryVersion = `${langchain}/${langchainVersion}`;\n        if (moduleName && moduleName.length) {\n            clientLibraryVersion = `${clientLibraryVersion}-${moduleName}`;\n        }\n        return {\n            userAgent: clientLibraryVersion,\n            clientLibraryVersion: `${langchainVersion}-${moduleName}`,\n        };\n    }\n    async _moduleName() {\n        return this.constructor.name;\n    }\n    async additionalHeaders() {\n        return {};\n    }\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const url = await this.buildUrl();\n        const method = this.buildMethod();\n        const infoHeaders = (await this._clientInfoHeaders()) ?? {};\n        const additionalHeaders = (await this.additionalHeaders()) ?? {};\n        const headers = {\n            ...infoHeaders,\n            ...additionalHeaders,\n            ...requestHeaders,\n        };\n        const opts = {\n            url,\n            method,\n            headers,\n        };\n        if (data && method === \"POST\") {\n            opts.data = data;\n        }\n        if (this.streaming) {\n            opts.responseType = \"stream\";\n        }\n        else {\n            opts.responseType = \"json\";\n        }\n        return opts;\n    }\n    async _request(data, options, requestHeaders = {}) {\n        const opts = await this._buildOpts(data, options, requestHeaders);\n        const callResponse = await this.caller.callWithOptions({ signal: options?.signal }, async () => this.client.request(opts));\n        const response = callResponse; // Done for typecast safety, I guess\n        return response;\n    }\n}\nexports.GoogleConnection = GoogleConnection;\nclass GoogleHostConnection extends GoogleConnection {\n    constructor(fields, caller, client, streaming) {\n        super(caller, client, streaming);\n        // This does not default to a value intentionally.\n        // Use the \"platform\" getter if you need this.\n        Object.defineProperty(this, \"platformType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_endpoint\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_location\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1\"\n        });\n        this.caller = caller;\n        this.platformType = fields?.platformType;\n        this._endpoint = fields?.endpoint;\n        this._location = fields?.location;\n        this.apiVersion = fields?.apiVersion ?? this.apiVersion;\n        this.client = client;\n    }\n    get platform() {\n        return this.platformType ?? this.computedPlatformType;\n    }\n    get computedPlatformType() {\n        return \"gcp\";\n    }\n    get location() {\n        return this._location ?? this.computedLocation;\n    }\n    get computedLocation() {\n        return \"us-central1\";\n    }\n    get endpoint() {\n        return this._endpoint ?? this.computedEndpoint;\n    }\n    get computedEndpoint() {\n        return `${this.location}-aiplatform.googleapis.com`;\n    }\n    buildMethod() {\n        return \"POST\";\n    }\n}\nexports.GoogleHostConnection = GoogleHostConnection;\nclass GoogleRawConnection extends GoogleHostConnection {\n    async _buildOpts(data, _options, requestHeaders = {}) {\n        const opts = await super._buildOpts(data, _options, requestHeaders);\n        opts.responseType = \"blob\";\n        return opts;\n    }\n}\nexports.GoogleRawConnection = GoogleRawConnection;\nclass GoogleAIConnection extends GoogleHostConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_apiName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiConfig\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.client = client;\n        this.modelName = fields?.model ?? fields?.modelName ?? this.model;\n        this.model = this.modelName;\n        this._apiName = fields?.apiName;\n        this.apiConfig = {\n            safetyHandler: fields?.safetyHandler,\n            ...fields?.apiConfig,\n        };\n    }\n    get modelFamily() {\n        return (0, index_js_1.modelToFamily)(this.model);\n    }\n    get modelPublisher() {\n        return (0, index_js_1.modelToPublisher)(this.model);\n    }\n    get computedAPIName() {\n        // At least at the moment, model publishers and APIs map the same\n        return this.modelPublisher;\n    }\n    get apiName() {\n        return this._apiName ?? this.computedAPIName;\n    }\n    get api() {\n        switch (this.apiName) {\n            case \"google\":\n                return (0, index_js_1.getGeminiAPI)(this.apiConfig);\n            case \"anthropic\":\n                return (0, anthropic_js_1.getAnthropicAPI)(this.apiConfig);\n            default:\n                throw new Error(`Unknown API: ${this.apiName}`);\n        }\n    }\n    get computedPlatformType() {\n        if (this.client.clientType === \"apiKey\") {\n            return \"gai\";\n        }\n        else {\n            return \"gcp\";\n        }\n    }\n    get computedLocation() {\n        switch (this.apiName) {\n            case \"google\":\n                return super.computedLocation;\n            case \"anthropic\":\n                return \"us-east5\";\n            default:\n                throw new Error(`Unknown apiName: ${this.apiName}. Can't get location.`);\n        }\n    }\n    async buildUrlGenerativeLanguage() {\n        const method = await this.buildUrlMethod();\n        const url = `https://generativelanguage.googleapis.com/${this.apiVersion}/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrlVertex() {\n        const projectId = await this.client.getProjectId();\n        const method = await this.buildUrlMethod();\n        const publisher = this.modelPublisher;\n        const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/publishers/${publisher}/models/${this.model}:${method}`;\n        return url;\n    }\n    async buildUrl() {\n        switch (this.platform) {\n            case \"gai\":\n                return this.buildUrlGenerativeLanguage();\n            default:\n                return this.buildUrlVertex();\n        }\n    }\n    async request(input, parameters, options, runManager) {\n        const moduleName = this.constructor.name;\n        const streamingParameters = {\n            ...parameters,\n            streaming: this.streaming,\n        };\n        const data = await this.formatData(input, streamingParameters);\n        await runManager?.handleCustomEvent(`google-request-${moduleName}`, {\n            data,\n            parameters: streamingParameters,\n            options,\n            connection: {\n                ...this,\n                url: await this.buildUrl(),\n                urlMethod: await this.buildUrlMethod(),\n                modelFamily: this.modelFamily,\n                modelPublisher: this.modelPublisher,\n                computedPlatformType: this.computedPlatformType,\n            },\n        });\n        const response = await this._request(data, options);\n        await runManager?.handleCustomEvent(`google-response-${moduleName}`, {\n            response,\n        });\n        return response;\n    }\n}\nexports.GoogleAIConnection = GoogleAIConnection;\nclass AbstractGoogleLLMConnection extends GoogleAIConnection {\n    async buildUrlMethodGemini() {\n        return this.streaming ? \"streamGenerateContent\" : \"generateContent\";\n    }\n    async buildUrlMethodClaude() {\n        return this.streaming ? \"streamRawPredict\" : \"rawPredict\";\n    }\n    async buildUrlMethod() {\n        switch (this.modelFamily) {\n            case \"gemini\":\n                return this.buildUrlMethodGemini();\n            case \"claude\":\n                return this.buildUrlMethodClaude();\n            default:\n                throw new Error(`Unknown model family: ${this.modelFamily}`);\n        }\n    }\n    async formatData(input, parameters) {\n        return this.api.formatData(input, parameters);\n    }\n}\nexports.AbstractGoogleLLMConnection = AbstractGoogleLLMConnection;\nclass GoogleRequestCallbackHandler extends base_1.BaseCallbackHandler {\n    customEventInfo(eventName) {\n        const names = eventName.split(\"-\");\n        return {\n            subEvent: names[1],\n            module: names[2],\n        };\n    }\n    handleCustomEvent(eventName, data, runId, tags, metadata) {\n        if (!eventName) {\n            return undefined;\n        }\n        const eventInfo = this.customEventInfo(eventName);\n        switch (eventInfo.subEvent) {\n            case \"request\":\n                return this.handleCustomRequestEvent(eventName, eventInfo, data, runId, tags, metadata);\n            case \"response\":\n                return this.handleCustomResponseEvent(eventName, eventInfo, data, runId, tags, metadata);\n            case \"chunk\":\n                return this.handleCustomChunkEvent(eventName, eventInfo, data, runId, tags, metadata);\n            default:\n                console.error(`Unexpected eventInfo for ${eventName} ${JSON.stringify(eventInfo, null, 1)}`);\n        }\n    }\n}\nexports.GoogleRequestCallbackHandler = GoogleRequestCallbackHandler;\nclass GoogleRequestLogger extends GoogleRequestCallbackHandler {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"GoogleRequestLogger\"\n        });\n    }\n    log(eventName, data, tags) {\n        const tagStr = tags ? `[${tags}]` : \"[]\";\n        console.log(`${eventName} ${tagStr} ${JSON.stringify(data, null, 1)}`);\n    }\n    handleCustomRequestEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n    handleCustomResponseEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n    handleCustomChunkEvent(eventName, _eventInfo, data, _runId, tags, _metadata) {\n        this.log(eventName, data, tags);\n    }\n}\nexports.GoogleRequestLogger = GoogleRequestLogger;\nclass GoogleRequestRecorder extends GoogleRequestCallbackHandler {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"GoogleRequestRecorder\"\n        });\n        Object.defineProperty(this, \"request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"chunk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    handleCustomRequestEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.request = data;\n    }\n    handleCustomResponseEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.response = data;\n    }\n    handleCustomChunkEvent(_eventName, _eventInfo, data, _runId, _tags, _metadata) {\n        this.chunk.push(data);\n    }\n}\nexports.GoogleRequestRecorder = GoogleRequestRecorder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvY29ubmVjdGlvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsb0NBQW9DLEdBQUcsbUNBQW1DLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsd0JBQXdCO0FBQzdQLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLCtGQUFnQztBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDOUMsdUJBQXVCLG1CQUFPLENBQUMscUdBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxpQkFBaUI7QUFDcEU7QUFDQSxzQ0FBc0MscUJBQXFCLEdBQUcsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCLEdBQUcsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsaUVBQWlFLHlCQUF5QjtBQUMxRix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCLFVBQVUsV0FBVyxHQUFHLE9BQU87QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWMsR0FBRyxnQkFBZ0IsWUFBWSxVQUFVLGFBQWEsY0FBYyxjQUFjLFVBQVUsVUFBVSxXQUFXLEdBQUcsT0FBTztBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVyxFQUFFLG1DQUFtQztBQUMxRztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkMsdUJBQXVCLFdBQVcsRUFBRSxRQUFRLEVBQUUsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9jb25uZWN0aW9uLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlUmVxdWVzdFJlY29yZGVyID0gZXhwb3J0cy5Hb29nbGVSZXF1ZXN0TG9nZ2VyID0gZXhwb3J0cy5Hb29nbGVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGVyID0gZXhwb3J0cy5BYnN0cmFjdEdvb2dsZUxMTUNvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUFJQ29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlUmF3Q29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlSG9zdENvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZUNvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBlbnZfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52XCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9jYWxsYmFja3MvYmFzZVwiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9pbmRleC5janNcIik7XG5jb25zdCBhbnRocm9waWNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FudGhyb3BpYy5janNcIik7XG5jbGFzcyBHb29nbGVDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gY2FsbGVyO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5zdHJlYW1pbmcgPSBzdHJlYW1pbmcgPz8gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIF9jbGllbnRJbmZvSGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgeyB1c2VyQWdlbnQsIGNsaWVudExpYnJhcnlWZXJzaW9uIH0gPSBhd2FpdCB0aGlzLl9nZXRDbGllbnRJbmZvKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogdXNlckFnZW50LFxuICAgICAgICAgICAgXCJDbGllbnQtSW5mb1wiOiBjbGllbnRMaWJyYXJ5VmVyc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2dldENsaWVudEluZm8oKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGF3YWl0ICgwLCBlbnZfMS5nZXRSdW50aW1lRW52aXJvbm1lbnQpKCk7XG4gICAgICAgIGNvbnN0IGxhbmdjaGFpbiA9IGVudj8ubGlicmFyeSA/PyBcImxhbmdjaGFpbi1qc1wiO1xuICAgICAgICAvLyBUT0RPOiBBZGQgYW4gQVBJIGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IExhbmdDaGFpbiB2ZXJzaW9uXG4gICAgICAgIGNvbnN0IGxhbmdjaGFpblZlcnNpb24gPSBcIjBcIjtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGF3YWl0IHRoaXMuX21vZHVsZU5hbWUoKTtcbiAgICAgICAgbGV0IGNsaWVudExpYnJhcnlWZXJzaW9uID0gYCR7bGFuZ2NoYWlufS8ke2xhbmdjaGFpblZlcnNpb259YDtcbiAgICAgICAgaWYgKG1vZHVsZU5hbWUgJiYgbW9kdWxlTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNsaWVudExpYnJhcnlWZXJzaW9uID0gYCR7Y2xpZW50TGlicmFyeVZlcnNpb259LSR7bW9kdWxlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQWdlbnQ6IGNsaWVudExpYnJhcnlWZXJzaW9uLFxuICAgICAgICAgICAgY2xpZW50TGlicmFyeVZlcnNpb246IGAke2xhbmdjaGFpblZlcnNpb259LSR7bW9kdWxlTmFtZX1gLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfbW9kdWxlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgYXN5bmMgYWRkaXRpb25hbEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmJ1aWxkVXJsKCk7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuYnVpbGRNZXRob2QoKTtcbiAgICAgICAgY29uc3QgaW5mb0hlYWRlcnMgPSAoYXdhaXQgdGhpcy5fY2xpZW50SW5mb0hlYWRlcnMoKSkgPz8ge307XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxIZWFkZXJzID0gKGF3YWl0IHRoaXMuYWRkaXRpb25hbEhlYWRlcnMoKSkgPz8ge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi5pbmZvSGVhZGVycyxcbiAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxIZWFkZXJzLFxuICAgICAgICAgICAgLi4ucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YSAmJiBtZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICBvcHRzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgICAgICAgb3B0cy5yZXNwb25zZVR5cGUgPSBcInN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5yZXNwb25zZVR5cGUgPSBcImpzb25cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gICAgYXN5bmMgX3JlcXVlc3QoZGF0YSwgb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5fYnVpbGRPcHRzKGRhdGEsIG9wdGlvbnMsIHJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgY29uc3QgY2FsbFJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbFdpdGhPcHRpb25zKHsgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgfSwgYXN5bmMgKCkgPT4gdGhpcy5jbGllbnQucmVxdWVzdChvcHRzKSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY2FsbFJlc3BvbnNlOyAvLyBEb25lIGZvciB0eXBlY2FzdCBzYWZldHksIEkgZ3Vlc3NcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ29ubmVjdGlvbiA9IEdvb2dsZUNvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVIb3N0Q29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZUNvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBzdXBlcihjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKTtcbiAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBkZWZhdWx0IHRvIGEgdmFsdWUgaW50ZW50aW9uYWxseS5cbiAgICAgICAgLy8gVXNlIHRoZSBcInBsYXRmb3JtXCIgZ2V0dGVyIGlmIHlvdSBuZWVkIHRoaXMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsYXRmb3JtVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW5kcG9pbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaVZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwidjFcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSBjYWxsZXI7XG4gICAgICAgIHRoaXMucGxhdGZvcm1UeXBlID0gZmllbGRzPy5wbGF0Zm9ybVR5cGU7XG4gICAgICAgIHRoaXMuX2VuZHBvaW50ID0gZmllbGRzPy5lbmRwb2ludDtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBmaWVsZHM/LmxvY2F0aW9uO1xuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBmaWVsZHM/LmFwaVZlcnNpb24gPz8gdGhpcy5hcGlWZXJzaW9uO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgZ2V0IHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybVR5cGUgPz8gdGhpcy5jb21wdXRlZFBsYXRmb3JtVHlwZTtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkUGxhdGZvcm1UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnY3BcIjtcbiAgICB9XG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24gPz8gdGhpcy5jb21wdXRlZExvY2F0aW9uO1xuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwidXMtY2VudHJhbDFcIjtcbiAgICB9XG4gICAgZ2V0IGVuZHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kcG9pbnQgPz8gdGhpcy5jb21wdXRlZEVuZHBvaW50O1xuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRFbmRwb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubG9jYXRpb259LWFpcGxhdGZvcm0uZ29vZ2xlYXBpcy5jb21gO1xuICAgIH1cbiAgICBidWlsZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlSG9zdENvbm5lY3Rpb24gPSBHb29nbGVIb3N0Q29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZVJhd0Nvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVIb3N0Q29ubmVjdGlvbiB7XG4gICAgYXN5bmMgX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgc3VwZXIuX2J1aWxkT3B0cyhkYXRhLCBfb3B0aW9ucywgcmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICBvcHRzLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZVJhd0Nvbm5lY3Rpb24gPSBHb29nbGVSYXdDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlQUlDb25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQsIHN0cmVhbWluZykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2RlbE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hcGlOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5tb2RlbE5hbWUgPSBmaWVsZHM/Lm1vZGVsID8/IGZpZWxkcz8ubW9kZWxOYW1lID8/IHRoaXMubW9kZWw7XG4gICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLm1vZGVsTmFtZTtcbiAgICAgICAgdGhpcy5fYXBpTmFtZSA9IGZpZWxkcz8uYXBpTmFtZTtcbiAgICAgICAgdGhpcy5hcGlDb25maWcgPSB7XG4gICAgICAgICAgICBzYWZldHlIYW5kbGVyOiBmaWVsZHM/LnNhZmV0eUhhbmRsZXIsXG4gICAgICAgICAgICAuLi5maWVsZHM/LmFwaUNvbmZpZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsRmFtaWx5KCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEubW9kZWxUb0ZhbWlseSkodGhpcy5tb2RlbCk7XG4gICAgfVxuICAgIGdldCBtb2RlbFB1Ymxpc2hlcigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLm1vZGVsVG9QdWJsaXNoZXIpKHRoaXMubW9kZWwpO1xuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRBUElOYW1lKCkge1xuICAgICAgICAvLyBBdCBsZWFzdCBhdCB0aGUgbW9tZW50LCBtb2RlbCBwdWJsaXNoZXJzIGFuZCBBUElzIG1hcCB0aGUgc2FtZVxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbFB1Ymxpc2hlcjtcbiAgICB9XG4gICAgZ2V0IGFwaU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGlOYW1lID8/IHRoaXMuY29tcHV0ZWRBUElOYW1lO1xuICAgIH1cbiAgICBnZXQgYXBpKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXBpTmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRHZW1pbmlBUEkpKHRoaXMuYXBpQ29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgXCJhbnRocm9waWNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGFudGhyb3BpY19qc18xLmdldEFudGhyb3BpY0FQSSkodGhpcy5hcGlDb25maWcpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gQVBJOiAke3RoaXMuYXBpTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29tcHV0ZWRQbGF0Zm9ybVR5cGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudC5jbGllbnRUeXBlID09PSBcImFwaUtleVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJnYWlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImdjcFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb21wdXRlZExvY2F0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuYXBpTmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImdvb2dsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5jb21wdXRlZExvY2F0aW9uO1xuICAgICAgICAgICAgY2FzZSBcImFudGhyb3BpY1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInVzLWVhc3Q1XCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhcGlOYW1lOiAke3RoaXMuYXBpTmFtZX0uIENhbid0IGdldCBsb2NhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBidWlsZFVybEdlbmVyYXRpdmVMYW5ndWFnZSgpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXdhaXQgdGhpcy5idWlsZFVybE1ldGhvZCgpO1xuICAgICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vJHt0aGlzLmFwaVZlcnNpb259L21vZGVscy8ke3RoaXMubW9kZWx9OiR7bWV0aG9kfWA7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsVmVydGV4KCkge1xuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRQcm9qZWN0SWQoKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gYXdhaXQgdGhpcy5idWlsZFVybE1ldGhvZCgpO1xuICAgICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLm1vZGVsUHVibGlzaGVyO1xuICAgICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke3RoaXMuZW5kcG9pbnR9LyR7dGhpcy5hcGlWZXJzaW9ufS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vbG9jYXRpb25zLyR7dGhpcy5sb2NhdGlvbn0vcHVibGlzaGVycy8ke3B1Ymxpc2hlcn0vbW9kZWxzLyR7dGhpcy5tb2RlbH06JHttZXRob2R9YDtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wbGF0Zm9ybSkge1xuICAgICAgICAgICAgY2FzZSBcImdhaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsR2VuZXJhdGl2ZUxhbmd1YWdlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsVmVydGV4KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChpbnB1dCwgcGFyYW1ldGVycywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCBtb2R1bGVOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBjb25zdCBzdHJlYW1pbmdQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbWluZzogdGhpcy5zdHJlYW1pbmcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmZvcm1hdERhdGEoaW5wdXQsIHN0cmVhbWluZ1BhcmFtZXRlcnMpO1xuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDdXN0b21FdmVudChgZ29vZ2xlLXJlcXVlc3QtJHttb2R1bGVOYW1lfWAsIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBzdHJlYW1pbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgICAgICAgIHVybDogYXdhaXQgdGhpcy5idWlsZFVybCgpLFxuICAgICAgICAgICAgICAgIHVybE1ldGhvZDogYXdhaXQgdGhpcy5idWlsZFVybE1ldGhvZCgpLFxuICAgICAgICAgICAgICAgIG1vZGVsRmFtaWx5OiB0aGlzLm1vZGVsRmFtaWx5LFxuICAgICAgICAgICAgICAgIG1vZGVsUHVibGlzaGVyOiB0aGlzLm1vZGVsUHVibGlzaGVyLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkUGxhdGZvcm1UeXBlOiB0aGlzLmNvbXB1dGVkUGxhdGZvcm1UeXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVxdWVzdChkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ3VzdG9tRXZlbnQoYGdvb2dsZS1yZXNwb25zZS0ke21vZHVsZU5hbWV9YCwge1xuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVBSUNvbm5lY3Rpb24gPSBHb29nbGVBSUNvbm5lY3Rpb247XG5jbGFzcyBBYnN0cmFjdEdvb2dsZUxMTUNvbm5lY3Rpb24gZXh0ZW5kcyBHb29nbGVBSUNvbm5lY3Rpb24ge1xuICAgIGFzeW5jIGJ1aWxkVXJsTWV0aG9kR2VtaW5pKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1pbmcgPyBcInN0cmVhbUdlbmVyYXRlQ29udGVudFwiIDogXCJnZW5lcmF0ZUNvbnRlbnRcIjtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmxNZXRob2RDbGF1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWluZyA/IFwic3RyZWFtUmF3UHJlZGljdFwiIDogXCJyYXdQcmVkaWN0XCI7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsTWV0aG9kKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWxGYW1pbHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZW1pbmlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFVybE1ldGhvZEdlbWluaSgpO1xuICAgICAgICAgICAgY2FzZSBcImNsYXVkZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsTWV0aG9kQ2xhdWRlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtb2RlbCBmYW1pbHk6ICR7dGhpcy5tb2RlbEZhbWlseX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmb3JtYXREYXRhKGlucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5mb3JtYXREYXRhKGlucHV0LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbiA9IEFic3RyYWN0R29vZ2xlTExNQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZVJlcXVlc3RDYWxsYmFja0hhbmRsZXIgZXh0ZW5kcyBiYXNlXzEuQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY3VzdG9tRXZlbnRJbmZvKGV2ZW50TmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIi1cIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJFdmVudDogbmFtZXNbMV0sXG4gICAgICAgICAgICBtb2R1bGU6IG5hbWVzWzJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBoYW5kbGVDdXN0b21FdmVudChldmVudE5hbWUsIGRhdGEsIHJ1bklkLCB0YWdzLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEluZm8gPSB0aGlzLmN1c3RvbUV2ZW50SW5mbyhldmVudE5hbWUpO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50SW5mby5zdWJFdmVudCkge1xuICAgICAgICAgICAgY2FzZSBcInJlcXVlc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDdXN0b21SZXF1ZXN0RXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8sIGRhdGEsIHJ1bklkLCB0YWdzLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICBjYXNlIFwicmVzcG9uc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDdXN0b21SZXNwb25zZUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRJbmZvLCBkYXRhLCBydW5JZCwgdGFncywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgY2FzZSBcImNodW5rXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ3VzdG9tQ2h1bmtFdmVudChldmVudE5hbWUsIGV2ZW50SW5mbywgZGF0YSwgcnVuSWQsIHRhZ3MsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBldmVudEluZm8gZm9yICR7ZXZlbnROYW1lfSAke0pTT04uc3RyaW5naWZ5KGV2ZW50SW5mbywgbnVsbCwgMSl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZVJlcXVlc3RDYWxsYmFja0hhbmRsZXIgPSBHb29nbGVSZXF1ZXN0Q2FsbGJhY2tIYW5kbGVyO1xuY2xhc3MgR29vZ2xlUmVxdWVzdExvZ2dlciBleHRlbmRzIEdvb2dsZVJlcXVlc3RDYWxsYmFja0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIkdvb2dsZVJlcXVlc3RMb2dnZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9nKGV2ZW50TmFtZSwgZGF0YSwgdGFncykge1xuICAgICAgICBjb25zdCB0YWdTdHIgPSB0YWdzID8gYFske3RhZ3N9XWAgOiBcIltdXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke2V2ZW50TmFtZX0gJHt0YWdTdHJ9ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMSl9YCk7XG4gICAgfVxuICAgIGhhbmRsZUN1c3RvbVJlcXVlc3RFdmVudChldmVudE5hbWUsIF9ldmVudEluZm8sIGRhdGEsIF9ydW5JZCwgdGFncywgX21ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nKGV2ZW50TmFtZSwgZGF0YSwgdGFncyk7XG4gICAgfVxuICAgIGhhbmRsZUN1c3RvbVJlc3BvbnNlRXZlbnQoZXZlbnROYW1lLCBfZXZlbnRJbmZvLCBkYXRhLCBfcnVuSWQsIHRhZ3MsIF9tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmxvZyhldmVudE5hbWUsIGRhdGEsIHRhZ3MpO1xuICAgIH1cbiAgICBoYW5kbGVDdXN0b21DaHVua0V2ZW50KGV2ZW50TmFtZSwgX2V2ZW50SW5mbywgZGF0YSwgX3J1bklkLCB0YWdzLCBfbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2coZXZlbnROYW1lLCBkYXRhLCB0YWdzKTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZVJlcXVlc3RMb2dnZXIgPSBHb29nbGVSZXF1ZXN0TG9nZ2VyO1xuY2xhc3MgR29vZ2xlUmVxdWVzdFJlY29yZGVyIGV4dGVuZHMgR29vZ2xlUmVxdWVzdENhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiR29vZ2xlUmVxdWVzdFJlY29yZGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNodW5rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tUmVxdWVzdEV2ZW50KF9ldmVudE5hbWUsIF9ldmVudEluZm8sIGRhdGEsIF9ydW5JZCwgX3RhZ3MsIF9tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSBkYXRhO1xuICAgIH1cbiAgICBoYW5kbGVDdXN0b21SZXNwb25zZUV2ZW50KF9ldmVudE5hbWUsIF9ldmVudEluZm8sIGRhdGEsIF9ydW5JZCwgX3RhZ3MsIF9tZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gZGF0YTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tQ2h1bmtFdmVudChfZXZlbnROYW1lLCBfZXZlbnRJbmZvLCBkYXRhLCBfcnVuSWQsIF90YWdzLCBfbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlUmVxdWVzdFJlY29yZGVyID0gR29vZ2xlUmVxdWVzdFJlY29yZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/embeddings.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGoogleEmbeddings = void 0;\nconst embeddings_1 = __webpack_require__(/*! @langchain/core/embeddings */ \"(rsc)/./node_modules/@langchain/core/embeddings.cjs\");\nconst chunk_array_1 = __webpack_require__(/*! @langchain/core/utils/chunk_array */ \"(rsc)/./node_modules/@langchain/core/utils/chunk_array.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass EmbeddingsConnection extends connection_js_1.GoogleAIConnection {\n    constructor(fields, caller, client, streaming) {\n        super(fields, caller, client, streaming);\n        Object.defineProperty(this, \"convertSystemMessageToHumanContent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async buildUrlMethod() {\n        return \"predict\";\n    }\n    get modelPublisher() {\n        // All the embedding models are currently published by \"google\"\n        return \"google\";\n    }\n    async formatData(input, parameters) {\n        return {\n            instances: input,\n            parameters,\n        };\n    }\n}\n/**\n * Enables calls to Google APIs for generating\n * text embeddings.\n */\nclass BaseGoogleEmbeddings extends embeddings_1.Embeddings {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.model = fields.model;\n        this.connection = new EmbeddingsConnection({ ...fields, ...this }, this.caller, this.buildClient(fields), false);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    /**\n     * Takes an array of documents as input and returns a promise that\n     * resolves to a 2D array of embeddings for each document. It splits the\n     * documents into chunks and makes requests to the Google Vertex AI API to\n     * generate embeddings.\n     * @param documents An array of documents to be embedded.\n     * @returns A promise that resolves to a 2D array of embeddings for each document.\n     */\n    async embedDocuments(documents) {\n        const instanceChunks = (0, chunk_array_1.chunkArray)(documents.map((document) => ({\n            content: document,\n        })), 5); // Vertex AI accepts max 5 instances per prediction\n        const parameters = {};\n        const options = {};\n        const responses = await Promise.all(instanceChunks.map((instances) => this.connection.request(instances, parameters, options)));\n        const result = responses\n            ?.map((response) => response?.data?.predictions?.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (result) => result.embeddings?.values) ?? [])\n            .flat() ?? [];\n        return result;\n    }\n    /**\n     * Takes a document as input and returns a promise that resolves to an\n     * embedding for the document. It calls the embedDocuments method with the\n     * document as the input.\n     * @param document A document to be embedded.\n     * @returns A promise that resolves to an embedding for the document.\n     */\n    async embedQuery(document) {\n        const data = await this.embedDocuments([document]);\n        return data[0];\n    }\n}\nexports.BaseGoogleEmbeddings = BaseGoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZW1iZWRkaW5ncy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLHVGQUE0QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxxR0FBbUM7QUFDakUsY0FBYyxtQkFBTyxDQUFDLHFGQUEyQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQywyRkFBa0I7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9lbWJlZGRpbmdzLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUdvb2dsZUVtYmVkZGluZ3MgPSB2b2lkIDA7XG5jb25zdCBlbWJlZGRpbmdzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2VtYmVkZGluZ3NcIik7XG5jb25zdCBjaHVua19hcnJheV8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9jaHVua19hcnJheVwiKTtcbmNvbnN0IGVudl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9lbnZcIik7XG5jb25zdCBjb25uZWN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLmNqc1wiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY2xhc3MgRW1iZWRkaW5nc0Nvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuR29vZ2xlQUlDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50LCBzdHJlYW1pbmcpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCwgc3RyZWFtaW5nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIFwicHJlZGljdFwiO1xuICAgIH1cbiAgICBnZXQgbW9kZWxQdWJsaXNoZXIoKSB7XG4gICAgICAgIC8vIEFsbCB0aGUgZW1iZWRkaW5nIG1vZGVscyBhcmUgY3VycmVudGx5IHB1Ymxpc2hlZCBieSBcImdvb2dsZVwiXG4gICAgICAgIHJldHVybiBcImdvb2dsZVwiO1xuICAgIH1cbiAgICBhc3luYyBmb3JtYXREYXRhKGlucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnN0YW5jZXM6IGlucHV0LFxuICAgICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEVuYWJsZXMgY2FsbHMgdG8gR29vZ2xlIEFQSXMgZm9yIGdlbmVyYXRpbmdcbiAqIHRleHQgZW1iZWRkaW5ncy5cbiAqL1xuY2xhc3MgQmFzZUdvb2dsZUVtYmVkZGluZ3MgZXh0ZW5kcyBlbWJlZGRpbmdzXzEuRW1iZWRkaW5ncyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZpZWxkcy5tb2RlbDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IEVtYmVkZGluZ3NDb25uZWN0aW9uKHsgLi4uZmllbGRzLCAuLi50aGlzIH0sIHRoaXMuY2FsbGVyLCB0aGlzLmJ1aWxkQ2xpZW50KGZpZWxkcyksIGZhbHNlKTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgYXV0aF9qc18xLkFwaUtleUdvb2dsZUF1dGgoYXBpS2V5KTtcbiAgICB9XG4gICAgYnVpbGRBcGlLZXkoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM/LmFwaUtleSA/PyAoMCwgZW52XzEuZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSkoXCJHT09HTEVfQVBJX0tFWVwiKTtcbiAgICB9XG4gICAgYnVpbGRDbGllbnQoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuYnVpbGRBcGlLZXkoZmllbGRzKTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBcGlLZXlDbGllbnQoYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQWJzdHJhY3RlZENsaWVudChmaWVsZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIGRvY3VtZW50cyBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIGEgMkQgYXJyYXkgb2YgZW1iZWRkaW5ncyBmb3IgZWFjaCBkb2N1bWVudC4gSXQgc3BsaXRzIHRoZVxuICAgICAqIGRvY3VtZW50cyBpbnRvIGNodW5rcyBhbmQgbWFrZXMgcmVxdWVzdHMgdG8gdGhlIEdvb2dsZSBWZXJ0ZXggQUkgQVBJIHRvXG4gICAgICogZ2VuZXJhdGUgZW1iZWRkaW5ncy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIEFuIGFycmF5IG9mIGRvY3VtZW50cyB0byBiZSBlbWJlZGRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIDJEIGFycmF5IG9mIGVtYmVkZGluZ3MgZm9yIGVhY2ggZG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWREb2N1bWVudHMoZG9jdW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlQ2h1bmtzID0gKDAsIGNodW5rX2FycmF5XzEuY2h1bmtBcnJheSkoZG9jdW1lbnRzLm1hcCgoZG9jdW1lbnQpID0+ICh7XG4gICAgICAgICAgICBjb250ZW50OiBkb2N1bWVudCxcbiAgICAgICAgfSkpLCA1KTsgLy8gVmVydGV4IEFJIGFjY2VwdHMgbWF4IDUgaW5zdGFuY2VzIHBlciBwcmVkaWN0aW9uXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZUNodW5rcy5tYXAoKGluc3RhbmNlcykgPT4gdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QoaW5zdGFuY2VzLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZXNcbiAgICAgICAgICAgID8ubWFwKChyZXNwb25zZSkgPT4gcmVzcG9uc2U/LmRhdGE/LnByZWRpY3Rpb25zPy5tYXAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChyZXN1bHQpID0+IHJlc3VsdC5lbWJlZGRpbmdzPy52YWx1ZXMpID8/IFtdKVxuICAgICAgICAgICAgLmZsYXQoKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBkb2N1bWVudCBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhblxuICAgICAqIGVtYmVkZGluZyBmb3IgdGhlIGRvY3VtZW50LiBJdCBjYWxscyB0aGUgZW1iZWREb2N1bWVudHMgbWV0aG9kIHdpdGggdGhlXG4gICAgICogZG9jdW1lbnQgYXMgdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBBIGRvY3VtZW50IHRvIGJlIGVtYmVkZGVkLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGVtYmVkZGluZyBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGVtYmVkUXVlcnkoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZW1iZWREb2N1bWVudHMoW2RvY3VtZW50XSk7XG4gICAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUdvb2dsZUVtYmVkZGluZ3MgPSBCYXNlR29vZ2xlRW1iZWRkaW5ncztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/media.cjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFileBase = exports.AIStudioFileDownloadConnection = exports.AIStudioFileUploadConnection = exports.AIStudioMediaBlob = exports.BlobStoreGoogleCloudStorageBase = exports.GoogleCloudStorageRawConnection = exports.GoogleCloudStorageDownloadConnection = exports.GoogleCloudStorageUploadConnection = exports.GoogleCloudStorageUri = exports.BlobStoreGoogle = exports.GoogleDownloadRawConnection = exports.GoogleDownloadConnection = exports.GoogleMultipartUploadConnection = void 0;\nconst async_caller_1 = __webpack_require__(/*! @langchain/core/utils/async_caller */ \"(rsc)/./node_modules/@langchain/core/utils/async_caller.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst media_core_js_1 = __webpack_require__(/*! ./utils/media_core.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ../connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ../auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nclass GoogleMultipartUploadConnection extends connection_js_1.GoogleHostConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n    }\n    async _body(separator, data, metadata) {\n        const contentType = data.mimetype;\n        const { encoded, encoding } = await data.encode();\n        const body = [\n            `--${separator}`,\n            \"Content-Type: application/json; charset=UTF-8\",\n            \"\",\n            JSON.stringify(metadata),\n            \"\",\n            `--${separator}`,\n            `Content-Type: ${contentType}`,\n            `Content-Transfer-Encoding: ${encoding}`,\n            \"\",\n            encoded,\n            `--${separator}--`,\n        ];\n        return body.join(\"\\n\");\n    }\n    async request(data, metadata, options) {\n        const separator = `separator-${Date.now()}`;\n        const body = await this._body(separator, data, metadata);\n        const requestHeaders = {\n            \"Content-Type\": `multipart/related; boundary=${separator}`,\n            \"X-Goog-Upload-Protocol\": \"multipart\",\n        };\n        const response = this._request(body, options, requestHeaders);\n        return response;\n    }\n}\nexports.GoogleMultipartUploadConnection = GoogleMultipartUploadConnection;\nclass GoogleDownloadConnection extends connection_js_1.GoogleHostConnection {\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadConnection = GoogleDownloadConnection;\nclass GoogleDownloadRawConnection extends connection_js_1.GoogleRawConnection {\n    buildMethod() {\n        return \"GET\";\n    }\n    async request(options) {\n        return this._request(undefined, options);\n    }\n}\nexports.GoogleDownloadRawConnection = GoogleDownloadRawConnection;\nclass BlobStoreGoogle extends media_core_js_1.BlobStore {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.caller = new async_caller_1.AsyncCaller(fields ?? {});\n        this.client = this.buildClient(fields);\n    }\n    async _set(keyValuePair) {\n        const [, blob] = keyValuePair;\n        const setMetadata = this.buildSetMetadata(keyValuePair);\n        const metadata = setMetadata;\n        const options = {};\n        const connection = this.buildSetConnection(keyValuePair);\n        const response = await connection.request(blob, metadata, options);\n        return response;\n    }\n    async mset(keyValuePairs) {\n        const ret = keyValuePairs.map((keyValue) => this._set(keyValue));\n        await Promise.all(ret);\n    }\n    async _getMetadata(key) {\n        const connection = this.buildGetMetadataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    async _getData(key) {\n        const connection = this.buildGetDataConnection(key);\n        const options = {};\n        const response = await connection.request(options);\n        return response.data;\n    }\n    _getMimetypeFromMetadata(metadata) {\n        return metadata.contentType;\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        const data = await this._getData(key);\n        if (data && metadata) {\n            const ret = await media_core_js_1.MediaBlob.fromBlob(data, { metadata, path: key });\n            return ret;\n        }\n        else {\n            return undefined;\n        }\n    }\n    async mget(keys) {\n        const ret = keys.map((key) => this._get(key));\n        return await Promise.all(ret);\n    }\n    async _del(key) {\n        const connection = this.buildDeleteConnection(key);\n        const options = {};\n        await connection.request(options);\n    }\n    async mdelete(keys) {\n        const ret = keys.map((key) => this._del(key));\n        await Promise.all(ret);\n    }\n    // eslint-disable-next-line require-yield\n    async *yieldKeys(_prefix) {\n        // TODO: Implement. Most have an implementation that uses nextToken.\n        throw new Error(\"yieldKeys is not implemented\");\n    }\n}\nexports.BlobStoreGoogle = BlobStoreGoogle;\nclass GoogleCloudStorageUri {\n    constructor(uri) {\n        Object.defineProperty(this, \"bucket\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const bucketAndPath = GoogleCloudStorageUri.uriToBucketAndPath(uri);\n        this.bucket = bucketAndPath.bucket;\n        this.path = bucketAndPath.path;\n    }\n    get uri() {\n        return `gs://${this.bucket}/${this.path}`;\n    }\n    get isValid() {\n        return (typeof this.bucket !== \"undefined\" && typeof this.path !== \"undefined\");\n    }\n    static uriToBucketAndPath(uri) {\n        const match = this.uriRegexp.exec(uri);\n        if (!match) {\n            throw new Error(`Invalid gs:// URI: ${uri}`);\n        }\n        return {\n            bucket: match[1],\n            path: match[2],\n        };\n    }\n    static isValidUri(uri) {\n        return this.uriRegexp.test(uri);\n    }\n}\nexports.GoogleCloudStorageUri = GoogleCloudStorageUri;\nObject.defineProperty(GoogleCloudStorageUri, \"uriRegexp\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: /gs:\\/\\/([a-z0-9][a-z0-9._-]+[a-z0-9])\\/(.*)/\n});\nclass GoogleCloudStorageUploadConnection extends GoogleMultipartUploadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        return `https://storage.googleapis.com/upload/storage/${this.apiVersion}/b/${this.uri.bucket}/o?uploadType=multipart`;\n    }\n}\nexports.GoogleCloudStorageUploadConnection = GoogleCloudStorageUploadConnection;\nclass GoogleCloudStorageDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"alt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n        this.method = fields.method;\n        this.alt = fields.alt;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}`;\n        return this.alt ? `${ret}?alt=${this.alt}` : ret;\n    }\n}\nexports.GoogleCloudStorageDownloadConnection = GoogleCloudStorageDownloadConnection;\nclass GoogleCloudStorageRawConnection extends GoogleDownloadRawConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"uri\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.uri = new GoogleCloudStorageUri(fields.uri);\n    }\n    async buildUrl() {\n        const path = encodeURIComponent(this.uri.path);\n        const ret = `https://storage.googleapis.com/storage/${this.apiVersion}/b/${this.uri.bucket}/o/${path}?alt=media`;\n        return ret;\n    }\n}\nexports.GoogleCloudStorageRawConnection = GoogleCloudStorageRawConnection;\nclass BlobStoreGoogleCloudStorageBase extends BlobStoreGoogle {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.params = fields;\n        this.defaultStoreOptions = {\n            ...this.defaultStoreOptions,\n            pathPrefix: fields.uriPrefix.uri,\n        };\n    }\n    buildSetConnection([key, _blob]) {\n        const params = {\n            ...this.params,\n            uri: key,\n        };\n        return new GoogleCloudStorageUploadConnection(params, this.caller, this.client);\n    }\n    buildSetMetadata([key, blob]) {\n        const uri = new GoogleCloudStorageUri(key);\n        const ret = {\n            name: uri.path,\n            metadata: blob.metadata,\n            contentType: blob.mimetype,\n        };\n        return ret;\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            uri: key,\n            method: \"GET\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(key) {\n        const params = {\n            uri: key,\n        };\n        return new GoogleCloudStorageRawConnection(params, this.caller, this.client);\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            uri: key,\n            method: \"DELETE\",\n            alt: undefined,\n        };\n        return new GoogleCloudStorageDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreGoogleCloudStorageBase = BlobStoreGoogleCloudStorageBase;\nclass AIStudioMediaBlob extends media_core_js_1.MediaBlob {\n    _valueAsDate(value) {\n        if (!value) {\n            return new Date(0);\n        }\n        return new Date(value);\n    }\n    _metadataFieldAsDate(field) {\n        return this._valueAsDate(this.metadata?.[field]);\n    }\n    get createDate() {\n        return this._metadataFieldAsDate(\"createTime\");\n    }\n    get updateDate() {\n        return this._metadataFieldAsDate(\"updateTime\");\n    }\n    get expirationDate() {\n        return this._metadataFieldAsDate(\"expirationTime\");\n    }\n    get isExpired() {\n        const now = new Date().toISOString();\n        const exp = this.metadata?.expirationTime ?? now;\n        return exp <= now;\n    }\n}\nexports.AIStudioMediaBlob = AIStudioMediaBlob;\nclass AIStudioFileUploadConnection extends GoogleMultipartUploadConnection {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/upload/${this.apiVersion}/files`;\n    }\n}\nexports.AIStudioFileUploadConnection = AIStudioFileUploadConnection;\nclass AIStudioFileDownloadConnection extends GoogleDownloadConnection {\n    constructor(fields, caller, client) {\n        super(fields, caller, client);\n        Object.defineProperty(this, \"method\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"v1beta\"\n        });\n        this.method = fields.method;\n        this.name = fields.name;\n    }\n    buildMethod() {\n        return this.method;\n    }\n    async buildUrl() {\n        return `https://generativelanguage.googleapis.com/${this.apiVersion}/files/${this.name}`;\n    }\n}\nexports.AIStudioFileDownloadConnection = AIStudioFileDownloadConnection;\nclass BlobStoreAIStudioFileBase extends BlobStoreGoogle {\n    constructor(fields) {\n        const params = {\n            defaultStoreOptions: {\n                pathPrefix: \"https://generativelanguage.googleapis.com/v1beta/files/\",\n                actionIfInvalid: \"removePath\",\n            },\n            ...fields,\n        };\n        super(params);\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryTime\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        this.params = params;\n        this.retryTime = params?.retryTime ?? this.retryTime ?? 1000;\n    }\n    _pathToName(path) {\n        return path.split(\"/\").pop() ?? path;\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            // TODO: Test that you can use OAuth to access\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    async _regetMetadata(key) {\n        // Sleep for some time period\n        // eslint-disable-next-line no-promise-executor-return\n        await new Promise((resolve) => setTimeout(resolve, this.retryTime));\n        // Fetch the latest metadata\n        return this._getMetadata(key);\n    }\n    async _set([key, blob]) {\n        const response = (await super._set([\n            key,\n            blob,\n        ]));\n        let file = response.data?.file ?? { state: \"FAILED\" };\n        while (file.state === \"PROCESSING\" && file.uri && this.retryTime > 0) {\n            file = await this._regetMetadata(file.uri);\n        }\n        // The response should contain the name (and valid URI), so we need to\n        // update the blob with this. We can't return a new blob, since mset()\n        // doesn't return anything.\n        /* eslint-disable no-param-reassign */\n        blob.path = file.uri;\n        blob.metadata = {\n            ...blob.metadata,\n            ...file,\n        };\n        /* eslint-enable no-param-reassign */\n        return response;\n    }\n    buildSetConnection([_key, _blob]) {\n        return new AIStudioFileUploadConnection(this.params, this.caller, this.client);\n    }\n    buildSetMetadata([_key, _blob]) {\n        return {};\n    }\n    buildGetMetadataConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"GET\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n    buildGetDataConnection(_key) {\n        throw new Error(\"AI Studio File API does not provide data\");\n    }\n    async _get(key) {\n        const metadata = await this._getMetadata(key);\n        if (metadata) {\n            const contentType = metadata?.mimeType ?? \"application/octet-stream\";\n            // TODO - Get the actual data (and other metadata) from an optional backing store\n            const data = {\n                value: \"\",\n                type: contentType,\n            };\n            return new media_core_js_1.MediaBlob({\n                path: key,\n                data,\n                metadata,\n            });\n        }\n        else {\n            return undefined;\n        }\n    }\n    buildDeleteConnection(key) {\n        const params = {\n            ...this.params,\n            method: \"DELETE\",\n            name: this._pathToName(key),\n        };\n        return new AIStudioFileDownloadConnection(params, this.caller, this.client);\n    }\n}\nexports.BlobStoreAIStudioFileBase = BlobStoreAIStudioFileBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyxvQ0FBb0MsR0FBRyx5QkFBeUIsR0FBRyx1Q0FBdUMsR0FBRyx1Q0FBdUMsR0FBRyw0Q0FBNEMsR0FBRywwQ0FBMEMsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyxtQ0FBbUMsR0FBRyxnQ0FBZ0MsR0FBRyx1Q0FBdUM7QUFDMWUsdUJBQXVCLG1CQUFPLENBQUMsdUdBQW9DO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyxxRkFBMkI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsb0hBQXdCO0FBQ3hELHdCQUF3QixtQkFBTyxDQUFDLDRGQUFtQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLDZCQUE2QixZQUFZO0FBQ3pDLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxxQkFBcUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksR0FBRyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0IsS0FBSyxnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCLEtBQUssZ0JBQWdCLEtBQUssS0FBSztBQUM3Ryw2QkFBNkIsSUFBSSxPQUFPLFNBQVM7QUFDakQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQixLQUFLLGdCQUFnQixLQUFLLEtBQUs7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0IsU0FBUyxVQUFVO0FBQy9GO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlQmFzZSA9IGV4cG9ydHMuQUlTdHVkaW9GaWxlRG93bmxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5BSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5BSVN0dWRpb01lZGlhQmxvYiA9IGV4cG9ydHMuQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlQmFzZSA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlUmF3Q29ubmVjdGlvbiA9IGV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlRG93bmxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVDbG91ZFN0b3JhZ2VVcGxvYWRDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVDbG91ZFN0b3JhZ2VVcmkgPSBleHBvcnRzLkJsb2JTdG9yZUdvb2dsZSA9IGV4cG9ydHMuR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uID0gZXhwb3J0cy5Hb29nbGVEb3dubG9hZENvbm5lY3Rpb24gPSBleHBvcnRzLkdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBhc3luY19jYWxsZXJfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvYXN5bmNfY2FsbGVyXCIpO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IG1lZGlhX2NvcmVfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL21lZGlhX2NvcmUuY2pzXCIpO1xuY29uc3QgY29ubmVjdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24uY2pzXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4uL2F1dGguY2pzXCIpO1xuY2xhc3MgR29vZ2xlTXVsdGlwYXJ0VXBsb2FkQ29ubmVjdGlvbiBleHRlbmRzIGNvbm5lY3Rpb25fanNfMS5Hb29nbGVIb3N0Q29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCkge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX2JvZHkoc2VwYXJhdG9yLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGRhdGEubWltZXR5cGU7XG4gICAgICAgIGNvbnN0IHsgZW5jb2RlZCwgZW5jb2RpbmcgfSA9IGF3YWl0IGRhdGEuZW5jb2RlKCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBbXG4gICAgICAgICAgICBgLS0ke3NlcGFyYXRvcn1gLFxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLThcIixcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSksXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgYC0tJHtzZXBhcmF0b3J9YCxcbiAgICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7Y29udGVudFR5cGV9YCxcbiAgICAgICAgICAgIGBDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nOiAke2VuY29kaW5nfWAsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgZW5jb2RlZCxcbiAgICAgICAgICAgIGAtLSR7c2VwYXJhdG9yfS0tYCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGJvZHkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChkYXRhLCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBgc2VwYXJhdG9yLSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgdGhpcy5fYm9keShzZXBhcmF0b3IsIGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBgbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PSR7c2VwYXJhdG9yfWAsXG4gICAgICAgICAgICBcIlgtR29vZy1VcGxvYWQtUHJvdG9jb2xcIjogXCJtdWx0aXBhcnRcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLl9yZXF1ZXN0KGJvZHksIG9wdGlvbnMsIHJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlTXVsdGlwYXJ0VXBsb2FkQ29ubmVjdGlvbiA9IEdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb247XG5jbGFzcyBHb29nbGVEb3dubG9hZENvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuR29vZ2xlSG9zdENvbm5lY3Rpb24ge1xuICAgIGFzeW5jIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCh1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uID0gR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlRG93bmxvYWRSYXdDb25uZWN0aW9uIGV4dGVuZHMgY29ubmVjdGlvbl9qc18xLkdvb2dsZVJhd0Nvbm5lY3Rpb24ge1xuICAgIGJ1aWxkTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gXCJHRVRcIjtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVEb3dubG9hZFJhd0Nvbm5lY3Rpb24gPSBHb29nbGVEb3dubG9hZFJhd0Nvbm5lY3Rpb247XG5jbGFzcyBCbG9iU3RvcmVHb29nbGUgZXh0ZW5kcyBtZWRpYV9jb3JlX2pzXzEuQmxvYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBhc3luY19jYWxsZXJfMS5Bc3luY0NhbGxlcihmaWVsZHMgPz8ge30pO1xuICAgICAgICB0aGlzLmNsaWVudCA9IHRoaXMuYnVpbGRDbGllbnQoZmllbGRzKTtcbiAgICB9XG4gICAgYXN5bmMgX3NldChrZXlWYWx1ZVBhaXIpIHtcbiAgICAgICAgY29uc3QgWywgYmxvYl0gPSBrZXlWYWx1ZVBhaXI7XG4gICAgICAgIGNvbnN0IHNldE1ldGFkYXRhID0gdGhpcy5idWlsZFNldE1ldGFkYXRhKGtleVZhbHVlUGFpcik7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gc2V0TWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuYnVpbGRTZXRDb25uZWN0aW9uKGtleVZhbHVlUGFpcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0KGJsb2IsIG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBtc2V0KGtleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0ga2V5VmFsdWVQYWlycy5tYXAoKGtleVZhbHVlKSA9PiB0aGlzLl9zZXQoa2V5VmFsdWUpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmV0KTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE1ldGFkYXRhKGtleSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5idWlsZEdldE1ldGFkYXRhQ29ubmVjdGlvbihrZXkpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgX2dldERhdGEoa2V5KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmJ1aWxkR2V0RGF0YUNvbm5lY3Rpb24oa2V5KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuICAgIF9nZXRNaW1ldHlwZUZyb21NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEuY29udGVudFR5cGU7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5fZ2V0TWV0YWRhdGEoa2V5KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2dldERhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGF3YWl0IG1lZGlhX2NvcmVfanNfMS5NZWRpYUJsb2IuZnJvbUJsb2IoZGF0YSwgeyBtZXRhZGF0YSwgcGF0aDoga2V5IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbWdldChrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGtleXMubWFwKChrZXkpID0+IHRoaXMuX2dldChrZXkpKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHJldCk7XG4gICAgfVxuICAgIGFzeW5jIF9kZWwoa2V5KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmJ1aWxkRGVsZXRlQ29ubmVjdGlvbihrZXkpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdChvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbWRlbGV0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGtleXMubWFwKChrZXkpID0+IHRoaXMuX2RlbChrZXkpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmV0KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUteWllbGRcbiAgICBhc3luYyAqeWllbGRLZXlzKF9wcmVmaXgpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50LiBNb3N0IGhhdmUgYW4gaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIG5leHRUb2tlbi5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieWllbGRLZXlzIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JTdG9yZUdvb2dsZSA9IEJsb2JTdG9yZUdvb2dsZTtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZVVyaSB7XG4gICAgY29uc3RydWN0b3IodXJpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1Y2tldFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldEFuZFBhdGggPSBHb29nbGVDbG91ZFN0b3JhZ2VVcmkudXJpVG9CdWNrZXRBbmRQYXRoKHVyaSk7XG4gICAgICAgIHRoaXMuYnVja2V0ID0gYnVja2V0QW5kUGF0aC5idWNrZXQ7XG4gICAgICAgIHRoaXMucGF0aCA9IGJ1Y2tldEFuZFBhdGgucGF0aDtcbiAgICB9XG4gICAgZ2V0IHVyaSgpIHtcbiAgICAgICAgcmV0dXJuIGBnczovLyR7dGhpcy5idWNrZXR9LyR7dGhpcy5wYXRofWA7XG4gICAgfVxuICAgIGdldCBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzLmJ1Y2tldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdGhpcy5wYXRoICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgc3RhdGljIHVyaVRvQnVja2V0QW5kUGF0aCh1cmkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLnVyaVJlZ2V4cC5leGVjKHVyaSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBnczovLyBVUkk6ICR7dXJpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWNrZXQ6IG1hdGNoWzFdLFxuICAgICAgICAgICAgcGF0aDogbWF0Y2hbMl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkVXJpKHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmlSZWdleHAudGVzdCh1cmkpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlVXJpID0gR29vZ2xlQ2xvdWRTdG9yYWdlVXJpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdvb2dsZUNsb3VkU3RvcmFnZVVyaSwgXCJ1cmlSZWdleHBcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAvZ3M6XFwvXFwvKFthLXowLTldW2EtejAtOS5fLV0rW2EtejAtOV0pXFwvKC4qKS9cbn0pO1xuY2xhc3MgR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzLCBjYWxsZXIsIGNsaWVudCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVyaVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVyaSA9IG5ldyBHb29nbGVDbG91ZFN0b3JhZ2VVcmkoZmllbGRzLnVyaSk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkVXJsKCkge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS91cGxvYWQvc3RvcmFnZS8ke3RoaXMuYXBpVmVyc2lvbn0vYi8ke3RoaXMudXJpLmJ1Y2tldH0vbz91cGxvYWRUeXBlPW11bHRpcGFydGA7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVDbG91ZFN0b3JhZ2VVcGxvYWRDb25uZWN0aW9uID0gR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZURvd25sb2FkQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCkge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXJpXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGhvZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmkgPSBuZXcgR29vZ2xlQ2xvdWRTdG9yYWdlVXJpKGZpZWxkcy51cmkpO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IGZpZWxkcy5tZXRob2Q7XG4gICAgICAgIHRoaXMuYWx0ID0gZmllbGRzLmFsdDtcbiAgICB9XG4gICAgYnVpbGRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZDtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy51cmkucGF0aCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vc3RvcmFnZS8ke3RoaXMuYXBpVmVyc2lvbn0vYi8ke3RoaXMudXJpLmJ1Y2tldH0vby8ke3BhdGh9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx0ID8gYCR7cmV0fT9hbHQ9JHt0aGlzLmFsdH1gIDogcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQ2xvdWRTdG9yYWdlRG93bmxvYWRDb25uZWN0aW9uID0gR29vZ2xlQ2xvdWRTdG9yYWdlRG93bmxvYWRDb25uZWN0aW9uO1xuY2xhc3MgR29vZ2xlQ2xvdWRTdG9yYWdlUmF3Q29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZURvd25sb2FkUmF3Q29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBjYWxsZXIsIGNsaWVudCkge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXJpXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJpID0gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVyaShmaWVsZHMudXJpKTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRVcmwoKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy51cmkucGF0aCk7XG4gICAgICAgIGNvbnN0IHJldCA9IGBodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vc3RvcmFnZS8ke3RoaXMuYXBpVmVyc2lvbn0vYi8ke3RoaXMudXJpLmJ1Y2tldH0vby8ke3BhdGh9P2FsdD1tZWRpYWA7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVDbG91ZFN0b3JhZ2VSYXdDb25uZWN0aW9uID0gR29vZ2xlQ2xvdWRTdG9yYWdlUmF3Q29ubmVjdGlvbjtcbmNsYXNzIEJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZUJhc2UgZXh0ZW5kcyBCbG9iU3RvcmVHb29nbGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJhbXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0b3JlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZGVmYXVsdFN0b3JlT3B0aW9ucyxcbiAgICAgICAgICAgIHBhdGhQcmVmaXg6IGZpZWxkcy51cmlQcmVmaXgudXJpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZFNldENvbm5lY3Rpb24oW2tleSwgX2Jsb2JdKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMucGFyYW1zLFxuICAgICAgICAgICAgdXJpOiBrZXksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgR29vZ2xlQ2xvdWRTdG9yYWdlVXBsb2FkQ29ubmVjdGlvbihwYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxuICAgIGJ1aWxkU2V0TWV0YWRhdGEoW2tleSwgYmxvYl0pIHtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVVyaShrZXkpO1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBuYW1lOiB1cmkucGF0aCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBibG9iLm1ldGFkYXRhLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGJsb2IubWltZXR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGJ1aWxkR2V0TWV0YWRhdGFDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB1cmk6IGtleSxcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGFsdDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZURvd25sb2FkQ29ubmVjdGlvbihwYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxuICAgIGJ1aWxkR2V0RGF0YUNvbm5lY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVyaToga2V5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUNsb3VkU3RvcmFnZVJhd0Nvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZERlbGV0ZUNvbm5lY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVyaToga2V5LFxuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgYWx0OiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgR29vZ2xlQ2xvdWRTdG9yYWdlRG93bmxvYWRDb25uZWN0aW9uKHBhcmFtcywgdGhpcy5jYWxsZXIsIHRoaXMuY2xpZW50KTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZUJhc2UgPSBCbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlO1xuY2xhc3MgQUlTdHVkaW9NZWRpYUJsb2IgZXh0ZW5kcyBtZWRpYV9jb3JlX2pzXzEuTWVkaWFCbG9iIHtcbiAgICBfdmFsdWVBc0RhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9tZXRhZGF0YUZpZWxkQXNEYXRlKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUFzRGF0ZSh0aGlzLm1ldGFkYXRhPy5bZmllbGRdKTtcbiAgICB9XG4gICAgZ2V0IGNyZWF0ZURhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YUZpZWxkQXNEYXRlKFwiY3JlYXRlVGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IHVwZGF0ZURhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YUZpZWxkQXNEYXRlKFwidXBkYXRlVGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGV4cGlyYXRpb25EYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFGaWVsZEFzRGF0ZShcImV4cGlyYXRpb25UaW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFeHBpcmVkKCkge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGV4cCA9IHRoaXMubWV0YWRhdGE/LmV4cGlyYXRpb25UaW1lID8/IG5vdztcbiAgICAgICAgcmV0dXJuIGV4cCA8PSBub3c7XG4gICAgfVxufVxuZXhwb3J0cy5BSVN0dWRpb01lZGlhQmxvYiA9IEFJU3R1ZGlvTWVkaWFCbG9iO1xuY2xhc3MgQUlTdHVkaW9GaWxlVXBsb2FkQ29ubmVjdGlvbiBleHRlbmRzIEdvb2dsZU11bHRpcGFydFVwbG9hZENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlWZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInYxYmV0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS91cGxvYWQvJHt0aGlzLmFwaVZlcnNpb259L2ZpbGVzYDtcbiAgICB9XG59XG5leHBvcnRzLkFJU3R1ZGlvRmlsZVVwbG9hZENvbm5lY3Rpb24gPSBBSVN0dWRpb0ZpbGVVcGxvYWRDb25uZWN0aW9uO1xuY2xhc3MgQUlTdHVkaW9GaWxlRG93bmxvYWRDb25uZWN0aW9uIGV4dGVuZHMgR29vZ2xlRG93bmxvYWRDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIGNhbGxlciwgY2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywgY2FsbGVyLCBjbGllbnQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRob2RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlWZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcInYxYmV0YVwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IGZpZWxkcy5tZXRob2Q7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgIH1cbiAgICBidWlsZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kO1xuICAgIH1cbiAgICBhc3luYyBidWlsZFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS8ke3RoaXMuYXBpVmVyc2lvbn0vZmlsZXMvJHt0aGlzLm5hbWV9YDtcbiAgICB9XG59XG5leHBvcnRzLkFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbiA9IEFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbjtcbmNsYXNzIEJsb2JTdG9yZUFJU3R1ZGlvRmlsZUJhc2UgZXh0ZW5kcyBCbG9iU3RvcmVHb29nbGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkZWZhdWx0U3RvcmVPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgcGF0aFByZWZpeDogXCJodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvZmlsZXMvXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uSWZJbnZhbGlkOiBcInJlbW92ZVBhdGhcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmFtc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXRyeVRpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnJldHJ5VGltZSA9IHBhcmFtcz8ucmV0cnlUaW1lID8/IHRoaXMucmV0cnlUaW1lID8/IDEwMDA7XG4gICAgfVxuICAgIF9wYXRoVG9OYW1lKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLnBvcCgpID8/IHBhdGg7XG4gICAgfVxuICAgIGJ1aWxkQXBpS2V5Q2xpZW50KGFwaUtleSkge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5BcGlLZXlHb29nbGVBdXRoKGFwaUtleSk7XG4gICAgfVxuICAgIGJ1aWxkQXBpS2V5KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gZmllbGRzPy5hcGlLZXkgPz8gKDAsIGVudl8xLmdldEVudmlyb25tZW50VmFyaWFibGUpKFwiR09PR0xFX0FQSV9LRVlcIik7XG4gICAgfVxuICAgIGJ1aWxkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmJ1aWxkQXBpS2V5KGZpZWxkcyk7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkQXBpS2V5Q2xpZW50KGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBUZXN0IHRoYXQgeW91IGNhbiB1c2UgT0F1dGggdG8gYWNjZXNzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFic3RyYWN0ZWRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVnZXRNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgLy8gU2xlZXAgZm9yIHNvbWUgdGltZSBwZXJpb2RcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb21pc2UtZXhlY3V0b3ItcmV0dXJuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMucmV0cnlUaW1lKSk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBsYXRlc3QgbWV0YWRhdGFcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhKGtleSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXQoW2tleSwgYmxvYl0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgc3VwZXIuX3NldChbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBibG9iLFxuICAgICAgICBdKSk7XG4gICAgICAgIGxldCBmaWxlID0gcmVzcG9uc2UuZGF0YT8uZmlsZSA/PyB7IHN0YXRlOiBcIkZBSUxFRFwiIH07XG4gICAgICAgIHdoaWxlIChmaWxlLnN0YXRlID09PSBcIlBST0NFU1NJTkdcIiAmJiBmaWxlLnVyaSAmJiB0aGlzLnJldHJ5VGltZSA+IDApIHtcbiAgICAgICAgICAgIGZpbGUgPSBhd2FpdCB0aGlzLl9yZWdldE1ldGFkYXRhKGZpbGUudXJpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcmVzcG9uc2Ugc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgKGFuZCB2YWxpZCBVUkkpLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYmxvYiB3aXRoIHRoaXMuIFdlIGNhbid0IHJldHVybiBhIG5ldyBibG9iLCBzaW5jZSBtc2V0KClcbiAgICAgICAgLy8gZG9lc24ndCByZXR1cm4gYW55dGhpbmcuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgIGJsb2IucGF0aCA9IGZpbGUudXJpO1xuICAgICAgICBibG9iLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4uYmxvYi5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBidWlsZFNldENvbm5lY3Rpb24oW19rZXksIF9ibG9iXSkge1xuICAgICAgICByZXR1cm4gbmV3IEFJU3R1ZGlvRmlsZVVwbG9hZENvbm5lY3Rpb24odGhpcy5wYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxuICAgIGJ1aWxkU2V0TWV0YWRhdGEoW19rZXksIF9ibG9iXSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGJ1aWxkR2V0TWV0YWRhdGFDb25uZWN0aW9uKGtleSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX3BhdGhUb05hbWUoa2V5KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSVN0dWRpb0ZpbGVEb3dubG9hZENvbm5lY3Rpb24ocGFyYW1zLCB0aGlzLmNhbGxlciwgdGhpcy5jbGllbnQpO1xuICAgIH1cbiAgICBidWlsZEdldERhdGFDb25uZWN0aW9uKF9rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUkgU3R1ZGlvIEZpbGUgQVBJIGRvZXMgbm90IHByb3ZpZGUgZGF0YVwiKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChrZXkpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLl9nZXRNZXRhZGF0YShrZXkpO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gbWV0YWRhdGE/Lm1pbWVUeXBlID8/IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgICAgICAvLyBUT0RPIC0gR2V0IHRoZSBhY3R1YWwgZGF0YSAoYW5kIG90aGVyIG1ldGFkYXRhKSBmcm9tIGFuIG9wdGlvbmFsIGJhY2tpbmcgc3RvcmVcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogY29udGVudFR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBtZWRpYV9jb3JlX2pzXzEuTWVkaWFCbG9iKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlbGV0ZUNvbm5lY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMucGFyYW1zLFxuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5fcGF0aFRvTmFtZShrZXkpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEFJU3R1ZGlvRmlsZURvd25sb2FkQ29ubmVjdGlvbihwYXJhbXMsIHRoaXMuY2FsbGVyLCB0aGlzLmNsaWVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmVBSVN0dWRpb0ZpbGVCYXNlID0gQmxvYlN0b3JlQUlTdHVkaW9GaWxlQmFzZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MediaManager = exports.DataBlobStore = exports.SimpleWebBlobStore = exports.ReadThroughBlobStore = exports.BackedBlobStore = exports.BlobStore = exports.MediaBlob = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\"); // FIXME - it is importing the wrong uuid, so v6 and v7 aren't implemented\nconst stores_1 = __webpack_require__(/*! @langchain/core/stores */ \"(rsc)/./node_modules/@langchain/core/stores.cjs\");\nconst serializable_1 = __webpack_require__(/*! @langchain/core/load/serializable */ \"(rsc)/./node_modules/@langchain/core/load/serializable.cjs\");\nfunction bytesToString(dataArray) {\n    // Need to handle the array in smaller chunks to deal with stack size limits\n    let ret = \"\";\n    const chunkSize = 102400;\n    for (let i = 0; i < dataArray.length; i += chunkSize) {\n        const chunk = dataArray.subarray(i, i + chunkSize);\n        ret += String.fromCharCode(...chunk);\n    }\n    return ret;\n}\n/**\n * Represents a chunk of data that can be identified by the path where the\n * data is (or will be) located, along with optional metadata about the data.\n */\nclass MediaBlob extends serializable_1.Serializable {\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                \"langchain\",\n                \"google_common\",\n                \"experimental\",\n                \"utils\",\n                \"media_core\",\n            ]\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                value: \"\",\n                type: \"text/plain\",\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"path\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = params.data ?? this.data;\n        this.metadata = params.metadata;\n        this.path = params.path;\n    }\n    get size() {\n        return this.asBytes.length;\n    }\n    get dataType() {\n        return this.data?.type ?? \"\";\n    }\n    get encoding() {\n        const charsetEquals = this.dataType.indexOf(\"charset=\");\n        return charsetEquals === -1\n            ? \"utf-8\"\n            : this.dataType.substring(charsetEquals + 8);\n    }\n    get mimetype() {\n        const semicolon = this.dataType.indexOf(\";\");\n        return semicolon === -1\n            ? this.dataType\n            : this.dataType.substring(0, semicolon);\n    }\n    get asBytes() {\n        if (!this.data) {\n            return Uint8Array.from([]);\n        }\n        const binString = atob(this.data?.value);\n        const ret = new Uint8Array(binString.length);\n        for (let co = 0; co < binString.length; co += 1) {\n            ret[co] = binString.charCodeAt(co);\n        }\n        return ret;\n    }\n    async asString() {\n        return bytesToString(this.asBytes);\n    }\n    async asBase64() {\n        return this.data?.value ?? \"\";\n    }\n    async asDataUrl() {\n        return `data:${this.mimetype};base64,${await this.asBase64()}`;\n    }\n    async asUri() {\n        return this.path ?? (await this.asDataUrl());\n    }\n    async encode() {\n        const dataUrl = await this.asDataUrl();\n        const comma = dataUrl.indexOf(\",\");\n        const encoded = dataUrl.substring(comma + 1);\n        const encoding = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n        return {\n            encoded,\n            encoding,\n        };\n    }\n    static fromDataUrl(url) {\n        if (!url.startsWith(\"data:\")) {\n            throw new Error(\"Not a data: URL\");\n        }\n        const colon = url.indexOf(\":\");\n        const semicolon = url.indexOf(\";\");\n        const mimeType = url.substring(colon + 1, semicolon);\n        const comma = url.indexOf(\",\");\n        const base64Data = url.substring(comma + 1);\n        const data = {\n            type: mimeType,\n            value: base64Data,\n        };\n        return new MediaBlob({\n            data,\n            path: url,\n        });\n    }\n    static async fromBlob(blob, other) {\n        const valueBuffer = await blob.arrayBuffer();\n        const valueArray = new Uint8Array(valueBuffer);\n        const valueStr = bytesToString(valueArray);\n        const value = btoa(valueStr);\n        return new MediaBlob({\n            ...other,\n            data: {\n                value,\n                type: blob.type,\n            },\n        });\n    }\n}\nexports.MediaBlob = MediaBlob;\n/**\n * A specialized Store that is designed to handle MediaBlobs and use the\n * key that is included in the blob to determine exactly how it is stored.\n *\n * The full details of a MediaBlob may be changed when it is stored.\n * For example, it may get additional or different Metadata. This should be\n * what is returned when the store() method is called.\n *\n * Although BlobStore extends BaseStore, not all of the methods from\n * BaseStore may be implemented (or even possible). Those that are not\n * implemented should be documented and throw an Error if called.\n */\nclass BlobStore extends stores_1.BaseStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"google-common\"]\n        }); // FIXME - What should this be? And why?\n        Object.defineProperty(this, \"defaultStoreOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultFetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n        this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n    }\n    async _realKey(key) {\n        return typeof key === \"string\" ? key : await key.asUri();\n    }\n    /**\n     * Is the path supported by this BlobStore?\n     *\n     * Although this is async, this is expected to be a relatively fast operation\n     * (ie - you shouldn't make network calls).\n     *\n     * @param path The path to check\n     * @param opts Any options (if needed) that may be used to determine if it is valid\n     * @return If the path is supported\n     */\n    hasValidPath(path, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const isPrefixed = typeof path !== \"undefined\" && path.startsWith(prefix);\n        return Promise.resolve(isPrefixed);\n    }\n    _blobPathSuffix(blob) {\n        // Get the path currently set and make sure we treat it as a string\n        const blobPath = `${blob.path}`;\n        // Advance past the first set of /\n        let pathStart = blobPath.indexOf(\"/\") + 1;\n        while (blobPath.charAt(pathStart) === \"/\") {\n            pathStart += 1;\n        }\n        // We will use the rest as the path for a replacement\n        return blobPath.substring(pathStart);\n    }\n    async _newBlob(oldBlob, newPath) {\n        const oldPath = oldBlob.path;\n        const metadata = oldBlob?.metadata ?? {};\n        metadata.langchainOldPath = oldPath;\n        const newBlob = new MediaBlob({\n            ...oldBlob,\n            metadata,\n        });\n        if (newPath) {\n            newBlob.path = newPath;\n        }\n        else if (newBlob.path) {\n            delete newBlob.path;\n        }\n        return newBlob;\n    }\n    async _validBlobPrefixPath(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._blobPathSuffix(blob);\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    _validBlobPrefixUuidFunction(name) {\n        switch (name) {\n            case \"prefixUuid1\":\n                return (0, uuid_1.v1)();\n            case \"prefixUuid4\":\n                return (0, uuid_1.v4)();\n            // case \"prefixUuid6\": return v6();\n            // case \"prefixUuid7\": return v7();\n            default:\n                throw new Error(`Unknown uuid function: ${name}`);\n        }\n    }\n    async _validBlobPrefixUuid(blob, opts) {\n        const prefix = opts?.pathPrefix ?? \"\";\n        const suffix = this._validBlobPrefixUuidFunction(opts?.actionIfInvalid ?? \"prefixUuid4\");\n        const newPath = `${prefix}${suffix}`;\n        return this._newBlob(blob, newPath);\n    }\n    async _validBlobRemovePath(blob, _opts) {\n        return this._newBlob(blob, undefined);\n    }\n    /**\n     * Based on the blob and options, return a blob that has a valid path\n     * that can be saved.\n     * @param blob\n     * @param opts\n     */\n    async _validStoreBlob(blob, opts) {\n        if (await this.hasValidPath(blob.path, opts)) {\n            return blob;\n        }\n        switch (opts?.actionIfInvalid) {\n            case \"ignore\":\n                return blob;\n            case \"prefixPath\":\n                return this._validBlobPrefixPath(blob, opts);\n            case \"prefixUuid1\":\n            case \"prefixUuid4\":\n            case \"prefixUuid6\":\n            case \"prefixUuid7\":\n                return this._validBlobPrefixUuid(blob, opts);\n            case \"removePath\":\n                return this._validBlobRemovePath(blob, opts);\n            default:\n                return undefined;\n        }\n    }\n    async store(blob, opts = {}) {\n        const allOpts = {\n            ...this.defaultStoreOptions,\n            ...opts,\n        };\n        const validBlob = await this._validStoreBlob(blob, allOpts);\n        if (typeof validBlob !== \"undefined\") {\n            const validKey = await validBlob.asUri();\n            await this.mset([[validKey, validBlob]]);\n            const savedKey = await validBlob.asUri();\n            return await this.fetch(savedKey);\n        }\n        return undefined;\n    }\n    async _missingFetchBlobEmpty(path, _opts) {\n        return new MediaBlob({ path });\n    }\n    async _missingFetchBlob(path, opts) {\n        switch (opts?.actionIfBlobMissing) {\n            case \"emptyBlob\":\n                return this._missingFetchBlobEmpty(path, opts);\n            default:\n                return undefined;\n        }\n    }\n    async fetch(key, opts = {}) {\n        const allOpts = {\n            ...this.defaultFetchOptions,\n            ...opts,\n        };\n        const realKey = await this._realKey(key);\n        const ret = await this.mget([realKey]);\n        return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n    }\n}\nexports.BlobStore = BlobStore;\nclass BackedBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.backingStore = opts.backingStore;\n    }\n    mdelete(keys) {\n        return this.backingStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.backingStore.mget(keys);\n    }\n    mset(keyValuePairs) {\n        return this.backingStore.mset(keyValuePairs);\n    }\n    yieldKeys(prefix) {\n        return this.backingStore.yieldKeys(prefix);\n    }\n}\nexports.BackedBlobStore = BackedBlobStore;\nclass ReadThroughBlobStore extends BlobStore {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"baseStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"backingStore\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStore = opts.baseStore;\n        this.backingStore = opts.backingStore;\n    }\n    async store(blob, opts = {}) {\n        const originalUri = await blob.asUri();\n        const newBlob = await this.backingStore.store(blob, opts);\n        if (newBlob) {\n            await this.baseStore.mset([[originalUri, newBlob]]);\n        }\n        return newBlob;\n    }\n    mdelete(keys) {\n        return this.baseStore.mdelete(keys);\n    }\n    mget(keys) {\n        return this.baseStore.mget(keys);\n    }\n    mset(_keyValuePairs) {\n        throw new Error(\"Do not call ReadThroughBlobStore.mset directly\");\n    }\n    yieldKeys(prefix) {\n        return this.baseStore.yieldKeys(prefix);\n    }\n}\nexports.ReadThroughBlobStore = ReadThroughBlobStore;\nclass SimpleWebBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for SimpleWebBlobStore\");\n    }\n    async hasValidPath(path, _opts) {\n        return ((await super.hasValidPath(path, { pathPrefix: \"https://\" })) ||\n            (await super.hasValidPath(path, { pathPrefix: \"http://\" })));\n    }\n    async _fetch(url) {\n        const ret = new MediaBlob({\n            path: url,\n        });\n        const metadata = {};\n        const fetchOptions = {\n            method: \"GET\",\n        };\n        const res = await fetch(url, fetchOptions);\n        metadata.status = res.status;\n        const headers = {};\n        for (const [key, value] of res.headers.entries()) {\n            headers[key] = value;\n        }\n        metadata.headers = headers;\n        metadata.ok = res.ok;\n        if (res.ok) {\n            const resMediaBlob = await MediaBlob.fromBlob(await res.blob());\n            ret.data = resMediaBlob.data;\n        }\n        ret.metadata = metadata;\n        return ret;\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return await Promise.all(blobMap);\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.SimpleWebBlobStore = SimpleWebBlobStore;\n/**\n * A blob \"store\" that works with data: URLs that will turn the URL into\n * a blob.\n */\nclass DataBlobStore extends BlobStore {\n    _notImplementedException() {\n        throw new Error(\"Not implemented for DataBlobStore\");\n    }\n    hasValidPath(path, _opts) {\n        return super.hasValidPath(path, { pathPrefix: \"data:\" });\n    }\n    _fetch(url) {\n        return MediaBlob.fromDataUrl(url);\n    }\n    async mget(keys) {\n        const blobMap = keys.map(this._fetch);\n        return blobMap;\n    }\n    async mdelete(_keys) {\n        this._notImplementedException();\n    }\n    async mset(_keyValuePairs) {\n        this._notImplementedException();\n    }\n    async *yieldKeys(_prefix) {\n        this._notImplementedException();\n        yield \"\";\n    }\n}\nexports.DataBlobStore = DataBlobStore;\n/**\n * Responsible for converting a URI (typically a web URL) into a MediaBlob.\n * Allows for aliasing / caching of the requested URI and what it resolves to.\n * This MediaBlob is expected to be usable to provide to an LLM, either\n * through the Base64 of the media or through a canonical URI that the LLM\n * supports.\n */\nclass MediaManager {\n    constructor(config) {\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resolvers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.store = config.store;\n        this.resolvers = config.resolvers;\n    }\n    defaultResolvers() {\n        return [new DataBlobStore({}), new SimpleWebBlobStore({})];\n    }\n    async _isInvalid(blob) {\n        return typeof blob === \"undefined\";\n    }\n    /**\n     * Given the public URI, load what is at this URI and save it\n     * in the store.\n     * @param uri The URI to resolve using the resolver\n     * @return A canonical MediaBlob for this URI\n     */\n    async _resolveAndSave(uri) {\n        let resolvedBlob;\n        const resolvers = this.resolvers || this.defaultResolvers();\n        for (let co = 0; co < resolvers.length; co += 1) {\n            const resolver = resolvers[co];\n            if (await resolver.hasValidPath(uri)) {\n                resolvedBlob = await resolver.fetch(uri);\n            }\n        }\n        if (resolvedBlob) {\n            return await this.store.store(resolvedBlob);\n        }\n        else {\n            return new MediaBlob({});\n        }\n    }\n    async getMediaBlob(uri) {\n        const aliasBlob = await this.store.fetch(uri);\n        const ret = (await this._isInvalid(aliasBlob))\n            ? await this._resolveAndSave(uri)\n            : aliasBlob;\n        return ret;\n    }\n}\nexports.MediaManager = MediaManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL3V0aWxzL21lZGlhX2NvcmUuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMxSyxlQUFlLG1CQUFPLENBQUMsb0dBQU0sR0FBRztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBd0I7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMscUdBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWUsU0FBUyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLEVBQUUsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUUsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvZXhwZXJpbWVudGFsL3V0aWxzL21lZGlhX2NvcmUuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZWRpYU1hbmFnZXIgPSBleHBvcnRzLkRhdGFCbG9iU3RvcmUgPSBleHBvcnRzLlNpbXBsZVdlYkJsb2JTdG9yZSA9IGV4cG9ydHMuUmVhZFRocm91Z2hCbG9iU3RvcmUgPSBleHBvcnRzLkJhY2tlZEJsb2JTdG9yZSA9IGV4cG9ydHMuQmxvYlN0b3JlID0gZXhwb3J0cy5NZWRpYUJsb2IgPSB2b2lkIDA7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTsgLy8gRklYTUUgLSBpdCBpcyBpbXBvcnRpbmcgdGhlIHdyb25nIHV1aWQsIHNvIHY2IGFuZCB2NyBhcmVuJ3QgaW1wbGVtZW50ZWRcbmNvbnN0IHN0b3Jlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9zdG9yZXNcIik7XG5jb25zdCBzZXJpYWxpemFibGVfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvbG9hZC9zZXJpYWxpemFibGVcIik7XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGRhdGFBcnJheSkge1xuICAgIC8vIE5lZWQgdG8gaGFuZGxlIHRoZSBhcnJheSBpbiBzbWFsbGVyIGNodW5rcyB0byBkZWFsIHdpdGggc3RhY2sgc2l6ZSBsaW1pdHNcbiAgICBsZXQgcmV0ID0gXCJcIjtcbiAgICBjb25zdCBjaHVua1NpemUgPSAxMDI0MDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGRhdGFBcnJheS5zdWJhcnJheShpLCBpICsgY2h1bmtTaXplKTtcbiAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgZGF0YSB0aGF0IGNhbiBiZSBpZGVudGlmaWVkIGJ5IHRoZSBwYXRoIHdoZXJlIHRoZVxuICogZGF0YSBpcyAob3Igd2lsbCBiZSkgbG9jYXRlZCwgYWxvbmcgd2l0aCBvcHRpb25hbCBtZXRhZGF0YSBhYm91dCB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgTWVkaWFCbG9iIGV4dGVuZHMgc2VyaWFsaXphYmxlXzEuU2VyaWFsaXphYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICBcImxhbmdjaGFpblwiLFxuICAgICAgICAgICAgICAgIFwiZ29vZ2xlX2NvbW1vblwiLFxuICAgICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsXCIsXG4gICAgICAgICAgICAgICAgXCJ1dGlsc1wiLFxuICAgICAgICAgICAgICAgIFwibWVkaWFfY29yZVwiLFxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGEgPSBwYXJhbXMuZGF0YSA/PyB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhcmFtcy5wYXRoO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNCeXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBkYXRhVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YT8udHlwZSA/PyBcIlwiO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIGNvbnN0IGNoYXJzZXRFcXVhbHMgPSB0aGlzLmRhdGFUeXBlLmluZGV4T2YoXCJjaGFyc2V0PVwiKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzZXRFcXVhbHMgPT09IC0xXG4gICAgICAgICAgICA/IFwidXRmLThcIlxuICAgICAgICAgICAgOiB0aGlzLmRhdGFUeXBlLnN1YnN0cmluZyhjaGFyc2V0RXF1YWxzICsgOCk7XG4gICAgfVxuICAgIGdldCBtaW1ldHlwZSgpIHtcbiAgICAgICAgY29uc3Qgc2VtaWNvbG9uID0gdGhpcy5kYXRhVHlwZS5pbmRleE9mKFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIHNlbWljb2xvbiA9PT0gLTFcbiAgICAgICAgICAgID8gdGhpcy5kYXRhVHlwZVxuICAgICAgICAgICAgOiB0aGlzLmRhdGFUeXBlLnN1YnN0cmluZygwLCBzZW1pY29sb24pO1xuICAgIH1cbiAgICBnZXQgYXNCeXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpblN0cmluZyA9IGF0b2IodGhpcy5kYXRhPy52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGJpblN0cmluZy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBjbyA9IDA7IGNvIDwgYmluU3RyaW5nLmxlbmd0aDsgY28gKz0gMSkge1xuICAgICAgICAgICAgcmV0W2NvXSA9IGJpblN0cmluZy5jaGFyQ29kZUF0KGNvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBhc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcodGhpcy5hc0J5dGVzKTtcbiAgICB9XG4gICAgYXN5bmMgYXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE/LnZhbHVlID8/IFwiXCI7XG4gICAgfVxuICAgIGFzeW5jIGFzRGF0YVVybCgpIHtcbiAgICAgICAgcmV0dXJuIGBkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7YXdhaXQgdGhpcy5hc0Jhc2U2NCgpfWA7XG4gICAgfVxuICAgIGFzeW5jIGFzVXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoID8/IChhd2FpdCB0aGlzLmFzRGF0YVVybCgpKTtcbiAgICB9XG4gICAgYXN5bmMgZW5jb2RlKCkge1xuICAgICAgICBjb25zdCBkYXRhVXJsID0gYXdhaXQgdGhpcy5hc0RhdGFVcmwoKTtcbiAgICAgICAgY29uc3QgY29tbWEgPSBkYXRhVXJsLmluZGV4T2YoXCIsXCIpO1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gZGF0YVVybC5zdWJzdHJpbmcoY29tbWEgKyAxKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBkYXRhVXJsLmluZGV4T2YoXCJiYXNlNjRcIikgPiAtMSA/IFwiYmFzZTY0XCIgOiBcIjhiaXRcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY29kZWQsXG4gICAgICAgICAgICBlbmNvZGluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EYXRhVXJsKHVybCkge1xuICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIGRhdGE6IFVSTFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvbiA9IHVybC5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgY29uc3Qgc2VtaWNvbG9uID0gdXJsLmluZGV4T2YoXCI7XCIpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHVybC5zdWJzdHJpbmcoY29sb24gKyAxLCBzZW1pY29sb24pO1xuICAgICAgICBjb25zdCBjb21tYSA9IHVybC5pbmRleE9mKFwiLFwiKTtcbiAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IHVybC5zdWJzdHJpbmcoY29tbWEgKyAxKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IG1pbWVUeXBlLFxuICAgICAgICAgICAgdmFsdWU6IGJhc2U2NERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgTWVkaWFCbG9iKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiB1cmwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUJsb2IoYmxvYiwgb3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQXJyYXkgPSBuZXcgVWludDhBcnJheSh2YWx1ZUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyID0gYnl0ZXNUb1N0cmluZyh2YWx1ZUFycmF5KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBidG9hKHZhbHVlU3RyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZWRpYUJsb2Ioe1xuICAgICAgICAgICAgLi4ub3RoZXIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYUJsb2IgPSBNZWRpYUJsb2I7XG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgU3RvcmUgdGhhdCBpcyBkZXNpZ25lZCB0byBoYW5kbGUgTWVkaWFCbG9icyBhbmQgdXNlIHRoZVxuICoga2V5IHRoYXQgaXMgaW5jbHVkZWQgaW4gdGhlIGJsb2IgdG8gZGV0ZXJtaW5lIGV4YWN0bHkgaG93IGl0IGlzIHN0b3JlZC5cbiAqXG4gKiBUaGUgZnVsbCBkZXRhaWxzIG9mIGEgTWVkaWFCbG9iIG1heSBiZSBjaGFuZ2VkIHdoZW4gaXQgaXMgc3RvcmVkLlxuICogRm9yIGV4YW1wbGUsIGl0IG1heSBnZXQgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQgTWV0YWRhdGEuIFRoaXMgc2hvdWxkIGJlXG4gKiB3aGF0IGlzIHJldHVybmVkIHdoZW4gdGhlIHN0b3JlKCkgbWV0aG9kIGlzIGNhbGxlZC5cbiAqXG4gKiBBbHRob3VnaCBCbG9iU3RvcmUgZXh0ZW5kcyBCYXNlU3RvcmUsIG5vdCBhbGwgb2YgdGhlIG1ldGhvZHMgZnJvbVxuICogQmFzZVN0b3JlIG1heSBiZSBpbXBsZW1lbnRlZCAob3IgZXZlbiBwb3NzaWJsZSkuIFRob3NlIHRoYXQgYXJlIG5vdFxuICogaW1wbGVtZW50ZWQgc2hvdWxkIGJlIGRvY3VtZW50ZWQgYW5kIHRocm93IGFuIEVycm9yIGlmIGNhbGxlZC5cbiAqL1xuY2xhc3MgQmxvYlN0b3JlIGV4dGVuZHMgc3RvcmVzXzEuQmFzZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcImdvb2dsZS1jb21tb25cIl1cbiAgICAgICAgfSk7IC8vIEZJWE1FIC0gV2hhdCBzaG91bGQgdGhpcyBiZT8gQW5kIHdoeT9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdFN0b3JlT3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0RmV0Y2hPcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0b3JlT3B0aW9ucyA9IG9wdHM/LmRlZmF1bHRTdG9yZU9wdGlvbnMgPz8ge307XG4gICAgICAgIHRoaXMuZGVmYXVsdEZldGNoT3B0aW9ucyA9IG9wdHM/LmRlZmF1bHRGZXRjaE9wdGlvbnMgPz8ge307XG4gICAgfVxuICAgIGFzeW5jIF9yZWFsS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiA/IGtleSA6IGF3YWl0IGtleS5hc1VyaSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBzdXBwb3J0ZWQgYnkgdGhpcyBCbG9iU3RvcmU/XG4gICAgICpcbiAgICAgKiBBbHRob3VnaCB0aGlzIGlzIGFzeW5jLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGEgcmVsYXRpdmVseSBmYXN0IG9wZXJhdGlvblxuICAgICAqIChpZSAtIHlvdSBzaG91bGRuJ3QgbWFrZSBuZXR3b3JrIGNhbGxzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIG9wdHMgQW55IG9wdGlvbnMgKGlmIG5lZWRlZCkgdGhhdCBtYXkgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgaXQgaXMgdmFsaWRcbiAgICAgKiBAcmV0dXJuIElmIHRoZSBwYXRoIGlzIHN1cHBvcnRlZFxuICAgICAqL1xuICAgIGhhc1ZhbGlkUGF0aChwYXRoLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdHM/LnBhdGhQcmVmaXggPz8gXCJcIjtcbiAgICAgICAgY29uc3QgaXNQcmVmaXhlZCA9IHR5cGVvZiBwYXRoICE9PSBcInVuZGVmaW5lZFwiICYmIHBhdGguc3RhcnRzV2l0aChwcmVmaXgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGlzUHJlZml4ZWQpO1xuICAgIH1cbiAgICBfYmxvYlBhdGhTdWZmaXgoYmxvYikge1xuICAgICAgICAvLyBHZXQgdGhlIHBhdGggY3VycmVudGx5IHNldCBhbmQgbWFrZSBzdXJlIHdlIHRyZWF0IGl0IGFzIGEgc3RyaW5nXG4gICAgICAgIGNvbnN0IGJsb2JQYXRoID0gYCR7YmxvYi5wYXRofWA7XG4gICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgZmlyc3Qgc2V0IG9mIC9cbiAgICAgICAgbGV0IHBhdGhTdGFydCA9IGJsb2JQYXRoLmluZGV4T2YoXCIvXCIpICsgMTtcbiAgICAgICAgd2hpbGUgKGJsb2JQYXRoLmNoYXJBdChwYXRoU3RhcnQpID09PSBcIi9cIikge1xuICAgICAgICAgICAgcGF0aFN0YXJ0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2lsbCB1c2UgdGhlIHJlc3QgYXMgdGhlIHBhdGggZm9yIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgcmV0dXJuIGJsb2JQYXRoLnN1YnN0cmluZyhwYXRoU3RhcnQpO1xuICAgIH1cbiAgICBhc3luYyBfbmV3QmxvYihvbGRCbG9iLCBuZXdQYXRoKSB7XG4gICAgICAgIGNvbnN0IG9sZFBhdGggPSBvbGRCbG9iLnBhdGg7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb2xkQmxvYj8ubWV0YWRhdGEgPz8ge307XG4gICAgICAgIG1ldGFkYXRhLmxhbmdjaGFpbk9sZFBhdGggPSBvbGRQYXRoO1xuICAgICAgICBjb25zdCBuZXdCbG9iID0gbmV3IE1lZGlhQmxvYih7XG4gICAgICAgICAgICAuLi5vbGRCbG9iLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3UGF0aCkge1xuICAgICAgICAgICAgbmV3QmxvYi5wYXRoID0gbmV3UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdCbG9iLnBhdGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdCbG9iLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0Jsb2I7XG4gICAgfVxuICAgIGFzeW5jIF92YWxpZEJsb2JQcmVmaXhQYXRoKGJsb2IsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gb3B0cz8ucGF0aFByZWZpeCA/PyBcIlwiO1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0aGlzLl9ibG9iUGF0aFN1ZmZpeChibG9iKTtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke3ByZWZpeH0ke3N1ZmZpeH1gO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3QmxvYihibG9iLCBuZXdQYXRoKTtcbiAgICB9XG4gICAgX3ZhbGlkQmxvYlByZWZpeFV1aWRGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQxXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dWlkXzEudjEpKCk7XG4gICAgICAgICAgICBjYXNlIFwicHJlZml4VXVpZDRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgICAgIC8vIGNhc2UgXCJwcmVmaXhVdWlkNlwiOiByZXR1cm4gdjYoKTtcbiAgICAgICAgICAgIC8vIGNhc2UgXCJwcmVmaXhVdWlkN1wiOiByZXR1cm4gdjcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHV1aWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdmFsaWRCbG9iUHJlZml4VXVpZChibG9iLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdHM/LnBhdGhQcmVmaXggPz8gXCJcIjtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdGhpcy5fdmFsaWRCbG9iUHJlZml4VXVpZEZ1bmN0aW9uKG9wdHM/LmFjdGlvbklmSW52YWxpZCA/PyBcInByZWZpeFV1aWQ0XCIpO1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gYCR7cHJlZml4fSR7c3VmZml4fWA7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdCbG9iKGJsb2IsIG5ld1BhdGgpO1xuICAgIH1cbiAgICBhc3luYyBfdmFsaWRCbG9iUmVtb3ZlUGF0aChibG9iLCBfb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV3QmxvYihibG9iLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgYmxvYiBhbmQgb3B0aW9ucywgcmV0dXJuIGEgYmxvYiB0aGF0IGhhcyBhIHZhbGlkIHBhdGhcbiAgICAgKiB0aGF0IGNhbiBiZSBzYXZlZC5cbiAgICAgKiBAcGFyYW0gYmxvYlxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICovXG4gICAgYXN5bmMgX3ZhbGlkU3RvcmVCbG9iKGJsb2IsIG9wdHMpIHtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaGFzVmFsaWRQYXRoKGJsb2IucGF0aCwgb3B0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBibG9iO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob3B0cz8uYWN0aW9uSWZJbnZhbGlkKSB7XG4gICAgICAgICAgICBjYXNlIFwiaWdub3JlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2I7XG4gICAgICAgICAgICBjYXNlIFwicHJlZml4UGF0aFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZEJsb2JQcmVmaXhQYXRoKGJsb2IsIG9wdHMpO1xuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQxXCI6XG4gICAgICAgICAgICBjYXNlIFwicHJlZml4VXVpZDRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwcmVmaXhVdWlkNlwiOlxuICAgICAgICAgICAgY2FzZSBcInByZWZpeFV1aWQ3XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkQmxvYlByZWZpeFV1aWQoYmxvYiwgb3B0cyk7XG4gICAgICAgICAgICBjYXNlIFwicmVtb3ZlUGF0aFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZEJsb2JSZW1vdmVQYXRoKGJsb2IsIG9wdHMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0b3JlKGJsb2IsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBhbGxPcHRzID0ge1xuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0U3RvcmVPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsaWRCbG9iID0gYXdhaXQgdGhpcy5fdmFsaWRTdG9yZUJsb2IoYmxvYiwgYWxsT3B0cyk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRCbG9iICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZEtleSA9IGF3YWl0IHZhbGlkQmxvYi5hc1VyaSgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tc2V0KFtbdmFsaWRLZXksIHZhbGlkQmxvYl1dKTtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkS2V5ID0gYXdhaXQgdmFsaWRCbG9iLmFzVXJpKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChzYXZlZEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgX21pc3NpbmdGZXRjaEJsb2JFbXB0eShwYXRoLCBfb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1lZGlhQmxvYih7IHBhdGggfSk7XG4gICAgfVxuICAgIGFzeW5jIF9taXNzaW5nRmV0Y2hCbG9iKHBhdGgsIG9wdHMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRzPy5hY3Rpb25JZkJsb2JNaXNzaW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiZW1wdHlCbG9iXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pc3NpbmdGZXRjaEJsb2JFbXB0eShwYXRoLCBvcHRzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaChrZXksIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBhbGxPcHRzID0ge1xuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0RmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVhbEtleSA9IGF3YWl0IHRoaXMuX3JlYWxLZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgdGhpcy5tZ2V0KFtyZWFsS2V5XSk7XG4gICAgICAgIHJldHVybiByZXQ/LlswXSA/PyAoYXdhaXQgdGhpcy5fbWlzc2luZ0ZldGNoQmxvYihyZWFsS2V5LCBhbGxPcHRzKSk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iU3RvcmUgPSBCbG9iU3RvcmU7XG5jbGFzcyBCYWNrZWRCbG9iU3RvcmUgZXh0ZW5kcyBCbG9iU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhY2tpbmdTdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhY2tpbmdTdG9yZSA9IG9wdHMuYmFja2luZ1N0b3JlO1xuICAgIH1cbiAgICBtZGVsZXRlKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2luZ1N0b3JlLm1kZWxldGUoa2V5cyk7XG4gICAgfVxuICAgIG1nZXQoa2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNraW5nU3RvcmUubWdldChrZXlzKTtcbiAgICB9XG4gICAgbXNldChrZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS5tc2V0KGtleVZhbHVlUGFpcnMpO1xuICAgIH1cbiAgICB5aWVsZEtleXMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tpbmdTdG9yZS55aWVsZEtleXMocHJlZml4KTtcbiAgICB9XG59XG5leHBvcnRzLkJhY2tlZEJsb2JTdG9yZSA9IEJhY2tlZEJsb2JTdG9yZTtcbmNsYXNzIFJlYWRUaHJvdWdoQmxvYlN0b3JlIGV4dGVuZHMgQmxvYlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXNlU3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFja2luZ1N0b3JlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFzZVN0b3JlID0gb3B0cy5iYXNlU3RvcmU7XG4gICAgICAgIHRoaXMuYmFja2luZ1N0b3JlID0gb3B0cy5iYWNraW5nU3RvcmU7XG4gICAgfVxuICAgIGFzeW5jIHN0b3JlKGJsb2IsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFVyaSA9IGF3YWl0IGJsb2IuYXNVcmkoKTtcbiAgICAgICAgY29uc3QgbmV3QmxvYiA9IGF3YWl0IHRoaXMuYmFja2luZ1N0b3JlLnN0b3JlKGJsb2IsIG9wdHMpO1xuICAgICAgICBpZiAobmV3QmxvYikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5iYXNlU3RvcmUubXNldChbW29yaWdpbmFsVXJpLCBuZXdCbG9iXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdCbG9iO1xuICAgIH1cbiAgICBtZGVsZXRlKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0b3JlLm1kZWxldGUoa2V5cyk7XG4gICAgfVxuICAgIG1nZXQoa2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RvcmUubWdldChrZXlzKTtcbiAgICB9XG4gICAgbXNldChfa2V5VmFsdWVQYWlycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEbyBub3QgY2FsbCBSZWFkVGhyb3VnaEJsb2JTdG9yZS5tc2V0IGRpcmVjdGx5XCIpO1xuICAgIH1cbiAgICB5aWVsZEtleXMocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdG9yZS55aWVsZEtleXMocHJlZml4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRUaHJvdWdoQmxvYlN0b3JlID0gUmVhZFRocm91Z2hCbG9iU3RvcmU7XG5jbGFzcyBTaW1wbGVXZWJCbG9iU3RvcmUgZXh0ZW5kcyBCbG9iU3RvcmUge1xuICAgIF9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIGZvciBTaW1wbGVXZWJCbG9iU3RvcmVcIik7XG4gICAgfVxuICAgIGFzeW5jIGhhc1ZhbGlkUGF0aChwYXRoLCBfb3B0cykge1xuICAgICAgICByZXR1cm4gKChhd2FpdCBzdXBlci5oYXNWYWxpZFBhdGgocGF0aCwgeyBwYXRoUHJlZml4OiBcImh0dHBzOi8vXCIgfSkpIHx8XG4gICAgICAgICAgICAoYXdhaXQgc3VwZXIuaGFzVmFsaWRQYXRoKHBhdGgsIHsgcGF0aFByZWZpeDogXCJodHRwOi8vXCIgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgTWVkaWFCbG9iKHtcbiAgICAgICAgICAgIHBhdGg6IHVybCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge307XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICBtZXRhZGF0YS5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHJlcy5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIG1ldGFkYXRhLm9rID0gcmVzLm9rO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXNNZWRpYUJsb2IgPSBhd2FpdCBNZWRpYUJsb2IuZnJvbUJsb2IoYXdhaXQgcmVzLmJsb2IoKSk7XG4gICAgICAgICAgICByZXQuZGF0YSA9IHJlc01lZGlhQmxvYi5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBtZ2V0KGtleXMpIHtcbiAgICAgICAgY29uc3QgYmxvYk1hcCA9IGtleXMubWFwKHRoaXMuX2ZldGNoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGJsb2JNYXApO1xuICAgIH1cbiAgICBhc3luYyBtZGVsZXRlKF9rZXlzKSB7XG4gICAgICAgIHRoaXMuX25vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIG1zZXQoX2tleVZhbHVlUGFpcnMpIHtcbiAgICAgICAgdGhpcy5fbm90SW1wbGVtZW50ZWRFeGNlcHRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKnlpZWxkS2V5cyhfcHJlZml4KSB7XG4gICAgICAgIHRoaXMuX25vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XG4gICAgICAgIHlpZWxkIFwiXCI7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVXZWJCbG9iU3RvcmUgPSBTaW1wbGVXZWJCbG9iU3RvcmU7XG4vKipcbiAqIEEgYmxvYiBcInN0b3JlXCIgdGhhdCB3b3JrcyB3aXRoIGRhdGE6IFVSTHMgdGhhdCB3aWxsIHR1cm4gdGhlIFVSTCBpbnRvXG4gKiBhIGJsb2IuXG4gKi9cbmNsYXNzIERhdGFCbG9iU3RvcmUgZXh0ZW5kcyBCbG9iU3RvcmUge1xuICAgIF9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkIGZvciBEYXRhQmxvYlN0b3JlXCIpO1xuICAgIH1cbiAgICBoYXNWYWxpZFBhdGgocGF0aCwgX29wdHMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmhhc1ZhbGlkUGF0aChwYXRoLCB7IHBhdGhQcmVmaXg6IFwiZGF0YTpcIiB9KTtcbiAgICB9XG4gICAgX2ZldGNoKHVybCkge1xuICAgICAgICByZXR1cm4gTWVkaWFCbG9iLmZyb21EYXRhVXJsKHVybCk7XG4gICAgfVxuICAgIGFzeW5jIG1nZXQoa2V5cykge1xuICAgICAgICBjb25zdCBibG9iTWFwID0ga2V5cy5tYXAodGhpcy5fZmV0Y2gpO1xuICAgICAgICByZXR1cm4gYmxvYk1hcDtcbiAgICB9XG4gICAgYXN5bmMgbWRlbGV0ZShfa2V5cykge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBtc2V0KF9rZXlWYWx1ZVBhaXJzKSB7XG4gICAgICAgIHRoaXMuX25vdEltcGxlbWVudGVkRXhjZXB0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jICp5aWVsZEtleXMoX3ByZWZpeCkge1xuICAgICAgICB0aGlzLl9ub3RJbXBsZW1lbnRlZEV4Y2VwdGlvbigpO1xuICAgICAgICB5aWVsZCBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YUJsb2JTdG9yZSA9IERhdGFCbG9iU3RvcmU7XG4vKipcbiAqIFJlc3BvbnNpYmxlIGZvciBjb252ZXJ0aW5nIGEgVVJJICh0eXBpY2FsbHkgYSB3ZWIgVVJMKSBpbnRvIGEgTWVkaWFCbG9iLlxuICogQWxsb3dzIGZvciBhbGlhc2luZyAvIGNhY2hpbmcgb2YgdGhlIHJlcXVlc3RlZCBVUkkgYW5kIHdoYXQgaXQgcmVzb2x2ZXMgdG8uXG4gKiBUaGlzIE1lZGlhQmxvYiBpcyBleHBlY3RlZCB0byBiZSB1c2FibGUgdG8gcHJvdmlkZSB0byBhbiBMTE0sIGVpdGhlclxuICogdGhyb3VnaCB0aGUgQmFzZTY0IG9mIHRoZSBtZWRpYSBvciB0aHJvdWdoIGEgY2Fub25pY2FsIFVSSSB0aGF0IHRoZSBMTE1cbiAqIHN1cHBvcnRzLlxuICovXG5jbGFzcyBNZWRpYU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNvbHZlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IGNvbmZpZy5zdG9yZTtcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSBjb25maWcucmVzb2x2ZXJzO1xuICAgIH1cbiAgICBkZWZhdWx0UmVzb2x2ZXJzKCkge1xuICAgICAgICByZXR1cm4gW25ldyBEYXRhQmxvYlN0b3JlKHt9KSwgbmV3IFNpbXBsZVdlYkJsb2JTdG9yZSh7fSldO1xuICAgIH1cbiAgICBhc3luYyBfaXNJbnZhbGlkKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBibG9iID09PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgcHVibGljIFVSSSwgbG9hZCB3aGF0IGlzIGF0IHRoaXMgVVJJIGFuZCBzYXZlIGl0XG4gICAgICogaW4gdGhlIHN0b3JlLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIFVSSSB0byByZXNvbHZlIHVzaW5nIHRoZSByZXNvbHZlclxuICAgICAqIEByZXR1cm4gQSBjYW5vbmljYWwgTWVkaWFCbG9iIGZvciB0aGlzIFVSSVxuICAgICAqL1xuICAgIGFzeW5jIF9yZXNvbHZlQW5kU2F2ZSh1cmkpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkQmxvYjtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJzID0gdGhpcy5yZXNvbHZlcnMgfHwgdGhpcy5kZWZhdWx0UmVzb2x2ZXJzKCk7XG4gICAgICAgIGZvciAobGV0IGNvID0gMDsgY28gPCByZXNvbHZlcnMubGVuZ3RoOyBjbyArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHJlc29sdmVyc1tjb107XG4gICAgICAgICAgICBpZiAoYXdhaXQgcmVzb2x2ZXIuaGFzVmFsaWRQYXRoKHVyaSkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEJsb2IgPSBhd2FpdCByZXNvbHZlci5mZXRjaCh1cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZEJsb2IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0b3JlLnN0b3JlKHJlc29sdmVkQmxvYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lZGlhQmxvYih7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TWVkaWFCbG9iKHVyaSkge1xuICAgICAgICBjb25zdCBhbGlhc0Jsb2IgPSBhd2FpdCB0aGlzLnN0b3JlLmZldGNoKHVyaSk7XG4gICAgICAgIGNvbnN0IHJldCA9IChhd2FpdCB0aGlzLl9pc0ludmFsaWQoYWxpYXNCbG9iKSlcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fcmVzb2x2ZUFuZFNhdmUodXJpKVxuICAgICAgICAgICAgOiBhbGlhc0Jsb2I7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5NZWRpYU1hbmFnZXIgPSBNZWRpYU1hbmFnZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/experimental/utils/media_core.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/index.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/index.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./output_parsers.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywyRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLG1HQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsK0VBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDJGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsaUZBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLCtGQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBc0M7QUFDM0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hhdF9tb2RlbHMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sbG1zLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW1iZWRkaW5ncy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL291dHB1dF9wYXJzZXJzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXV0aC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3N0cmVhbS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL2NvbW1vbi5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL3NhZmV0eS5janNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/llms.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleBaseLLM = void 0;\nconst manager_1 = __webpack_require__(/*! @langchain/core/callbacks/manager */ \"(rsc)/./node_modules/@langchain/core/callbacks/manager.cjs\");\nconst llms_1 = __webpack_require__(/*! @langchain/core/language_models/llms */ \"(rsc)/./node_modules/@langchain/core/language_models/llms.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst env_1 = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.cjs\");\nconst connection_js_1 = __webpack_require__(/*! ./connection.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/connection.cjs\");\nconst common_js_1 = __webpack_require__(/*! ./utils/common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./utils/gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/auth.cjs\");\nconst failed_handler_js_1 = __webpack_require__(/*! ./utils/failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\");\nconst chat_models_js_1 = __webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/chat_models.cjs\");\nclass GoogleLLMConnection extends connection_js_1.AbstractGoogleLLMConnection {\n    async formatContents(input, _parameters) {\n        const parts = await this.api.messageContentToParts(input);\n        const contents = [\n            {\n                role: \"user\",\n                parts,\n            },\n        ];\n        return contents;\n    }\n}\nclass ProxyChatGoogle extends chat_models_js_1.ChatGoogleBase {\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return fields.connection.client;\n    }\n}\n/**\n * Integration with an LLM.\n */\nclass GoogleBaseLLM extends llms_1.LLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    get lc_secrets() {\n        return {\n            authOptions: \"GOOGLE_AUTH_OPTIONS\",\n        };\n    }\n    constructor(fields) {\n        super((0, failed_handler_js_1.ensureParams)(fields));\n        Object.defineProperty(this, \"originalFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"model\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"gemini-pro\"\n        });\n        Object.defineProperty(this, \"temperature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.7\n        });\n        Object.defineProperty(this, \"maxOutputTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1024\n        });\n        Object.defineProperty(this, \"topP\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0.8\n        });\n        Object.defineProperty(this, \"topK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 40\n        });\n        Object.defineProperty(this, \"stopSequences\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetySettings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"safetyHandler\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"responseMimeType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text/plain\"\n        });\n        Object.defineProperty(this, \"connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"streamedConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.originalFields = fields;\n        (0, common_js_1.copyAndValidateModelParamsInto)(fields, this);\n        this.safetyHandler =\n            fields?.safetyHandler ?? new gemini_js_1.DefaultGeminiSafetyHandler();\n        const client = this.buildClient(fields);\n        this.buildConnection(fields ?? {}, client);\n    }\n    buildApiKeyClient(apiKey) {\n        return new auth_js_1.ApiKeyGoogleAuth(apiKey);\n    }\n    buildApiKey(fields) {\n        return fields?.apiKey ?? (0, env_1.getEnvironmentVariable)(\"GOOGLE_API_KEY\");\n    }\n    buildClient(fields) {\n        const apiKey = this.buildApiKey(fields);\n        if (apiKey) {\n            return this.buildApiKeyClient(apiKey);\n        }\n        else {\n            return this.buildAbstractedClient(fields);\n        }\n    }\n    buildConnection(fields, client) {\n        this.connection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, false);\n        this.streamedConnection = new GoogleLLMConnection({ ...fields, ...this }, this.caller, client, true);\n    }\n    get platform() {\n        return this.connection.platform;\n    }\n    // Replace\n    _llmType() {\n        return \"googlellm\";\n    }\n    formatPrompt(prompt) {\n        return prompt;\n    }\n    /**\n     * For some given input string and options, return a string output.\n     *\n     * Despite the fact that `invoke` is overridden below, we still need this\n     * in order to handle public APi calls to `generate()`.\n     */\n    async _call(prompt, options) {\n        const parameters = (0, common_js_1.copyAIModelParams)(this, options);\n        const result = await this.connection.request(prompt, parameters, options);\n        const ret = this.connection.api.responseToString(result);\n        return ret;\n    }\n    // Normally, you should not override this method and instead should override\n    // _streamResponseChunks. We are doing so here to allow for multimodal inputs into\n    // the LLM.\n    async *_streamIterator(input, options) {\n        // TODO: Refactor callback setup and teardown code into core\n        const prompt = llms_1.BaseLLM._convertInputToPromptValue(input);\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n        const callbackManager_ = await manager_1.CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: callOptions,\n            invocation_params: this?.invocationParams(callOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleLLMStart(this.toJSON(), [prompt.toString()], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n        let generation = new outputs_1.GenerationChunk({\n            text: \"\",\n        });\n        const proxyChat = this.createProxyChat();\n        try {\n            for await (const chunk of proxyChat._streamIterator(input, options)) {\n                const stringValue = this.connection.api.chunkToString(chunk);\n                const generationChunk = new outputs_1.GenerationChunk({\n                    text: stringValue,\n                });\n                generation = generation.concat(generationChunk);\n                yield stringValue;\n            }\n        }\n        catch (err) {\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n            throw err;\n        }\n        await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n            generations: [[generation]],\n        })));\n    }\n    async predictMessages(messages, options, _callbacks) {\n        const { content } = messages[0];\n        const result = await this.connection.request(content, {}, options);\n        const ret = this.connection.api.responseToBaseMessage(result);\n        return ret;\n    }\n    /**\n     * Internal implementation detail to allow Google LLMs to support\n     * multimodal input by delegating to the chat model implementation.\n     *\n     * TODO: Replace with something less hacky.\n     */\n    createProxyChat() {\n        return new ProxyChatGoogle({\n            ...this.originalFields,\n            connection: this.connection,\n        });\n    }\n    // TODO: Remove the need to override this - we are doing it to\n    // allow the LLM to handle multimodal types of input.\n    async invoke(input, options) {\n        const stream = await this._streamIterator(input, options);\n        let generatedOutput = \"\";\n        for await (const chunk of stream) {\n            generatedOutput += chunk;\n        }\n        return generatedOutput;\n    }\n}\nexports.GoogleBaseLLM = GoogleBaseLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvbGxtcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFtQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsMkdBQXNDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLGlGQUF5QjtBQUNuRCxjQUFjLG1CQUFPLENBQUMscUZBQTJCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLDJGQUFrQjtBQUNsRCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBb0I7QUFDaEQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQW9CO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUE0QjtBQUNoRSx5QkFBeUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEUsNERBQTRELG9CQUFvQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTEFBK0wsdUJBQXVCO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9sbG1zLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlQmFzZUxMTSA9IHZvaWQgMDtcbmNvbnN0IG1hbmFnZXJfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL2NvcmUvY2FsbGJhY2tzL21hbmFnZXJcIik7XG5jb25zdCBsbG1zXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgZW52XzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2VudlwiKTtcbmNvbnN0IGNvbm5lY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24uY2pzXCIpO1xuY29uc3QgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9jb21tb24uY2pzXCIpO1xuY29uc3QgZ2VtaW5pX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9nZW1pbmkuY2pzXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4vYXV0aC5janNcIik7XG5jb25zdCBmYWlsZWRfaGFuZGxlcl9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzXCIpO1xuY29uc3QgY2hhdF9tb2RlbHNfanNfMSA9IHJlcXVpcmUoXCIuL2NoYXRfbW9kZWxzLmNqc1wiKTtcbmNsYXNzIEdvb2dsZUxMTUNvbm5lY3Rpb24gZXh0ZW5kcyBjb25uZWN0aW9uX2pzXzEuQWJzdHJhY3RHb29nbGVMTE1Db25uZWN0aW9uIHtcbiAgICBhc3luYyBmb3JtYXRDb250ZW50cyhpbnB1dCwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBhd2FpdCB0aGlzLmFwaS5tZXNzYWdlQ29udGVudFRvUGFydHMoaW5wdXQpO1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICB9XG59XG5jbGFzcyBQcm94eUNoYXRHb29nbGUgZXh0ZW5kcyBjaGF0X21vZGVsc19qc18xLkNoYXRHb29nbGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICB9XG4gICAgYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gZmllbGRzLmNvbm5lY3Rpb24uY2xpZW50O1xuICAgIH1cbn1cbi8qKlxuICogSW50ZWdyYXRpb24gd2l0aCBhbiBMTE0uXG4gKi9cbmNsYXNzIEdvb2dsZUJhc2VMTE0gZXh0ZW5kcyBsbG1zXzEuTExNIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkdvb2dsZUxMTVwiO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dGhPcHRpb25zOiBcIkdPT0dMRV9BVVRIX09QVElPTlNcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKCgwLCBmYWlsZWRfaGFuZGxlcl9qc18xLmVuc3VyZVBhcmFtcykoZmllbGRzKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsRmllbGRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxOYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImdlbWluaS1wcm9cIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiZ2VtaW5pLXByb1wiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wZXJhdHVyZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMC43XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhPdXRwdXRUb2tlbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMjRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcFBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDAuOFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wS1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0b3BTZXF1ZW5jZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYWZldHlTZXR0aW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNhZmV0eUhhbmRsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VNaW1lVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RyZWFtZWRDb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxGaWVsZHMgPSBmaWVsZHM7XG4gICAgICAgICgwLCBjb21tb25fanNfMS5jb3B5QW5kVmFsaWRhdGVNb2RlbFBhcmFtc0ludG8pKGZpZWxkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZXR5SGFuZGxlciA9XG4gICAgICAgICAgICBmaWVsZHM/LnNhZmV0eUhhbmRsZXIgPz8gbmV3IGdlbWluaV9qc18xLkRlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuYnVpbGRDbGllbnQoZmllbGRzKTtcbiAgICAgICAgdGhpcy5idWlsZENvbm5lY3Rpb24oZmllbGRzID8/IHt9LCBjbGllbnQpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleUNsaWVudChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuQXBpS2V5R29vZ2xlQXV0aChhcGlLZXkpO1xuICAgIH1cbiAgICBidWlsZEFwaUtleShmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcz8uYXBpS2V5ID8/ICgwLCBlbnZfMS5nZXRFbnZpcm9ubWVudFZhcmlhYmxlKShcIkdPT0dMRV9BUElfS0VZXCIpO1xuICAgIH1cbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5idWlsZEFwaUtleShmaWVsZHMpO1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEFwaUtleUNsaWVudChhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRDb25uZWN0aW9uKGZpZWxkcywgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBHb29nbGVMTE1Db25uZWN0aW9uKHsgLi4uZmllbGRzLCAuLi50aGlzIH0sIHRoaXMuY2FsbGVyLCBjbGllbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdHJlYW1lZENvbm5lY3Rpb24gPSBuZXcgR29vZ2xlTExNQ29ubmVjdGlvbih7IC4uLmZpZWxkcywgLi4udGhpcyB9LCB0aGlzLmNhbGxlciwgY2xpZW50LCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0IHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnBsYXRmb3JtO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlXG4gICAgX2xsbVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdvb2dsZWxsbVwiO1xuICAgIH1cbiAgICBmb3JtYXRQcm9tcHQocHJvbXB0KSB7XG4gICAgICAgIHJldHVybiBwcm9tcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBzb21lIGdpdmVuIGlucHV0IHN0cmluZyBhbmQgb3B0aW9ucywgcmV0dXJuIGEgc3RyaW5nIG91dHB1dC5cbiAgICAgKlxuICAgICAqIERlc3BpdGUgdGhlIGZhY3QgdGhhdCBgaW52b2tlYCBpcyBvdmVycmlkZGVuIGJlbG93LCB3ZSBzdGlsbCBuZWVkIHRoaXNcbiAgICAgKiBpbiBvcmRlciB0byBoYW5kbGUgcHVibGljIEFQaSBjYWxscyB0byBgZ2VuZXJhdGUoKWAuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwocHJvbXB0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSAoMCwgY29tbW9uX2pzXzEuY29weUFJTW9kZWxQYXJhbXMpKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucmVxdWVzdChwcm9tcHQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLmNvbm5lY3Rpb24uYXBpLnJlc3BvbnNlVG9TdHJpbmcocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLy8gTm9ybWFsbHksIHlvdSBzaG91bGQgbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZCBpbnN0ZWFkIHNob3VsZCBvdmVycmlkZVxuICAgIC8vIF9zdHJlYW1SZXNwb25zZUNodW5rcy4gV2UgYXJlIGRvaW5nIHNvIGhlcmUgdG8gYWxsb3cgZm9yIG11bHRpbW9kYWwgaW5wdXRzIGludG9cbiAgICAvLyB0aGUgTExNLlxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgY2FsbGJhY2sgc2V0dXAgYW5kIHRlYXJkb3duIGNvZGUgaW50byBjb3JlXG4gICAgICAgIGNvbnN0IHByb21wdCA9IGxsbXNfMS5CYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgbWFuYWdlcl8xLkNhbGxiYWNrTWFuYWdlci5jb25maWd1cmUocnVubmFibGVDb25maWcuY2FsbGJhY2tzLCB0aGlzLmNhbGxiYWNrcywgcnVubmFibGVDb25maWcudGFncywgdGhpcy50YWdzLCBydW5uYWJsZUNvbmZpZy5tZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgb3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhjYWxsT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUxMTVN0YXJ0KHRoaXMudG9KU09OKCksIFtwcm9tcHQudG9TdHJpbmcoKV0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleHRyYSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJ1bm5hYmxlQ29uZmlnLnJ1bk5hbWUpO1xuICAgICAgICBsZXQgZ2VuZXJhdGlvbiA9IG5ldyBvdXRwdXRzXzEuR2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm94eUNoYXQgPSB0aGlzLmNyZWF0ZVByb3h5Q2hhdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBwcm94eUNoYXQuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gdGhpcy5jb25uZWN0aW9uLmFwaS5jaHVua1RvU3RyaW5nKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0aW9uQ2h1bmsgPSBuZXcgb3V0cHV0c18xLkdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0cmluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb24gPSBnZW5lcmF0aW9uLmNvbmNhdChnZW5lcmF0aW9uQ2h1bmspO1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihlcnIpKSk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoKHJ1bk1hbmFnZXJzID8/IFtdKS5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICBnZW5lcmF0aW9uczogW1tnZW5lcmF0aW9uXV0sXG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIHByZWRpY3RNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucywgX2NhbGxiYWNrcykge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IG1lc3NhZ2VzWzBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucmVxdWVzdChjb250ZW50LCB7fSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuY29ubmVjdGlvbi5hcGkucmVzcG9uc2VUb0Jhc2VNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIGRldGFpbCB0byBhbGxvdyBHb29nbGUgTExNcyB0byBzdXBwb3J0XG4gICAgICogbXVsdGltb2RhbCBpbnB1dCBieSBkZWxlZ2F0aW5nIHRvIHRoZSBjaGF0IG1vZGVsIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB3aXRoIHNvbWV0aGluZyBsZXNzIGhhY2t5LlxuICAgICAqL1xuICAgIGNyZWF0ZVByb3h5Q2hhdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eUNoYXRHb29nbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5vcmlnaW5hbEZpZWxkcyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRoaXMuY29ubmVjdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGUgbmVlZCB0byBvdmVycmlkZSB0aGlzIC0gd2UgYXJlIGRvaW5nIGl0IHRvXG4gICAgLy8gYWxsb3cgdGhlIExMTSB0byBoYW5kbGUgbXVsdGltb2RhbCB0eXBlcyBvZiBpbnB1dC5cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkT3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZE91dHB1dCArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVkT3V0cHV0O1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlQmFzZUxMTSA9IEdvb2dsZUJhc2VMTE07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/output_parsers.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkdownGoogleSearchOutputParser = exports.SimpleGoogleSearchOutputParser = exports.BaseGoogleSearchOutputParser = void 0;\nconst output_parsers_1 = __webpack_require__(/*! @langchain/core/output_parsers */ \"(rsc)/./node_modules/@langchain/core/output_parsers.cjs\");\nclass BaseGoogleSearchOutputParser extends output_parsers_1.BaseLLMOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"google_common\", \"output_parsers\"]\n        });\n    }\n    generationToGroundingInfo(generation) {\n        if (\"message\" in generation) {\n            const responseMetadata = generation?.message?.response_metadata;\n            const metadata = responseMetadata?.groundingMetadata;\n            const supports = responseMetadata?.groundingSupport ?? metadata?.groundingSupports ?? [];\n            if (metadata) {\n                return {\n                    metadata,\n                    supports,\n                };\n            }\n        }\n        return undefined;\n    }\n    generationsToGroundingInfo(generations) {\n        for (const generation of generations) {\n            const info = this.generationToGroundingInfo(generation);\n            if (info !== undefined) {\n                return info;\n            }\n        }\n        return undefined;\n    }\n    generationToString(generation) {\n        if (\"message\" in generation) {\n            const content = generation?.message?.content;\n            if (typeof content === \"string\") {\n                return content;\n            }\n            else {\n                return content\n                    .map((c) => {\n                    if (c?.type === \"text\") {\n                        return c?.text ?? \"\";\n                    }\n                    else {\n                        return \"\";\n                    }\n                })\n                    .reduce((previousValue, currentValue) => `${previousValue}${currentValue}`);\n            }\n        }\n        return generation.text;\n    }\n    generationsToString(generations) {\n        return generations\n            .map((generation) => this.generationToString(generation))\n            .reduce((previousValue, currentValue) => `${previousValue}${currentValue}`);\n    }\n    annotateSegment(text, grounding, support, index) {\n        const start = support.segment.startIndex ?? 0;\n        const end = support.segment.endIndex;\n        const textBefore = text.substring(0, start);\n        const textSegment = text.substring(start, end);\n        const textAfter = text.substring(end);\n        const textPrefix = this.segmentPrefix(grounding, support, index) ?? \"\";\n        const textSuffix = this.segmentSuffix(grounding, support, index) ?? \"\";\n        return `${textBefore}${textPrefix}${textSegment}${textSuffix}${textAfter}`;\n    }\n    annotateTextSegments(text, grounding) {\n        // Go through each support info in reverse, since the segment info\n        // is sorted, and we won't need to adjust string indexes this way.\n        let ret = text;\n        for (let co = grounding.supports.length - 1; co >= 0; co -= 1) {\n            const support = grounding.supports[co];\n            ret = this.annotateSegment(ret, grounding, support, co);\n        }\n        return ret;\n    }\n    /**\n     * Google requires us to\n     * \"Display the Search Suggestion exactly as provided without any modifications\"\n     * So this will typically be called from the textSuffix() method to get\n     * a string that renders HTML.\n     * See https://ai.google.dev/gemini-api/docs/grounding/search-suggestions\n     * @param grounding\n     */\n    searchSuggestion(grounding) {\n        return grounding?.metadata?.searchEntryPoint?.renderedContent ?? \"\";\n    }\n    annotateText(text, grounding) {\n        const prefix = this.textPrefix(text, grounding) ?? \"\";\n        const suffix = this.textSuffix(text, grounding) ?? \"\";\n        const body = this.annotateTextSegments(text, grounding);\n        return `${prefix}${body}${suffix}`;\n    }\n    async parseResult(generations, _callbacks) {\n        const text = this.generationsToString(generations);\n        const grounding = this.generationsToGroundingInfo(generations);\n        if (!grounding) {\n            return text;\n        }\n        return this.annotateText(text, grounding);\n    }\n}\nexports.BaseGoogleSearchOutputParser = BaseGoogleSearchOutputParser;\nclass SimpleGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n    segmentPrefix(_grounding, _support, _index) {\n        return undefined;\n    }\n    segmentSuffix(_grounding, support, _index) {\n        const indices = support.groundingChunkIndices.map((i) => i + 1);\n        return ` [${indices.join(\", \")}]`;\n    }\n    textPrefix(_text, _grounding) {\n        return \"Google Says:\\n\";\n    }\n    chunkToString(chunk, index) {\n        const info = chunk.retrievedContext ?? chunk.web;\n        return `${index + 1}. ${info.title} - ${info.uri}`;\n    }\n    textSuffix(_text, grounding) {\n        let ret = \"\\n\";\n        const chunks = grounding?.metadata?.groundingChunks ?? [];\n        chunks.forEach((chunk, index) => {\n            ret = `${ret}${this.chunkToString(chunk, index)}\\n`;\n        });\n        return ret;\n    }\n}\nexports.SimpleGoogleSearchOutputParser = SimpleGoogleSearchOutputParser;\nclass MarkdownGoogleSearchOutputParser extends BaseGoogleSearchOutputParser {\n    segmentPrefix(_grounding, _support, _index) {\n        return undefined;\n    }\n    chunkLink(grounding, index) {\n        const chunk = grounding.metadata.groundingChunks[index];\n        const url = chunk.retrievedContext?.uri ?? chunk.web?.uri;\n        const num = index + 1;\n        return `[[${num}](${url})]`;\n    }\n    segmentSuffix(grounding, support, _index) {\n        let ret = \"\";\n        support.groundingChunkIndices.forEach((chunkIndex) => {\n            const link = this.chunkLink(grounding, chunkIndex);\n            ret = `${ret}${link}`;\n        });\n        return ret;\n    }\n    textPrefix(_text, _grounding) {\n        return undefined;\n    }\n    chunkSuffixLink(chunk, index) {\n        const num = index + 1;\n        const info = chunk.retrievedContext ?? chunk.web;\n        const url = info.uri;\n        const site = info.title;\n        return `${num}. [${site}](${url})`;\n    }\n    textSuffix(_text, grounding) {\n        let ret = \"\\n**Search Sources**\\n\";\n        const chunks = grounding.metadata.groundingChunks;\n        chunks.forEach((chunk, index) => {\n            ret = `${ret}${this.chunkSuffixLink(chunk, index)}\\n`;\n        });\n        const search = this.searchSuggestion(grounding);\n        ret = `${ret}\\n${search}`;\n        return ret;\n    }\n}\nexports.MarkdownGoogleSearchOutputParser = MarkdownGoogleSearchOutputParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3Qvb3V0cHV0X3BhcnNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QyxHQUFHLHNDQUFzQyxHQUFHLG9DQUFvQztBQUN4SCx5QkFBeUIsbUJBQU8sQ0FBQywrRkFBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0VBQWdFLGNBQWMsRUFBRSxhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsRUFBRSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsVUFBVTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxJQUFJLFlBQVksSUFBSSxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLGlDQUFpQztBQUM1RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSSxJQUFJLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLEVBQUUsS0FBSztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxFQUFFLG1DQUFtQztBQUM5RCxTQUFTO0FBQ1Q7QUFDQSxpQkFBaUIsSUFBSSxJQUFJLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC9vdXRwdXRfcGFyc2Vycy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1hcmtkb3duR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyID0gZXhwb3J0cy5TaW1wbGVHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgPSBleHBvcnRzLkJhc2VHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBvdXRwdXRfcGFyc2Vyc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRfcGFyc2Vyc1wiKTtcbmNsYXNzIEJhc2VHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgZXh0ZW5kcyBvdXRwdXRfcGFyc2Vyc18xLkJhc2VMTE1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImdvb2dsZV9jb21tb25cIiwgXCJvdXRwdXRfcGFyc2Vyc1wiXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGlvblRvR3JvdW5kaW5nSW5mbyhnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiBnZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZU1ldGFkYXRhID0gZ2VuZXJhdGlvbj8ubWVzc2FnZT8ucmVzcG9uc2VfbWV0YWRhdGE7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3BvbnNlTWV0YWRhdGE/Lmdyb3VuZGluZ01ldGFkYXRhO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydHMgPSByZXNwb25zZU1ldGFkYXRhPy5ncm91bmRpbmdTdXBwb3J0ID8/IG1ldGFkYXRhPy5ncm91bmRpbmdTdXBwb3J0cyA/PyBbXTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdlbmVyYXRpb25zVG9Hcm91bmRpbmdJbmZvKGdlbmVyYXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZ2VuZXJhdGlvbiBvZiBnZW5lcmF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuZ2VuZXJhdGlvblRvR3JvdW5kaW5nSW5mbyhnZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZW5lcmF0aW9uVG9TdHJpbmcoZ2VuZXJhdGlvbikge1xuICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGdlbmVyYXRpb24/Lm1lc3NhZ2U/LmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGM/LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYz8udGV4dCA/PyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IGAke3ByZXZpb3VzVmFsdWV9JHtjdXJyZW50VmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRpb24udGV4dDtcbiAgICB9XG4gICAgZ2VuZXJhdGlvbnNUb1N0cmluZyhnZW5lcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGlvbnNcbiAgICAgICAgICAgIC5tYXAoKGdlbmVyYXRpb24pID0+IHRoaXMuZ2VuZXJhdGlvblRvU3RyaW5nKGdlbmVyYXRpb24pKVxuICAgICAgICAgICAgLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiBgJHtwcmV2aW91c1ZhbHVlfSR7Y3VycmVudFZhbHVlfWApO1xuICAgIH1cbiAgICBhbm5vdGF0ZVNlZ21lbnQodGV4dCwgZ3JvdW5kaW5nLCBzdXBwb3J0LCBpbmRleCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHN1cHBvcnQuc2VnbWVudC5zdGFydEluZGV4ID8/IDA7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN1cHBvcnQuc2VnbWVudC5lbmRJbmRleDtcbiAgICAgICAgY29uc3QgdGV4dEJlZm9yZSA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgdGV4dFNlZ21lbnQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3QgdGV4dEFmdGVyID0gdGV4dC5zdWJzdHJpbmcoZW5kKTtcbiAgICAgICAgY29uc3QgdGV4dFByZWZpeCA9IHRoaXMuc2VnbWVudFByZWZpeChncm91bmRpbmcsIHN1cHBvcnQsIGluZGV4KSA/PyBcIlwiO1xuICAgICAgICBjb25zdCB0ZXh0U3VmZml4ID0gdGhpcy5zZWdtZW50U3VmZml4KGdyb3VuZGluZywgc3VwcG9ydCwgaW5kZXgpID8/IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHt0ZXh0QmVmb3JlfSR7dGV4dFByZWZpeH0ke3RleHRTZWdtZW50fSR7dGV4dFN1ZmZpeH0ke3RleHRBZnRlcn1gO1xuICAgIH1cbiAgICBhbm5vdGF0ZVRleHRTZWdtZW50cyh0ZXh0LCBncm91bmRpbmcpIHtcbiAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIHN1cHBvcnQgaW5mbyBpbiByZXZlcnNlLCBzaW5jZSB0aGUgc2VnbWVudCBpbmZvXG4gICAgICAgIC8vIGlzIHNvcnRlZCwgYW5kIHdlIHdvbid0IG5lZWQgdG8gYWRqdXN0IHN0cmluZyBpbmRleGVzIHRoaXMgd2F5LlxuICAgICAgICBsZXQgcmV0ID0gdGV4dDtcbiAgICAgICAgZm9yIChsZXQgY28gPSBncm91bmRpbmcuc3VwcG9ydHMubGVuZ3RoIC0gMTsgY28gPj0gMDsgY28gLT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydCA9IGdyb3VuZGluZy5zdXBwb3J0c1tjb107XG4gICAgICAgICAgICByZXQgPSB0aGlzLmFubm90YXRlU2VnbWVudChyZXQsIGdyb3VuZGluZywgc3VwcG9ydCwgY28pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdvb2dsZSByZXF1aXJlcyB1cyB0b1xuICAgICAqIFwiRGlzcGxheSB0aGUgU2VhcmNoIFN1Z2dlc3Rpb24gZXhhY3RseSBhcyBwcm92aWRlZCB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zXCJcbiAgICAgKiBTbyB0aGlzIHdpbGwgdHlwaWNhbGx5IGJlIGNhbGxlZCBmcm9tIHRoZSB0ZXh0U3VmZml4KCkgbWV0aG9kIHRvIGdldFxuICAgICAqIGEgc3RyaW5nIHRoYXQgcmVuZGVycyBIVE1MLlxuICAgICAqIFNlZSBodHRwczovL2FpLmdvb2dsZS5kZXYvZ2VtaW5pLWFwaS9kb2NzL2dyb3VuZGluZy9zZWFyY2gtc3VnZ2VzdGlvbnNcbiAgICAgKiBAcGFyYW0gZ3JvdW5kaW5nXG4gICAgICovXG4gICAgc2VhcmNoU3VnZ2VzdGlvbihncm91bmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VuZGluZz8ubWV0YWRhdGE/LnNlYXJjaEVudHJ5UG9pbnQ/LnJlbmRlcmVkQ29udGVudCA/PyBcIlwiO1xuICAgIH1cbiAgICBhbm5vdGF0ZVRleHQodGV4dCwgZ3JvdW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMudGV4dFByZWZpeCh0ZXh0LCBncm91bmRpbmcpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMudGV4dFN1ZmZpeCh0ZXh0LCBncm91bmRpbmcpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmFubm90YXRlVGV4dFNlZ21lbnRzKHRleHQsIGdyb3VuZGluZyk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtib2R5fSR7c3VmZml4fWA7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBfY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmdlbmVyYXRpb25zVG9TdHJpbmcoZ2VuZXJhdGlvbnMpO1xuICAgICAgICBjb25zdCBncm91bmRpbmcgPSB0aGlzLmdlbmVyYXRpb25zVG9Hcm91bmRpbmdJbmZvKGdlbmVyYXRpb25zKTtcbiAgICAgICAgaWYgKCFncm91bmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFubm90YXRlVGV4dCh0ZXh0LCBncm91bmRpbmcpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciA9IEJhc2VHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXI7XG5jbGFzcyBTaW1wbGVHb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyIHtcbiAgICBzZWdtZW50UHJlZml4KF9ncm91bmRpbmcsIF9zdXBwb3J0LCBfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2VnbWVudFN1ZmZpeChfZ3JvdW5kaW5nLCBzdXBwb3J0LCBfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHN1cHBvcnQuZ3JvdW5kaW5nQ2h1bmtJbmRpY2VzLm1hcCgoaSkgPT4gaSArIDEpO1xuICAgICAgICByZXR1cm4gYCBbJHtpbmRpY2VzLmpvaW4oXCIsIFwiKX1dYDtcbiAgICB9XG4gICAgdGV4dFByZWZpeChfdGV4dCwgX2dyb3VuZGluZykge1xuICAgICAgICByZXR1cm4gXCJHb29nbGUgU2F5czpcXG5cIjtcbiAgICB9XG4gICAgY2h1bmtUb1N0cmluZyhjaHVuaywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IGNodW5rLnJldHJpZXZlZENvbnRleHQgPz8gY2h1bmsud2ViO1xuICAgICAgICByZXR1cm4gYCR7aW5kZXggKyAxfS4gJHtpbmZvLnRpdGxlfSAtICR7aW5mby51cml9YDtcbiAgICB9XG4gICAgdGV4dFN1ZmZpeChfdGV4dCwgZ3JvdW5kaW5nKSB7XG4gICAgICAgIGxldCByZXQgPSBcIlxcblwiO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBncm91bmRpbmc/Lm1ldGFkYXRhPy5ncm91bmRpbmdDaHVua3MgPz8gW107XG4gICAgICAgIGNodW5rcy5mb3JFYWNoKChjaHVuaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldCA9IGAke3JldH0ke3RoaXMuY2h1bmtUb1N0cmluZyhjaHVuaywgaW5kZXgpfVxcbmA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyID0gU2ltcGxlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyO1xuY2xhc3MgTWFya2Rvd25Hb29nbGVTZWFyY2hPdXRwdXRQYXJzZXIgZXh0ZW5kcyBCYXNlR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyIHtcbiAgICBzZWdtZW50UHJlZml4KF9ncm91bmRpbmcsIF9zdXBwb3J0LCBfaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2h1bmtMaW5rKGdyb3VuZGluZywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBncm91bmRpbmcubWV0YWRhdGEuZ3JvdW5kaW5nQ2h1bmtzW2luZGV4XTtcbiAgICAgICAgY29uc3QgdXJsID0gY2h1bmsucmV0cmlldmVkQ29udGV4dD8udXJpID8/IGNodW5rLndlYj8udXJpO1xuICAgICAgICBjb25zdCBudW0gPSBpbmRleCArIDE7XG4gICAgICAgIHJldHVybiBgW1ske251bX1dKCR7dXJsfSldYDtcbiAgICB9XG4gICAgc2VnbWVudFN1ZmZpeChncm91bmRpbmcsIHN1cHBvcnQsIF9pbmRleCkge1xuICAgICAgICBsZXQgcmV0ID0gXCJcIjtcbiAgICAgICAgc3VwcG9ydC5ncm91bmRpbmdDaHVua0luZGljZXMuZm9yRWFjaCgoY2h1bmtJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMuY2h1bmtMaW5rKGdyb3VuZGluZywgY2h1bmtJbmRleCk7XG4gICAgICAgICAgICByZXQgPSBgJHtyZXR9JHtsaW5rfWA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB0ZXh0UHJlZml4KF90ZXh0LCBfZ3JvdW5kaW5nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNodW5rU3VmZml4TGluayhjaHVuaywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbnVtID0gaW5kZXggKyAxO1xuICAgICAgICBjb25zdCBpbmZvID0gY2h1bmsucmV0cmlldmVkQ29udGV4dCA/PyBjaHVuay53ZWI7XG4gICAgICAgIGNvbnN0IHVybCA9IGluZm8udXJpO1xuICAgICAgICBjb25zdCBzaXRlID0gaW5mby50aXRsZTtcbiAgICAgICAgcmV0dXJuIGAke251bX0uIFske3NpdGV9XSgke3VybH0pYDtcbiAgICB9XG4gICAgdGV4dFN1ZmZpeChfdGV4dCwgZ3JvdW5kaW5nKSB7XG4gICAgICAgIGxldCByZXQgPSBcIlxcbioqU2VhcmNoIFNvdXJjZXMqKlxcblwiO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBncm91bmRpbmcubWV0YWRhdGEuZ3JvdW5kaW5nQ2h1bmtzO1xuICAgICAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmssIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXQgPSBgJHtyZXR9JHt0aGlzLmNodW5rU3VmZml4TGluayhjaHVuaywgaW5kZXgpfVxcbmA7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSB0aGlzLnNlYXJjaFN1Z2dlc3Rpb24oZ3JvdW5kaW5nKTtcbiAgICAgICAgcmV0ID0gYCR7cmV0fVxcbiR7c2VhcmNofWA7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZXhwb3J0cy5NYXJrZG93bkdvb2dsZVNlYXJjaE91dHB1dFBhcnNlciA9IE1hcmtkb3duR29vZ2xlU2VhcmNoT3V0cHV0UGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/output_parsers.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/types-anthropic.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMtYW50aHJvcGljLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMtYW50aHJvcGljLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/types.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/types.cjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeminiToolAttributes = exports.GeminiSearchToolAttributes = exports.GoogleAISafetyMethod = exports.GoogleAISafetyThreshold = exports.GoogleAISafetyCategory = void 0;\n__exportStar(__webpack_require__(/*! ./types-anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types-anthropic.cjs\"), exports);\nexports.GoogleAISafetyCategory = {\n    Harassment: \"HARM_CATEGORY_HARASSMENT\",\n    HARASSMENT: \"HARM_CATEGORY_HARASSMENT\",\n    HARM_CATEGORY_HARASSMENT: \"HARM_CATEGORY_HARASSMENT\",\n    HateSpeech: \"HARM_CATEGORY_HATE_SPEECH\",\n    HATE_SPEECH: \"HARM_CATEGORY_HATE_SPEECH\",\n    HARM_CATEGORY_HATE_SPEECH: \"HARM_CATEGORY_HATE_SPEECH\",\n    SexuallyExplicit: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    SEXUALLY_EXPLICIT: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    HARM_CATEGORY_SEXUALLY_EXPLICIT: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    Dangerous: \"HARM_CATEGORY_DANGEROUS\",\n    DANGEROUS: \"HARM_CATEGORY_DANGEROUS\",\n    HARM_CATEGORY_DANGEROUS: \"HARM_CATEGORY_DANGEROUS\",\n    CivicIntegrity: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n    CIVIC_INTEGRITY: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n    HARM_CATEGORY_CIVIC_INTEGRITY: \"HARM_CATEGORY_CIVIC_INTEGRITY\",\n};\nexports.GoogleAISafetyThreshold = {\n    None: \"BLOCK_NONE\",\n    NONE: \"BLOCK_NONE\",\n    BLOCK_NONE: \"BLOCK_NONE\",\n    Few: \"BLOCK_ONLY_HIGH\",\n    FEW: \"BLOCK_ONLY_HIGH\",\n    BLOCK_ONLY_HIGH: \"BLOCK_ONLY_HIGH\",\n    Some: \"BLOCK_MEDIUM_AND_ABOVE\",\n    SOME: \"BLOCK_MEDIUM_AND_ABOVE\",\n    BLOCK_MEDIUM_AND_ABOVE: \"BLOCK_MEDIUM_AND_ABOVE\",\n    Most: \"BLOCK_LOW_AND_ABOVE\",\n    MOST: \"BLOCK_LOW_AND_ABOVE\",\n    BLOCK_LOW_AND_ABOVE: \"BLOCK_LOW_AND_ABOVE\",\n    Off: \"OFF\",\n    OFF: \"OFF\",\n    BLOCK_OFF: \"OFF\",\n};\nexports.GoogleAISafetyMethod = {\n    Severity: \"SEVERITY\",\n    Probability: \"PROBABILITY\",\n};\nexports.GeminiSearchToolAttributes = [\n    \"googleSearchRetrieval\",\n    \"googleSearch\",\n];\nexports.GeminiToolAttributes = [\n    \"functionDeclaration\",\n    \"retrieval\",\n    ...exports.GeminiSearchToolAttributes,\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLDhCQUE4QjtBQUNuSyxhQUFhLG1CQUFPLENBQUMscUdBQXVCO0FBQzVDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC90eXBlcy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2VtaW5pVG9vbEF0dHJpYnV0ZXMgPSBleHBvcnRzLkdlbWluaVNlYXJjaFRvb2xBdHRyaWJ1dGVzID0gZXhwb3J0cy5Hb29nbGVBSVNhZmV0eU1ldGhvZCA9IGV4cG9ydHMuR29vZ2xlQUlTYWZldHlUaHJlc2hvbGQgPSBleHBvcnRzLkdvb2dsZUFJU2FmZXR5Q2F0ZWdvcnkgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMtYW50aHJvcGljLmNqc1wiKSwgZXhwb3J0cyk7XG5leHBvcnRzLkdvb2dsZUFJU2FmZXR5Q2F0ZWdvcnkgPSB7XG4gICAgSGFyYXNzbWVudDogXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICBIQVJBU1NNRU5UOiBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiLFxuICAgIEhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVDogXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIixcbiAgICBIYXRlU3BlZWNoOiBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIixcbiAgICBIQVRFX1NQRUVDSDogXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSDogXCJIQVJNX0NBVEVHT1JZX0hBVEVfU1BFRUNIXCIsXG4gICAgU2V4dWFsbHlFeHBsaWNpdDogXCJIQVJNX0NBVEVHT1JZX1NFWFVBTExZX0VYUExJQ0lUXCIsXG4gICAgU0VYVUFMTFlfRVhQTElDSVQ6IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiLFxuICAgIEhBUk1fQ0FURUdPUllfU0VYVUFMTFlfRVhQTElDSVQ6IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiLFxuICAgIERhbmdlcm91czogXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU1wiLFxuICAgIERBTkdFUk9VUzogXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU1wiLFxuICAgIEhBUk1fQ0FURUdPUllfREFOR0VST1VTOiBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTXCIsXG4gICAgQ2l2aWNJbnRlZ3JpdHk6IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIixcbiAgICBDSVZJQ19JTlRFR1JJVFk6IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIixcbiAgICBIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWTogXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiLFxufTtcbmV4cG9ydHMuR29vZ2xlQUlTYWZldHlUaHJlc2hvbGQgPSB7XG4gICAgTm9uZTogXCJCTE9DS19OT05FXCIsXG4gICAgTk9ORTogXCJCTE9DS19OT05FXCIsXG4gICAgQkxPQ0tfTk9ORTogXCJCTE9DS19OT05FXCIsXG4gICAgRmV3OiBcIkJMT0NLX09OTFlfSElHSFwiLFxuICAgIEZFVzogXCJCTE9DS19PTkxZX0hJR0hcIixcbiAgICBCTE9DS19PTkxZX0hJR0g6IFwiQkxPQ0tfT05MWV9ISUdIXCIsXG4gICAgU29tZTogXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgU09NRTogXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgQkxPQ0tfTUVESVVNX0FORF9BQk9WRTogXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCIsXG4gICAgTW9zdDogXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgTU9TVDogXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgQkxPQ0tfTE9XX0FORF9BQk9WRTogXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCIsXG4gICAgT2ZmOiBcIk9GRlwiLFxuICAgIE9GRjogXCJPRkZcIixcbiAgICBCTE9DS19PRkY6IFwiT0ZGXCIsXG59O1xuZXhwb3J0cy5Hb29nbGVBSVNhZmV0eU1ldGhvZCA9IHtcbiAgICBTZXZlcml0eTogXCJTRVZFUklUWVwiLFxuICAgIFByb2JhYmlsaXR5OiBcIlBST0JBQklMSVRZXCIsXG59O1xuZXhwb3J0cy5HZW1pbmlTZWFyY2hUb29sQXR0cmlidXRlcyA9IFtcbiAgICBcImdvb2dsZVNlYXJjaFJldHJpZXZhbFwiLFxuICAgIFwiZ29vZ2xlU2VhcmNoXCIsXG5dO1xuZXhwb3J0cy5HZW1pbmlUb29sQXR0cmlidXRlcyA9IFtcbiAgICBcImZ1bmN0aW9uRGVjbGFyYXRpb25cIixcbiAgICBcInJldHJpZXZhbFwiLFxuICAgIC4uLmV4cG9ydHMuR2VtaW5pU2VhcmNoVG9vbEF0dHJpYnV0ZXMsXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/anthropic.cjs ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isModelClaude = exports.validateClaudeParams = exports.getAnthropicAPI = void 0;\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nfunction getAnthropicAPI(config) {\n    function partToString(part) {\n        return \"text\" in part ? part.text : \"\";\n    }\n    function messageToString(message) {\n        const content = message?.content ?? [];\n        const ret = content.reduce((acc, part) => {\n            const str = partToString(part);\n            return acc + str;\n        }, \"\");\n        return ret;\n    }\n    function responseToString(response) {\n        const data = response.data;\n        switch (data?.type) {\n            case \"message\":\n                return messageToString(data);\n            default:\n                throw Error(`Unknown type: ${data?.type}`);\n        }\n    }\n    /**\n     * Normalize the AIMessageChunk.\n     * If the fields are just a string - use that as content.\n     * If the content is an array of just text fields, turn them into a string.\n     * @param fields\n     */\n    function newAIMessageChunk(fields) {\n        if (typeof fields === \"string\") {\n            return new messages_1.AIMessageChunk(fields);\n        }\n        const ret = {\n            ...fields,\n        };\n        if (Array.isArray(fields?.content)) {\n            let str = \"\";\n            fields.content.forEach((val) => {\n                if (str !== undefined && val.type === \"text\") {\n                    str = `${str}${val.text}`;\n                }\n                else {\n                    str = undefined;\n                }\n            });\n            if (str) {\n                ret.content = str;\n            }\n        }\n        return new messages_1.AIMessageChunk(ret);\n    }\n    function textContentToMessageFields(textContent) {\n        return {\n            content: [textContent],\n        };\n    }\n    function toolUseContentToMessageFields(toolUseContent) {\n        const tool = {\n            id: toolUseContent.id,\n            name: toolUseContent.name,\n            type: \"tool_call\",\n            args: toolUseContent.input,\n        };\n        return {\n            content: [],\n            tool_calls: [tool],\n        };\n    }\n    function anthropicContentToMessageFields(anthropicContent) {\n        const type = anthropicContent?.type;\n        switch (type) {\n            case \"text\":\n                return textContentToMessageFields(anthropicContent);\n            case \"tool_use\":\n                return toolUseContentToMessageFields(anthropicContent);\n            default:\n                return undefined;\n        }\n    }\n    function contentToMessage(anthropicContent) {\n        const complexContent = [];\n        const toolCalls = [];\n        anthropicContent.forEach((ac) => {\n            const messageFields = anthropicContentToMessageFields(ac);\n            if (messageFields?.content) {\n                complexContent.push(...messageFields.content);\n            }\n            if (messageFields?.tool_calls) {\n                toolCalls.push(...messageFields.tool_calls);\n            }\n        });\n        const ret = {\n            content: complexContent,\n            tool_calls: toolCalls,\n        };\n        return newAIMessageChunk(ret);\n    }\n    function messageToGenerationInfo(message) {\n        const usage = message?.usage;\n        const usageMetadata = {\n            input_tokens: usage?.input_tokens ?? 0,\n            output_tokens: usage?.output_tokens ?? 0,\n            total_tokens: (usage?.input_tokens ?? 0) + (usage?.output_tokens ?? 0),\n        };\n        return {\n            usage_metadata: usageMetadata,\n            finish_reason: message.stop_reason,\n        };\n    }\n    function messageToChatGeneration(responseMessage) {\n        const content = responseMessage?.content ?? [];\n        const text = messageToString(responseMessage);\n        const message = contentToMessage(content);\n        const generationInfo = messageToGenerationInfo(responseMessage);\n        return new outputs_1.ChatGenerationChunk({\n            text,\n            message,\n            generationInfo,\n        });\n    }\n    function messageStartToChatGeneration(event) {\n        const responseMessage = event.message;\n        return messageToChatGeneration(responseMessage);\n    }\n    function messageDeltaToChatGeneration(event) {\n        const responseMessage = event.delta;\n        return messageToChatGeneration(responseMessage);\n    }\n    function contentBlockStartTextToChatGeneration(event) {\n        const content = event.content_block;\n        const message = contentToMessage([content]);\n        if (!message) {\n            return null;\n        }\n        const text = \"text\" in content ? content.text : \"\";\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockStartToolUseToChatGeneration(event) {\n        const contentBlock = event.content_block;\n        const text = \"\";\n        const toolChunk = {\n            type: \"tool_call_chunk\",\n            index: event.index,\n            name: contentBlock.name,\n            id: contentBlock.id,\n        };\n        if (typeof contentBlock.input === \"object\" &&\n            Object.keys(contentBlock.input).length > 0) {\n            toolChunk.args = JSON.stringify(contentBlock.input);\n        }\n        const toolChunks = [toolChunk];\n        const content = [\n            {\n                index: event.index,\n                ...contentBlock,\n            },\n        ];\n        const messageFields = {\n            content,\n            tool_call_chunks: toolChunks,\n        };\n        const message = newAIMessageChunk(messageFields);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockStartToChatGeneration(event) {\n        switch (event.content_block.type) {\n            case \"text\":\n                return contentBlockStartTextToChatGeneration(event);\n            case \"tool_use\":\n                return contentBlockStartToolUseToChatGeneration(event);\n            default:\n                console.warn(`Unexpected start content_block type: ${JSON.stringify(event)}`);\n                return null;\n        }\n    }\n    function contentBlockDeltaTextToChatGeneration(event) {\n        const delta = event.delta;\n        const text = delta?.text;\n        const message = newAIMessageChunk(text);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockDeltaInputJsonDeltaToChatGeneration(event) {\n        const delta = event.delta;\n        const text = \"\";\n        const toolChunks = [\n            {\n                index: event.index,\n                args: delta.partial_json,\n            },\n        ];\n        const content = [\n            {\n                index: event.index,\n                ...delta,\n            },\n        ];\n        const messageFields = {\n            content,\n            tool_call_chunks: toolChunks,\n        };\n        const message = newAIMessageChunk(messageFields);\n        return new outputs_1.ChatGenerationChunk({\n            message,\n            text,\n        });\n    }\n    function contentBlockDeltaToChatGeneration(event) {\n        switch (event.delta.type) {\n            case \"text_delta\":\n                return contentBlockDeltaTextToChatGeneration(event);\n            case \"input_json_delta\":\n                return contentBlockDeltaInputJsonDeltaToChatGeneration(event);\n            default:\n                console.warn(`Unexpected delta content_block type: ${JSON.stringify(event)}`);\n                return null;\n        }\n    }\n    function responseToChatGeneration(response) {\n        const data = response.data;\n        switch (data.type) {\n            case \"message\":\n                return messageToChatGeneration(data);\n            case \"message_start\":\n                return messageStartToChatGeneration(data);\n            case \"message_delta\":\n                return messageDeltaToChatGeneration(data);\n            case \"content_block_start\":\n                return contentBlockStartToChatGeneration(data);\n            case \"content_block_delta\":\n                return contentBlockDeltaToChatGeneration(data);\n            case \"ping\":\n            case \"message_stop\":\n            case \"content_block_stop\":\n                // These are ignorable\n                return null;\n            case \"error\":\n                throw new Error(`Error while streaming results: ${JSON.stringify(data)}`);\n            default:\n                // We don't know what type this is, but Anthropic may have added\n                // new ones without telling us. Don't error, but don't use them.\n                console.warn(\"Unknown data for responseToChatGeneration\", data);\n                // throw new Error(`Unknown response type: ${data.type}`);\n                return null;\n        }\n    }\n    function chunkToString(chunk) {\n        if (chunk === null) {\n            return \"\";\n        }\n        else if (typeof chunk.content === \"string\") {\n            return chunk.content;\n        }\n        else if (chunk.content.length === 0) {\n            return \"\";\n        }\n        else if (chunk.content[0].type === \"text\") {\n            return chunk.content[0].text;\n        }\n        else {\n            throw new Error(`Unexpected chunk: ${chunk}`);\n        }\n    }\n    function responseToBaseMessage(response) {\n        const data = response.data;\n        const content = data?.content ?? [];\n        return contentToMessage(content);\n    }\n    function responseToChatResult(response) {\n        const message = response.data;\n        const generations = [];\n        const gen = responseToChatGeneration(response);\n        if (gen) {\n            generations.push(gen);\n        }\n        const llmOutput = messageToGenerationInfo(message);\n        return {\n            generations,\n            llmOutput,\n        };\n    }\n    function formatAnthropicVersion() {\n        return config?.version ?? \"vertex-2023-10-16\";\n    }\n    function textContentToAnthropicContent(content) {\n        return content;\n    }\n    function extractMimeType(str) {\n        if (str.startsWith(\"data:\")) {\n            return {\n                media_type: str.split(\":\")[1].split(\";\")[0],\n                data: str.split(\",\")[1],\n            };\n        }\n        return null;\n    }\n    function imageContentToAnthropicContent(content) {\n        const dataUrl = content.image_url;\n        const url = typeof dataUrl === \"string\" ? dataUrl : dataUrl?.url;\n        const urlInfo = extractMimeType(url);\n        if (!urlInfo) {\n            return undefined;\n        }\n        return {\n            type: \"image\",\n            source: {\n                type: \"base64\",\n                ...urlInfo,\n            },\n        };\n    }\n    function contentComplexToAnthropicContent(content) {\n        const type = content?.type;\n        switch (type) {\n            case \"text\":\n                return textContentToAnthropicContent(content);\n            case \"image_url\":\n                return imageContentToAnthropicContent(content);\n            default:\n                console.warn(`Unexpected content type: ${type}`);\n                return undefined;\n        }\n    }\n    function contentToAnthropicContent(content) {\n        const ret = [];\n        const ca = typeof content === \"string\" ? [{ type: \"text\", text: content }] : content;\n        ca.forEach((complex) => {\n            const ac = contentComplexToAnthropicContent(complex);\n            if (ac) {\n                ret.push(ac);\n            }\n        });\n        return ret;\n    }\n    function baseRoleToAnthropicMessage(base, role) {\n        const content = contentToAnthropicContent(base.content);\n        return {\n            role,\n            content,\n        };\n    }\n    function toolMessageToAnthropicMessage(base) {\n        const role = \"user\";\n        const toolUseId = base.tool_call_id;\n        const toolContent = contentToAnthropicContent(base.content);\n        const content = [\n            {\n                type: \"tool_result\",\n                tool_use_id: toolUseId,\n                content: toolContent,\n            },\n        ];\n        return {\n            role,\n            content,\n        };\n    }\n    function baseToAnthropicMessage(base) {\n        const type = base._getType();\n        switch (type) {\n            case \"human\":\n                return baseRoleToAnthropicMessage(base, \"user\");\n            case \"ai\":\n                return baseRoleToAnthropicMessage(base, \"assistant\");\n            case \"tool\":\n                return toolMessageToAnthropicMessage(base);\n            default:\n                return undefined;\n        }\n    }\n    function formatMessages(input) {\n        const ret = [];\n        input.forEach((baseMessage) => {\n            const anthropicMessage = baseToAnthropicMessage(baseMessage);\n            if (anthropicMessage) {\n                ret.push(anthropicMessage);\n            }\n        });\n        return ret;\n    }\n    function formatSettings(parameters) {\n        const ret = {\n            stream: parameters?.streaming ?? false,\n            max_tokens: parameters?.maxOutputTokens ?? 8192,\n        };\n        if (parameters.topP) {\n            ret.top_p = parameters.topP;\n        }\n        if (parameters.topK) {\n            ret.top_k = parameters.topK;\n        }\n        if (parameters.temperature) {\n            ret.temperature = parameters.temperature;\n        }\n        if (parameters.stopSequences) {\n            ret.stop_sequences = parameters.stopSequences;\n        }\n        return ret;\n    }\n    function contentComplexArrayToText(contentArray) {\n        let ret = \"\";\n        contentArray.forEach((content) => {\n            const contentType = content?.type;\n            if (contentType === \"text\") {\n                const textContent = content;\n                ret = `${ret}\\n${textContent.text}`;\n            }\n        });\n        return ret;\n    }\n    function formatSystem(input) {\n        let ret = \"\";\n        input.forEach((message) => {\n            if (message._getType() === \"system\") {\n                const content = message?.content;\n                const contentString = typeof content === \"string\"\n                    ? content\n                    : contentComplexArrayToText(content);\n                ret = `${ret}\\n${contentString}`;\n            }\n        });\n        return ret;\n    }\n    function formatGeminiTool(tool) {\n        if (Object.hasOwn(tool, \"functionDeclarations\")) {\n            const funcs = tool?.functionDeclarations ?? [];\n            return funcs.map((func) => {\n                const inputSchema = func.parameters;\n                return {\n                    // type: \"tool\",  // This may only be valid for models 20241022+\n                    name: func.name,\n                    description: func.description,\n                    input_schema: inputSchema,\n                };\n            });\n        }\n        else {\n            console.warn(`Unable to format GeminiTool: ${JSON.stringify(tool, null, 1)}`);\n            return [];\n        }\n    }\n    function formatTool(tool) {\n        if (Object.hasOwn(tool, \"name\")) {\n            return [tool];\n        }\n        else {\n            return formatGeminiTool(tool);\n        }\n    }\n    function formatTools(parameters) {\n        const tools = parameters?.tools ?? [];\n        const ret = [];\n        tools.forEach((tool) => {\n            const anthropicTools = formatTool(tool);\n            anthropicTools.forEach((anthropicTool) => {\n                if (anthropicTool) {\n                    ret.push(anthropicTool);\n                }\n            });\n        });\n        return ret;\n    }\n    function formatToolChoice(parameters) {\n        const choice = parameters?.tool_choice;\n        if (!choice) {\n            return undefined;\n        }\n        else if (typeof choice === \"object\") {\n            return choice;\n        }\n        else {\n            switch (choice) {\n                case \"any\":\n                case \"auto\":\n                    return {\n                        type: choice,\n                    };\n                case \"none\":\n                    return undefined;\n                default:\n                    return {\n                        type: \"tool\",\n                        name: choice,\n                    };\n            }\n        }\n    }\n    async function formatData(input, parameters) {\n        const typedInput = input;\n        const anthropicVersion = formatAnthropicVersion();\n        const messages = formatMessages(typedInput);\n        const settings = formatSettings(parameters);\n        const system = formatSystem(typedInput);\n        const tools = formatTools(parameters);\n        const toolChoice = formatToolChoice(parameters);\n        const ret = {\n            anthropic_version: anthropicVersion,\n            messages,\n            ...settings,\n        };\n        if (tools && tools.length && parameters?.tool_choice !== \"none\") {\n            ret.tools = tools;\n        }\n        if (toolChoice) {\n            ret.tool_choice = toolChoice;\n        }\n        if (system?.length) {\n            ret.system = system;\n        }\n        return ret;\n    }\n    return {\n        responseToString,\n        responseToChatGeneration,\n        chunkToString,\n        responseToBaseMessage,\n        responseToChatResult,\n        formatData,\n    };\n}\nexports.getAnthropicAPI = getAnthropicAPI;\nfunction validateClaudeParams(_params) {\n    // FIXME - validate the parameters\n}\nexports.validateClaudeParams = validateClaudeParams;\nfunction isModelClaude(modelName) {\n    return modelName.toLowerCase().startsWith(\"claude\");\n}\nexports.isModelClaude = isModelClaude;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvYW50aHJvcGljLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUI7QUFDOUUsa0JBQWtCLG1CQUFPLENBQUMsaUZBQXlCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksRUFBRSxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxzQkFBc0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNkJBQTZCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksSUFBSSxpQkFBaUI7QUFDbEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSSxJQUFJLGNBQWM7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlEQUF5RCw4QkFBOEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL2FudGhyb3BpYy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTW9kZWxDbGF1ZGUgPSBleHBvcnRzLnZhbGlkYXRlQ2xhdWRlUGFyYW1zID0gZXhwb3J0cy5nZXRBbnRocm9waWNBUEkgPSB2b2lkIDA7XG5jb25zdCBvdXRwdXRzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL291dHB1dHNcIik7XG5jb25zdCBtZXNzYWdlc18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiKTtcbmZ1bmN0aW9uIGdldEFudGhyb3BpY0FQSShjb25maWcpIHtcbiAgICBmdW5jdGlvbiBwYXJ0VG9TdHJpbmcocGFydCkge1xuICAgICAgICByZXR1cm4gXCJ0ZXh0XCIgaW4gcGFydCA/IHBhcnQudGV4dCA6IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VUb1N0cmluZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBtZXNzYWdlPy5jb250ZW50ID8/IFtdO1xuICAgICAgICBjb25zdCByZXQgPSBjb250ZW50LnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBwYXJ0VG9TdHJpbmcocGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgc3RyO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb1N0cmluZyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgc3dpdGNoIChkYXRhPy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlVG9TdHJpbmcoZGF0YSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIHR5cGU6ICR7ZGF0YT8udHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIEFJTWVzc2FnZUNodW5rLlxuICAgICAqIElmIHRoZSBmaWVsZHMgYXJlIGp1c3QgYSBzdHJpbmcgLSB1c2UgdGhhdCBhcyBjb250ZW50LlxuICAgICAqIElmIHRoZSBjb250ZW50IGlzIGFuIGFycmF5IG9mIGp1c3QgdGV4dCBmaWVsZHMsIHR1cm4gdGhlbSBpbnRvIGEgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZXdBSU1lc3NhZ2VDaHVuayhmaWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5BSU1lc3NhZ2VDaHVuayhmaWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzPy5jb250ZW50KSkge1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgICAgICBmaWVsZHMuY29udGVudC5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyICE9PSB1bmRlZmluZWQgJiYgdmFsLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGAke3N0cn0ke3ZhbC50ZXh0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0LmNvbnRlbnQgPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHJldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRleHRDb250ZW50VG9NZXNzYWdlRmllbGRzKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiBbdGV4dENvbnRlbnRdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b29sVXNlQ29udGVudFRvTWVzc2FnZUZpZWxkcyh0b29sVXNlQ29udGVudCkge1xuICAgICAgICBjb25zdCB0b29sID0ge1xuICAgICAgICAgICAgaWQ6IHRvb2xVc2VDb250ZW50LmlkLFxuICAgICAgICAgICAgbmFtZTogdG9vbFVzZUNvbnRlbnQubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICAgICAgICBhcmdzOiB0b29sVXNlQ29udGVudC5pbnB1dCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtdLFxuICAgICAgICAgICAgdG9vbF9jYWxsczogW3Rvb2xdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbnRocm9waWNDb250ZW50VG9NZXNzYWdlRmllbGRzKGFudGhyb3BpY0NvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGFudGhyb3BpY0NvbnRlbnQ/LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dENvbnRlbnRUb01lc3NhZ2VGaWVsZHMoYW50aHJvcGljQ29udGVudCk7XG4gICAgICAgICAgICBjYXNlIFwidG9vbF91c2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFVzZUNvbnRlbnRUb01lc3NhZ2VGaWVsZHMoYW50aHJvcGljQ29udGVudCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudFRvTWVzc2FnZShhbnRocm9waWNDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXhDb250ZW50ID0gW107XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgICAgICBhbnRocm9waWNDb250ZW50LmZvckVhY2goKGFjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlRmllbGRzID0gYW50aHJvcGljQ29udGVudFRvTWVzc2FnZUZpZWxkcyhhYyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUZpZWxkcz8uY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXhDb250ZW50LnB1c2goLi4ubWVzc2FnZUZpZWxkcy5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlRmllbGRzPy50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goLi4ubWVzc2FnZUZpZWxkcy50b29sX2NhbGxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbXBsZXhDb250ZW50LFxuICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbENhbGxzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3QUlNZXNzYWdlQ2h1bmsocmV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZVRvR2VuZXJhdGlvbkluZm8obWVzc2FnZSkge1xuICAgICAgICBjb25zdCB1c2FnZSA9IG1lc3NhZ2U/LnVzYWdlO1xuICAgICAgICBjb25zdCB1c2FnZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiB1c2FnZT8uaW5wdXRfdG9rZW5zID8/IDAsXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiB1c2FnZT8ub3V0cHV0X3Rva2VucyA/PyAwLFxuICAgICAgICAgICAgdG90YWxfdG9rZW5zOiAodXNhZ2U/LmlucHV0X3Rva2VucyA/PyAwKSArICh1c2FnZT8ub3V0cHV0X3Rva2VucyA/PyAwKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzYWdlX21ldGFkYXRhOiB1c2FnZU1ldGFkYXRhLFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogbWVzc2FnZS5zdG9wX3JlYXNvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZVRvQ2hhdEdlbmVyYXRpb24ocmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZXNwb25zZU1lc3NhZ2U/LmNvbnRlbnQgPz8gW107XG4gICAgICAgIGNvbnN0IHRleHQgPSBtZXNzYWdlVG9TdHJpbmcocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbnRlbnRUb01lc3NhZ2UoY29udGVudCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25JbmZvID0gbWVzc2FnZVRvR2VuZXJhdGlvbkluZm8ocmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGdlbmVyYXRpb25JbmZvLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZVN0YXJ0VG9DaGF0R2VuZXJhdGlvbihldmVudCkge1xuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBldmVudC5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gbWVzc2FnZVRvQ2hhdEdlbmVyYXRpb24ocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZURlbHRhVG9DaGF0R2VuZXJhdGlvbihldmVudCkge1xuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBldmVudC5kZWx0YTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRlbnRCbG9ja1N0YXJ0VGV4dFRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGV2ZW50LmNvbnRlbnRfYmxvY2s7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb250ZW50VG9NZXNzYWdlKFtjb250ZW50XSk7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IFwidGV4dFwiIGluIGNvbnRlbnQgPyBjb250ZW50LnRleHQgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudEJsb2NrU3RhcnRUb29sVXNlVG9DaGF0R2VuZXJhdGlvbihldmVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50QmxvY2sgPSBldmVudC5jb250ZW50X2Jsb2NrO1xuICAgICAgICBjb25zdCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgY29uc3QgdG9vbENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgIGluZGV4OiBldmVudC5pbmRleCxcbiAgICAgICAgICAgIG5hbWU6IGNvbnRlbnRCbG9jay5uYW1lLFxuICAgICAgICAgICAgaWQ6IGNvbnRlbnRCbG9jay5pZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50QmxvY2suaW5wdXQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRlbnRCbG9jay5pbnB1dCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9vbENodW5rLmFyZ3MgPSBKU09OLnN0cmluZ2lmeShjb250ZW50QmxvY2suaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDaHVua3MgPSBbdG9vbENodW5rXTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleDogZXZlbnQuaW5kZXgsXG4gICAgICAgICAgICAgICAgLi4uY29udGVudEJsb2NrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiB0b29sQ2h1bmtzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3QUlNZXNzYWdlQ2h1bmsobWVzc2FnZUZpZWxkcyk7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50QmxvY2tTdGFydFRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5jb250ZW50X2Jsb2NrLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja1N0YXJ0VGV4dFRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgY2FzZSBcInRvb2xfdXNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja1N0YXJ0VG9vbFVzZVRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuZXhwZWN0ZWQgc3RhcnQgY29udGVudF9ibG9jayB0eXBlOiAke0pTT04uc3RyaW5naWZ5KGV2ZW50KX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50QmxvY2tEZWx0YVRleHRUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGVsdGE7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWx0YT8udGV4dDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ld0FJTWVzc2FnZUNodW5rKHRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudEJsb2NrRGVsdGFJbnB1dEpzb25EZWx0YVRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBldmVudC5kZWx0YTtcbiAgICAgICAgY29uc3QgdGV4dCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHRvb2xDaHVua3MgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGV2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgIGFyZ3M6IGRlbHRhLnBhcnRpYWxfanNvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGV2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgIC4uLmRlbHRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiB0b29sQ2h1bmtzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3QUlNZXNzYWdlQ2h1bmsobWVzc2FnZUZpZWxkcyk7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50QmxvY2tEZWx0YVRvQ2hhdEdlbmVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5kZWx0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dF9kZWx0YVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50QmxvY2tEZWx0YVRleHRUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dF9qc29uX2RlbHRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja0RlbHRhSW5wdXRKc29uRGVsdGFUb0NoYXRHZW5lcmF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmV4cGVjdGVkIGRlbHRhIGNvbnRlbnRfYmxvY2sgdHlwZTogJHtKU09OLnN0cmluZ2lmeShldmVudCl9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVRvQ2hhdEdlbmVyYXRpb24oZGF0YSk7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZV9zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlU3RhcnRUb0NoYXRHZW5lcmF0aW9uKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VfZGVsdGFcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZURlbHRhVG9DaGF0R2VuZXJhdGlvbihkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50X2Jsb2NrX3N0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja1N0YXJ0VG9DaGF0R2VuZXJhdGlvbihkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50X2Jsb2NrX2RlbHRhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9ja0RlbHRhVG9DaGF0R2VuZXJhdGlvbihkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgXCJwaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZV9zdG9wXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudF9ibG9ja19zdG9wXCI6XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGlnbm9yYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBzdHJlYW1pbmcgcmVzdWx0czogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB3aGF0IHR5cGUgdGhpcyBpcywgYnV0IEFudGhyb3BpYyBtYXkgaGF2ZSBhZGRlZFxuICAgICAgICAgICAgICAgIC8vIG5ldyBvbmVzIHdpdGhvdXQgdGVsbGluZyB1cy4gRG9uJ3QgZXJyb3IsIGJ1dCBkb24ndCB1c2UgdGhlbS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIGRhdGEgZm9yIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvblwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcmVzcG9uc2UgdHlwZTogJHtkYXRhLnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2h1bmtUb1N0cmluZyhjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmNvbnRlbnRbMF0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaHVuazogJHtjaHVua31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQmFzZU1lc3NhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkYXRhPy5jb250ZW50ID8/IFtdO1xuICAgICAgICByZXR1cm4gY29udGVudFRvTWVzc2FnZShjb250ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0NoYXRSZXN1bHQocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IGdlbiA9IHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZSk7XG4gICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLnB1c2goZ2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsbG1PdXRwdXQgPSBtZXNzYWdlVG9HZW5lcmF0aW9uSW5mbyhtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbGxtT3V0cHV0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRBbnRocm9waWNWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnPy52ZXJzaW9uID8/IFwidmVydGV4LTIwMjMtMTAtMTZcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGV4dENvbnRlbnRUb0FudGhyb3BpY0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdE1pbWVUeXBlKHN0cikge1xuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZWRpYV90eXBlOiBzdHIuc3BsaXQoXCI6XCIpWzFdLnNwbGl0KFwiO1wiKVswXSxcbiAgICAgICAgICAgICAgICBkYXRhOiBzdHIuc3BsaXQoXCIsXCIpWzFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW1hZ2VDb250ZW50VG9BbnRocm9waWNDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgZGF0YVVybCA9IGNvbnRlbnQuaW1hZ2VfdXJsO1xuICAgICAgICBjb25zdCB1cmwgPSB0eXBlb2YgZGF0YVVybCA9PT0gXCJzdHJpbmdcIiA/IGRhdGFVcmwgOiBkYXRhVXJsPy51cmw7XG4gICAgICAgIGNvbnN0IHVybEluZm8gPSBleHRyYWN0TWltZVR5cGUodXJsKTtcbiAgICAgICAgaWYgKCF1cmxJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgIC4uLnVybEluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50Q29tcGxleFRvQW50aHJvcGljQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjb250ZW50Py50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRDb250ZW50VG9BbnRocm9waWNDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgY2FzZSBcImltYWdlX3VybFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZUNvbnRlbnRUb0FudGhyb3BpY0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCBjb250ZW50IHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRlbnRUb0FudGhyb3BpY0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgY29uc3QgY2EgPSB0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH1dIDogY29udGVudDtcbiAgICAgICAgY2EuZm9yRWFjaCgoY29tcGxleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWMgPSBjb250ZW50Q29tcGxleFRvQW50aHJvcGljQ29udGVudChjb21wbGV4KTtcbiAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGFjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2VSb2xlVG9BbnRocm9waWNNZXNzYWdlKGJhc2UsIHJvbGUpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGNvbnRlbnRUb0FudGhyb3BpY0NvbnRlbnQoYmFzZS5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b29sTWVzc2FnZVRvQW50aHJvcGljTWVzc2FnZShiYXNlKSB7XG4gICAgICAgIGNvbnN0IHJvbGUgPSBcInVzZXJcIjtcbiAgICAgICAgY29uc3QgdG9vbFVzZUlkID0gYmFzZS50b29sX2NhbGxfaWQ7XG4gICAgICAgIGNvbnN0IHRvb2xDb250ZW50ID0gY29udGVudFRvQW50aHJvcGljQ29udGVudChiYXNlLmNvbnRlbnQpO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9yZXN1bHRcIixcbiAgICAgICAgICAgICAgICB0b29sX3VzZV9pZDogdG9vbFVzZUlkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvb2xDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlVG9BbnRocm9waWNNZXNzYWdlKGJhc2UpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGJhc2UuX2dldFR5cGUoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVJvbGVUb0FudGhyb3BpY01lc3NhZ2UoYmFzZSwgXCJ1c2VyXCIpO1xuICAgICAgICAgICAgY2FzZSBcImFpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VSb2xlVG9BbnRocm9waWNNZXNzYWdlKGJhc2UsIFwiYXNzaXN0YW50XCIpO1xuICAgICAgICAgICAgY2FzZSBcInRvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbE1lc3NhZ2VUb0FudGhyb3BpY01lc3NhZ2UoYmFzZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZXMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGlucHV0LmZvckVhY2goKGJhc2VNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbnRocm9waWNNZXNzYWdlID0gYmFzZVRvQW50aHJvcGljTWVzc2FnZShiYXNlTWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoYW50aHJvcGljTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGFudGhyb3BpY01lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0U2V0dGluZ3MocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBzdHJlYW06IHBhcmFtZXRlcnM/LnN0cmVhbWluZyA/PyBmYWxzZSxcbiAgICAgICAgICAgIG1heF90b2tlbnM6IHBhcmFtZXRlcnM/Lm1heE91dHB1dFRva2VucyA/PyA4MTkyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyYW1ldGVycy50b3BQKSB7XG4gICAgICAgICAgICByZXQudG9wX3AgPSBwYXJhbWV0ZXJzLnRvcFA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtZXRlcnMudG9wSykge1xuICAgICAgICAgICAgcmV0LnRvcF9rID0gcGFyYW1ldGVycy50b3BLO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnRlbXBlcmF0dXJlKSB7XG4gICAgICAgICAgICByZXQudGVtcGVyYXR1cmUgPSBwYXJhbWV0ZXJzLnRlbXBlcmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnN0b3BTZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgIHJldC5zdG9wX3NlcXVlbmNlcyA9IHBhcmFtZXRlcnMuc3RvcFNlcXVlbmNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250ZW50Q29tcGxleEFycmF5VG9UZXh0KGNvbnRlbnRBcnJheSkge1xuICAgICAgICBsZXQgcmV0ID0gXCJcIjtcbiAgICAgICAgY29udGVudEFycmF5LmZvckVhY2goKGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gY29udGVudD8udHlwZTtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgcmV0ID0gYCR7cmV0fVxcbiR7dGV4dENvbnRlbnQudGV4dH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0U3lzdGVtKGlucHV0KSB7XG4gICAgICAgIGxldCByZXQgPSBcIlwiO1xuICAgICAgICBpbnB1dC5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IG1lc3NhZ2U/LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFN0cmluZyA9IHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY29udGVudFxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRlbnRDb21wbGV4QXJyYXlUb1RleHQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgcmV0ID0gYCR7cmV0fVxcbiR7Y29udGVudFN0cmluZ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0R2VtaW5pVG9vbCh0b29sKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRvb2wsIFwiZnVuY3Rpb25EZWNsYXJhdGlvbnNcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmNzID0gdG9vbD8uZnVuY3Rpb25EZWNsYXJhdGlvbnMgPz8gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3MubWFwKChmdW5jKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRTY2hlbWEgPSBmdW5jLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZTogXCJ0b29sXCIsICAvLyBUaGlzIG1heSBvbmx5IGJlIHZhbGlkIGZvciBtb2RlbHMgMjAyNDEwMjIrXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGZ1bmMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0X3NjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gZm9ybWF0IEdlbWluaVRvb2w6ICR7SlNPTi5zdHJpbmdpZnkodG9vbCwgbnVsbCwgMSl9YCk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VG9vbCh0b29sKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRvb2wsIFwibmFtZVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0b29sXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRHZW1pbmlUb29sKHRvb2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFRvb2xzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBwYXJhbWV0ZXJzPy50b29scyA/PyBbXTtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIHRvb2xzLmZvckVhY2goKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFudGhyb3BpY1Rvb2xzID0gZm9ybWF0VG9vbCh0b29sKTtcbiAgICAgICAgICAgIGFudGhyb3BpY1Rvb2xzLmZvckVhY2goKGFudGhyb3BpY1Rvb2wpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYW50aHJvcGljVG9vbCkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhbnRocm9waWNUb29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFRvb2xDaG9pY2UocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBjaG9pY2UgPSBwYXJhbWV0ZXJzPy50b29sX2Nob2ljZTtcbiAgICAgICAgaWYgKCFjaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNob2ljZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZm9ybWF0RGF0YShpbnB1dCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCB0eXBlZElucHV0ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IGFudGhyb3BpY1ZlcnNpb24gPSBmb3JtYXRBbnRocm9waWNWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZm9ybWF0TWVzc2FnZXModHlwZWRJbnB1dCk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gZm9ybWF0U2V0dGluZ3MocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHN5c3RlbSA9IGZvcm1hdFN5c3RlbSh0eXBlZElucHV0KTtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBmb3JtYXRUb29scyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgdG9vbENob2ljZSA9IGZvcm1hdFRvb2xDaG9pY2UocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIGFudGhyb3BpY192ZXJzaW9uOiBhbnRocm9waWNWZXJzaW9uLFxuICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRvb2xzICYmIHRvb2xzLmxlbmd0aCAmJiBwYXJhbWV0ZXJzPy50b29sX2Nob2ljZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJldC50b29scyA9IHRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sQ2hvaWNlKSB7XG4gICAgICAgICAgICByZXQudG9vbF9jaG9pY2UgPSB0b29sQ2hvaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeXN0ZW0/Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LnN5c3RlbSA9IHN5c3RlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZXNwb25zZVRvU3RyaW5nLFxuICAgICAgICByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb24sXG4gICAgICAgIGNodW5rVG9TdHJpbmcsXG4gICAgICAgIHJlc3BvbnNlVG9CYXNlTWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2VUb0NoYXRSZXN1bHQsXG4gICAgICAgIGZvcm1hdERhdGEsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0QW50aHJvcGljQVBJID0gZ2V0QW50aHJvcGljQVBJO1xuZnVuY3Rpb24gdmFsaWRhdGVDbGF1ZGVQYXJhbXMoX3BhcmFtcykge1xuICAgIC8vIEZJWE1FIC0gdmFsaWRhdGUgdGhlIHBhcmFtZXRlcnNcbn1cbmV4cG9ydHMudmFsaWRhdGVDbGF1ZGVQYXJhbXMgPSB2YWxpZGF0ZUNsYXVkZVBhcmFtcztcbmZ1bmN0aW9uIGlzTW9kZWxDbGF1ZGUobW9kZWxOYW1lKSB7XG4gICAgcmV0dXJuIG1vZGVsTmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJjbGF1ZGVcIik7XG59XG5leHBvcnRzLmlzTW9kZWxDbGF1ZGUgPSBpc01vZGVsQ2xhdWRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/common.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyAndValidateModelParamsInto = exports.validateModelParams = exports.modelToPublisher = exports.modelToFamily = exports.copyAIModelParamsInto = exports.convertToGeminiTools = exports.copyAIModelParams = void 0;\nconst base_1 = __webpack_require__(/*! @langchain/core/language_models/base */ \"(rsc)/./node_modules/@langchain/core/language_models/base.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst gemini_js_1 = __webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\");\nconst types_js_1 = __webpack_require__(/*! ../types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nconst anthropic_js_1 = __webpack_require__(/*! ./anthropic.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/anthropic.cjs\");\nfunction copyAIModelParams(params, options) {\n    return copyAIModelParamsInto(params, options, {});\n}\nexports.copyAIModelParams = copyAIModelParams;\nfunction processToolChoice(toolChoice, allowedFunctionNames) {\n    if (!toolChoice) {\n        if (allowedFunctionNames) {\n            // Allowed func names is passed, return 'any' so it forces the model to use a tool.\n            return {\n                tool_choice: \"any\",\n                allowed_function_names: allowedFunctionNames,\n            };\n        }\n        return undefined;\n    }\n    if (toolChoice === \"any\" || toolChoice === \"auto\" || toolChoice === \"none\") {\n        return {\n            tool_choice: toolChoice,\n            allowed_function_names: allowedFunctionNames,\n        };\n    }\n    if (typeof toolChoice === \"string\") {\n        // String representing the function name.\n        // Return any to force the model to predict the specified function call.\n        return {\n            tool_choice: \"any\",\n            allowed_function_names: [...(allowedFunctionNames ?? []), toolChoice],\n        };\n    }\n    throw new Error(\"Object inputs for tool_choice not supported.\");\n}\nfunction isGeminiTool(tool) {\n    for (const toolAttribute of types_js_1.GeminiToolAttributes) {\n        if (toolAttribute in tool) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isGeminiNonFunctionTool(tool) {\n    return isGeminiTool(tool) && !(\"functionDeclaration\" in tool);\n}\nfunction convertToGeminiTools(tools) {\n    const geminiTools = [];\n    let functionDeclarationsIndex = -1;\n    tools.forEach((tool) => {\n        if (isGeminiNonFunctionTool(tool)) {\n            geminiTools.push(tool);\n        }\n        else {\n            if (functionDeclarationsIndex === -1) {\n                geminiTools.push({\n                    functionDeclarations: [],\n                });\n                functionDeclarationsIndex = geminiTools.length - 1;\n            }\n            if (\"functionDeclarations\" in tool &&\n                Array.isArray(tool.functionDeclarations)) {\n                const funcs = tool.functionDeclarations;\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push(...funcs);\n            }\n            else if ((0, function_calling_1.isLangChainTool)(tool)) {\n                const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push({\n                    name: tool.name,\n                    description: tool.description ?? `A function available to call.`,\n                    parameters: jsonSchema,\n                });\n            }\n            else if ((0, base_1.isOpenAITool)(tool)) {\n                geminiTools[functionDeclarationsIndex].functionDeclarations.push({\n                    name: tool.function.name,\n                    description: tool.function.description ?? `A function available to call.`,\n                    parameters: (0, zod_to_gemini_parameters_js_1.jsonSchemaToGeminiParameters)(tool.function.parameters),\n                });\n            }\n            else {\n                throw new Error(`Received invalid tool: ${JSON.stringify(tool)}`);\n            }\n        }\n    });\n    return geminiTools;\n}\nexports.convertToGeminiTools = convertToGeminiTools;\nfunction copyAIModelParamsInto(params, options, target) {\n    const ret = target || {};\n    const model = options?.model ?? params?.model ?? target.model;\n    ret.modelName =\n        model ?? options?.modelName ?? params?.modelName ?? target.modelName;\n    ret.model = model;\n    ret.temperature =\n        options?.temperature ?? params?.temperature ?? target.temperature;\n    ret.maxOutputTokens =\n        options?.maxOutputTokens ??\n            params?.maxOutputTokens ??\n            target.maxOutputTokens;\n    ret.topP = options?.topP ?? params?.topP ?? target.topP;\n    ret.topK = options?.topK ?? params?.topK ?? target.topK;\n    ret.presencePenalty =\n        options?.presencePenalty ??\n            params?.presencePenalty ??\n            target.presencePenalty;\n    ret.frequencyPenalty =\n        options?.frequencyPenalty ??\n            params?.frequencyPenalty ??\n            target.frequencyPenalty;\n    ret.stopSequences =\n        options?.stopSequences ?? params?.stopSequences ?? target.stopSequences;\n    ret.safetySettings =\n        options?.safetySettings ?? params?.safetySettings ?? target.safetySettings;\n    ret.logprobs = options?.logprobs ?? params?.logprobs ?? target.logprobs;\n    ret.topLogprobs =\n        options?.topLogprobs ?? params?.topLogprobs ?? target.topLogprobs;\n    ret.convertSystemMessageToHumanContent =\n        options?.convertSystemMessageToHumanContent ??\n            params?.convertSystemMessageToHumanContent ??\n            target?.convertSystemMessageToHumanContent;\n    ret.responseMimeType =\n        options?.responseMimeType ??\n            params?.responseMimeType ??\n            target?.responseMimeType;\n    ret.streaming = options?.streaming ?? params?.streaming ?? target?.streaming;\n    const toolChoice = processToolChoice(options?.tool_choice, options?.allowed_function_names);\n    if (toolChoice) {\n        ret.tool_choice = toolChoice.tool_choice;\n        ret.allowed_function_names = toolChoice.allowed_function_names;\n    }\n    const tools = options?.tools;\n    if (tools) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ret.tools = convertToGeminiTools(tools);\n    }\n    return ret;\n}\nexports.copyAIModelParamsInto = copyAIModelParamsInto;\nfunction modelToFamily(modelName) {\n    if (!modelName) {\n        return null;\n    }\n    else if ((0, gemini_js_1.isModelGemini)(modelName)) {\n        return \"gemini\";\n    }\n    else if ((0, anthropic_js_1.isModelClaude)(modelName)) {\n        return \"claude\";\n    }\n    else {\n        return null;\n    }\n}\nexports.modelToFamily = modelToFamily;\nfunction modelToPublisher(modelName) {\n    const family = modelToFamily(modelName);\n    switch (family) {\n        case \"gemini\":\n        case \"palm\":\n            return \"google\";\n        case \"claude\":\n            return \"anthropic\";\n        default:\n            return \"unknown\";\n    }\n}\nexports.modelToPublisher = modelToPublisher;\nfunction validateModelParams(params) {\n    const testParams = params ?? {};\n    const model = testParams.model ?? testParams.modelName;\n    switch (modelToFamily(model)) {\n        case \"gemini\":\n            return (0, gemini_js_1.validateGeminiParams)(testParams);\n        case \"claude\":\n            return (0, anthropic_js_1.validateClaudeParams)(testParams);\n        default:\n            throw new Error(`Unable to verify model params: ${JSON.stringify(params)}`);\n    }\n}\nexports.validateModelParams = validateModelParams;\nfunction copyAndValidateModelParamsInto(params, target) {\n    copyAIModelParamsInto(params, undefined, target);\n    validateModelParams(target);\n    return target;\n}\nexports.copyAndValidateModelParamsInto = copyAndValidateModelParamsInto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvY29tbW9uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDbE4sZUFBZSxtQkFBTyxDQUFDLDJHQUFzQztBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQywrR0FBd0M7QUFDM0Usb0JBQW9CLG1CQUFPLENBQUMseUZBQWM7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWM7QUFDekMsc0NBQXNDLG1CQUFPLENBQUMsNkhBQWdDO0FBQzlFLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNoRDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVCQUF1QjtBQUNyRjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL2NvbW1vbi5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50byA9IGV4cG9ydHMudmFsaWRhdGVNb2RlbFBhcmFtcyA9IGV4cG9ydHMubW9kZWxUb1B1Ymxpc2hlciA9IGV4cG9ydHMubW9kZWxUb0ZhbWlseSA9IGV4cG9ydHMuY29weUFJTW9kZWxQYXJhbXNJbnRvID0gZXhwb3J0cy5jb252ZXJ0VG9HZW1pbmlUb29scyA9IGV4cG9ydHMuY29weUFJTW9kZWxQYXJhbXMgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9iYXNlXCIpO1xuY29uc3QgZnVuY3Rpb25fY2FsbGluZ18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9mdW5jdGlvbl9jYWxsaW5nXCIpO1xuY29uc3QgZ2VtaW5pX2pzXzEgPSByZXF1aXJlKFwiLi9nZW1pbmkuY2pzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5janNcIik7XG5jb25zdCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMSA9IHJlcXVpcmUoXCIuL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janNcIik7XG5jb25zdCBhbnRocm9waWNfanNfMSA9IHJlcXVpcmUoXCIuL2FudGhyb3BpYy5janNcIik7XG5mdW5jdGlvbiBjb3B5QUlNb2RlbFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29weUFJTW9kZWxQYXJhbXNJbnRvKHBhcmFtcywgb3B0aW9ucywge30pO1xufVxuZXhwb3J0cy5jb3B5QUlNb2RlbFBhcmFtcyA9IGNvcHlBSU1vZGVsUGFyYW1zO1xuZnVuY3Rpb24gcHJvY2Vzc1Rvb2xDaG9pY2UodG9vbENob2ljZSwgYWxsb3dlZEZ1bmN0aW9uTmFtZXMpIHtcbiAgICBpZiAoIXRvb2xDaG9pY2UpIHtcbiAgICAgICAgaWYgKGFsbG93ZWRGdW5jdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICAvLyBBbGxvd2VkIGZ1bmMgbmFtZXMgaXMgcGFzc2VkLCByZXR1cm4gJ2FueScgc28gaXQgZm9yY2VzIHRoZSBtb2RlbCB0byB1c2UgYSB0b29sLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b29sX2Nob2ljZTogXCJhbnlcIixcbiAgICAgICAgICAgICAgICBhbGxvd2VkX2Z1bmN0aW9uX25hbWVzOiBhbGxvd2VkRnVuY3Rpb25OYW1lcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRvb2xDaG9pY2UgPT09IFwiYW55XCIgfHwgdG9vbENob2ljZSA9PT0gXCJhdXRvXCIgfHwgdG9vbENob2ljZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvb2xfY2hvaWNlOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgYWxsb3dlZF9mdW5jdGlvbl9uYW1lczogYWxsb3dlZEZ1bmN0aW9uTmFtZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAgICAvLyBSZXR1cm4gYW55IHRvIGZvcmNlIHRoZSBtb2RlbCB0byBwcmVkaWN0IHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvb2xfY2hvaWNlOiBcImFueVwiLFxuICAgICAgICAgICAgYWxsb3dlZF9mdW5jdGlvbl9uYW1lczogWy4uLihhbGxvd2VkRnVuY3Rpb25OYW1lcyA/PyBbXSksIHRvb2xDaG9pY2VdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgaW5wdXRzIGZvciB0b29sX2Nob2ljZSBub3Qgc3VwcG9ydGVkLlwiKTtcbn1cbmZ1bmN0aW9uIGlzR2VtaW5pVG9vbCh0b29sKSB7XG4gICAgZm9yIChjb25zdCB0b29sQXR0cmlidXRlIG9mIHR5cGVzX2pzXzEuR2VtaW5pVG9vbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKHRvb2xBdHRyaWJ1dGUgaW4gdG9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNHZW1pbmlOb25GdW5jdGlvblRvb2wodG9vbCkge1xuICAgIHJldHVybiBpc0dlbWluaVRvb2wodG9vbCkgJiYgIShcImZ1bmN0aW9uRGVjbGFyYXRpb25cIiBpbiB0b29sKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0dlbWluaVRvb2xzKHRvb2xzKSB7XG4gICAgY29uc3QgZ2VtaW5pVG9vbHMgPSBbXTtcbiAgICBsZXQgZnVuY3Rpb25EZWNsYXJhdGlvbnNJbmRleCA9IC0xO1xuICAgIHRvb2xzLmZvckVhY2goKHRvb2wpID0+IHtcbiAgICAgICAgaWYgKGlzR2VtaW5pTm9uRnVuY3Rpb25Ub29sKHRvb2wpKSB7XG4gICAgICAgICAgICBnZW1pbmlUb29scy5wdXNoKHRvb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb25zSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VtaW5pVG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uc0luZGV4ID0gZ2VtaW5pVG9vbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uRGVjbGFyYXRpb25zXCIgaW4gdG9vbCAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jcyA9IHRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgZ2VtaW5pVG9vbHNbZnVuY3Rpb25EZWNsYXJhdGlvbnNJbmRleF0uZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaCguLi5mdW5jcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgZnVuY3Rpb25fY2FsbGluZ18xLmlzTGFuZ0NoYWluVG9vbCkodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uU2NoZW1hID0gKDAsIHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xLnpvZFRvR2VtaW5pUGFyYW1ldGVycykodG9vbC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGdlbWluaVRvb2xzW2Z1bmN0aW9uRGVjbGFyYXRpb25zSW5kZXhdLmZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uID8/IGBBIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsLmAsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgYmFzZV8xLmlzT3BlbkFJVG9vbCkodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBnZW1pbmlUb29sc1tmdW5jdGlvbkRlY2xhcmF0aW9uc0luZGV4XS5mdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5mdW5jdGlvbi5kZXNjcmlwdGlvbiA/PyBgQSBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbC5gLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiAoMCwgem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzX2pzXzEuanNvblNjaGVtYVRvR2VtaW5pUGFyYW1ldGVycykodG9vbC5mdW5jdGlvbi5wYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgaW52YWxpZCB0b29sOiAke0pTT04uc3RyaW5naWZ5KHRvb2wpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbWluaVRvb2xzO1xufVxuZXhwb3J0cy5jb252ZXJ0VG9HZW1pbmlUb29scyA9IGNvbnZlcnRUb0dlbWluaVRvb2xzO1xuZnVuY3Rpb24gY29weUFJTW9kZWxQYXJhbXNJbnRvKHBhcmFtcywgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgY29uc3QgcmV0ID0gdGFyZ2V0IHx8IHt9O1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucz8ubW9kZWwgPz8gcGFyYW1zPy5tb2RlbCA/PyB0YXJnZXQubW9kZWw7XG4gICAgcmV0Lm1vZGVsTmFtZSA9XG4gICAgICAgIG1vZGVsID8/IG9wdGlvbnM/Lm1vZGVsTmFtZSA/PyBwYXJhbXM/Lm1vZGVsTmFtZSA/PyB0YXJnZXQubW9kZWxOYW1lO1xuICAgIHJldC5tb2RlbCA9IG1vZGVsO1xuICAgIHJldC50ZW1wZXJhdHVyZSA9XG4gICAgICAgIG9wdGlvbnM/LnRlbXBlcmF0dXJlID8/IHBhcmFtcz8udGVtcGVyYXR1cmUgPz8gdGFyZ2V0LnRlbXBlcmF0dXJlO1xuICAgIHJldC5tYXhPdXRwdXRUb2tlbnMgPVxuICAgICAgICBvcHRpb25zPy5tYXhPdXRwdXRUb2tlbnMgPz9cbiAgICAgICAgICAgIHBhcmFtcz8ubWF4T3V0cHV0VG9rZW5zID8/XG4gICAgICAgICAgICB0YXJnZXQubWF4T3V0cHV0VG9rZW5zO1xuICAgIHJldC50b3BQID0gb3B0aW9ucz8udG9wUCA/PyBwYXJhbXM/LnRvcFAgPz8gdGFyZ2V0LnRvcFA7XG4gICAgcmV0LnRvcEsgPSBvcHRpb25zPy50b3BLID8/IHBhcmFtcz8udG9wSyA/PyB0YXJnZXQudG9wSztcbiAgICByZXQucHJlc2VuY2VQZW5hbHR5ID1cbiAgICAgICAgb3B0aW9ucz8ucHJlc2VuY2VQZW5hbHR5ID8/XG4gICAgICAgICAgICBwYXJhbXM/LnByZXNlbmNlUGVuYWx0eSA/P1xuICAgICAgICAgICAgdGFyZ2V0LnByZXNlbmNlUGVuYWx0eTtcbiAgICByZXQuZnJlcXVlbmN5UGVuYWx0eSA9XG4gICAgICAgIG9wdGlvbnM/LmZyZXF1ZW5jeVBlbmFsdHkgPz9cbiAgICAgICAgICAgIHBhcmFtcz8uZnJlcXVlbmN5UGVuYWx0eSA/P1xuICAgICAgICAgICAgdGFyZ2V0LmZyZXF1ZW5jeVBlbmFsdHk7XG4gICAgcmV0LnN0b3BTZXF1ZW5jZXMgPVxuICAgICAgICBvcHRpb25zPy5zdG9wU2VxdWVuY2VzID8/IHBhcmFtcz8uc3RvcFNlcXVlbmNlcyA/PyB0YXJnZXQuc3RvcFNlcXVlbmNlcztcbiAgICByZXQuc2FmZXR5U2V0dGluZ3MgPVxuICAgICAgICBvcHRpb25zPy5zYWZldHlTZXR0aW5ncyA/PyBwYXJhbXM/LnNhZmV0eVNldHRpbmdzID8/IHRhcmdldC5zYWZldHlTZXR0aW5ncztcbiAgICByZXQubG9ncHJvYnMgPSBvcHRpb25zPy5sb2dwcm9icyA/PyBwYXJhbXM/LmxvZ3Byb2JzID8/IHRhcmdldC5sb2dwcm9icztcbiAgICByZXQudG9wTG9ncHJvYnMgPVxuICAgICAgICBvcHRpb25zPy50b3BMb2dwcm9icyA/PyBwYXJhbXM/LnRvcExvZ3Byb2JzID8/IHRhcmdldC50b3BMb2dwcm9icztcbiAgICByZXQuY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudCA9XG4gICAgICAgIG9wdGlvbnM/LmNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9IdW1hbkNvbnRlbnQgPz9cbiAgICAgICAgICAgIHBhcmFtcz8uY29udmVydFN5c3RlbU1lc3NhZ2VUb0h1bWFuQ29udGVudCA/P1xuICAgICAgICAgICAgdGFyZ2V0Py5jb252ZXJ0U3lzdGVtTWVzc2FnZVRvSHVtYW5Db250ZW50O1xuICAgIHJldC5yZXNwb25zZU1pbWVUeXBlID1cbiAgICAgICAgb3B0aW9ucz8ucmVzcG9uc2VNaW1lVHlwZSA/P1xuICAgICAgICAgICAgcGFyYW1zPy5yZXNwb25zZU1pbWVUeXBlID8/XG4gICAgICAgICAgICB0YXJnZXQ/LnJlc3BvbnNlTWltZVR5cGU7XG4gICAgcmV0LnN0cmVhbWluZyA9IG9wdGlvbnM/LnN0cmVhbWluZyA/PyBwYXJhbXM/LnN0cmVhbWluZyA/PyB0YXJnZXQ/LnN0cmVhbWluZztcbiAgICBjb25zdCB0b29sQ2hvaWNlID0gcHJvY2Vzc1Rvb2xDaG9pY2Uob3B0aW9ucz8udG9vbF9jaG9pY2UsIG9wdGlvbnM/LmFsbG93ZWRfZnVuY3Rpb25fbmFtZXMpO1xuICAgIGlmICh0b29sQ2hvaWNlKSB7XG4gICAgICAgIHJldC50b29sX2Nob2ljZSA9IHRvb2xDaG9pY2UudG9vbF9jaG9pY2U7XG4gICAgICAgIHJldC5hbGxvd2VkX2Z1bmN0aW9uX25hbWVzID0gdG9vbENob2ljZS5hbGxvd2VkX2Z1bmN0aW9uX25hbWVzO1xuICAgIH1cbiAgICBjb25zdCB0b29scyA9IG9wdGlvbnM/LnRvb2xzO1xuICAgIGlmICh0b29scykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXQudG9vbHMgPSBjb252ZXJ0VG9HZW1pbmlUb29scyh0b29scyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLmNvcHlBSU1vZGVsUGFyYW1zSW50byA9IGNvcHlBSU1vZGVsUGFyYW1zSW50bztcbmZ1bmN0aW9uIG1vZGVsVG9GYW1pbHkobW9kZWxOYW1lKSB7XG4gICAgaWYgKCFtb2RlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBnZW1pbmlfanNfMS5pc01vZGVsR2VtaW5pKShtb2RlbE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBcImdlbWluaVwiO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgYW50aHJvcGljX2pzXzEuaXNNb2RlbENsYXVkZSkobW9kZWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJjbGF1ZGVcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMubW9kZWxUb0ZhbWlseSA9IG1vZGVsVG9GYW1pbHk7XG5mdW5jdGlvbiBtb2RlbFRvUHVibGlzaGVyKG1vZGVsTmFtZSkge1xuICAgIGNvbnN0IGZhbWlseSA9IG1vZGVsVG9GYW1pbHkobW9kZWxOYW1lKTtcbiAgICBzd2l0Y2ggKGZhbWlseSkge1xuICAgICAgICBjYXNlIFwiZ2VtaW5pXCI6XG4gICAgICAgIGNhc2UgXCJwYWxtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJnb29nbGVcIjtcbiAgICAgICAgY2FzZSBcImNsYXVkZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYW50aHJvcGljXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgfVxufVxuZXhwb3J0cy5tb2RlbFRvUHVibGlzaGVyID0gbW9kZWxUb1B1Ymxpc2hlcjtcbmZ1bmN0aW9uIHZhbGlkYXRlTW9kZWxQYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgdGVzdFBhcmFtcyA9IHBhcmFtcyA/PyB7fTtcbiAgICBjb25zdCBtb2RlbCA9IHRlc3RQYXJhbXMubW9kZWwgPz8gdGVzdFBhcmFtcy5tb2RlbE5hbWU7XG4gICAgc3dpdGNoIChtb2RlbFRvRmFtaWx5KG1vZGVsKSkge1xuICAgICAgICBjYXNlIFwiZ2VtaW5pXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdlbWluaV9qc18xLnZhbGlkYXRlR2VtaW5pUGFyYW1zKSh0ZXN0UGFyYW1zKTtcbiAgICAgICAgY2FzZSBcImNsYXVkZVwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBhbnRocm9waWNfanNfMS52YWxpZGF0ZUNsYXVkZVBhcmFtcykodGVzdFBhcmFtcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB2ZXJpZnkgbW9kZWwgcGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KHBhcmFtcyl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZU1vZGVsUGFyYW1zID0gdmFsaWRhdGVNb2RlbFBhcmFtcztcbmZ1bmN0aW9uIGNvcHlBbmRWYWxpZGF0ZU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIHRhcmdldCkge1xuICAgIGNvcHlBSU1vZGVsUGFyYW1zSW50byhwYXJhbXMsIHVuZGVmaW5lZCwgdGFyZ2V0KTtcbiAgICB2YWxpZGF0ZU1vZGVsUGFyYW1zKHRhcmdldCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMuY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvID0gY29weUFuZFZhbGlkYXRlTW9kZWxQYXJhbXNJbnRvO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureParams = exports.failedAttemptHandler = void 0;\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    402,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408,\n    409, // Conflict\n];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction failedAttemptHandler(error) {\n    const status = error?.response?.status ?? 0;\n    if (status === 0) {\n        // What is this?\n        console.error(\"failedAttemptHandler\", error);\n        throw error;\n    }\n    // What errors shouldn't be retried?\n    if (STATUS_NO_RETRY.includes(+status)) {\n        throw error;\n    }\n}\nexports.failedAttemptHandler = failedAttemptHandler;\nfunction ensureParams(params) {\n    const base = params ?? {};\n    return {\n        onFailedAttempt: failedAttemptHandler,\n        ...base,\n    };\n}\nexports.ensureParams = ensureParams;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZmFpbGVkX2hhbmRsZXIuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnN1cmVQYXJhbXMgPSBleHBvcnRzLmZhaWxlZEF0dGVtcHRIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAyLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA4LFxuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZmFpbGVkQXR0ZW1wdEhhbmRsZXIoZXJyb3IpIHtcbiAgICBjb25zdCBzdGF0dXMgPSBlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cyA/PyAwO1xuICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgLy8gV2hhdCBpcyB0aGlzP1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkQXR0ZW1wdEhhbmRsZXJcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gV2hhdCBlcnJvcnMgc2hvdWxkbid0IGJlIHJldHJpZWQ/XG4gICAgaWYgKFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmZhaWxlZEF0dGVtcHRIYW5kbGVyID0gZmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG5mdW5jdGlvbiBlbnN1cmVQYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgYmFzZSA9IHBhcmFtcyA/PyB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IGZhaWxlZEF0dGVtcHRIYW5kbGVyLFxuICAgICAgICAuLi5iYXNlLFxuICAgIH07XG59XG5leHBvcnRzLmVuc3VyZVBhcmFtcyA9IGVuc3VyZVBhcmFtcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/gemini.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isModelGemini = exports.validateGeminiParams = exports.getGeminiAPI = exports.MessageGeminiSafetyHandler = exports.DefaultGeminiSafetyHandler = void 0;\nconst uuid_1 = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\");\nconst messages_1 = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.cjs\");\nconst outputs_1 = __webpack_require__(/*! @langchain/core/outputs */ \"(rsc)/./node_modules/@langchain/core/outputs.cjs\");\nconst function_calling_1 = __webpack_require__(/*! @langchain/core/utils/function_calling */ \"(rsc)/./node_modules/@langchain/core/utils/function_calling.cjs\");\nconst safety_js_1 = __webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\");\nconst types_js_1 = __webpack_require__(/*! ../types.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/types.cjs\");\nconst zod_to_gemini_parameters_js_1 = __webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\");\nclass DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        Object.defineProperty(this, \"errorFinish\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"SAFETY\", \"RECITATION\", \"OTHER\"]\n        });\n        this.errorFinish = settings?.errorFinish ?? this.errorFinish;\n    }\n    handleDataPromptFeedback(response, data) {\n        // Check to see if our prompt was blocked in the first place\n        const promptFeedback = data?.promptFeedback;\n        const blockReason = promptFeedback?.blockReason;\n        if (blockReason) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Prompt blocked: ${blockReason}`);\n        }\n        return data;\n    }\n    handleDataFinishReason(response, data) {\n        const firstCandidate = data?.candidates?.[0];\n        const finishReason = firstCandidate?.finishReason;\n        if (this.errorFinish.includes(finishReason)) {\n            throw new safety_js_1.GoogleAISafetyError(response, `Finish reason: ${finishReason}`);\n        }\n        return data;\n    }\n    handleData(response, data) {\n        let ret = data;\n        ret = this.handleDataPromptFeedback(response, ret);\n        ret = this.handleDataFinishReason(response, ret);\n        return ret;\n    }\n    handle(response) {\n        let newdata;\n        if (\"nextChunk\" in response.data) {\n            // TODO: This is a stream. How to handle?\n            newdata = response.data;\n        }\n        else if (Array.isArray(response.data)) {\n            // If it is an array, try to handle every item in the array\n            try {\n                newdata = response.data.map((item) => this.handleData(response, item));\n            }\n            catch (xx) {\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                    throw new safety_js_1.GoogleAISafetyError(response, xx.message);\n                }\n                else {\n                    throw xx;\n                }\n            }\n        }\n        else {\n            const data = response.data;\n            newdata = this.handleData(response, data);\n        }\n        return {\n            ...response,\n            data: newdata,\n        };\n    }\n}\nexports.DefaultGeminiSafetyHandler = DefaultGeminiSafetyHandler;\nclass MessageGeminiSafetyHandler extends DefaultGeminiSafetyHandler {\n    constructor(settings) {\n        super(settings);\n        Object.defineProperty(this, \"msg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"forceNewMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.msg = settings?.msg ?? this.msg;\n        this.forceNewMessage = settings?.forceNewMessage ?? this.forceNewMessage;\n    }\n    setMessage(data) {\n        const ret = data;\n        if (this.forceNewMessage ||\n            !data?.candidates?.[0]?.content?.parts?.length) {\n            ret.candidates = data.candidates ?? [];\n            ret.candidates[0] = data.candidates[0] ?? {};\n            ret.candidates[0].content = data.candidates[0].content ?? {};\n            ret.candidates[0].content = {\n                role: \"model\",\n                parts: [{ text: this.msg }],\n            };\n        }\n        return ret;\n    }\n    handleData(response, data) {\n        try {\n            return super.handleData(response, data);\n        }\n        catch (xx) {\n            return this.setMessage(data);\n        }\n    }\n}\nexports.MessageGeminiSafetyHandler = MessageGeminiSafetyHandler;\nconst extractMimeType = (str) => {\n    if (str.startsWith(\"data:\")) {\n        return {\n            mimeType: str.split(\":\")[1].split(\";\")[0],\n            data: str.split(\",\")[1],\n        };\n    }\n    return null;\n};\nfunction getGeminiAPI(config) {\n    function messageContentText(content) {\n        if (content?.text && content?.text.length > 0) {\n            return {\n                text: content.text,\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    function messageContentImageUrl(content) {\n        const url = typeof content.image_url === \"string\"\n            ? content.image_url\n            : content.image_url.url;\n        if (!url) {\n            throw new Error(\"Missing Image URL\");\n        }\n        const mimeTypeAndData = extractMimeType(url);\n        if (mimeTypeAndData) {\n            return {\n                inlineData: mimeTypeAndData,\n            };\n        }\n        else {\n            // FIXME - need some way to get mime type\n            return {\n                fileData: {\n                    mimeType: \"image/png\",\n                    fileUri: url,\n                },\n            };\n        }\n    }\n    async function blobToFileData(blob) {\n        return {\n            fileData: {\n                fileUri: blob.path,\n                mimeType: blob.mimetype,\n            },\n        };\n    }\n    async function fileUriContentToBlob(uri) {\n        return config?.mediaManager?.getMediaBlob(uri);\n    }\n    async function messageContentMedia(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    content) {\n        if (\"mimeType\" in content && \"data\" in content) {\n            return {\n                inlineData: {\n                    mimeType: content.mimeType,\n                    data: content.data,\n                },\n            };\n        }\n        else if (\"mimeType\" in content && \"fileUri\" in content) {\n            return {\n                fileData: {\n                    mimeType: content.mimeType,\n                    fileUri: content.fileUri,\n                },\n            };\n        }\n        else {\n            const uri = content.fileUri;\n            const blob = await fileUriContentToBlob(uri);\n            if (blob) {\n                return await blobToFileData(blob);\n            }\n        }\n        throw new Error(`Invalid media content: ${JSON.stringify(content, null, 1)}`);\n    }\n    async function messageContentComplexToPart(content) {\n        switch (content.type) {\n            case \"text\":\n                if (\"text\" in content) {\n                    return messageContentText(content);\n                }\n                break;\n            case \"image_url\":\n                if (\"image_url\" in content) {\n                    // Type guard for MessageContentImageUrl\n                    return messageContentImageUrl(content);\n                }\n                break;\n            case \"media\":\n                return await messageContentMedia(content);\n            default:\n                throw new Error(`Unsupported type \"${content.type}\" received while converting message to message parts: ${content}`);\n        }\n        throw new Error(`Cannot coerce \"${content.type}\" message part into a string.`);\n    }\n    async function messageContentComplexToParts(content) {\n        const contents = content.map(messageContentComplexToPart);\n        return Promise.all(contents);\n    }\n    async function messageContentToParts(content) {\n        // Convert a string to a text type MessageContent if needed\n        const messageContent = typeof content === \"string\"\n            ? [\n                {\n                    type: \"text\",\n                    text: content,\n                },\n            ]\n            : content;\n        // Get all of the parts, even those that don't correctly resolve\n        const allParts = await messageContentComplexToParts(messageContent);\n        // Remove any invalid parts\n        const parts = allParts.reduce((acc, val) => {\n            if (val) {\n                return [...acc, val];\n            }\n            else {\n                return acc;\n            }\n        }, []);\n        return parts;\n    }\n    function messageToolCallsToParts(toolCalls) {\n        if (!toolCalls || toolCalls.length === 0) {\n            return [];\n        }\n        return toolCalls.map((tool) => {\n            let args = {};\n            if (tool?.function?.arguments) {\n                const argStr = tool.function.arguments;\n                args = JSON.parse(argStr);\n            }\n            return {\n                functionCall: {\n                    name: tool.function.name,\n                    args,\n                },\n            };\n        });\n    }\n    function messageKwargsToParts(kwargs) {\n        const ret = [];\n        if (kwargs?.tool_calls) {\n            ret.push(...messageToolCallsToParts(kwargs.tool_calls));\n        }\n        return ret;\n    }\n    async function roleMessageToContent(role, message) {\n        const contentParts = await messageContentToParts(message.content);\n        let toolParts;\n        if ((0, messages_1.isAIMessage)(message) && !!message.tool_calls?.length) {\n            toolParts = message.tool_calls.map((toolCall) => ({\n                functionCall: {\n                    name: toolCall.name,\n                    args: toolCall.args,\n                },\n            }));\n        }\n        else {\n            toolParts = messageKwargsToParts(message.additional_kwargs);\n        }\n        const parts = [...contentParts, ...toolParts];\n        return [\n            {\n                role,\n                parts,\n            },\n        ];\n    }\n    async function systemMessageToContent(message) {\n        return config?.useSystemInstruction\n            ? roleMessageToContent(\"system\", message)\n            : [\n                ...(await roleMessageToContent(\"user\", message)),\n                ...(await roleMessageToContent(\"model\", new messages_1.AIMessage(\"Ok\"))),\n            ];\n    }\n    function toolMessageToContent(message, prevMessage) {\n        const contentStr = typeof message.content === \"string\"\n            ? message.content\n            : message.content.reduce((acc, content) => {\n                if (content.type === \"text\") {\n                    return acc + content.text;\n                }\n                else {\n                    return acc;\n                }\n            }, \"\");\n        // Hacky :(\n        const responseName = ((0, messages_1.isAIMessage)(prevMessage) && !!prevMessage.tool_calls?.length\n            ? prevMessage.tool_calls[0].name\n            : prevMessage.name) ?? message.tool_call_id;\n        try {\n            const content = JSON.parse(contentStr);\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n        catch (_) {\n            return [\n                {\n                    role: \"function\",\n                    parts: [\n                        {\n                            functionResponse: {\n                                name: responseName,\n                                response: { content: contentStr },\n                            },\n                        },\n                    ],\n                },\n            ];\n        }\n    }\n    async function baseMessageToContent(message, prevMessage) {\n        const type = message._getType();\n        switch (type) {\n            case \"system\":\n                return systemMessageToContent(message);\n            case \"human\":\n                return roleMessageToContent(\"user\", message);\n            case \"ai\":\n                return roleMessageToContent(\"model\", message);\n            case \"tool\":\n                if (!prevMessage) {\n                    throw new Error(\"Tool messages cannot be the first message passed to the model.\");\n                }\n                return toolMessageToContent(message, prevMessage);\n            default:\n                console.log(`Unsupported message type: ${type}`);\n                return [];\n        }\n    }\n    function textPartToMessageContent(part) {\n        return {\n            type: \"text\",\n            text: part.text,\n        };\n    }\n    function inlineDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,\n        };\n    }\n    function fileDataPartToMessageContent(part) {\n        return {\n            type: \"image_url\",\n            image_url: part.fileData.fileUri,\n        };\n    }\n    function partsToMessageContent(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"text\" in part) {\n                return textPartToMessageContent(part);\n            }\n            else if (\"inlineData\" in part) {\n                return inlineDataPartToMessageContent(part);\n            }\n            else if (\"fileData\" in part) {\n                return fileDataPartToMessageContent(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolRawToTool(raw) {\n        return {\n            id: raw.id,\n            type: raw.type,\n            function: {\n                name: raw.function.name,\n                arguments: JSON.stringify(raw.function.arguments),\n            },\n        };\n    }\n    function functionCallPartToToolRaw(part) {\n        return {\n            id: (0, uuid_1.v4)().replace(/-/g, \"\"),\n            type: \"function\",\n            function: {\n                name: part.functionCall.name,\n                arguments: part.functionCall.args ?? {},\n            },\n        };\n    }\n    function partsToToolsRaw(parts) {\n        return parts\n            .map((part) => {\n            if (part === undefined || part === null) {\n                return null;\n            }\n            else if (\"functionCall\" in part) {\n                return functionCallPartToToolRaw(part);\n            }\n            else {\n                return null;\n            }\n        })\n            .reduce((acc, content) => {\n            if (content) {\n                acc.push(content);\n            }\n            return acc;\n        }, []);\n    }\n    function toolsRawToTools(raws) {\n        return raws.map((raw) => toolRawToTool(raw));\n    }\n    function responseToGenerateContentResponseData(response) {\n        if (\"nextChunk\" in response.data) {\n            throw new Error(\"Cannot convert Stream to GenerateContentResponseData\");\n        }\n        else if (Array.isArray(response.data)) {\n            // Collapse the array of response data as if it was a single one\n            return response.data.reduce((acc, val) => {\n                // Add all the parts\n                // FIXME: Handle other candidates?\n                const valParts = val?.candidates?.[0]?.content?.parts ?? [];\n                acc.candidates[0].content.parts.push(...valParts);\n                // FIXME: Merge promptFeedback and safety settings\n                acc.promptFeedback = val.promptFeedback;\n                return acc;\n            });\n        }\n        else {\n            return response.data;\n        }\n    }\n    function responseToParts(response) {\n        const responseData = responseToGenerateContentResponseData(response);\n        const parts = responseData?.candidates?.[0]?.content?.parts ?? [];\n        return parts;\n    }\n    function partToText(part) {\n        return \"text\" in part ? part.text : \"\";\n    }\n    function responseToString(response) {\n        const parts = responseToParts(response);\n        const ret = parts.reduce((acc, part) => {\n            const val = partToText(part);\n            return acc + val;\n        }, \"\");\n        return ret;\n    }\n    function safeResponseTo(response, responseTo) {\n        const safetyHandler = config?.safetyHandler ?? new DefaultGeminiSafetyHandler();\n        try {\n            const safeResponse = safetyHandler.handle(response);\n            return responseTo(safeResponse);\n        }\n        catch (xx) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (xx instanceof safety_js_1.GoogleAISafetyError) {\n                const ret = responseTo(xx.response);\n                xx.reply = ret;\n            }\n            throw xx;\n        }\n    }\n    function safeResponseToString(response) {\n        return safeResponseTo(response, responseToString);\n    }\n    function logprobResultToLogprob(result) {\n        const token = result?.token;\n        const logprob = result?.logProbability;\n        const encoder = new TextEncoder();\n        const bytes = Array.from(encoder.encode(token));\n        return {\n            token,\n            logprob,\n            bytes,\n        };\n    }\n    function candidateToLogprobs(candidate) {\n        const logprobs = candidate?.logprobsResult;\n        const chosenTokens = logprobs?.chosenCandidates ?? [];\n        const topTokens = logprobs?.topCandidates ?? [];\n        const content = [];\n        for (let co = 0; co < chosenTokens.length; co += 1) {\n            const chosen = chosenTokens[co];\n            const top = topTokens[co]?.candidates ?? [];\n            const logprob = logprobResultToLogprob(chosen);\n            logprob.top_logprobs = top.map((l) => logprobResultToLogprob(l));\n            content.push(logprob);\n        }\n        return {\n            content,\n        };\n    }\n    function responseToGenerationInfo(response) {\n        if (!Array.isArray(response.data)) {\n            return {};\n        }\n        const data = response.data[0];\n        return {\n            usage_metadata: {\n                prompt_token_count: data.usageMetadata?.promptTokenCount,\n                candidates_token_count: data.usageMetadata?.candidatesTokenCount,\n                total_token_count: data.usageMetadata?.totalTokenCount,\n            },\n            safety_ratings: data.candidates[0]?.safetyRatings?.map((rating) => ({\n                category: rating.category,\n                probability: rating.probability,\n                probability_score: rating.probabilityScore,\n                severity: rating.severity,\n                severity_score: rating.severityScore,\n            })),\n            citation_metadata: data.candidates[0]?.citationMetadata,\n            grounding_metadata: data.candidates[0]?.groundingMetadata,\n            finish_reason: data.candidates[0]?.finishReason,\n            avgLogprobs: data.candidates[0]?.avgLogprobs,\n            logprobs: candidateToLogprobs(data.candidates[0]),\n        };\n    }\n    function responseToChatGeneration(response) {\n        return new outputs_1.ChatGenerationChunk({\n            text: responseToString(response),\n            message: partToMessageChunk(responseToParts(response)[0]),\n            generationInfo: responseToGenerationInfo(response),\n        });\n    }\n    function safeResponseToChatGeneration(response) {\n        return safeResponseTo(response, responseToChatGeneration);\n    }\n    function chunkToString(chunk) {\n        if (chunk === null) {\n            return \"\";\n        }\n        else if (typeof chunk.content === \"string\") {\n            return chunk.content;\n        }\n        else if (chunk.content.length === 0) {\n            return \"\";\n        }\n        else if (chunk.content[0].type === \"text\") {\n            return chunk.content[0].text;\n        }\n        else {\n            throw new Error(`Unexpected chunk: ${chunk}`);\n        }\n    }\n    function partToMessageChunk(part) {\n        const fields = partsToBaseMessageChunkFields([part]);\n        if (typeof fields.content === \"string\") {\n            return new messages_1.AIMessageChunk(fields);\n        }\n        else if (fields.content.every((item) => item.type === \"text\")) {\n            const newContent = fields.content\n                .map((item) => (\"text\" in item ? item.text : \"\"))\n                .join(\"\");\n            return new messages_1.AIMessageChunk({\n                ...fields,\n                content: newContent,\n            });\n        }\n        return new messages_1.AIMessageChunk(fields);\n    }\n    function partToChatGeneration(part) {\n        const message = partToMessageChunk(part);\n        const text = partToText(part);\n        return new outputs_1.ChatGenerationChunk({\n            text,\n            message,\n        });\n    }\n    function groundingSupportByPart(groundingSupports) {\n        const ret = [];\n        if (!groundingSupports || groundingSupports.length === 0) {\n            return [];\n        }\n        groundingSupports?.forEach((groundingSupport) => {\n            const segment = groundingSupport?.segment;\n            const partIndex = segment?.partIndex ?? 0;\n            if (ret[partIndex]) {\n                ret[partIndex].push(groundingSupport);\n            }\n            else {\n                ret[partIndex] = [groundingSupport];\n            }\n        });\n        return ret;\n    }\n    function responseToGroundedChatGenerations(response) {\n        const parts = responseToParts(response);\n        if (parts.length === 0) {\n            return [];\n        }\n        // Citation and grounding information connected to each part / ChatGeneration\n        // to make sure they are available in downstream filters.\n        const candidate = response?.data\n            ?.candidates?.[0];\n        const groundingMetadata = candidate?.groundingMetadata;\n        const citationMetadata = candidate?.citationMetadata;\n        const groundingParts = groundingSupportByPart(groundingMetadata?.groundingSupports);\n        const ret = parts.map((part, index) => {\n            const gen = partToChatGeneration(part);\n            if (!gen.generationInfo) {\n                gen.generationInfo = {};\n            }\n            if (groundingMetadata) {\n                gen.generationInfo.groundingMetadata = groundingMetadata;\n                const groundingPart = groundingParts[index];\n                if (groundingPart) {\n                    gen.generationInfo.groundingSupport = groundingPart;\n                }\n            }\n            if (citationMetadata) {\n                gen.generationInfo.citationMetadata = citationMetadata;\n            }\n            return gen;\n        });\n        return ret;\n    }\n    function responseToChatGenerations(response) {\n        let ret = responseToGroundedChatGenerations(response);\n        if (ret.length === 0) {\n            return [];\n        }\n        if (ret.every((item) => typeof item.message.content === \"string\")) {\n            const combinedContent = ret.map((item) => item.message.content).join(\"\");\n            const combinedText = ret.map((item) => item.text).join(\"\");\n            const toolCallChunks = ret[ret.length - 1]?.message.additional_kwargs?.tool_calls?.map((toolCall, i) => ({\n                name: toolCall.function.name,\n                args: toolCall.function.arguments,\n                id: toolCall.id,\n                index: i,\n                type: \"tool_call_chunk\",\n            }));\n            let usageMetadata;\n            if (\"usageMetadata\" in response.data) {\n                usageMetadata = {\n                    input_tokens: response.data.usageMetadata.promptTokenCount,\n                    output_tokens: response.data.usageMetadata\n                        .candidatesTokenCount,\n                    total_tokens: response.data.usageMetadata.totalTokenCount,\n                };\n            }\n            ret = [\n                new outputs_1.ChatGenerationChunk({\n                    message: new messages_1.AIMessageChunk({\n                        content: combinedContent,\n                        additional_kwargs: ret[ret.length - 1]?.message.additional_kwargs,\n                        tool_call_chunks: toolCallChunks,\n                        usage_metadata: usageMetadata,\n                    }),\n                    text: combinedText,\n                    generationInfo: ret[ret.length - 1].generationInfo,\n                }),\n            ];\n        }\n        // Add logprobs information to the message\n        const candidate = response?.data\n            ?.candidates?.[0];\n        const avgLogprobs = candidate?.avgLogprobs;\n        const logprobs = candidateToLogprobs(candidate);\n        if (logprobs) {\n            ret[0].message.response_metadata = {\n                ...ret[0].message.response_metadata,\n                logprobs,\n                avgLogprobs,\n            };\n        }\n        return ret;\n    }\n    function responseToBaseMessageFields(response) {\n        const parts = responseToParts(response);\n        return partsToBaseMessageChunkFields(parts);\n    }\n    function partsToBaseMessageChunkFields(parts) {\n        const fields = {\n            content: partsToMessageContent(parts),\n            tool_call_chunks: [],\n            tool_calls: [],\n            invalid_tool_calls: [],\n        };\n        const rawTools = partsToToolsRaw(parts);\n        if (rawTools.length > 0) {\n            const tools = toolsRawToTools(rawTools);\n            for (const tool of tools) {\n                fields.tool_call_chunks?.push({\n                    name: tool.function.name,\n                    args: tool.function.arguments,\n                    id: tool.id,\n                    type: \"tool_call_chunk\",\n                });\n                try {\n                    fields.tool_calls?.push({\n                        name: tool.function.name,\n                        args: JSON.parse(tool.function.arguments),\n                        id: tool.id,\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                catch (e) {\n                    fields.invalid_tool_calls?.push({\n                        name: tool.function.name,\n                        args: tool.function.arguments,\n                        id: tool.id,\n                        error: e.message,\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            fields.additional_kwargs = {\n                tool_calls: tools,\n            };\n        }\n        return fields;\n    }\n    function responseToBaseMessage(response) {\n        const fields = responseToBaseMessageFields(response);\n        return new messages_1.AIMessage(fields);\n    }\n    function safeResponseToBaseMessage(response) {\n        return safeResponseTo(response, responseToBaseMessage);\n    }\n    function responseToChatResult(response) {\n        const generations = responseToChatGenerations(response);\n        return {\n            generations,\n            llmOutput: responseToGenerationInfo(response),\n        };\n    }\n    function safeResponseToChatResult(response) {\n        return safeResponseTo(response, responseToChatResult);\n    }\n    function inputType(input) {\n        if (typeof input === \"string\") {\n            return \"MessageContent\";\n        }\n        else {\n            const firstItem = input[0];\n            if (Object.hasOwn(firstItem, \"content\")) {\n                return \"BaseMessageArray\";\n            }\n            else {\n                return \"MessageContent\";\n            }\n        }\n    }\n    async function formatMessageContents(input, _parameters) {\n        const parts = await messageContentToParts(input);\n        const contents = [\n            {\n                role: \"user\",\n                parts,\n            },\n        ];\n        return contents;\n    }\n    async function formatBaseMessageContents(input, _parameters) {\n        const inputPromises = input.map((msg, i) => baseMessageToContent(msg, input[i - 1]));\n        const inputs = await Promise.all(inputPromises);\n        return inputs.reduce((acc, cur) => {\n            // Filter out the system content\n            if (cur.every((content) => content.role === \"system\")) {\n                return acc;\n            }\n            // Combine adjacent function messages\n            if (cur[0]?.role === \"function\" &&\n                acc.length > 0 &&\n                acc[acc.length - 1].role === \"function\") {\n                acc[acc.length - 1].parts = [\n                    ...acc[acc.length - 1].parts,\n                    ...cur[0].parts,\n                ];\n            }\n            else {\n                acc.push(...cur);\n            }\n            return acc;\n        }, []);\n    }\n    async function formatContents(input, parameters) {\n        const it = inputType(input);\n        switch (it) {\n            case \"MessageContent\":\n                return formatMessageContents(input, parameters);\n            case \"BaseMessageArray\":\n                return formatBaseMessageContents(input, parameters);\n            default:\n                throw new Error(`Unknown input type \"${it}\": ${input}`);\n        }\n    }\n    function formatGenerationConfig(parameters) {\n        const ret = {\n            temperature: parameters.temperature,\n            topK: parameters.topK,\n            topP: parameters.topP,\n            presencePenalty: parameters.presencePenalty,\n            frequencyPenalty: parameters.frequencyPenalty,\n            maxOutputTokens: parameters.maxOutputTokens,\n            stopSequences: parameters.stopSequences,\n            responseMimeType: parameters.responseMimeType,\n        };\n        // Add the logprobs if explicitly set\n        if (typeof parameters.logprobs !== \"undefined\") {\n            ret.responseLogprobs = parameters.logprobs;\n            if (parameters.logprobs &&\n                typeof parameters.topLogprobs !== \"undefined\") {\n                ret.logprobs = parameters.topLogprobs;\n            }\n        }\n        return ret;\n    }\n    function formatSafetySettings(parameters) {\n        return parameters.safetySettings ?? [];\n    }\n    async function formatBaseMessageSystemInstruction(input) {\n        let ret = {};\n        for (let index = 0; index < input.length; index += 1) {\n            const message = input[index];\n            if (message._getType() === \"system\") {\n                // For system types, we only want it if it is the first message,\n                // if it appears anywhere else, it should be an error.\n                if (index === 0) {\n                    // eslint-disable-next-line prefer-destructuring\n                    ret = (await baseMessageToContent(message, undefined))[0];\n                }\n                else {\n                    throw new Error(\"System messages are only permitted as the first passed message.\");\n                }\n            }\n        }\n        return ret;\n    }\n    async function formatSystemInstruction(input) {\n        if (!config?.useSystemInstruction) {\n            return {};\n        }\n        const it = inputType(input);\n        switch (it) {\n            case \"BaseMessageArray\":\n                return formatBaseMessageSystemInstruction(input);\n            default:\n                return {};\n        }\n    }\n    function structuredToolToFunctionDeclaration(tool) {\n        const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);\n        return {\n            name: tool.name,\n            description: tool.description ?? `A function available to call.`,\n            parameters: jsonSchema,\n        };\n    }\n    function searchToolName(tool) {\n        for (const name of types_js_1.GeminiSearchToolAttributes) {\n            if (name in tool) {\n                return name;\n            }\n        }\n        return undefined;\n    }\n    function cleanGeminiTool(tool) {\n        const orig = searchToolName(tool);\n        const adj = config?.googleSearchToolAdjustment;\n        if (orig && adj && adj !== orig) {\n            return {\n                [adj]: {},\n            };\n        }\n        else {\n            return tool;\n        }\n    }\n    function formatTools(parameters) {\n        const tools = parameters?.tools;\n        if (!tools || tools.length === 0) {\n            return [];\n        }\n        // Group all LangChain tools into a single functionDeclarations array.\n        // Gemini Tools may be normalized to different tool names\n        const langChainTools = [];\n        const otherTools = [];\n        tools.forEach((tool) => {\n            if ((0, function_calling_1.isLangChainTool)(tool)) {\n                langChainTools.push(tool);\n            }\n            else {\n                otherTools.push(cleanGeminiTool(tool));\n            }\n        });\n        const result = [...otherTools];\n        if (langChainTools.length > 0) {\n            result.push({\n                functionDeclarations: langChainTools.map(structuredToolToFunctionDeclaration),\n            });\n        }\n        return result;\n    }\n    function formatToolConfig(parameters) {\n        if (!parameters.tool_choice || typeof parameters.tool_choice !== \"string\") {\n            return undefined;\n        }\n        if ([\"auto\", \"any\", \"none\"].includes(parameters.tool_choice)) {\n            return {\n                functionCallingConfig: {\n                    mode: parameters.tool_choice,\n                    allowedFunctionNames: parameters.allowed_function_names,\n                },\n            };\n        }\n        // force tool choice to be a single function name in case of structured output\n        return {\n            functionCallingConfig: {\n                mode: \"any\",\n                allowedFunctionNames: [parameters.tool_choice],\n            },\n        };\n    }\n    async function formatData(input, parameters) {\n        const typedInput = input;\n        const contents = await formatContents(typedInput, parameters);\n        const generationConfig = formatGenerationConfig(parameters);\n        const tools = formatTools(parameters);\n        const toolConfig = formatToolConfig(parameters);\n        const safetySettings = formatSafetySettings(parameters);\n        const systemInstruction = await formatSystemInstruction(typedInput);\n        const ret = {\n            contents,\n            generationConfig,\n        };\n        if (tools && tools.length) {\n            ret.tools = tools;\n        }\n        if (toolConfig) {\n            ret.toolConfig = toolConfig;\n        }\n        if (safetySettings && safetySettings.length) {\n            ret.safetySettings = safetySettings;\n        }\n        if (systemInstruction?.role &&\n            systemInstruction?.parts &&\n            systemInstruction?.parts?.length) {\n            ret.systemInstruction = systemInstruction;\n        }\n        return ret;\n    }\n    return {\n        messageContentToParts,\n        baseMessageToContent,\n        responseToString: safeResponseToString,\n        responseToChatGeneration: safeResponseToChatGeneration,\n        chunkToString,\n        responseToBaseMessage: safeResponseToBaseMessage,\n        responseToChatResult: safeResponseToChatResult,\n        formatData,\n    };\n}\nexports.getGeminiAPI = getGeminiAPI;\nfunction validateGeminiParams(params) {\n    if (params.maxOutputTokens && params.maxOutputTokens < 0) {\n        throw new Error(\"`maxOutputTokens` must be a positive integer\");\n    }\n    if (params.temperature &&\n        (params.temperature < 0 || params.temperature > 2)) {\n        throw new Error(\"`temperature` must be in the range of [0.0,2.0]\");\n    }\n    if (params.topP && (params.topP < 0 || params.topP > 1)) {\n        throw new Error(\"`topP` must be in the range of [0.0,1.0]\");\n    }\n    if (params.topK && params.topK < 0) {\n        throw new Error(\"`topK` must be a positive integer\");\n    }\n}\nexports.validateGeminiParams = validateGeminiParams;\nfunction isModelGemini(modelName) {\n    return modelName.toLowerCase().startsWith(\"gemini\");\n}\nexports.isModelGemini = isModelGemini;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvZ2VtaW5pLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyxrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDckosZUFBZSxtQkFBTyxDQUFDLG9HQUFNO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLG1GQUEwQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBeUI7QUFDbkQsMkJBQTJCLG1CQUFPLENBQUMsK0dBQXdDO0FBQzNFLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFjO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFjO0FBQ3pDLHNDQUFzQyxtQkFBTyxDQUFDLDZIQUFnQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixZQUFZO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGFBQWE7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYSx3REFBd0QsUUFBUTtBQUNsSTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCLFNBQVMscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsR0FBRyxLQUFLLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9nZW1pbmkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc01vZGVsR2VtaW5pID0gZXhwb3J0cy52YWxpZGF0ZUdlbWluaVBhcmFtcyA9IGV4cG9ydHMuZ2V0R2VtaW5pQVBJID0gZXhwb3J0cy5NZXNzYWdlR2VtaW5pU2FmZXR5SGFuZGxlciA9IGV4cG9ydHMuRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCIpO1xuY29uc3Qgb3V0cHV0c18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCIpO1xuY29uc3QgZnVuY3Rpb25fY2FsbGluZ18xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vY29yZS91dGlscy9mdW5jdGlvbl9jYWxsaW5nXCIpO1xuY29uc3Qgc2FmZXR5X2pzXzEgPSByZXF1aXJlKFwiLi9zYWZldHkuY2pzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5janNcIik7XG5jb25zdCB6b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnNfanNfMSA9IHJlcXVpcmUoXCIuL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janNcIik7XG5jbGFzcyBEZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JGaW5pc2hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcIlNBRkVUWVwiLCBcIlJFQ0lUQVRJT05cIiwgXCJPVEhFUlwiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lcnJvckZpbmlzaCA9IHNldHRpbmdzPy5lcnJvckZpbmlzaCA/PyB0aGlzLmVycm9yRmluaXNoO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhUHJvbXB0RmVlZGJhY2socmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG91ciBwcm9tcHQgd2FzIGJsb2NrZWQgaW4gdGhlIGZpcnN0IHBsYWNlXG4gICAgICAgIGNvbnN0IHByb21wdEZlZWRiYWNrID0gZGF0YT8ucHJvbXB0RmVlZGJhY2s7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVhc29uID0gcHJvbXB0RmVlZGJhY2s/LmJsb2NrUmVhc29uO1xuICAgICAgICBpZiAoYmxvY2tSZWFzb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzYWZldHlfanNfMS5Hb29nbGVBSVNhZmV0eUVycm9yKHJlc3BvbnNlLCBgUHJvbXB0IGJsb2NrZWQ6ICR7YmxvY2tSZWFzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGhhbmRsZURhdGFGaW5pc2hSZWFzb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDYW5kaWRhdGUgPSBkYXRhPy5jYW5kaWRhdGVzPy5bMF07XG4gICAgICAgIGNvbnN0IGZpbmlzaFJlYXNvbiA9IGZpcnN0Q2FuZGlkYXRlPy5maW5pc2hSZWFzb247XG4gICAgICAgIGlmICh0aGlzLmVycm9yRmluaXNoLmluY2x1ZGVzKGZpbmlzaFJlYXNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzYWZldHlfanNfMS5Hb29nbGVBSVNhZmV0eUVycm9yKHJlc3BvbnNlLCBgRmluaXNoIHJlYXNvbjogJHtmaW5pc2hSZWFzb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGhhbmRsZURhdGEocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgbGV0IHJldCA9IGRhdGE7XG4gICAgICAgIHJldCA9IHRoaXMuaGFuZGxlRGF0YVByb21wdEZlZWRiYWNrKHJlc3BvbnNlLCByZXQpO1xuICAgICAgICByZXQgPSB0aGlzLmhhbmRsZURhdGFGaW5pc2hSZWFzb24ocmVzcG9uc2UsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGhhbmRsZShyZXNwb25zZSkge1xuICAgICAgICBsZXQgbmV3ZGF0YTtcbiAgICAgICAgaWYgKFwibmV4dENodW5rXCIgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIHN0cmVhbS4gSG93IHRvIGhhbmRsZT9cbiAgICAgICAgICAgIG5ld2RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFycmF5LCB0cnkgdG8gaGFuZGxlIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld2RhdGEgPSByZXNwb25zZS5kYXRhLm1hcCgoaXRlbSkgPT4gdGhpcy5oYW5kbGVEYXRhKHJlc3BvbnNlLCBpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoeHgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgaWYgKHh4IGluc3RhbmNlb2Ygc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2FmZXR5X2pzXzEuR29vZ2xlQUlTYWZldHlFcnJvcihyZXNwb25zZSwgeHgubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB4eDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIG5ld2RhdGEgPSB0aGlzLmhhbmRsZURhdGEocmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgIGRhdGE6IG5ld2RhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciA9IERlZmF1bHRHZW1pbmlTYWZldHlIYW5kbGVyO1xuY2xhc3MgTWVzc2FnZUdlbWluaVNhZmV0eUhhbmRsZXIgZXh0ZW5kcyBEZWZhdWx0R2VtaW5pU2FmZXR5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtc2dcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvcmNlTmV3TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXNnID0gc2V0dGluZ3M/Lm1zZyA/PyB0aGlzLm1zZztcbiAgICAgICAgdGhpcy5mb3JjZU5ld01lc3NhZ2UgPSBzZXR0aW5ncz8uZm9yY2VOZXdNZXNzYWdlID8/IHRoaXMuZm9yY2VOZXdNZXNzYWdlO1xuICAgIH1cbiAgICBzZXRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VOZXdNZXNzYWdlIHx8XG4gICAgICAgICAgICAhZGF0YT8uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQuY2FuZGlkYXRlcyA9IGRhdGEuY2FuZGlkYXRlcyA/PyBbXTtcbiAgICAgICAgICAgIHJldC5jYW5kaWRhdGVzWzBdID0gZGF0YS5jYW5kaWRhdGVzWzBdID8/IHt9O1xuICAgICAgICAgICAgcmV0LmNhbmRpZGF0ZXNbMF0uY29udGVudCA9IGRhdGEuY2FuZGlkYXRlc1swXS5jb250ZW50ID8/IHt9O1xuICAgICAgICAgICAgcmV0LmNhbmRpZGF0ZXNbMF0uY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICByb2xlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgcGFydHM6IFt7IHRleHQ6IHRoaXMubXNnIH1dLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBoYW5kbGVEYXRhKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuaGFuZGxlRGF0YShyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXNzYWdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlR2VtaW5pU2FmZXR5SGFuZGxlciA9IE1lc3NhZ2VHZW1pbmlTYWZldHlIYW5kbGVyO1xuY29uc3QgZXh0cmFjdE1pbWVUeXBlID0gKHN0cikgPT4ge1xuICAgIGlmIChzdHIuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW1lVHlwZTogc3RyLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF0sXG4gICAgICAgICAgICBkYXRhOiBzdHIuc3BsaXQoXCIsXCIpWzFdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5mdW5jdGlvbiBnZXRHZW1pbmlBUEkoY29uZmlnKSB7XG4gICAgZnVuY3Rpb24gbWVzc2FnZUNvbnRlbnRUZXh0KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQ/LnRleHQgJiYgY29udGVudD8udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQudGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXNzYWdlQ29udGVudEltYWdlVXJsKGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIGNvbnRlbnQuaW1hZ2VfdXJsID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGNvbnRlbnQuaW1hZ2VfdXJsXG4gICAgICAgICAgICA6IGNvbnRlbnQuaW1hZ2VfdXJsLnVybDtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgSW1hZ2UgVVJMXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlQW5kRGF0YSA9IGV4dHJhY3RNaW1lVHlwZSh1cmwpO1xuICAgICAgICBpZiAobWltZVR5cGVBbmREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZURhdGE6IG1pbWVUeXBlQW5kRGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRSAtIG5lZWQgc29tZSB3YXkgdG8gZ2V0IG1pbWUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIixcbiAgICAgICAgICAgICAgICAgICAgZmlsZVVyaTogdXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGJsb2JUb0ZpbGVEYXRhKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICAgICAgZmlsZVVyaTogYmxvYi5wYXRoLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBibG9iLm1pbWV0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmlsZVVyaUNvbnRlbnRUb0Jsb2IodXJpKSB7XG4gICAgICAgIHJldHVybiBjb25maWc/Lm1lZGlhTWFuYWdlcj8uZ2V0TWVkaWFCbG9iKHVyaSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50TWVkaWEoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb250ZW50KSB7XG4gICAgICAgIGlmIChcIm1pbWVUeXBlXCIgaW4gY29udGVudCAmJiBcImRhdGFcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IGNvbnRlbnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbnRlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcIm1pbWVUeXBlXCIgaW4gY29udGVudCAmJiBcImZpbGVVcmlcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBjb250ZW50Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXJpOiBjb250ZW50LmZpbGVVcmksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBjb250ZW50LmZpbGVVcmk7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgZmlsZVVyaUNvbnRlbnRUb0Jsb2IodXJpKTtcbiAgICAgICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGJsb2JUb0ZpbGVEYXRhKGJsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZWRpYSBjb250ZW50OiAke0pTT04uc3RyaW5naWZ5KGNvbnRlbnQsIG51bGwsIDEpfWApO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBtZXNzYWdlQ29udGVudENvbXBsZXhUb1BhcnQoY29udGVudCkge1xuICAgICAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXh0XCIgaW4gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZUNvbnRlbnRUZXh0KGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZV91cmxcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJpbWFnZV91cmxcIiBpbiBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIE1lc3NhZ2VDb250ZW50SW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50SW1hZ2VVcmwoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lZGlhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG1lc3NhZ2VDb250ZW50TWVkaWEoY29udGVudCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBcIiR7Y29udGVudC50eXBlfVwiIHJlY2VpdmVkIHdoaWxlIGNvbnZlcnRpbmcgbWVzc2FnZSB0byBtZXNzYWdlIHBhcnRzOiAke2NvbnRlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29lcmNlIFwiJHtjb250ZW50LnR5cGV9XCIgbWVzc2FnZSBwYXJ0IGludG8gYSBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydHMoY29udGVudCkge1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGNvbnRlbnQubWFwKG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjb250ZW50cyk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIG1lc3NhZ2VDb250ZW50VG9QYXJ0cyhjb250ZW50KSB7XG4gICAgICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSB0ZXh0IHR5cGUgTWVzc2FnZUNvbnRlbnQgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogY29udGVudDtcbiAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgcGFydHMsIGV2ZW4gdGhvc2UgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVzb2x2ZVxuICAgICAgICBjb25zdCBhbGxQYXJ0cyA9IGF3YWl0IG1lc3NhZ2VDb250ZW50Q29tcGxleFRvUGFydHMobWVzc2FnZUNvbnRlbnQpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGludmFsaWQgcGFydHNcbiAgICAgICAgY29uc3QgcGFydHMgPSBhbGxQYXJ0cy5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHZhbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVzc2FnZVRvb2xDYWxsc1RvUGFydHModG9vbENhbGxzKSB7XG4gICAgICAgIGlmICghdG9vbENhbGxzIHx8IHRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vbENhbGxzLm1hcCgodG9vbCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGlmICh0b29sPy5mdW5jdGlvbj8uYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnU3RyID0gdG9vbC5mdW5jdGlvbi5hcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgYXJncyA9IEpTT04ucGFyc2UoYXJnU3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lc3NhZ2VLd2FyZ3NUb1BhcnRzKGt3YXJncykge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgaWYgKGt3YXJncz8udG9vbF9jYWxscykge1xuICAgICAgICAgICAgcmV0LnB1c2goLi4ubWVzc2FnZVRvb2xDYWxsc1RvUGFydHMoa3dhcmdzLnRvb2xfY2FsbHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiByb2xlTWVzc2FnZVRvQ29udGVudChyb2xlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRQYXJ0cyA9IGF3YWl0IG1lc3NhZ2VDb250ZW50VG9QYXJ0cyhtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICBsZXQgdG9vbFBhcnRzO1xuICAgICAgICBpZiAoKDAsIG1lc3NhZ2VzXzEuaXNBSU1lc3NhZ2UpKG1lc3NhZ2UpICYmICEhbWVzc2FnZS50b29sX2NhbGxzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvb2xQYXJ0cyA9IG1lc3NhZ2UudG9vbF9jYWxscy5tYXAoKHRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbDoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sUGFydHMgPSBtZXNzYWdlS3dhcmdzVG9QYXJ0cyhtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IFsuLi5jb250ZW50UGFydHMsIC4uLnRvb2xQYXJ0c107XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHN5c3RlbU1lc3NhZ2VUb0NvbnRlbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY29uZmlnPy51c2VTeXN0ZW1JbnN0cnVjdGlvblxuICAgICAgICAgICAgPyByb2xlTWVzc2FnZVRvQ29udGVudChcInN5c3RlbVwiLCBtZXNzYWdlKVxuICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IHJvbGVNZXNzYWdlVG9Db250ZW50KFwidXNlclwiLCBtZXNzYWdlKSksXG4gICAgICAgICAgICAgICAgLi4uKGF3YWl0IHJvbGVNZXNzYWdlVG9Db250ZW50KFwibW9kZWxcIiwgbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlKFwiT2tcIikpKSxcbiAgICAgICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvb2xNZXNzYWdlVG9Db250ZW50KG1lc3NhZ2UsIHByZXZNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRTdHIgPSB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgICAgOiBtZXNzYWdlLmNvbnRlbnQucmVkdWNlKChhY2MsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgY29udGVudC50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgLy8gSGFja3kgOihcbiAgICAgICAgY29uc3QgcmVzcG9uc2VOYW1lID0gKCgwLCBtZXNzYWdlc18xLmlzQUlNZXNzYWdlKShwcmV2TWVzc2FnZSkgJiYgISFwcmV2TWVzc2FnZS50b29sX2NhbGxzPy5sZW5ndGhcbiAgICAgICAgICAgID8gcHJldk1lc3NhZ2UudG9vbF9jYWxsc1swXS5uYW1lXG4gICAgICAgICAgICA6IHByZXZNZXNzYWdlLm5hbWUpID8/IG1lc3NhZ2UudG9vbF9jYWxsX2lkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoY29udGVudFN0cik7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVzcG9uc2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogeyBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZXNwb25zZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7IGNvbnRlbnQ6IGNvbnRlbnRTdHIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBiYXNlTWVzc2FnZVRvQ29udGVudChtZXNzYWdlLCBwcmV2TWVzc2FnZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzeXN0ZW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtTWVzc2FnZVRvQ29udGVudChtZXNzYWdlKTtcbiAgICAgICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiByb2xlTWVzc2FnZVRvQ29udGVudChcInVzZXJcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlIFwiYWlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9sZU1lc3NhZ2VUb0NvbnRlbnQoXCJtb2RlbFwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29sIG1lc3NhZ2VzIGNhbm5vdCBiZSB0aGUgZmlyc3QgbWVzc2FnZSBwYXNzZWQgdG8gdGhlIG1vZGVsLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xNZXNzYWdlVG9Db250ZW50KG1lc3NhZ2UsIHByZXZNZXNzYWdlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXh0UGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlubGluZURhdGFQYXJ0VG9NZXNzYWdlQ29udGVudChwYXJ0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgaW1hZ2VfdXJsOiBgZGF0YToke3BhcnQuaW5saW5lRGF0YS5taW1lVHlwZX07YmFzZTY0LCR7cGFydC5pbmxpbmVEYXRhLmRhdGF9YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmlsZURhdGFQYXJ0VG9NZXNzYWdlQ29udGVudChwYXJ0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgaW1hZ2VfdXJsOiBwYXJ0LmZpbGVEYXRhLmZpbGVVcmksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRzVG9NZXNzYWdlQ29udGVudChwYXJ0cykge1xuICAgICAgICByZXR1cm4gcGFydHNcbiAgICAgICAgICAgIC5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSB1bmRlZmluZWQgfHwgcGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ0ZXh0XCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0UGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcImlubGluZURhdGFcIiBpbiBwYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZURhdGFQYXJ0VG9NZXNzYWdlQ29udGVudChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwiZmlsZURhdGFcIiBpbiBwYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVEYXRhUGFydFRvTWVzc2FnZUNvbnRlbnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY29udGVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9vbFJhd1RvVG9vbChyYXcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiByYXcuaWQsXG4gICAgICAgICAgICB0eXBlOiByYXcudHlwZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcmF3LmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShyYXcuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFBhcnRUb1Rvb2xSYXcocGFydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6ICgwLCB1dWlkXzEudjQpKCkucmVwbGFjZSgvLS9nLCBcIlwiKSxcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFydC5mdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHBhcnQuZnVuY3Rpb25DYWxsLmFyZ3MgPz8ge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0c1RvVG9vbHNSYXcocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzXG4gICAgICAgICAgICAubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwiZnVuY3Rpb25DYWxsXCIgaW4gcGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxQYXJ0VG9Ub29sUmF3KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGNvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvb2xzUmF3VG9Ub29scyhyYXdzKSB7XG4gICAgICAgIHJldHVybiByYXdzLm1hcCgocmF3KSA9PiB0b29sUmF3VG9Ub29sKHJhdykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvR2VuZXJhdGVDb250ZW50UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChcIm5leHRDaHVua1wiIGluIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFN0cmVhbSB0byBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZURhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5kYXRhKSkge1xuICAgICAgICAgICAgLy8gQ29sbGFwc2UgdGhlIGFycmF5IG9mIHJlc3BvbnNlIGRhdGEgYXMgaWYgaXQgd2FzIGEgc2luZ2xlIG9uZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEucmVkdWNlKChhY2MsIHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIHBhcnRzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEhhbmRsZSBvdGhlciBjYW5kaWRhdGVzP1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbFBhcnRzID0gdmFsPy5jYW5kaWRhdGVzPy5bMF0/LmNvbnRlbnQ/LnBhcnRzID8/IFtdO1xuICAgICAgICAgICAgICAgIGFjYy5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHMucHVzaCguLi52YWxQYXJ0cyk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IE1lcmdlIHByb21wdEZlZWRiYWNrIGFuZCBzYWZldHkgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBhY2MucHJvbXB0RmVlZGJhY2sgPSB2YWwucHJvbXB0RmVlZGJhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb1BhcnRzKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlVG9HZW5lcmF0ZUNvbnRlbnRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlRGF0YT8uY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cyA/PyBbXTtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0VG9UZXh0KHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIFwidGV4dFwiIGluIHBhcnQgPyBwYXJ0LnRleHQgOiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvU3RyaW5nKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcmVzcG9uc2VUb1BhcnRzKHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gcGFydHMucmVkdWNlKChhY2MsIHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHBhcnRUb1RleHQocGFydCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgdmFsO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZVJlc3BvbnNlVG8ocmVzcG9uc2UsIHJlc3BvbnNlVG8pIHtcbiAgICAgICAgY29uc3Qgc2FmZXR5SGFuZGxlciA9IGNvbmZpZz8uc2FmZXR5SGFuZGxlciA/PyBuZXcgRGVmYXVsdEdlbWluaVNhZmV0eUhhbmRsZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNhZmVSZXNwb25zZSA9IHNhZmV0eUhhbmRsZXIuaGFuZGxlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVRvKHNhZmVSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoeHggaW5zdGFuY2VvZiBzYWZldHlfanNfMS5Hb29nbGVBSVNhZmV0eUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gcmVzcG9uc2VUbyh4eC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgeHgucmVwbHkgPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB4eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb1N0cmluZyhyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gc2FmZVJlc3BvbnNlVG8ocmVzcG9uc2UsIHJlc3BvbnNlVG9TdHJpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dwcm9iUmVzdWx0VG9Mb2dwcm9iKHJlc3VsdCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHJlc3VsdD8udG9rZW47XG4gICAgICAgIGNvbnN0IGxvZ3Byb2IgPSByZXN1bHQ/LmxvZ1Byb2JhYmlsaXR5O1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQXJyYXkuZnJvbShlbmNvZGVyLmVuY29kZSh0b2tlbikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBsb2dwcm9iLFxuICAgICAgICAgICAgYnl0ZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmRpZGF0ZVRvTG9ncHJvYnMoY2FuZGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IGxvZ3Byb2JzID0gY2FuZGlkYXRlPy5sb2dwcm9ic1Jlc3VsdDtcbiAgICAgICAgY29uc3QgY2hvc2VuVG9rZW5zID0gbG9ncHJvYnM/LmNob3NlbkNhbmRpZGF0ZXMgPz8gW107XG4gICAgICAgIGNvbnN0IHRvcFRva2VucyA9IGxvZ3Byb2JzPy50b3BDYW5kaWRhdGVzID8/IFtdO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgIGZvciAobGV0IGNvID0gMDsgY28gPCBjaG9zZW5Ub2tlbnMubGVuZ3RoOyBjbyArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjaG9zZW4gPSBjaG9zZW5Ub2tlbnNbY29dO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdG9wVG9rZW5zW2NvXT8uY2FuZGlkYXRlcyA/PyBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3Byb2IgPSBsb2dwcm9iUmVzdWx0VG9Mb2dwcm9iKGNob3Nlbik7XG4gICAgICAgICAgICBsb2dwcm9iLnRvcF9sb2dwcm9icyA9IHRvcC5tYXAoKGwpID0+IGxvZ3Byb2JSZXN1bHRUb0xvZ3Byb2IobCkpO1xuICAgICAgICAgICAgY29udGVudC5wdXNoKGxvZ3Byb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvR2VuZXJhdGlvbkluZm8ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGFbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIHByb21wdF90b2tlbl9jb3VudDogZGF0YS51c2FnZU1ldGFkYXRhPy5wcm9tcHRUb2tlbkNvdW50LFxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXNfdG9rZW5fY291bnQ6IGRhdGEudXNhZ2VNZXRhZGF0YT8uY2FuZGlkYXRlc1Rva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgdG90YWxfdG9rZW5fY291bnQ6IGRhdGEudXNhZ2VNZXRhZGF0YT8udG90YWxUb2tlbkNvdW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhZmV0eV9yYXRpbmdzOiBkYXRhLmNhbmRpZGF0ZXNbMF0/LnNhZmV0eVJhdGluZ3M/Lm1hcCgocmF0aW5nKSA9PiAoe1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiByYXRpbmcuY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgcHJvYmFiaWxpdHk6IHJhdGluZy5wcm9iYWJpbGl0eSxcbiAgICAgICAgICAgICAgICBwcm9iYWJpbGl0eV9zY29yZTogcmF0aW5nLnByb2JhYmlsaXR5U2NvcmUsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IHJhdGluZy5zZXZlcml0eSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eV9zY29yZTogcmF0aW5nLnNldmVyaXR5U2NvcmUsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBjaXRhdGlvbl9tZXRhZGF0YTogZGF0YS5jYW5kaWRhdGVzWzBdPy5jaXRhdGlvbk1ldGFkYXRhLFxuICAgICAgICAgICAgZ3JvdW5kaW5nX21ldGFkYXRhOiBkYXRhLmNhbmRpZGF0ZXNbMF0/Lmdyb3VuZGluZ01ldGFkYXRhLFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogZGF0YS5jYW5kaWRhdGVzWzBdPy5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBhdmdMb2dwcm9iczogZGF0YS5jYW5kaWRhdGVzWzBdPy5hdmdMb2dwcm9icyxcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjYW5kaWRhdGVUb0xvZ3Byb2JzKGRhdGEuY2FuZGlkYXRlc1swXSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gbmV3IG91dHB1dHNfMS5DaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHJlc3BvbnNlVG9TdHJpbmcocmVzcG9uc2UpLFxuICAgICAgICAgICAgbWVzc2FnZTogcGFydFRvTWVzc2FnZUNodW5rKHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSlbMF0pLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHJlc3BvbnNlVG9HZW5lcmF0aW9uSW5mbyhyZXNwb25zZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBzYWZlUmVzcG9uc2VUbyhyZXNwb25zZSwgcmVzcG9uc2VUb0NoYXRHZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2h1bmtUb1N0cmluZyhjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsuY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmNvbnRlbnRbMF0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaHVuazogJHtjaHVua31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0VG9NZXNzYWdlQ2h1bmsocGFydCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBwYXJ0c1RvQmFzZU1lc3NhZ2VDaHVua0ZpZWxkcyhbcGFydF0pO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZHMuY29udGVudC5ldmVyeSgoaXRlbSkgPT4gaXRlbS50eXBlID09PSBcInRleHRcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBmaWVsZHMuY29udGVudFxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IChcInRleHRcIiBpbiBpdGVtID8gaXRlbS50ZXh0IDogXCJcIikpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VzXzEuQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBuZXdDb250ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKGZpZWxkcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRUb0NoYXRHZW5lcmF0aW9uKHBhcnQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnRUb01lc3NhZ2VDaHVuayhwYXJ0KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IHBhcnRUb1RleHQocGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgb3V0cHV0c18xLkNoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncm91bmRpbmdTdXBwb3J0QnlQYXJ0KGdyb3VuZGluZ1N1cHBvcnRzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBpZiAoIWdyb3VuZGluZ1N1cHBvcnRzIHx8IGdyb3VuZGluZ1N1cHBvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VuZGluZ1N1cHBvcnRzPy5mb3JFYWNoKChncm91bmRpbmdTdXBwb3J0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gZ3JvdW5kaW5nU3VwcG9ydD8uc2VnbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHNlZ21lbnQ/LnBhcnRJbmRleCA/PyAwO1xuICAgICAgICAgICAgaWYgKHJldFtwYXJ0SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0W3BhcnRJbmRleF0ucHVzaChncm91bmRpbmdTdXBwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldFtwYXJ0SW5kZXhdID0gW2dyb3VuZGluZ1N1cHBvcnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0dyb3VuZGVkQ2hhdEdlbmVyYXRpb25zKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcmVzcG9uc2VUb1BhcnRzKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENpdGF0aW9uIGFuZCBncm91bmRpbmcgaW5mb3JtYXRpb24gY29ubmVjdGVkIHRvIGVhY2ggcGFydCAvIENoYXRHZW5lcmF0aW9uXG4gICAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBhdmFpbGFibGUgaW4gZG93bnN0cmVhbSBmaWx0ZXJzLlxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSByZXNwb25zZT8uZGF0YVxuICAgICAgICAgICAgPy5jYW5kaWRhdGVzPy5bMF07XG4gICAgICAgIGNvbnN0IGdyb3VuZGluZ01ldGFkYXRhID0gY2FuZGlkYXRlPy5ncm91bmRpbmdNZXRhZGF0YTtcbiAgICAgICAgY29uc3QgY2l0YXRpb25NZXRhZGF0YSA9IGNhbmRpZGF0ZT8uY2l0YXRpb25NZXRhZGF0YTtcbiAgICAgICAgY29uc3QgZ3JvdW5kaW5nUGFydHMgPSBncm91bmRpbmdTdXBwb3J0QnlQYXJ0KGdyb3VuZGluZ01ldGFkYXRhPy5ncm91bmRpbmdTdXBwb3J0cyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdlbiA9IHBhcnRUb0NoYXRHZW5lcmF0aW9uKHBhcnQpO1xuICAgICAgICAgICAgaWYgKCFnZW4uZ2VuZXJhdGlvbkluZm8pIHtcbiAgICAgICAgICAgICAgICBnZW4uZ2VuZXJhdGlvbkluZm8gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncm91bmRpbmdNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGdlbi5nZW5lcmF0aW9uSW5mby5ncm91bmRpbmdNZXRhZGF0YSA9IGdyb3VuZGluZ01ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VuZGluZ1BhcnQgPSBncm91bmRpbmdQYXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VuZGluZ1BhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmdlbmVyYXRpb25JbmZvLmdyb3VuZGluZ1N1cHBvcnQgPSBncm91bmRpbmdQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaXRhdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmdlbmVyYXRpb25JbmZvLmNpdGF0aW9uTWV0YWRhdGEgPSBjaXRhdGlvbk1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9DaGF0R2VuZXJhdGlvbnMocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHJldCA9IHJlc3BvbnNlVG9Hcm91bmRlZENoYXRHZW5lcmF0aW9ucyhyZXNwb25zZSk7XG4gICAgICAgIGlmIChyZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldC5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0ubWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRDb250ZW50ID0gcmV0Lm1hcCgoaXRlbSkgPT4gaXRlbS5tZXNzYWdlLmNvbnRlbnQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFRleHQgPSByZXQubWFwKChpdGVtKSA9PiBpdGVtLnRleHQpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbENodW5rcyA9IHJldFtyZXQubGVuZ3RoIC0gMV0/Lm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3M/LnRvb2xfY2FsbHM/Lm1hcCgodG9vbENhbGwsIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsZXQgdXNhZ2VNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChcInVzYWdlTWV0YWRhdGFcIiBpbiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdXNhZ2VNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiByZXNwb25zZS5kYXRhLnVzYWdlTWV0YWRhdGEucHJvbXB0VG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogcmVzcG9uc2UuZGF0YS51c2FnZU1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FuZGlkYXRlc1Rva2VuQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogcmVzcG9uc2UuZGF0YS51c2FnZU1ldGFkYXRhLnRvdGFsVG9rZW5Db3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gW1xuICAgICAgICAgICAgICAgIG5ldyBvdXRwdXRzXzEuQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbWJpbmVkQ29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiByZXRbcmV0Lmxlbmd0aCAtIDFdPy5tZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2NodW5rczogdG9vbENhbGxDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbWJpbmVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHJldFtyZXQubGVuZ3RoIC0gMV0uZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBsb2dwcm9icyBpbmZvcm1hdGlvbiB0byB0aGUgbWVzc2FnZVxuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSByZXNwb25zZT8uZGF0YVxuICAgICAgICAgICAgPy5jYW5kaWRhdGVzPy5bMF07XG4gICAgICAgIGNvbnN0IGF2Z0xvZ3Byb2JzID0gY2FuZGlkYXRlPy5hdmdMb2dwcm9icztcbiAgICAgICAgY29uc3QgbG9ncHJvYnMgPSBjYW5kaWRhdGVUb0xvZ3Byb2JzKGNhbmRpZGF0ZSk7XG4gICAgICAgIGlmIChsb2dwcm9icykge1xuICAgICAgICAgICAgcmV0WzBdLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmV0WzBdLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnMsXG4gICAgICAgICAgICAgICAgYXZnTG9ncHJvYnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlVG9CYXNlTWVzc2FnZUZpZWxkcyhyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJlc3BvbnNlVG9QYXJ0cyhyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBwYXJ0c1RvQmFzZU1lc3NhZ2VDaHVua0ZpZWxkcyhwYXJ0cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRzVG9CYXNlTWVzc2FnZUNodW5rRmllbGRzKHBhcnRzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnRzVG9NZXNzYWdlQ29udGVudChwYXJ0cyksXG4gICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmF3VG9vbHMgPSBwYXJ0c1RvVG9vbHNSYXcocGFydHMpO1xuICAgICAgICBpZiAocmF3VG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbHMgPSB0b29sc1Jhd1RvVG9vbHMocmF3VG9vbHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnRvb2xfY2FsbF9jaHVua3M/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sX2NhbGxfY2h1bmtcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMudG9vbF9jYWxscz8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLmludmFsaWRfdG9vbF9jYWxscz8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZF90b29sX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzID0ge1xuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNwb25zZVRvQmFzZU1lc3NhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gcmVzcG9uc2VUb0Jhc2VNZXNzYWdlRmllbGRzKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXNzYWdlc18xLkFJTWVzc2FnZShmaWVsZHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0Jhc2VNZXNzYWdlKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBzYWZlUmVzcG9uc2VUbyhyZXNwb25zZSwgcmVzcG9uc2VUb0Jhc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2VUb0NoYXRSZXN1bHQocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb25zKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbGxtT3V0cHV0OiByZXNwb25zZVRvR2VuZXJhdGlvbkluZm8ocmVzcG9uc2UpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlUmVzcG9uc2VUb0NoYXRSZXN1bHQocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVSZXNwb25zZVRvKHJlc3BvbnNlLCByZXNwb25zZVRvQ2hhdFJlc3VsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlucHV0VHlwZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlQ29udGVudFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtID0gaW5wdXRbMF07XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihmaXJzdEl0ZW0sIFwiY29udGVudFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkJhc2VNZXNzYWdlQXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2VDb250ZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZUNvbnRlbnRzKGlucHV0LCBfcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IG1lc3NhZ2VDb250ZW50VG9QYXJ0cyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmb3JtYXRCYXNlTWVzc2FnZUNvbnRlbnRzKGlucHV0LCBfcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBpbnB1dFByb21pc2VzID0gaW5wdXQubWFwKChtc2csIGkpID0+IGJhc2VNZXNzYWdlVG9Db250ZW50KG1zZywgaW5wdXRbaSAtIDFdKSk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKGlucHV0UHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gaW5wdXRzLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHN5c3RlbSBjb250ZW50XG4gICAgICAgICAgICBpZiAoY3VyLmV2ZXJ5KChjb250ZW50KSA9PiBjb250ZW50LnJvbGUgPT09IFwic3lzdGVtXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbWJpbmUgYWRqYWNlbnQgZnVuY3Rpb24gbWVzc2FnZXNcbiAgICAgICAgICAgIGlmIChjdXJbMF0/LnJvbGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGFjYy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgYWNjW2FjYy5sZW5ndGggLSAxXS5yb2xlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBhY2NbYWNjLmxlbmd0aCAtIDFdLnBhcnRzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2NbYWNjLmxlbmd0aCAtIDFdLnBhcnRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5jdXJbMF0ucGFydHMsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKC4uLmN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZvcm1hdENvbnRlbnRzKGlucHV0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gaW5wdXRUeXBlKGlucHV0KTtcbiAgICAgICAgc3dpdGNoIChpdCkge1xuICAgICAgICAgICAgY2FzZSBcIk1lc3NhZ2VDb250ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2VDb250ZW50cyhpbnB1dCwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBjYXNlIFwiQmFzZU1lc3NhZ2VBcnJheVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRCYXNlTWVzc2FnZUNvbnRlbnRzKGlucHV0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGlucHV0IHR5cGUgXCIke2l0fVwiOiAke2lucHV0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdEdlbmVyYXRpb25Db25maWcocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTogcGFyYW1ldGVycy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgIHRvcEs6IHBhcmFtZXRlcnMudG9wSyxcbiAgICAgICAgICAgIHRvcFA6IHBhcmFtZXRlcnMudG9wUCxcbiAgICAgICAgICAgIHByZXNlbmNlUGVuYWx0eTogcGFyYW1ldGVycy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICBmcmVxdWVuY3lQZW5hbHR5OiBwYXJhbWV0ZXJzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICBtYXhPdXRwdXRUb2tlbnM6IHBhcmFtZXRlcnMubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgc3RvcFNlcXVlbmNlczogcGFyYW1ldGVycy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgcmVzcG9uc2VNaW1lVHlwZTogcGFyYW1ldGVycy5yZXNwb25zZU1pbWVUeXBlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgdGhlIGxvZ3Byb2JzIGlmIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycy5sb2dwcm9icyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0LnJlc3BvbnNlTG9ncHJvYnMgPSBwYXJhbWV0ZXJzLmxvZ3Byb2JzO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMubG9ncHJvYnMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGFyYW1ldGVycy50b3BMb2dwcm9icyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldC5sb2dwcm9icyA9IHBhcmFtZXRlcnMudG9wTG9ncHJvYnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0U2FmZXR5U2V0dGluZ3MocGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zYWZldHlTZXR0aW5ncyA/PyBbXTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZm9ybWF0QmFzZU1lc3NhZ2VTeXN0ZW1JbnN0cnVjdGlvbihpbnB1dCkge1xuICAgICAgICBsZXQgcmV0ID0ge307XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpbnB1dFtpbmRleF07XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5fZ2V0VHlwZSgpID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN5c3RlbSB0eXBlcywgd2Ugb25seSB3YW50IGl0IGlmIGl0IGlzIHRoZSBmaXJzdCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGFwcGVhcnMgYW55d2hlcmUgZWxzZSwgaXQgc2hvdWxkIGJlIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gKGF3YWl0IGJhc2VNZXNzYWdlVG9Db250ZW50KG1lc3NhZ2UsIHVuZGVmaW5lZCkpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIG1lc3NhZ2VzIGFyZSBvbmx5IHBlcm1pdHRlZCBhcyB0aGUgZmlyc3QgcGFzc2VkIG1lc3NhZ2UuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmb3JtYXRTeXN0ZW1JbnN0cnVjdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoIWNvbmZpZz8udXNlU3lzdGVtSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdCA9IGlucHV0VHlwZShpbnB1dCk7XG4gICAgICAgIHN3aXRjaCAoaXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJCYXNlTWVzc2FnZUFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEJhc2VNZXNzYWdlU3lzdGVtSW5zdHJ1Y3Rpb24oaW5wdXQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RydWN0dXJlZFRvb2xUb0Z1bmN0aW9uRGVjbGFyYXRpb24odG9vbCkge1xuICAgICAgICBjb25zdCBqc29uU2NoZW1hID0gKDAsIHpvZF90b19nZW1pbmlfcGFyYW1ldGVyc19qc18xLnpvZFRvR2VtaW5pUGFyYW1ldGVycykodG9vbC5zY2hlbWEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24gPz8gYEEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuYCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlYXJjaFRvb2xOYW1lKHRvb2wpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHR5cGVzX2pzXzEuR2VtaW5pU2VhcmNoVG9vbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHRvb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhbkdlbWluaVRvb2wodG9vbCkge1xuICAgICAgICBjb25zdCBvcmlnID0gc2VhcmNoVG9vbE5hbWUodG9vbCk7XG4gICAgICAgIGNvbnN0IGFkaiA9IGNvbmZpZz8uZ29vZ2xlU2VhcmNoVG9vbEFkanVzdG1lbnQ7XG4gICAgICAgIGlmIChvcmlnICYmIGFkaiAmJiBhZGogIT09IG9yaWcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2Fkal06IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFRvb2xzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBwYXJhbWV0ZXJzPy50b29scztcbiAgICAgICAgaWYgKCF0b29scyB8fCB0b29scy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHcm91cCBhbGwgTGFuZ0NoYWluIHRvb2xzIGludG8gYSBzaW5nbGUgZnVuY3Rpb25EZWNsYXJhdGlvbnMgYXJyYXkuXG4gICAgICAgIC8vIEdlbWluaSBUb29scyBtYXkgYmUgbm9ybWFsaXplZCB0byBkaWZmZXJlbnQgdG9vbCBuYW1lc1xuICAgICAgICBjb25zdCBsYW5nQ2hhaW5Ub29scyA9IFtdO1xuICAgICAgICBjb25zdCBvdGhlclRvb2xzID0gW107XG4gICAgICAgIHRvb2xzLmZvckVhY2goKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgZnVuY3Rpb25fY2FsbGluZ18xLmlzTGFuZ0NoYWluVG9vbCkodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBsYW5nQ2hhaW5Ub29scy5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3RoZXJUb29scy5wdXNoKGNsZWFuR2VtaW5pVG9vbCh0b29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4ub3RoZXJUb29sc107XG4gICAgICAgIGlmIChsYW5nQ2hhaW5Ub29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IGxhbmdDaGFpblRvb2xzLm1hcChzdHJ1Y3R1cmVkVG9vbFRvRnVuY3Rpb25EZWNsYXJhdGlvbiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRUb29sQ29uZmlnKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlIHx8IHR5cGVvZiBwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbXCJhdXRvXCIsIFwiYW55XCIsIFwibm9uZVwiXS5pbmNsdWRlcyhwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogcGFyYW1ldGVycy50b29sX2Nob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IHBhcmFtZXRlcnMuYWxsb3dlZF9mdW5jdGlvbl9uYW1lcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JjZSB0b29sIGNob2ljZSB0byBiZSBhIHNpbmdsZSBmdW5jdGlvbiBuYW1lIGluIGNhc2Ugb2Ygc3RydWN0dXJlZCBvdXRwdXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZzoge1xuICAgICAgICAgICAgICAgIG1vZGU6IFwiYW55XCIsXG4gICAgICAgICAgICAgICAgYWxsb3dlZEZ1bmN0aW9uTmFtZXM6IFtwYXJhbWV0ZXJzLnRvb2xfY2hvaWNlXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZvcm1hdERhdGEoaW5wdXQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdHlwZWRJbnB1dCA9IGlucHV0O1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZvcm1hdENvbnRlbnRzKHR5cGVkSW5wdXQsIHBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9uQ29uZmlnID0gZm9ybWF0R2VuZXJhdGlvbkNvbmZpZyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBmb3JtYXRUb29scyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgdG9vbENvbmZpZyA9IGZvcm1hdFRvb2xDb25maWcocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHNhZmV0eVNldHRpbmdzID0gZm9ybWF0U2FmZXR5U2V0dGluZ3MocGFyYW1ldGVycyk7XG4gICAgICAgIGNvbnN0IHN5c3RlbUluc3RydWN0aW9uID0gYXdhaXQgZm9ybWF0U3lzdGVtSW5zdHJ1Y3Rpb24odHlwZWRJbnB1dCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRvb2xzICYmIHRvb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LnRvb2xzID0gdG9vbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xDb25maWcpIHtcbiAgICAgICAgICAgIHJldC50b29sQ29uZmlnID0gdG9vbENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FmZXR5U2V0dGluZ3MgJiYgc2FmZXR5U2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQuc2FmZXR5U2V0dGluZ3MgPSBzYWZldHlTZXR0aW5ncztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3lzdGVtSW5zdHJ1Y3Rpb24/LnJvbGUgJiZcbiAgICAgICAgICAgIHN5c3RlbUluc3RydWN0aW9uPy5wYXJ0cyAmJlxuICAgICAgICAgICAgc3lzdGVtSW5zdHJ1Y3Rpb24/LnBhcnRzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldC5zeXN0ZW1JbnN0cnVjdGlvbiA9IHN5c3RlbUluc3RydWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50VG9QYXJ0cyxcbiAgICAgICAgYmFzZU1lc3NhZ2VUb0NvbnRlbnQsXG4gICAgICAgIHJlc3BvbnNlVG9TdHJpbmc6IHNhZmVSZXNwb25zZVRvU3RyaW5nLFxuICAgICAgICByZXNwb25zZVRvQ2hhdEdlbmVyYXRpb246IHNhZmVSZXNwb25zZVRvQ2hhdEdlbmVyYXRpb24sXG4gICAgICAgIGNodW5rVG9TdHJpbmcsXG4gICAgICAgIHJlc3BvbnNlVG9CYXNlTWVzc2FnZTogc2FmZVJlc3BvbnNlVG9CYXNlTWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2VUb0NoYXRSZXN1bHQ6IHNhZmVSZXNwb25zZVRvQ2hhdFJlc3VsdCxcbiAgICAgICAgZm9ybWF0RGF0YSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRHZW1pbmlBUEkgPSBnZXRHZW1pbmlBUEk7XG5mdW5jdGlvbiB2YWxpZGF0ZUdlbWluaVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLm1heE91dHB1dFRva2VucyAmJiBwYXJhbXMubWF4T3V0cHV0VG9rZW5zIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbWF4T3V0cHV0VG9rZW5zYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50ZW1wZXJhdHVyZSAmJlxuICAgICAgICAocGFyYW1zLnRlbXBlcmF0dXJlIDwgMCB8fCBwYXJhbXMudGVtcGVyYXR1cmUgPiAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdGVtcGVyYXR1cmVgIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIFswLjAsMi4wXVwiKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy50b3BQICYmIChwYXJhbXMudG9wUCA8IDAgfHwgcGFyYW1zLnRvcFAgPiAxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdG9wUGAgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgWzAuMCwxLjBdXCIpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnRvcEsgJiYgcGFyYW1zLnRvcEsgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB0b3BLYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlR2VtaW5pUGFyYW1zID0gdmFsaWRhdGVHZW1pbmlQYXJhbXM7XG5mdW5jdGlvbiBpc01vZGVsR2VtaW5pKG1vZGVsTmFtZSkge1xuICAgIHJldHVybiBtb2RlbE5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZ2VtaW5pXCIpO1xufVxuZXhwb3J0cy5pc01vZGVsR2VtaW5pID0gaXNNb2RlbEdlbWluaTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/index.cjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./common.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/common.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./failed_handler.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/failed_handler.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./gemini.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/gemini.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./zod_to_gemini_parameters.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./palm.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./safety.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./stream.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMseUdBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsNkhBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMseUZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHlGQUFjIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mYWlsZWRfaGFuZGxlci5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dlbWluaS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3pvZF90b19nZW1pbmlfcGFyYW1ldGVycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhbG0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zYWZldHkuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJlYW0uY2pzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/palm.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvcGFsbS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9kaXN0L3V0aWxzL3BhbG0uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/palm.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/safety.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleAISafetyError = void 0;\nclass GoogleAISafetyError extends Error {\n    constructor(response, message) {\n        super(message);\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"reply\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        this.response = response;\n    }\n}\nexports.GoogleAISafetyError = GoogleAISafetyError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc2FmZXR5LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9zYWZldHkuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVBSVNhZmV0eUVycm9yID0gdm9pZCAwO1xuY2xhc3MgR29vZ2xlQUlTYWZldHlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnRzLkdvb2dsZUFJU2FmZXR5RXJyb3IgPSBHb29nbGVBSVNhZmV0eUVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/safety.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/stream.cjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadableSseJsonStream = exports.SseJsonStream = exports.ReadableSseStream = exports.SseStream = exports.ReadableJsonStream = exports.ReadableAbstractStream = exports.ComplexJsonStream = exports.JsonStream = exports.simpleValue = exports.complexValue = void 0;\nfunction complexValue(value) {\n    if (value === null || typeof value === \"undefined\") {\n        // I dunno what to put here. An error, probably\n        return undefined;\n    }\n    else if (typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            return {\n                list_val: value.map((avalue) => complexValue(avalue)),\n            };\n        }\n        else {\n            const ret = {};\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const v = value;\n            Object.keys(v).forEach((key) => {\n                ret[key] = complexValue(v[key]);\n            });\n            return { struct_val: ret };\n        }\n    }\n    else if (typeof value === \"number\") {\n        if (Number.isInteger(value)) {\n            return { int_val: value };\n        }\n        else {\n            return { float_val: value };\n        }\n    }\n    else {\n        return {\n            string_val: [value],\n        };\n    }\n}\nexports.complexValue = complexValue;\nfunction simpleValue(val) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (val.hasOwnProperty(\"stringVal\")) {\n            return val.stringVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"boolVal\")) {\n            return val.boolVal[0];\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"listVal\")) {\n            const { listVal } = val;\n            return listVal.map((aval) => simpleValue(aval));\n            // eslint-disable-next-line no-prototype-builtins\n        }\n        else if (val.hasOwnProperty(\"structVal\")) {\n            const ret = {};\n            const struct = val.structVal;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n        else {\n            const ret = {};\n            const struct = val;\n            Object.keys(struct).forEach((key) => {\n                ret[key] = simpleValue(struct[key]);\n            });\n            return ret;\n        }\n    }\n    else if (Array.isArray(val)) {\n        return val.map((aval) => simpleValue(aval));\n    }\n    else {\n        return val;\n    }\n}\nexports.simpleValue = simpleValue;\nclass JsonStream {\n    constructor() {\n        Object.defineProperty(this, \"_buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"_bufferOpen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"_firstRun\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set up a potential Promise that the handler can resolve.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkResolution\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If there is no Promise (it is null), the handler must add it to the queue\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        // A queue that will collect chunks while there is no Promise\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data) {\n        this._buffer += data;\n        // Our first time, skip to the opening of the array\n        if (this._firstRun) {\n            this._skipTo(\"[\");\n            this._firstRun = false;\n        }\n        this._parseBuffer();\n    }\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer() {\n        this._bufferOpen = false;\n        this._parseBuffer();\n    }\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer() {\n        let obj = null;\n        do {\n            this._skipTo(\"{\");\n            obj = this._getFullObject();\n            if (obj !== null) {\n                const chunk = this._simplifyObject(obj);\n                this._handleChunk(chunk);\n            }\n        } while (obj !== null);\n        if (!this._bufferOpen) {\n            // No more data will be added, and we have parsed everything we could,\n            // so everything else is garbage.\n            this._handleChunk(null);\n            this._buffer = \"\";\n        }\n    }\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start) {\n        const index = this._buffer.indexOf(start);\n        if (index > 0) {\n            this._buffer = this._buffer.slice(index);\n        }\n    }\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject() {\n        let ret = null;\n        // Loop while we don't have something to return AND we have something in the buffer\n        let index = 0;\n        while (ret === null && this._buffer.length > index) {\n            // Advance to the next close bracket after our current index\n            index = this._buffer.indexOf(\"}\", index + 1);\n            // If we don't find one, exit with null\n            if (index === -1) {\n                return null;\n            }\n            // If we have one, try to turn it into an object to return\n            try {\n                const objStr = this._buffer.substring(0, index + 1);\n                ret = JSON.parse(objStr);\n                // We only get here if it parsed it ok\n                // If we did turn it into an object, remove it from the buffer\n                this._buffer = this._buffer.slice(index + 1);\n            }\n            catch (xx) {\n                // It didn't parse it correctly, so we swallow the exception and continue\n            }\n        }\n        return ret;\n    }\n    _simplifyObject(obj) {\n        return obj;\n    }\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _handleChunk(chunk) {\n        if (this._chunkPending) {\n            this._chunkResolution(chunk);\n            this._chunkPending = null;\n        }\n        else {\n            this._chunkQueue.push(chunk);\n        }\n    }\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        if (this._chunkQueue.length > 0) {\n            // If there is data in the queue, return the next queue chunk\n            return this._chunkQueue.shift();\n        }\n        else {\n            // Otherwise, set up a promise that handleChunk will cause to be resolved\n            this._chunkPending = new Promise((resolve) => {\n                this._chunkResolution = resolve;\n            });\n            return this._chunkPending;\n        }\n    }\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone() {\n        return (!this._bufferOpen &&\n            this._buffer.length === 0 &&\n            this._chunkQueue.length === 0 &&\n            this._chunkPending === null);\n    }\n}\nexports.JsonStream = JsonStream;\nclass ComplexJsonStream extends JsonStream {\n    _simplifyObject(obj) {\n        return simpleValue(obj);\n    }\n}\nexports.ComplexJsonStream = ComplexJsonStream;\nclass ReadableAbstractStream {\n    constructor(baseStream, body) {\n        Object.defineProperty(this, \"baseStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"decoder\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStream = baseStream;\n        this.decoder = new TextDecoder(\"utf-8\");\n        if (body) {\n            void this.run(body);\n        }\n        else {\n            console.error(\"Unexpected empty body while streaming\");\n        }\n    }\n    appendBuffer(data) {\n        return this.baseStream.appendBuffer(data);\n    }\n    closeBuffer() {\n        return this.baseStream.closeBuffer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk() {\n        return this.baseStream.nextChunk();\n    }\n    get streamDone() {\n        return this.baseStream.streamDone;\n    }\n    async run(body) {\n        const reader = body.getReader();\n        let isDone = false;\n        while (!isDone) {\n            const { value, done } = await reader.read();\n            if (!done) {\n                const svalue = this.decoder.decode(value, { stream: true });\n                this.appendBuffer(svalue);\n            }\n            else {\n                isDone = done;\n                this.closeBuffer();\n            }\n        }\n    }\n}\nexports.ReadableAbstractStream = ReadableAbstractStream;\nclass ReadableJsonStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new JsonStream(), body);\n    }\n}\nexports.ReadableJsonStream = ReadableJsonStream;\nclass SseStream {\n    constructor() {\n        Object.defineProperty(this, \"_buffer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\"\n        });\n        Object.defineProperty(this, \"_bufferOpen\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        // Set up a potential Promise that the handler can resolve.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkResolution\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If there is no Promise (it is null), the handler must add it to the queue\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        // A queue that will collect chunks while there is no Promise\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_chunkQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    appendBuffer(data) {\n        this._buffer += data;\n        this._parseBuffer();\n    }\n    closeBuffer() {\n        this._bufferOpen = false;\n        this._parseBuffer();\n    }\n    /**\n     * Attempt to load an entire event.\n     * For each entire event we load,\n     * send them to be handled.\n     */\n    _parseBuffer() {\n        const events = this._buffer.split(/\\n\\n/);\n        this._buffer = events.pop() ?? \"\";\n        events.forEach((event) => this._handleEvent(event.trim()));\n        if (!this._bufferOpen) {\n            // No more data will be added, and we have parsed\n            // everything. So dump the rest.\n            this._handleEvent(null);\n            this._buffer = \"\";\n        }\n    }\n    /**\n     * Given an event string, get all the fields\n     * in the event. It is assumed there is one field\n     * per line, but that field names can be duplicated,\n     * indicating to append the new value to the previous value\n     * @param event\n     */\n    _parseEvent(event) {\n        if (!event || event.trim() === \"\") {\n            return null;\n        }\n        const ret = {};\n        const lines = event.split(/\\n/);\n        lines.forEach((line) => {\n            const match = line.match(/^([^:]+): \\s*(.+)\\n*$/);\n            if (match && match.length === 3) {\n                const key = match[1];\n                const val = match[2];\n                const cur = ret[key] ?? \"\";\n                ret[key] = `${cur}${val}`;\n            }\n        });\n        return ret;\n    }\n    _handleEvent(event) {\n        const chunk = this._parseEvent(event);\n        if (this._chunkPending) {\n            this._chunkResolution(chunk);\n            this._chunkPending = null;\n        }\n        else {\n            this._chunkQueue.push(chunk);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        if (this._chunkQueue.length > 0) {\n            // If there is data in the queue, return the next queue chunk\n            return this._chunkQueue.shift();\n        }\n        else {\n            // Otherwise, set up a promise that handleChunk will cause to be resolved\n            this._chunkPending = new Promise((resolve) => {\n                this._chunkResolution = resolve;\n            });\n            return this._chunkPending;\n        }\n    }\n    get streamDone() {\n        return (!this._bufferOpen &&\n            this._buffer.length === 0 &&\n            this._chunkQueue.length === 0 &&\n            this._chunkPending === null);\n    }\n}\nexports.SseStream = SseStream;\nclass ReadableSseStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new SseStream(), body);\n    }\n}\nexports.ReadableSseStream = ReadableSseStream;\nclass SseJsonStream extends SseStream {\n    constructor(jsonAttribute) {\n        super();\n        Object.defineProperty(this, \"_jsonAttribute\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"data\"\n        });\n        this._jsonAttribute = jsonAttribute ?? this._jsonAttribute;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async nextChunk() {\n        const eventRecord = (await super.nextChunk());\n        const json = eventRecord?.[this._jsonAttribute];\n        if (!json) {\n            return null;\n        }\n        else {\n            return JSON.parse(json);\n        }\n    }\n}\nexports.SseJsonStream = SseJsonStream;\nclass ReadableSseJsonStream extends ReadableAbstractStream {\n    constructor(body) {\n        super(new SseJsonStream(), body);\n    }\n}\nexports.ReadableSseJsonStream = ReadableSseJsonStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvc3RyZWFtLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyw4QkFBOEIsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDalE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLEVBQUUsSUFBSTtBQUN4QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy9zdHJlYW0uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFkYWJsZVNzZUpzb25TdHJlYW0gPSBleHBvcnRzLlNzZUpzb25TdHJlYW0gPSBleHBvcnRzLlJlYWRhYmxlU3NlU3RyZWFtID0gZXhwb3J0cy5Tc2VTdHJlYW0gPSBleHBvcnRzLlJlYWRhYmxlSnNvblN0cmVhbSA9IGV4cG9ydHMuUmVhZGFibGVBYnN0cmFjdFN0cmVhbSA9IGV4cG9ydHMuQ29tcGxleEpzb25TdHJlYW0gPSBleHBvcnRzLkpzb25TdHJlYW0gPSBleHBvcnRzLnNpbXBsZVZhbHVlID0gZXhwb3J0cy5jb21wbGV4VmFsdWUgPSB2b2lkIDA7XG5mdW5jdGlvbiBjb21wbGV4VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIEkgZHVubm8gd2hhdCB0byBwdXQgaGVyZS4gQW4gZXJyb3IsIHByb2JhYmx5XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlzdF92YWw6IHZhbHVlLm1hcCgoYXZhbHVlKSA9PiBjb21wbGV4VmFsdWUoYXZhbHVlKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0ge307XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBjb21wbGV4VmFsdWUodltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RydWN0X3ZhbDogcmV0IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW50X3ZhbDogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZsb2F0X3ZhbDogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmluZ192YWw6IFt2YWx1ZV0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5jb21wbGV4VmFsdWUgPSBjb21wbGV4VmFsdWU7XG5mdW5jdGlvbiBzaW1wbGVWYWx1ZSh2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWxcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RyaW5nVmFsWzBdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShcImJvb2xWYWxcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuYm9vbFZhbFswXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwuaGFzT3duUHJvcGVydHkoXCJsaXN0VmFsXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxpc3RWYWwgfSA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiBsaXN0VmFsLm1hcCgoYXZhbCkgPT4gc2ltcGxlVmFsdWUoYXZhbCkpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShcInN0cnVjdFZhbFwiKSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0ge307XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSB2YWwuc3RydWN0VmFsO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RydWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHNpbXBsZVZhbHVlKHN0cnVjdFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gdmFsO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RydWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHNpbXBsZVZhbHVlKHN0cnVjdFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5tYXAoKGF2YWwpID0+IHNpbXBsZVZhbHVlKGF2YWwpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxufVxuZXhwb3J0cy5zaW1wbGVWYWx1ZSA9IHNpbXBsZVZhbHVlO1xuY2xhc3MgSnNvblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9idWZmZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9idWZmZXJPcGVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZmlyc3RSdW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCB1cCBhIHBvdGVudGlhbCBQcm9taXNlIHRoYXQgdGhlIGhhbmRsZXIgY2FuIHJlc29sdmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1Jlc29sdXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gUHJvbWlzZSAoaXQgaXMgbnVsbCksIHRoZSBoYW5kbGVyIG11c3QgYWRkIGl0IHRvIHRoZSBxdWV1ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2h1bmtQZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBIHF1ZXVlIHRoYXQgd2lsbCBjb2xsZWN0IGNodW5rcyB3aGlsZSB0aGVyZSBpcyBubyBQcm9taXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1F1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgdG8gdGhlIGJ1ZmZlci4gVGhpcyBtYXkgY2F1c2UgY2h1bmtzIHRvIGJlIGdlbmVyYXRlZCwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgYXBwZW5kQnVmZmVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyICs9IGRhdGE7XG4gICAgICAgIC8vIE91ciBmaXJzdCB0aW1lLCBza2lwIHRvIHRoZSBvcGVuaW5nIG9mIHRoZSBhcnJheVxuICAgICAgICBpZiAodGhpcy5fZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NraXBUbyhcIltcIik7XG4gICAgICAgICAgICB0aGlzLl9maXJzdFJ1biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnNlQnVmZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRleHQgYnVmZmVyLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFsbCB0aGUgZGF0YSBoYXMgYmVlbiByZWFkIGFuZCBhZGRlZCB0byBpbmRpY2F0ZVxuICAgICAqIHRoYXQgd2Ugc2hvdWxkIHByb2Nlc3MgZXZlcnl0aGluZyByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBjbG9zZUJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJzZUJ1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwIGNoYXJhY3RlcnMgaW4gdGhlIGJ1ZmZlciB0aWxsIHdlIGdldCB0byB0aGUgc3RhcnQgb2YgYW4gb2JqZWN0LlxuICAgICAqIFRoZW4gYXR0ZW1wdCB0byByZWFkIGEgZnVsbCBvYmplY3QuXG4gICAgICogSWYgd2UgZG8gcmVhZCBhIGZ1bGwgb2JqZWN0LCB0dXJuIGl0IGludG8gYSBjaHVuayBhbmQgc2VuZCBpdCB0byB0aGUgY2h1bmsgaGFuZGxlci5cbiAgICAgKiBSZXBlYXQgdGhpcyBmb3IgYXMgbXVjaCBhcyB3ZSBjYW4uXG4gICAgICovXG4gICAgX3BhcnNlQnVmZmVyKCkge1xuICAgICAgICBsZXQgb2JqID0gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5fc2tpcFRvKFwie1wiKTtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuX2dldEZ1bGxPYmplY3QoKTtcbiAgICAgICAgICAgIGlmIChvYmogIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3NpbXBsaWZ5T2JqZWN0KG9iaik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChvYmogIT09IG51bGwpO1xuICAgICAgICBpZiAoIXRoaXMuX2J1ZmZlck9wZW4pIHtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgZGF0YSB3aWxsIGJlIGFkZGVkLCBhbmQgd2UgaGF2ZSBwYXJzZWQgZXZlcnl0aGluZyB3ZSBjb3VsZCxcbiAgICAgICAgICAgIC8vIHNvIGV2ZXJ5dGhpbmcgZWxzZSBpcyBnYXJiYWdlLlxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2h1bmsobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdHJpbmcgaXMgcHJlc2VudCwgbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciB0byB0aGUgZmlyc3Qgb2NjdXJyZW5jZVxuICAgICAqIG9mIHRoYXQgc3RyaW5nLiBUaGlzIGlzIHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBlbGVtZW50cyBvciBwYXJ0cyB0aGF0IHdlJ3JlIG5vdFxuICAgICAqIHJlYWxseSBpbnRlcmVzdGVkIGluIHBhcnNpbmcuIChpZSAtIHRoZSBvcGVuaW5nIGNoYXJhY3RlcnMsIGNvbW1hIHNlcGFyYXRvcnMsIGV0Yy4pXG4gICAgICogQHBhcmFtIHN0YXJ0IFRoZSBzdHJpbmcgdG8gc3RhcnQgdGhlIGJ1ZmZlciB3aXRoXG4gICAgICovXG4gICAgX3NraXBUbyhzdGFydCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2J1ZmZlci5pbmRleE9mKHN0YXJ0KTtcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyLnNsaWNlKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB3aGF0IGlzIGluIHRoZSBidWZmZXIsIHBhcnNlIGEgc2luZ2xlIG9iamVjdCBvdXQgb2YgaXQuXG4gICAgICogSWYgYSBjb21wbGV0ZSBvYmplY3QgaXNuJ3QgYXZhaWxhYmxlLCByZXR1cm4gbnVsbC5cbiAgICAgKiBBc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhbiBvYmplY3QgdG8gcGFyc2UuXG4gICAgICovXG4gICAgX2dldEZ1bGxPYmplY3QoKSB7XG4gICAgICAgIGxldCByZXQgPSBudWxsO1xuICAgICAgICAvLyBMb29wIHdoaWxlIHdlIGRvbid0IGhhdmUgc29tZXRoaW5nIHRvIHJldHVybiBBTkQgd2UgaGF2ZSBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAocmV0ID09PSBudWxsICYmIHRoaXMuX2J1ZmZlci5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zZSBicmFja2V0IGFmdGVyIG91ciBjdXJyZW50IGluZGV4XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2J1ZmZlci5pbmRleE9mKFwifVwiLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCBvbmUsIGV4aXQgd2l0aCBudWxsXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG9uZSwgdHJ5IHRvIHR1cm4gaXQgaW50byBhbiBvYmplY3QgdG8gcmV0dXJuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialN0ciA9IHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICByZXQgPSBKU09OLnBhcnNlKG9ialN0cik7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBnZXQgaGVyZSBpZiBpdCBwYXJzZWQgaXQgb2tcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWQgdHVybiBpdCBpbnRvIGFuIG9iamVjdCwgcmVtb3ZlIGl0IGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zbGljZShpbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHh4KSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgZGlkbid0IHBhcnNlIGl0IGNvcnJlY3RseSwgc28gd2Ugc3dhbGxvdyB0aGUgZXhjZXB0aW9uIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIF9zaW1wbGlmeU9iamVjdChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGhhdCB3ZSBoYXZlIGFub3RoZXIgY2h1bmsgYXZhaWxhYmxlIGZvciBjb25zdW1wdGlvbi5cbiAgICAgKiBJZiB3ZSBhcmUgd2FpdGluZyBmb3IgYSBjaHVuaywgcmVzb2x2ZSB0aGUgcHJvbWlzZSB3YWl0aW5nIGZvciBpdCBpbW1lZGlhdGVseS5cbiAgICAgKiBJZiBub3QsIHRoZW4gYWRkIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gY2h1bmtcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9oYW5kbGVDaHVuayhjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1Jlc29sdXRpb24oY2h1bmspO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUXVldWUucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IGNodW5rIHRoYXQgaXMgY29taW5nIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKiBUaGlzIGNodW5rIG1heSBiZSBudWxsLCB1c3VhbGx5IGluZGljYXRpbmcgdGhlIGxhc3QgY2h1bmsgaW4gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIG5leHRDaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NodW5rUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgZGF0YSBpbiB0aGUgcXVldWUsIHJldHVybiB0aGUgbmV4dCBxdWV1ZSBjaHVua1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rUXVldWUuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgc2V0IHVwIGEgcHJvbWlzZSB0aGF0IGhhbmRsZUNodW5rIHdpbGwgY2F1c2UgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUGVuZGluZyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtSZXNvbHV0aW9uID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rUGVuZGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgc3RyZWFtIGRvbmU/XG4gICAgICogQSBzdHJlYW0gaXMgb25seSBkb25lIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlOlxuICAgICAqIC0gVGhlcmUgaXMgbm8gbW9yZSBkYXRhIHRvIGJlIGFkZGVkIHRvIHRoZSB0ZXh0IGJ1ZmZlclxuICAgICAqIC0gVGhlcmUgaXMgbm8gbW9yZSBkYXRhIGluIHRoZSB0ZXh0IGJ1ZmZlclxuICAgICAqIC0gVGhlcmUgYXJlIG5vIGNodW5rcyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIGNvbnN1bWVkXG4gICAgICovXG4gICAgZ2V0IHN0cmVhbURvbmUoKSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMuX2J1ZmZlck9wZW4gJiZcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUXVldWUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jaHVua1BlbmRpbmcgPT09IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblN0cmVhbSA9IEpzb25TdHJlYW07XG5jbGFzcyBDb21wbGV4SnNvblN0cmVhbSBleHRlbmRzIEpzb25TdHJlYW0ge1xuICAgIF9zaW1wbGlmeU9iamVjdChvYmopIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZVZhbHVlKG9iaik7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wbGV4SnNvblN0cmVhbSA9IENvbXBsZXhKc29uU3RyZWFtO1xuY2xhc3MgUmVhZGFibGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoYmFzZVN0cmVhbSwgYm9keSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXNlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY29kZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iYXNlU3RyZWFtID0gYmFzZVN0cmVhbTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMucnVuKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZW1wdHkgYm9keSB3aGlsZSBzdHJlYW1pbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kQnVmZmVyKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gICAgfVxuICAgIGNsb3NlQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RyZWFtLmNsb3NlQnVmZmVyKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlU3RyZWFtLm5leHRDaHVuaygpO1xuICAgIH1cbiAgICBnZXQgc3RyZWFtRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5zdHJlYW1Eb25lO1xuICAgIH1cbiAgICBhc3luYyBydW4oYm9keSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICAgICAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghaXNEb25lKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ZhbHVlID0gdGhpcy5kZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRCdWZmZXIoc3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzRG9uZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZUFic3RyYWN0U3RyZWFtID0gUmVhZGFibGVBYnN0cmFjdFN0cmVhbTtcbmNsYXNzIFJlYWRhYmxlSnNvblN0cmVhbSBleHRlbmRzIFJlYWRhYmxlQWJzdHJhY3RTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGJvZHkpIHtcbiAgICAgICAgc3VwZXIobmV3IEpzb25TdHJlYW0oKSwgYm9keSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZUpzb25TdHJlYW0gPSBSZWFkYWJsZUpzb25TdHJlYW07XG5jbGFzcyBTc2VTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVmZmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVmZmVyT3BlblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHVwIGEgcG90ZW50aWFsIFByb21pc2UgdGhhdCB0aGUgaGFuZGxlciBjYW4gcmVzb2x2ZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NodW5rUmVzb2x1dGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBQcm9taXNlIChpdCBpcyBudWxsKSwgdGhlIGhhbmRsZXIgbXVzdCBhZGQgaXQgdG8gdGhlIHF1ZXVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaHVua1BlbmRpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEEgcXVldWUgdGhhdCB3aWxsIGNvbGxlY3QgY2h1bmtzIHdoaWxlIHRoZXJlIGlzIG5vIFByb21pc2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NodW5rUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBlbmRCdWZmZXIoZGF0YSkge1xuICAgICAgICB0aGlzLl9idWZmZXIgKz0gZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyc2VCdWZmZXIoKTtcbiAgICB9XG4gICAgY2xvc2VCdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlck9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyc2VCdWZmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBsb2FkIGFuIGVudGlyZSBldmVudC5cbiAgICAgKiBGb3IgZWFjaCBlbnRpcmUgZXZlbnQgd2UgbG9hZCxcbiAgICAgKiBzZW5kIHRoZW0gdG8gYmUgaGFuZGxlZC5cbiAgICAgKi9cbiAgICBfcGFyc2VCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2J1ZmZlci5zcGxpdCgvXFxuXFxuLyk7XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IGV2ZW50cy5wb3AoKSA/PyBcIlwiO1xuICAgICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHRoaXMuX2hhbmRsZUV2ZW50KGV2ZW50LnRyaW0oKSkpO1xuICAgICAgICBpZiAoIXRoaXMuX2J1ZmZlck9wZW4pIHtcbiAgICAgICAgICAgIC8vIE5vIG1vcmUgZGF0YSB3aWxsIGJlIGFkZGVkLCBhbmQgd2UgaGF2ZSBwYXJzZWRcbiAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcuIFNvIGR1bXAgdGhlIHJlc3QuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZXZlbnQgc3RyaW5nLCBnZXQgYWxsIHRoZSBmaWVsZHNcbiAgICAgKiBpbiB0aGUgZXZlbnQuIEl0IGlzIGFzc3VtZWQgdGhlcmUgaXMgb25lIGZpZWxkXG4gICAgICogcGVyIGxpbmUsIGJ1dCB0aGF0IGZpZWxkIG5hbWVzIGNhbiBiZSBkdXBsaWNhdGVkLFxuICAgICAqIGluZGljYXRpbmcgdG8gYXBwZW5kIHRoZSBuZXcgdmFsdWUgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgX3BhcnNlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudC50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBjb25zdCBsaW5lcyA9IGV2ZW50LnNwbGl0KC9cXG4vKTtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eKFteOl0rKTogXFxzKiguKylcXG4qJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IHJldFtrZXldID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBgJHtjdXJ9JHt2YWx9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIF9oYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3BhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9jaHVua1Jlc29sdXRpb24oY2h1bmspO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUXVldWUucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRhdGEgaW4gdGhlIHF1ZXVlLCByZXR1cm4gdGhlIG5leHQgcXVldWUgY2h1bmtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNldCB1cCBhIHByb21pc2UgdGhhdCBoYW5kbGVDaHVuayB3aWxsIGNhdXNlIHRvIGJlIHJlc29sdmVkXG4gICAgICAgICAgICB0aGlzLl9jaHVua1BlbmRpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rUmVzb2x1dGlvbiA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1BlbmRpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0cmVhbURvbmUoKSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMuX2J1ZmZlck9wZW4gJiZcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2NodW5rUXVldWUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9jaHVua1BlbmRpbmcgPT09IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3NlU3RyZWFtID0gU3NlU3RyZWFtO1xuY2xhc3MgUmVhZGFibGVTc2VTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZUFic3RyYWN0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3Rvcihib2R5KSB7XG4gICAgICAgIHN1cGVyKG5ldyBTc2VTdHJlYW0oKSwgYm9keSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVNzZVN0cmVhbSA9IFJlYWRhYmxlU3NlU3RyZWFtO1xuY2xhc3MgU3NlSnNvblN0cmVhbSBleHRlbmRzIFNzZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoanNvbkF0dHJpYnV0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfanNvbkF0dHJpYnV0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJkYXRhXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2pzb25BdHRyaWJ1dGUgPSBqc29uQXR0cmlidXRlID8/IHRoaXMuX2pzb25BdHRyaWJ1dGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgbmV4dENodW5rKCkge1xuICAgICAgICBjb25zdCBldmVudFJlY29yZCA9IChhd2FpdCBzdXBlci5uZXh0Q2h1bmsoKSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBldmVudFJlY29yZD8uW3RoaXMuX2pzb25BdHRyaWJ1dGVdO1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNzZUpzb25TdHJlYW0gPSBTc2VKc29uU3RyZWFtO1xuY2xhc3MgUmVhZGFibGVTc2VKc29uU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoYm9keSkge1xuICAgICAgICBzdXBlcihuZXcgU3NlSnNvblN0cmVhbSgpLCBib2R5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3NlSnNvblN0cmVhbSA9IFJlYWRhYmxlU3NlSnNvblN0cmVhbTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/stream.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jsonSchemaToGeminiParameters = exports.zodToGeminiParameters = exports.removeAdditionalProperties = void 0;\nconst zod_to_json_schema_1 = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nfunction removeAdditionalProperties(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nobj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        const newObj = { ...obj };\n        if (\"additionalProperties\" in newObj) {\n            delete newObj.additionalProperties;\n        }\n        for (const key in newObj) {\n            if (key in newObj) {\n                if (Array.isArray(newObj[key])) {\n                    newObj[key] = newObj[key].map(removeAdditionalProperties);\n                }\n                else if (typeof newObj[key] === \"object\" && newObj[key] !== null) {\n                    newObj[key] = removeAdditionalProperties(newObj[key]);\n                }\n            }\n        }\n        return newObj;\n    }\n    return obj;\n}\nexports.removeAdditionalProperties = removeAdditionalProperties;\nfunction zodToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nzodObj) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties((0, zod_to_json_schema_1.zodToJsonSchema)(zodObj));\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.zodToGeminiParameters = zodToGeminiParameters;\nfunction jsonSchemaToGeminiParameters(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nschema) {\n    // Gemini doesn't accept either the $schema or additionalProperties\n    // attributes, so we need to explicitly remove them.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const jsonSchema = removeAdditionalProperties(schema);\n    const { $schema, ...rest } = jsonSchema;\n    return rest;\n}\nexports.jsonSchemaToGeminiParameters = jsonSchemaToGeminiParameters;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2Rpc3QvdXRpbHMvem9kX3RvX2dlbWluaV9wYXJhbWV0ZXJzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQztBQUN6Ryw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0Esb0NBQW9DIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZGlzdC91dGlscy96b2RfdG9fZ2VtaW5pX3BhcmFtZXRlcnMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmpzb25TY2hlbWFUb0dlbWluaVBhcmFtZXRlcnMgPSBleHBvcnRzLnpvZFRvR2VtaW5pUGFyYW1ldGVycyA9IGV4cG9ydHMucmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMgPSB2b2lkIDA7XG5jb25zdCB6b2RfdG9fanNvbl9zY2hlbWFfMSA9IHJlcXVpcmUoXCJ6b2QtdG8tanNvbi1zY2hlbWFcIik7XG5mdW5jdGlvbiByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5vYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5vYmogfTtcbiAgICAgICAgaWYgKFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiBpbiBuZXdPYmopIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdPYmouYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG5ld09iaikge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld09ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG5ld09ialtrZXldLm1hcChyZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZXdPYmpba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBuZXdPYmpba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKG5ld09ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMucmVtb3ZlQWRkaXRpb25hbFByb3BlcnRpZXMgPSByZW1vdmVBZGRpdGlvbmFsUHJvcGVydGllcztcbmZ1bmN0aW9uIHpvZFRvR2VtaW5pUGFyYW1ldGVycyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG56b2RPYmopIHtcbiAgICAvLyBHZW1pbmkgZG9lc24ndCBhY2NlcHQgZWl0aGVyIHRoZSAkc2NoZW1hIG9yIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgLy8gYXR0cmlidXRlcywgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHJlbW92ZSB0aGVtLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QganNvblNjaGVtYSA9IHJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKCgwLCB6b2RfdG9fanNvbl9zY2hlbWFfMS56b2RUb0pzb25TY2hlbWEpKHpvZE9iaikpO1xuICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4ucmVzdCB9ID0ganNvblNjaGVtYTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmV4cG9ydHMuem9kVG9HZW1pbmlQYXJhbWV0ZXJzID0gem9kVG9HZW1pbmlQYXJhbWV0ZXJzO1xuZnVuY3Rpb24ganNvblNjaGVtYVRvR2VtaW5pUGFyYW1ldGVycyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5zY2hlbWEpIHtcbiAgICAvLyBHZW1pbmkgZG9lc24ndCBhY2NlcHQgZWl0aGVyIHRoZSAkc2NoZW1hIG9yIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgLy8gYXR0cmlidXRlcywgc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHJlbW92ZSB0aGVtLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QganNvblNjaGVtYSA9IHJlbW92ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgY29uc3QgeyAkc2NoZW1hLCAuLi5yZXN0IH0gPSBqc29uU2NoZW1hO1xuICAgIHJldHVybiByZXN0O1xufVxuZXhwb3J0cy5qc29uU2NoZW1hVG9HZW1pbmlQYXJhbWV0ZXJzID0ganNvblNjaGVtYVRvR2VtaW5pUGFyYW1ldGVycztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/dist/utils/zod_to_gemini_parameters.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@langchain/google-common/experimental/media.cjs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../dist/experimental/media.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/experimental/media.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2V4cGVyaW1lbnRhbC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQUEsdUpBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vZXhwZXJpbWVudGFsL21lZGlhLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Rpc3QvZXhwZXJpbWVudGFsL21lZGlhLmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/@langchain/google-common/index.cjs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-common/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQSw0SEFBNEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXguY2pzJyk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js\");\n/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0k7QUFDUTtBQUNkO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNRO0FBQ1I7QUFDWSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBNQVggfSBmcm9tICcuL21heC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MVRvVjYgfSBmcm9tICcuL3YxVG9WNi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2IH0gZnJvbSAnLi92Ni5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2VG9WMSB9IGZyb20gJy4vdjZUb1YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjcgfSBmcm9tICcuL3Y3LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21heC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/max.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsNkRBQWlCO0FBQzFCO0FBQ0EsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIC8vXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cbiAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxubGV0IF9ub2RlSWQ7XG5sZXQgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcTtcblxuICAvLyB2MSBvbmx5OiBVc2UgY2FjaGVkIGBub2RlYCBhbmQgYGNsb2Nrc2VxYCB2YWx1ZXNcbiAgaWYgKCFvcHRpb25zLl92Nikge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IF9ub2RlSWQ7XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgd2UgbmVlZCBlbnRyb3B5LiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzXG4gIC8vIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50IHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIC8vIFJhbmRvbWl6ZSBub2RlXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IFtzZWVkQnl0ZXNbMF0sIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcblxuICAgICAgLy8gdjEgb25seTogY2FjaGUgbm9kZSB2YWx1ZSBmb3IgcmV1c2VcbiAgICAgIGlmICghX25vZGVJZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgLy8gcGVyIFJGQzQxMjIgNC41OiBTZXQgTUFDIG11bHRpY2FzdCBiaXQgKHYxIG9ubHkpXG4gICAgICAgIG5vZGVbMF0gfD0gMHgwMTsgLy8gU2V0IG11bHRpY2FzdCBiaXRcblxuICAgICAgICBfbm9kZUlkID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSYW5kb21pemUgY2xvY2tzZXFcbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICAgIGlmIChfY2xvY2tzZXEgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdjEgJiB2NiB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc28gdGltZSBpc1xuICAvLyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MVRvVjYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2MSBVVUlEIHRvIGEgdjYgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjEgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2NiBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjFUb1Y2KHV1aWQpIHtcbiAgY29uc3QgdjFCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjZCeXRlcyA9IF92MVRvVjYodjFCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjZCeXRlcykgOiB2NkJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2MSAtPiB2NlxuZnVuY3Rpb24gX3YxVG9WNih2MUJ5dGVzLCByYW5kb21pemUgPSBmYWxzZSkge1xuICByZXR1cm4gVWludDhBcnJheS5vZigodjFCeXRlc1s2XSAmIDB4MGYpIDw8IDQgfCB2MUJ5dGVzWzddID4+IDQgJiAweDBmLCAodjFCeXRlc1s3XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s0XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1sxXSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgMHg2MCB8IHYxQnl0ZXNbMl0gJiAweDBmLCB2MUJ5dGVzWzNdLCB2MUJ5dGVzWzhdLCB2MUJ5dGVzWzldLCB2MUJ5dGVzWzEwXSwgdjFCeXRlc1sxMV0sIHYxQnl0ZXNbMTJdLCB2MUJ5dGVzWzEzXSwgdjFCeXRlc1sxNF0sIHYxQnl0ZXNbMTVdKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIF9uYW1lc3BhY2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUN4QjtBQUNROztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxzREFBTTs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHYxIGZyb20gJy4vdjEuanMnO1xuaW1wb3J0IHYxVG9WNiBmcm9tICcuL3YxVG9WNi5qcyc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXk9fSBidWZcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2NihvcHRpb25zID0ge30sIGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAvLyB2NiBpcyB2MSB3aXRoIGRpZmZlcmVudCBmaWVsZCBsYXlvdXQsIHNvIHdlIHN0YXJ0IHdpdGggYSB2MSBVVUlELCBhbGJlaXRcbiAgLy8gd2l0aCBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgYXJvdW5kIGhvdyB0aGUgY2xvY2tfc2VxIGFuZCBub2RlIGZpZWxkc1xuICAvLyBhcmUgcmFuZG9taXplZCwgd2hpY2ggaXMgd2h5IHdlIGNhbGwgdjEgd2l0aCBfdjY6IHRydWUuXG4gIGxldCBieXRlcyA9IHYxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIF92NjogdHJ1ZVxuICB9LCBuZXcgVWludDhBcnJheSgxNikpO1xuXG4gIC8vIFJlb3JkZXIgdGhlIGZpZWxkcyB0byB2NiBsYXlvdXQuXG4gIGJ5dGVzID0gdjFUb1Y2KGJ5dGVzKTtcblxuICAvLyBSZXR1cm4gYXMgYSBieXRlIGFycmF5IGlmIHJlcXVlc3RlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6ToV1)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NlRvVjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2NiBVVUlEIHRvIGEgdjEgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjYgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2MSBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjZUb1YxKHV1aWQpIHtcbiAgY29uc3QgdjZCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjFCeXRlcyA9IF92NlRvVjEodjZCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjFCeXRlcykgOiB2MUJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2NiAtPiB2MVxuZnVuY3Rpb24gX3Y2VG9WMSh2NkJ5dGVzKSB7XG4gIHJldHVybiBVaW50OEFycmF5Lm9mKCh2NkJ5dGVzWzNdICYgMHgwZikgPDwgNCB8IHY2Qnl0ZXNbNF0gPj4gNCAmIDB4MGYsICh2NkJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgdjZCeXRlc1s2XSAmIDB4MGYsIHY2Qnl0ZXNbN10sICh2NkJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbMl0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbM10gJiAweGYwKSA+PiA0LCAweDEwIHwgKHY2Qnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjZCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1sxXSAmIDB4ZjApID4+IDQsIHY2Qnl0ZXNbOF0sIHY2Qnl0ZXNbOV0sIHY2Qnl0ZXNbMTBdLCB2NkJ5dGVzWzExXSwgdjZCeXRlc1sxMl0sIHY2Qnl0ZXNbMTNdLCB2NkJ5dGVzWzE0XSwgdjZCeXRlc1sxNV0pO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v6ToV1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIFVVSUQgVjcgLSBVbml4IEVwb2NoIHRpbWUtYmFzZWQgVVVJRFxuICpcbiAqIFRoZSBJRVRGIGhhcyBwdWJsaXNoZWQgUkZDOTU2MiwgaW50cm9kdWNpbmcgMyBuZXcgVVVJRCB2ZXJzaW9ucyAoNiw3LDgpLiBUaGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBWNyBpcyBiYXNlZCBvbiB0aGUgYWNjZXB0ZWQsIHRob3VnaCBub3QgeWV0IGFwcHJvdmVkLFxuICogcmV2aXNpb25zLlxuICpcbiAqIFJGQyA5NTYyOmh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwgVW5pdmVyc2FsbHkgVW5pcXVlXG4gKiBJRGVudGlmaWVycyAoVVVJRHMpXG5cbiAqXG4gKiBTYW1wbGUgVjcgdmFsdWU6XG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI25hbWUtZXhhbXBsZS1vZi1hLXV1aWR2Ny12YWx1ZVxuICpcbiAqIE1vbm90b25pYyBCaXQgTGF5b3V0OiBSRkMgcmZjOTU2Mi42LjIgTWV0aG9kIDEsIERlZGljYXRlZCBDb3VudGVyIEJpdHMgcmVmOlxuICogICAgIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwjc2VjdGlvbi02LjItNS4xXG4gKlxuICogICAwICAgICAgICAgICAgICAgICAgIDEgICAgICAgICAgICAgICAgICAgMiAgICAgICAgICAgICAgICAgICAzIDAgMSAyIDMgNCA1IDZcbiAqICAgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDEgMiAzIDQgNSA2IDcgOCA5IDAgMVxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgfCAgdmVyICB8ICAgICAgICBzZXFfaGkgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8dmFyfCAgICAgICAgICAgICAgIHNlcV9sb3cgICAgICAgICAgICAgICB8ICAgICAgICByYW5kICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICpcbiAqIHNlcSBpcyBhIDMxIGJpdCBzZXJpYWxpemVkIGNvdW50ZXI7IGNvbXByaXNlZCBvZiAxMiBiaXQgc2VxX2hpIGFuZCAxOSBiaXRcbiAqIHNlcV9sb3csIGFuZCByYW5kb21seSBpbml0aWFsaXplZCB1cG9uIHRpbWVzdGFtcCBjaGFuZ2UuIDMxIGJpdCBjb3VudGVyIHNpemVcbiAqIHdhcyBzZWxlY3RlZCBhcyBhbnkgYml0d2lzZSBvcGVyYXRpb25zIGluIG5vZGUgYXJlIGRvbmUgYXMgX3NpZ25lZF8gMzIgYml0XG4gKiBpbnRzLiB3ZSBleGNsdWRlIHRoZSBzaWduIGJpdC5cbiAqL1xuXG5sZXQgX3NlcUxvdyA9IG51bGw7XG5sZXQgX3NlcUhpZ2ggPSBudWxsO1xubGV0IF9tc2VjcyA9IDA7XG5mdW5jdGlvbiB2NyhvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBpbml0aWFsaXplIGJ1ZmZlciBhbmQgcG9pbnRlclxuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gcm5kcyBpcyBVaW50OEFycmF5KDE2KSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXNcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gbWlsbGlzZWNvbmRzIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDBcbiAgY29uc3QgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBzZXEgaXMgdXNlciBwcm92aWRlZCAzMSBiaXQgY291bnRlclxuICBsZXQgc2VxID0gb3B0aW9ucy5zZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2VxIDogbnVsbDtcblxuICAvLyBpbml0aWFsaXplIGxvY2FsIHNlcSBoaWdoL2xvdyBwYXJ0c1xuICBsZXQgc2VxSGlnaCA9IF9zZXFIaWdoO1xuICBsZXQgc2VxTG93ID0gX3NlcUxvdztcblxuICAvLyBjaGVjayBpZiBjbG9jayBoYXMgYWR2YW5jZWQgYW5kIHVzZXIgaGFzIG5vdCBwcm92aWRlZCBtc2Vjc1xuICBpZiAobXNlY3MgPiBfbXNlY3MgJiYgb3B0aW9ucy5tc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgX21zZWNzID0gbXNlY3M7XG5cbiAgICAvLyB1bmxlc3MgdXNlciBwcm92aWRlZCBzZXEsIHJlc2V0IHNlcSBwYXJ0c1xuICAgIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAgIHNlcUhpZ2ggPSBudWxsO1xuICAgICAgc2VxTG93ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgdXNlciBwcm92aWRlZCBzZXFcbiAgaWYgKHNlcSAhPT0gbnVsbCkge1xuICAgIC8vIHRyaW0gcHJvdmlkZWQgc2VxIHRvIDMxIGJpdHMgb2YgdmFsdWUsIGF2b2lkaW5nIG92ZXJmbG93XG4gICAgaWYgKHNlcSA+IDB4N2ZmZmZmZmYpIHtcbiAgICAgIHNlcSA9IDB4N2ZmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgcHJvdmlkZWQgc2VxIGludG8gaGlnaC9sb3cgcGFydHNcbiAgICBzZXFIaWdoID0gc2VxID4+PiAxOSAmIDB4ZmZmO1xuICAgIHNlcUxvdyA9IHNlcSAmIDB4N2ZmZmY7XG4gIH1cblxuICAvLyByYW5kb21seSBpbml0aWFsaXplIHNlcVxuICBpZiAoc2VxSGlnaCA9PT0gbnVsbCB8fCBzZXFMb3cgPT09IG51bGwpIHtcbiAgICBzZXFIaWdoID0gcm5kc1s2XSAmIDB4N2Y7XG4gICAgc2VxSGlnaCA9IHNlcUhpZ2ggPDwgOCB8IHJuZHNbN107XG4gICAgc2VxTG93ID0gcm5kc1s4XSAmIDB4M2Y7IC8vIHBhZCBmb3IgdmFyXG4gICAgc2VxTG93ID0gc2VxTG93IDw8IDggfCBybmRzWzldO1xuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA1IHwgcm5kc1sxMF0gPj4+IDM7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgc2VxIGlmIHdpdGhpbiBtc2VjcyB3aW5kb3dcbiAgaWYgKG1zZWNzICsgMTAwMDAgPiBfbXNlY3MgJiYgc2VxID09PSBudWxsKSB7XG4gICAgaWYgKCsrc2VxTG93ID4gMHg3ZmZmZikge1xuICAgICAgc2VxTG93ID0gMDtcbiAgICAgIGlmICgrK3NlcUhpZ2ggPiAweGZmZikge1xuICAgICAgICBzZXFIaWdoID0gMDtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgaW50ZXJuYWwgX21zZWNzLiB0aGlzIGFsbG93cyB1cyB0byBjb250aW51ZSBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gd2hpbGUgc3RheWluZyBtb25vdG9uaWMuIE5vdGUsIG9uY2Ugd2UgaGl0IDEwayBtaWxsaXNlY29uZHMgYmV5b25kIHN5c3RlbVxuICAgICAgICAvLyBjbG9jaywgd2Ugd2lsbCByZXNldCBicmVha2luZyBtb25vdG9uaWNpdHkgKGFmdGVyICgyXjMxKSoxMDAwMCBnZW5lcmF0aW9ucylcbiAgICAgICAgX21zZWNzKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0dGluZzsgd2UgaGF2ZSBhZHZhbmNlZCBtb3JlIHRoYW5cbiAgICAvLyAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW0gY2xvY2tcbiAgICBfbXNlY3MgPSBtc2VjcztcbiAgfVxuICBfc2VxSGlnaCA9IHNlcUhpZ2g7XG4gIF9zZXFMb3cgPSBzZXFMb3c7XG5cbiAgLy8gW2J5dGVzIDAtNV0gNDggYml0cyBvZiBsb2NhbCB0aW1lc3RhbXBcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzICYgMHhmZjtcblxuICAvLyBbYnl0ZSA2XSAtIHNldCA0IGJpdHMgb2YgdmVyc2lvbiAoNykgd2l0aCBmaXJzdCA0IGJpdHMgc2VxX2hpXG4gIGJbaSsrXSA9IHNlcUhpZ2ggPj4+IDQgJiAweDBmIHwgMHg3MDtcblxuICAvLyBbYnl0ZSA3XSByZW1haW5pbmcgOCBiaXRzIG9mIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoICYgMHhmZjtcblxuICAvLyBbYnl0ZSA4XSAtIHZhcmlhbnQgKDIgYml0cyksIGZpcnN0IDYgYml0cyBzZXFfbG93XG4gIGJbaSsrXSA9IHNlcUxvdyA+Pj4gMTMgJiAweDNmIHwgMHg4MDtcblxuICAvLyBbYnl0ZSA5XSA4IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDUgJiAweGZmO1xuXG4gIC8vIFtieXRlIDEwXSByZW1haW5pbmcgNSBiaXRzIHNlcV9sb3csIDMgYml0cyByYW5kb21cbiAgYltpKytdID0gc2VxTG93IDw8IDMgJiAweGZmIHwgcm5kc1sxMF0gJiAweDA3O1xuXG4gIC8vIFtieXRlcyAxMS0xNV0gYWx3YXlzIHJhbmRvbVxuICBiW2krK10gPSBybmRzWzExXTtcbiAgYltpKytdID0gcm5kc1sxMl07XG4gIGJbaSsrXSA9IHJuZHNbMTNdO1xuICBiW2krK10gPSBybmRzWzE0XTtcbiAgYltpKytdID0gcm5kc1sxNV07XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1jb21tb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-common/node_modules/uuid/dist/esm-node/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/auth.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GAuthClient = exports.NodeSseJsonStream = exports.NodeSseStream = exports.NodeJsonStream = exports.NodeAbstractStream = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\nclass NodeAbstractStream {\n    constructor(baseStream, data) {\n        Object.defineProperty(this, \"baseStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.baseStream = baseStream;\n        const decoder = new TextDecoder(\"utf-8\");\n        data.on(\"data\", (data) => {\n            const text = decoder.decode(data, { stream: true });\n            this.appendBuffer(text);\n        });\n        data.on(\"end\", () => {\n            const rest = decoder.decode();\n            this.appendBuffer(rest);\n            this.closeBuffer();\n        });\n    }\n    appendBuffer(data) {\n        return this.baseStream.appendBuffer(data);\n    }\n    closeBuffer() {\n        return this.baseStream.closeBuffer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk() {\n        return this.baseStream.nextChunk();\n    }\n    get streamDone() {\n        return this.baseStream.streamDone;\n    }\n}\nexports.NodeAbstractStream = NodeAbstractStream;\nclass NodeJsonStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.JsonStream(), data);\n    }\n}\nexports.NodeJsonStream = NodeJsonStream;\nclass NodeSseStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.SseStream(), data);\n    }\n}\nexports.NodeSseStream = NodeSseStream;\nclass NodeSseJsonStream extends NodeAbstractStream {\n    constructor(data) {\n        super(new google_common_1.SseJsonStream(), data);\n    }\n}\nexports.NodeSseJsonStream = NodeSseJsonStream;\nclass GAuthClient {\n    constructor(fields) {\n        Object.defineProperty(this, \"gauth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const options = (0, google_common_1.ensureAuthOptionScopes)(fields?.authOptions, \"scopes\", fields?.platformType);\n        this.gauth = new google_auth_library_1.GoogleAuth(options);\n    }\n    get clientType() {\n        return \"gauth\";\n    }\n    async getProjectId() {\n        return this.gauth.getProjectId();\n    }\n    async request(opts) {\n        const ret = await this.gauth.request(opts);\n        const [contentType] = ret?.headers?.[\"content-type\"]?.split(/;/) ?? [\"\"];\n        if (opts.responseType !== \"stream\") {\n            return ret;\n        }\n        else if (contentType === \"text/event-stream\") {\n            return {\n                ...ret,\n                data: new NodeSseJsonStream(ret.data),\n            };\n        }\n        else {\n            return {\n                ...ret,\n                data: new NodeJsonStream(ret.data),\n            };\n        }\n    }\n}\nexports.GAuthClient = GAuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9hdXRoLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRywwQkFBMEI7QUFDN0gsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELDhCQUE4QixtQkFBTyxDQUFDLHdGQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2F1dGguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HQXV0aENsaWVudCA9IGV4cG9ydHMuTm9kZVNzZUpzb25TdHJlYW0gPSBleHBvcnRzLk5vZGVTc2VTdHJlYW0gPSBleHBvcnRzLk5vZGVKc29uU3RyZWFtID0gZXhwb3J0cy5Ob2RlQWJzdHJhY3RTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBnb29nbGVfY29tbW9uXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uXCIpO1xuY29uc3QgZ29vZ2xlX2F1dGhfbGlicmFyeV8xID0gcmVxdWlyZShcImdvb2dsZS1hdXRoLWxpYnJhcnlcIik7XG5jbGFzcyBOb2RlQWJzdHJhY3RTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VTdHJlYW0sIGRhdGEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhc2VTdHJlYW0gPSBiYXNlU3RyZWFtO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgICAgIGRhdGEub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUoZGF0YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ1ZmZlcih0ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ1ZmZlcihyZXN0KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VCdWZmZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFwcGVuZEJ1ZmZlcihkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0uYXBwZW5kQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICBjbG9zZUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5jbG9zZUJ1ZmZlcigpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0cmVhbS5uZXh0Q2h1bmsoKTtcbiAgICB9XG4gICAgZ2V0IHN0cmVhbURvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VTdHJlYW0uc3RyZWFtRG9uZTtcbiAgICB9XG59XG5leHBvcnRzLk5vZGVBYnN0cmFjdFN0cmVhbSA9IE5vZGVBYnN0cmFjdFN0cmVhbTtcbmNsYXNzIE5vZGVKc29uU3RyZWFtIGV4dGVuZHMgTm9kZUFic3RyYWN0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKG5ldyBnb29nbGVfY29tbW9uXzEuSnNvblN0cmVhbSgpLCBkYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLk5vZGVKc29uU3RyZWFtID0gTm9kZUpzb25TdHJlYW07XG5jbGFzcyBOb2RlU3NlU3RyZWFtIGV4dGVuZHMgTm9kZUFic3RyYWN0U3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKG5ldyBnb29nbGVfY29tbW9uXzEuU3NlU3RyZWFtKCksIGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZVNzZVN0cmVhbSA9IE5vZGVTc2VTdHJlYW07XG5jbGFzcyBOb2RlU3NlSnNvblN0cmVhbSBleHRlbmRzIE5vZGVBYnN0cmFjdFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcihuZXcgZ29vZ2xlX2NvbW1vbl8xLlNzZUpzb25TdHJlYW0oKSwgZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlU3NlSnNvblN0cmVhbSA9IE5vZGVTc2VKc29uU3RyZWFtO1xuY2xhc3MgR0F1dGhDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnYXV0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gKDAsIGdvb2dsZV9jb21tb25fMS5lbnN1cmVBdXRoT3B0aW9uU2NvcGVzKShmaWVsZHM/LmF1dGhPcHRpb25zLCBcInNjb3Blc1wiLCBmaWVsZHM/LnBsYXRmb3JtVHlwZSk7XG4gICAgICAgIHRoaXMuZ2F1dGggPSBuZXcgZ29vZ2xlX2F1dGhfbGlicmFyeV8xLkdvb2dsZUF1dGgob3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBjbGllbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnYXV0aFwiO1xuICAgIH1cbiAgICBhc3luYyBnZXRQcm9qZWN0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhdXRoLmdldFByb2plY3RJZCgpO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgdGhpcy5nYXV0aC5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICBjb25zdCBbY29udGVudFR5cGVdID0gcmV0Py5oZWFkZXJzPy5bXCJjb250ZW50LXR5cGVcIl0/LnNwbGl0KC87LykgPz8gW1wiXCJdO1xuICAgICAgICBpZiAob3B0cy5yZXNwb25zZVR5cGUgIT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09IFwidGV4dC9ldmVudC1zdHJlYW1cIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXQsXG4gICAgICAgICAgICAgICAgZGF0YTogbmV3IE5vZGVTc2VKc29uU3RyZWFtKHJldC5kYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJldCxcbiAgICAgICAgICAgICAgICBkYXRhOiBuZXcgTm9kZUpzb25TdHJlYW0ocmV0LmRhdGEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuR0F1dGhDbGllbnQgPSBHQXV0aENsaWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/chat_models.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChatGoogle = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google chat model.\n */\nclass ChatGoogle extends google_common_1.ChatGoogleBase {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"ChatGoogle\";\n    }\n    constructor(fields) {\n        super(fields);\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.ChatGoogle = ChatGoogle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9jaGF0X21vZGVscy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHdCQUF3QixtQkFBTyxDQUFDLHlGQUEwQjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2Rpc3QvY2hhdF9tb2RlbHMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0R29vZ2xlID0gdm9pZCAwO1xuY29uc3QgZ29vZ2xlX2NvbW1vbl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vblwiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuLyoqXG4gKiBJbnRlZ3JhdGlvbiB3aXRoIGEgR29vZ2xlIGNoYXQgbW9kZWwuXG4gKi9cbmNsYXNzIENoYXRHb29nbGUgZXh0ZW5kcyBnb29nbGVfY29tbW9uXzEuQ2hhdEdvb2dsZUJhc2Uge1xuICAgIC8vIFVzZWQgZm9yIHRyYWNpbmcsIHJlcGxhY2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHlvdXIgY2xhc3NcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdEdvb2dsZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICB9XG4gICAgYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5HQXV0aENsaWVudChmaWVsZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdEdvb2dsZSA9IENoYXRHb29nbGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs":
/*!******************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/embeddings.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleEmbeddings = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with an Google embeddings model.\n */\nclass GoogleEmbeddings extends google_common_1.BaseGoogleEmbeddings {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleEmbeddings\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleEmbeddings = GoogleEmbeddings;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9lbWJlZGRpbmdzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2VtYmVkZGluZ3MuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVFbWJlZGRpbmdzID0gdm9pZCAwO1xuY29uc3QgZ29vZ2xlX2NvbW1vbl8xID0gcmVxdWlyZShcIkBsYW5nY2hhaW4vZ29vZ2xlLWNvbW1vblwiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuLyoqXG4gKiBJbnRlZ3JhdGlvbiB3aXRoIGFuIEdvb2dsZSBlbWJlZGRpbmdzIG1vZGVsLlxuICovXG5jbGFzcyBHb29nbGVFbWJlZGRpbmdzIGV4dGVuZHMgZ29vZ2xlX2NvbW1vbl8xLkJhc2VHb29nbGVFbWJlZGRpbmdzIHtcbiAgICAvLyBVc2VkIGZvciB0cmFjaW5nLCByZXBsYWNlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB5b3VyIGNsYXNzXG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkdvb2dsZUVtYmVkZGluZ3NcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5HQXV0aENsaWVudChmaWVsZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlRW1iZWRkaW5ncyA9IEdvb2dsZUVtYmVkZGluZ3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/index.cjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chat_models.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/chat_models.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./llms.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./embeddings.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/embeddings.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./media.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRGQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDBGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hhdF9tb2RlbHMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sbG1zLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW1iZWRkaW5ncy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lZGlhLmNqc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/llms.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleLLM = void 0;\nconst google_common_1 = __webpack_require__(/*! @langchain/google-common */ \"(rsc)/./node_modules/@langchain/google-common/index.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\n/**\n * Integration with a Google LLM.\n */\nclass GoogleLLM extends google_common_1.GoogleBaseLLM {\n    // Used for tracing, replace with the same name as your class\n    static lc_name() {\n        return \"GoogleLLM\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.GoogleLLM = GoogleLLM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9sbG1zLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2dvb2dsZS1nYXV0aC9kaXN0L2xsbXMuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVMTE0gPSB2b2lkIDA7XG5jb25zdCBnb29nbGVfY29tbW9uXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uXCIpO1xuY29uc3QgYXV0aF9qc18xID0gcmVxdWlyZShcIi4vYXV0aC5janNcIik7XG4vKipcbiAqIEludGVncmF0aW9uIHdpdGggYSBHb29nbGUgTExNLlxuICovXG5jbGFzcyBHb29nbGVMTE0gZXh0ZW5kcyBnb29nbGVfY29tbW9uXzEuR29vZ2xlQmFzZUxMTSB7XG4gICAgLy8gVXNlZCBmb3IgdHJhY2luZywgcmVwbGFjZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgeW91ciBjbGFzc1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJHb29nbGVMTE1cIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5HQXV0aENsaWVudChmaWVsZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR29vZ2xlTExNID0gR29vZ2xlTExNO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/llms.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/dist/media.cjs ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlobStoreAIStudioFile = exports.BlobStoreGoogleCloudStorage = void 0;\nconst media_1 = __webpack_require__(/*! @langchain/google-common/experimental/media */ \"(rsc)/./node_modules/@langchain/google-common/experimental/media.cjs\");\nconst auth_js_1 = __webpack_require__(/*! ./auth.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/auth.cjs\");\nclass BlobStoreGoogleCloudStorage extends media_1.BlobStoreGoogleCloudStorageBase {\n    buildClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreGoogleCloudStorage = BlobStoreGoogleCloudStorage;\nclass BlobStoreAIStudioFile extends media_1.BlobStoreAIStudioFileBase {\n    buildAbstractedClient(fields) {\n        return new auth_js_1.GAuthClient(fields);\n    }\n}\nexports.BlobStoreAIStudioFile = BlobStoreAIStudioFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvZGlzdC9tZWRpYS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsbUNBQW1DO0FBQ25FLGdCQUFnQixtQkFBTyxDQUFDLHlIQUE2QztBQUNyRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vZ29vZ2xlLWdhdXRoL2Rpc3QvbWVkaWEuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbG9iU3RvcmVBSVN0dWRpb0ZpbGUgPSBleHBvcnRzLkJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IG1lZGlhXzEgPSByZXF1aXJlKFwiQGxhbmdjaGFpbi9nb29nbGUtY29tbW9uL2V4cGVyaW1lbnRhbC9tZWRpYVwiKTtcbmNvbnN0IGF1dGhfanNfMSA9IHJlcXVpcmUoXCIuL2F1dGguY2pzXCIpO1xuY2xhc3MgQmxvYlN0b3JlR29vZ2xlQ2xvdWRTdG9yYWdlIGV4dGVuZHMgbWVkaWFfMS5CbG9iU3RvcmVHb29nbGVDbG91ZFN0b3JhZ2VCYXNlIHtcbiAgICBidWlsZENsaWVudChmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhdXRoX2pzXzEuR0F1dGhDbGllbnQoZmllbGRzKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZSA9IEJsb2JTdG9yZUdvb2dsZUNsb3VkU3RvcmFnZTtcbmNsYXNzIEJsb2JTdG9yZUFJU3R1ZGlvRmlsZSBleHRlbmRzIG1lZGlhXzEuQmxvYlN0b3JlQUlTdHVkaW9GaWxlQmFzZSB7XG4gICAgYnVpbGRBYnN0cmFjdGVkQ2xpZW50KGZpZWxkcykge1xuICAgICAgICByZXR1cm4gbmV3IGF1dGhfanNfMS5HQXV0aENsaWVudChmaWVsZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYlN0b3JlQUlTdHVkaW9GaWxlID0gQmxvYlN0b3JlQUlTdHVkaW9GaWxlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/dist/media.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/google-gauth/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/google-gauth/index.cjs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/index.cjs */ \"(rsc)/./node_modules/@langchain/google-gauth/dist/index.cjs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBLDJIQUE0QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9nb29nbGUtZ2F1dGgvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmNqcycpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/google-gauth/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js":
/*!**************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/client.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssistantsClient: () => (/* binding */ AssistantsClient),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CronsClient: () => (/* binding */ CronsClient),\n/* harmony export */   RunsClient: () => (/* binding */ RunsClient),\n/* harmony export */   StoreClient: () => (/* binding */ StoreClient),\n/* harmony export */   ThreadsClient: () => (/* binding */ ThreadsClient),\n/* harmony export */   getApiKey: () => (/* binding */ getApiKey),\n/* harmony export */   getClientConfigHash: () => (/* binding */ getClientConfigHash)\n/* harmony export */ });\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\");\n/* harmony import */ var _utils_signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/signals.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\");\n/* harmony import */ var _utils_sse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/sse.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js\");\n/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/stream.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\");\n\n\n\n\n\nfunction* iterateHeaders(headers) {\n    let iter;\n    let shouldClear = false;\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (headers instanceof Headers) {\n        const entries = [];\n        headers.forEach((value, name) => {\n            entries.push([name, value]);\n        });\n        iter = entries;\n    }\n    else if (Array.isArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (const item of iter) {\n        const name = item[0];\n        if (typeof name !== \"string\")\n            throw new TypeError(`Expected header name to be a string, got ${typeof name}`);\n        const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // New object keys should always overwrite older headers\n            // Yield a null to clear the header in the headers object\n            // before adding the new value\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nfunction mergeHeaders(...headerObjects) {\n    const outputHeaders = new Headers();\n    for (const headers of headerObjects) {\n        if (!headers)\n            continue;\n        for (const [name, value] of iterateHeaders(headers)) {\n            if (value === null)\n                outputHeaders.delete(name);\n            else\n                outputHeaders.append(name, value);\n        }\n    }\n    const headerEntries = [];\n    outputHeaders.forEach((value, name) => {\n        headerEntries.push([name, value]);\n    });\n    return Object.fromEntries(headerEntries);\n}\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nfunction getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_1__.getEnvironmentVariable)(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nconst REGEX_RUN_METADATA = /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\nfunction getRunMetadataFromResponse(response) {\n    const contentLocation = response.headers.get(\"Content-Location\");\n    if (!contentLocation)\n        return undefined;\n    const match = REGEX_RUN_METADATA.exec(contentLocation);\n    if (!match?.groups?.run_id)\n        return undefined;\n    return {\n        run_id: match.groups.run_id,\n        thread_id: match.groups.thread_id || undefined,\n    };\n}\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const callerOptions = {\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        };\n        let defaultApiUrl = \"http://localhost:8123\";\n        if (!config?.apiUrl &&\n            typeof globalThis === \"object\" &&\n            globalThis != null) {\n            const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n            const urlSmb = Symbol.for(\"langgraph_api:url\");\n            const global = globalThis;\n            if (global[fetchSmb])\n                callerOptions.fetch ??= global[fetchSmb];\n            if (global[urlSmb])\n                defaultApiUrl = global[urlSmb];\n        }\n        this.asyncCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(callerOptions);\n        this.timeoutMs = config?.timeoutMs;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n        this.defaultHeaders = config?.defaultHeaders || {};\n        this.onRequest = config?.onRequest;\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"x-api-key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: mergeHeaders(this.defaultHeaders, options?.headers),\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n                \"content-type\": \"application/json\",\n            });\n            delete mutatedOptions.json;\n        }\n        if (mutatedOptions.withResponse) {\n            delete mutatedOptions.withResponse;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else if (this.timeoutMs != null) {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = (0,_utils_signals_js__WEBPACK_IMPORTED_MODULE_2__.mergeSignals)(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                const strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const [url, init] = this.prepareFetchOptions(path, options);\n        let finalInit = init;\n        if (this.onRequest) {\n            finalInit = await this.onRequest(url, init);\n        }\n        const response = await this.asyncCaller.fetch(url, finalInit);\n        const body = (() => {\n            if (response.status === 202 || response.status === 204) {\n                return undefined;\n            }\n            return response.json();\n        })();\n        if (options?.withResponse) {\n            return [await body, response];\n        }\n        return body;\n    }\n}\nclass CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/runs/crons/count`, {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n            },\n        });\n    }\n}\nclass AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/assistants/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                graph_id: query?.graphId ?? undefined,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nclass ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        // Normalize ttl to an object if a number is provided\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: {\n                    ...payload?.metadata,\n                    graph_id: payload?.graphId,\n                },\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n                supersteps: payload?.supersteps?.map((s) => ({\n                    updates: s.updates.map((u) => ({\n                        values: u.values,\n                        command: u.command,\n                        as_node: u.asNode,\n                    })),\n                })),\n                ttl: ttlPayload,\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        const ttlPayload = typeof payload?.ttl === \"number\"\n            ? { ttl: payload.ttl, strategy: \"delete\" }\n            : payload?.ttl;\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata, ttl: ttlPayload },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                ids: query?.ids ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n                sort_by: query?.sortBy,\n                sort_order: query?.sortOrder,\n                select: query?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    async count(query) {\n        return this.fetch(`/threads/count`, {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                values: query?.values ?? undefined,\n                status: query?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n    async *joinStream(threadId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        let [url, init] = this.prepareFetchOptions(`/threads/${threadId}/stream`, {\n            method: \"GET\",\n            headers: options?.lastEventId\n                ? { \"Last-Event-ID\": options.lastEventId }\n                : undefined,\n            params: options?.streamMode\n                ? { stream_mode: options.streamMode }\n                : undefined,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n}\nclass RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        let [url, init] = this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId === null ? \"/runs\" : `/threads/${threadId}/runs`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        return run;\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            durability: payload?.durability,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in run &&\n            typeof run.__error__ === \"object\" &&\n            run.__error__ &&\n            \"error\" in run.__error__ &&\n            \"message\" in run.__error__) {\n            throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n        }\n        return run;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n                select: options?.select ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        let [url, init] = this.prepareFetchOptions(threadId != null\n            ? `/threads/${threadId}/runs/${runId}/stream`\n            : `/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            headers: opts?.lastEventId\n                ? { \"Last-Event-ID\": opts.lastEventId }\n                : undefined,\n            params: {\n                cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n                stream_mode: opts?.streamMode,\n            },\n        });\n        if (this.onRequest != null)\n            init = await this.onRequest(url, init);\n        const response = await this.asyncCaller.fetch(url, init);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.BytesLineDecoder)())\n            .pipeThrough((0,_utils_sse_js__WEBPACK_IMPORTED_MODULE_3__.SSEDecoder)());\n        yield* _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nclass StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    async putItem(namespace, key, value, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n            index: options?.index,\n            ttl: options?.ttl,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    async getItem(namespace, key, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const params = {\n            namespace: namespace.join(\".\"),\n            key,\n        };\n        if (options?.refreshTtl !== undefined) {\n            params.refresh_ttl = options.refreshTtl;\n        }\n        const response = await this.fetch(\"/store/items\", {\n            params,\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n            refresh_ttl: options?.refreshTtl,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nclass UiClient extends BaseClient {\n    static getOrCached(key, fn) {\n        if (UiClient.promiseCache[key] != null) {\n            return UiClient.promiseCache[key];\n        }\n        const promise = fn();\n        UiClient.promiseCache[key] = promise;\n        return promise;\n    }\n    async getComponent(assistantId, agentName) {\n        return UiClient.getOrCached(`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n            let [url, init] = this.prepareFetchOptions(`/ui/${assistantId}`, {\n                headers: {\n                    Accept: \"text/html\",\n                    \"Content-Type\": \"application/json\",\n                },\n                method: \"POST\",\n                json: { name: agentName },\n            });\n            if (this.onRequest != null)\n                init = await this.onRequest(url, init);\n            const response = await this.asyncCaller.fetch(url, init);\n            return response.text();\n        });\n    }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {}\n});\nclass Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the UI.\n         * @internal Used by LoadExternalComponent and the API might change in the future.\n         */\n        Object.defineProperty(this, \"~ui\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal Used to obtain a stable key representing the client.\n         */\n        Object.defineProperty(this, \"~configHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[\"~configHash\"] = (() => JSON.stringify({\n            apiUrl: config?.apiUrl,\n            apiKey: config?.apiKey,\n            timeoutMs: config?.timeoutMs,\n            defaultHeaders: config?.defaultHeaders,\n            maxConcurrency: config?.callerOptions?.maxConcurrency,\n            maxRetries: config?.callerOptions?.maxRetries,\n            callbacks: {\n                onFailedResponseHook: config?.callerOptions?.onFailedResponseHook != null,\n                onRequest: config?.onRequest != null,\n                fetch: config?.callerOptions?.fetch != null,\n            },\n        }))();\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n        this[\"~ui\"] = new UiClient(config);\n    }\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nfunction getClientConfigHash(client) {\n    return client[\"~configHash\"];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDRTtBQUNOO0FBQ1k7QUFDSDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUVBQXNCLElBQUksT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFZO0FBQzVDLHFDQUFxQyxZQUFZLEVBQUUsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQsc0JBQXNCLHFCQUFxQjtBQUMzQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLGFBQWEsa0JBQWtCLEtBQUssVUFBVSw2QkFBNkI7QUFDcEk7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRCxzQkFBc0IsMkJBQTJCO0FBQ2pELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMENBQTBDLFNBQVMsU0FBUyxXQUFXLEtBQUssVUFBVSxpQ0FBaUM7QUFDdkg7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQyxzQkFBc0IsK0JBQStCO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBLG9CQUFvQixVQUFVO0FBQzlCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtCQUErQjtBQUM3Rix5QkFBeUIsK0RBQWdCO0FBQ3pDLHlCQUF5Qix5REFBVTtBQUNuQyxlQUFlLG9FQUFzQjtBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrQkFBK0I7QUFDN0YseUJBQXlCLCtEQUFnQjtBQUN6Qyx5QkFBeUIseURBQVU7QUFDbkMsZUFBZSxvRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtDQUErQztBQUNoRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCLElBQUksdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxRQUFRLE1BQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLFFBQVEsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVMsUUFBUSxNQUFNO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDBCQUEwQixTQUFTLFFBQVEsTUFBTTtBQUNqRCx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0JBQStCO0FBQzdGLHlCQUF5QiwrREFBZ0I7QUFDekMseUJBQXlCLHlEQUFVO0FBQ25DLGVBQWUsb0VBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLFFBQVEsTUFBTTtBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUE4QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWSxHQUFHLFlBQVksR0FBRyxVQUFVO0FBQy9FLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBtZXJnZVNpZ25hbHMgfSBmcm9tIFwiLi91dGlscy9zaWduYWxzLmpzXCI7XG5pbXBvcnQgeyBCeXRlc0xpbmVEZWNvZGVyLCBTU0VEZWNvZGVyIH0gZnJvbSBcIi4vdXRpbHMvc3NlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5mdW5jdGlvbiogaXRlcmF0ZUhlYWRlcnMoaGVhZGVycykge1xuICAgIGxldCBpdGVyO1xuICAgIGxldCBzaG91bGRDbGVhciA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyID0gZW50cmllcztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICBpdGVyID0gaGVhZGVycztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNob3VsZENsZWFyID0gdHJ1ZTtcbiAgICAgICAgaXRlciA9IE9iamVjdC5lbnRyaWVzKGhlYWRlcnMgPz8ge30pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcikge1xuICAgICAgICBjb25zdCBuYW1lID0gaXRlbVswXTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaGVhZGVyIG5hbWUgdG8gYmUgYSBzdHJpbmcsIGdvdCAke3R5cGVvZiBuYW1lfWApO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGl0ZW1bMV0pID8gaXRlbVsxXSA6IFtpdGVtWzFdXTtcbiAgICAgICAgbGV0IGRpZENsZWFyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIE5ldyBvYmplY3Qga2V5cyBzaG91bGQgYWx3YXlzIG92ZXJ3cml0ZSBvbGRlciBoZWFkZXJzXG4gICAgICAgICAgICAvLyBZaWVsZCBhIG51bGwgdG8gY2xlYXIgdGhlIGhlYWRlciBpbiB0aGUgaGVhZGVycyBvYmplY3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgICAgaWYgKHNob3VsZENsZWFyICYmICFkaWRDbGVhcikge1xuICAgICAgICAgICAgICAgIGRpZENsZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB5aWVsZCBbbmFtZSwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VIZWFkZXJzKC4uLmhlYWRlck9iamVjdHMpIHtcbiAgICBjb25zdCBvdXRwdXRIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlcnMgb2YgaGVhZGVyT2JqZWN0cykge1xuICAgICAgICBpZiAoIWhlYWRlcnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGl0ZXJhdGVIZWFkZXJzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgb3V0cHV0SGVhZGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3V0cHV0SGVhZGVycy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlckVudHJpZXMgPSBbXTtcbiAgICBvdXRwdXRIZWFkZXJzLmZvckVhY2goKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIGhlYWRlckVudHJpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlckVudHJpZXMpO1xufVxuLyoqXG4gKiBHZXQgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQuXG4gKiBQcmVjZWRlbmNlOlxuICogICAxLiBleHBsaWNpdCBhcmd1bWVudFxuICogICAyLiBMQU5HR1JBUEhfQVBJX0tFWVxuICogICAzLiBMQU5HU01JVEhfQVBJX0tFWVxuICogICA0LiBMQU5HQ0hBSU5fQVBJX0tFWVxuICpcbiAqIEBwYXJhbSBhcGlLZXkgLSBPcHRpb25hbCBBUEkga2V5IHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50XG4gKiBAcmV0dXJucyBUaGUgQVBJIGtleSBpZiBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ZXMgPSBbXCJMQU5HR1JBUEhcIiwgXCJMQU5HU01JVEhcIiwgXCJMQU5HQ0hBSU5cIl07XG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgY29uc3QgZW52S2V5ID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgJHtwcmVmaXh9X0FQSV9LRVlgKTtcbiAgICAgICAgaWYgKGVudktleSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgICAgICAgICAgcmV0dXJuIGVudktleS50cmltKCkucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY29uc3QgUkVHRVhfUlVOX01FVEFEQVRBID0gLyhcXC90aHJlYWRzXFwvKD88dGhyZWFkX2lkPi4rKSk/XFwvcnVuc1xcLyg/PHJ1bl9pZD4uKykvO1xuZnVuY3Rpb24gZ2V0UnVuTWV0YWRhdGFGcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBjb250ZW50TG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtTG9jYXRpb25cIik7XG4gICAgaWYgKCFjb250ZW50TG9jYXRpb24pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF0Y2ggPSBSRUdFWF9SVU5fTUVUQURBVEEuZXhlYyhjb250ZW50TG9jYXRpb24pO1xuICAgIGlmICghbWF0Y2g/Lmdyb3Vwcz8ucnVuX2lkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bl9pZDogbWF0Y2guZ3JvdXBzLnJ1bl9pZCxcbiAgICAgICAgdGhyZWFkX2lkOiBtYXRjaC5ncm91cHMudGhyZWFkX2lkIHx8IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuY2xhc3MgQmFzZUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jQ2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWVvdXRNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdEhlYWRlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXF1ZXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhSZXRyaWVzOiA0LFxuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3k6IDQsXG4gICAgICAgICAgICAuLi5jb25maWc/LmNhbGxlck9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBkZWZhdWx0QXBpVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjgxMjNcIjtcbiAgICAgICAgaWYgKCFjb25maWc/LmFwaVVybCAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGdsb2JhbFRoaXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hTbWIgPSBTeW1ib2wuZm9yKFwibGFuZ2dyYXBoX2FwaTpmZXRjaFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHVybFNtYiA9IFN5bWJvbC5mb3IoXCJsYW5nZ3JhcGhfYXBpOnVybFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXM7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsW2ZldGNoU21iXSlcbiAgICAgICAgICAgICAgICBjYWxsZXJPcHRpb25zLmZldGNoID8/PSBnbG9iYWxbZmV0Y2hTbWJdO1xuICAgICAgICAgICAgaWYgKGdsb2JhbFt1cmxTbWJdKVxuICAgICAgICAgICAgICAgIGRlZmF1bHRBcGlVcmwgPSBnbG9iYWxbdXJsU21iXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzeW5jQ2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNhbGxlck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRpbWVvdXRNcyA9IGNvbmZpZz8udGltZW91dE1zO1xuICAgICAgICAvLyBkZWZhdWx0IGxpbWl0IGJlaW5nIGNhcHBlZCBieSBDaHJvbWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzEzNzNcbiAgICAgICAgLy8gUmVnZXggdG8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoLCBpZiBwcmVzZW50XG4gICAgICAgIHRoaXMuYXBpVXJsID0gY29uZmlnPy5hcGlVcmw/LnJlcGxhY2UoL1xcLyQvLCBcIlwiKSB8fCBkZWZhdWx0QXBpVXJsO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzID0gY29uZmlnPy5kZWZhdWx0SGVhZGVycyB8fCB7fTtcbiAgICAgICAgdGhpcy5vblJlcXVlc3QgPSBjb25maWc/Lm9uUmVxdWVzdDtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gZ2V0QXBpS2V5KGNvbmZpZz8uYXBpS2V5KTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0SGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlRmV0Y2hPcHRpb25zKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbXV0YXRlZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogbWVyZ2VIZWFkZXJzKHRoaXMuZGVmYXVsdEhlYWRlcnMsIG9wdGlvbnM/LmhlYWRlcnMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobXV0YXRlZE9wdGlvbnMuanNvbikge1xuICAgICAgICAgICAgbXV0YXRlZE9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG11dGF0ZWRPcHRpb25zLmpzb24pO1xuICAgICAgICAgICAgbXV0YXRlZE9wdGlvbnMuaGVhZGVycyA9IG1lcmdlSGVhZGVycyhtdXRhdGVkT3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBtdXRhdGVkT3B0aW9ucy5qc29uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdXRhdGVkT3B0aW9ucy53aXRoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtdXRhdGVkT3B0aW9ucy53aXRoUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVvdXRTaWduYWwgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnM/LnRpbWVvdXRNcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dE1zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0U2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChvcHRpb25zLnRpbWVvdXRNcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lb3V0TXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGltZW91dFNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0TXMpO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0ZWRPcHRpb25zLnNpZ25hbCA9IG1lcmdlU2lnbmFscyh0aW1lb3V0U2lnbmFsLCBtdXRhdGVkT3B0aW9ucy5zaWduYWwpO1xuICAgICAgICBjb25zdCB0YXJnZXRVcmwgPSBuZXcgVVJMKGAke3RoaXMuYXBpVXJsfSR7cGF0aH1gKTtcbiAgICAgICAgaWYgKG11dGF0ZWRPcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobXV0YXRlZE9wdGlvbnMucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRhcmdldFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgc3RyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG11dGF0ZWRPcHRpb25zLnBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RhcmdldFVybCwgbXV0YXRlZE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFt1cmwsIGluaXRdID0gdGhpcy5wcmVwYXJlRmV0Y2hPcHRpb25zKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgZmluYWxJbml0ID0gaW5pdDtcbiAgICAgICAgaWYgKHRoaXMub25SZXF1ZXN0KSB7XG4gICAgICAgICAgICBmaW5hbEluaXQgPSBhd2FpdCB0aGlzLm9uUmVxdWVzdCh1cmwsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCh1cmwsIGZpbmFsSW5pdCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAyIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmIChvcHRpb25zPy53aXRoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbYXdhaXQgYm9keSwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDcm9uc0NsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIGNyb24gam9iLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgY3JvbiBqb2IuXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYmFja2dyb3VuZCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRm9yVGhyZWFkKHRocmVhZElkLCBhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgc2NoZWR1bGU6IHBheWxvYWQ/LnNjaGVkdWxlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29uZmlnOiBwYXlsb2FkPy5jb25maWcsXG4gICAgICAgICAgICBjb250ZXh0OiBwYXlsb2FkPy5jb250ZXh0LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kdXJpbmc6IHBheWxvYWQ/LmNoZWNrcG9pbnREdXJpbmcsXG4gICAgICAgICAgICBkdXJhYmlsaXR5OiBwYXlsb2FkPy5kdXJhYmlsaXR5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy9jcm9uc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBjcm9uIGpvYi5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIGNyb24gam9iLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICBzY2hlZHVsZTogcGF5bG9hZD8uc2NoZWR1bGUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZD8uaW5wdXQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQ/LmNvbnRleHQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgICAgICBtdWx0aXRhc2tfc3RyYXRlZ3k6IHBheWxvYWQ/Lm11bHRpdGFza1N0cmF0ZWd5LFxuICAgICAgICAgICAgaWZfbm90X2V4aXN0czogcGF5bG9hZD8uaWZOb3RFeGlzdHMsXG4gICAgICAgICAgICBjaGVja3BvaW50X2R1cmluZzogcGF5bG9hZD8uY2hlY2twb2ludER1cmluZyxcbiAgICAgICAgICAgIGR1cmFiaWxpdHk6IHBheWxvYWQ/LmR1cmFiaWxpdHksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvcnVucy9jcm9uc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3JvbklkIENyb24gSUQgb2YgQ3JvbiBqb2IgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShjcm9uSWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5mZXRjaChgL3J1bnMvY3JvbnMvJHtjcm9uSWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGNyb25zLlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9ydW5zL2Nyb25zL3NlYXJjaFwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIGFzc2lzdGFudF9pZDogcXVlcnk/LmFzc2lzdGFudElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aHJlYWRfaWQ6IHF1ZXJ5Py50aHJlYWRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHF1ZXJ5Py5saW1pdCA/PyAxMCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHF1ZXJ5Py5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgICAgICBzb3J0X2J5OiBxdWVyeT8uc29ydEJ5ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzb3J0X29yZGVyOiBxdWVyeT8uc29ydE9yZGVyID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHF1ZXJ5Py5zZWxlY3QgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IGNyb24gam9icyBtYXRjaGluZyBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5LmFzc2lzdGFudElkIEFzc2lzdGFudCBJRCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5LnRocmVhZElkIFRocmVhZCBJRCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGNyb24gam9icyBtYXRjaGluZyB0aGUgY3JpdGVyaWEuXG4gICAgICovXG4gICAgYXN5bmMgY291bnQocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9ydW5zL2Nyb25zL2NvdW50YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IHF1ZXJ5Py5hc3Npc3RhbnRJZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhyZWFkX2lkOiBxdWVyeT8udGhyZWFkSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFzc2lzdGFudHNDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXNzaXN0YW50IGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIEFzc2lzdGFudFxuICAgICAqL1xuICAgIGFzeW5jIGdldChhc3Npc3RhbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaCBhc3NpZ25lZCB0byBhIHJ1bm5hYmxlXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnhyYXkgV2hldGhlciB0byBpbmNsdWRlIHN1YmdyYXBocyBpbiB0aGUgc2VyaWFsaXplZCBncmFwaCByZXByZXNlbnRhdGlvbi4gSWYgYW4gaW50ZWdlciB2YWx1ZSBpcyBwcm92aWRlZCwgb25seSBzdWJncmFwaHMgd2l0aCBhIGRlcHRoIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgd2lsbCBiZSBpbmNsdWRlZC5cbiAgICAgKiBAcmV0dXJucyBTZXJpYWxpemVkIGdyYXBoXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R3JhcGgoYXNzaXN0YW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L2dyYXBoYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7IHhyYXk6IG9wdGlvbnM/LnhyYXkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdGUgYW5kIGNvbmZpZyBzY2hlbWEgb2YgdGhlIGdyYXBoIGFzc2lnbmVkIHRvIGEgcnVubmFibGVcbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgVGhlIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgR3JhcGggc2NoZW1hXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2NoZW1hcyhhc3Npc3RhbnRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vc2NoZW1hc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNjaGVtYXMgb2YgYW4gYXNzaXN0YW50IGJ5IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIFRoZSBJRCBvZiB0aGUgYXNzaXN0YW50IHRvIGdldCB0aGUgc2NoZW1hIG9mLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyBzdWJncmFwaHMsIHN1Y2ggYXMgbmFtZXNwYWNlIG9yIHJlY3Vyc2lvbiBleHRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdWJncmFwaHMgb2YgdGhlIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdWJncmFwaHMoYXNzaXN0YW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L3N1YmdyYXBocy8ke29wdGlvbnMubmFtZXNwYWNlfWAsIHsgcGFyYW1zOiB7IHJlY3Vyc2U6IG9wdGlvbnM/LnJlY3Vyc2UgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH0vc3ViZ3JhcGhzYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7IHJlY3Vyc2U6IG9wdGlvbnM/LnJlY3Vyc2UgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhc3Npc3RhbnQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYW4gYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9hc3Npc3RhbnRzXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHBheWxvYWQuZ3JhcGhJZCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBheWxvYWQuY29uZmlnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQuY29udGV4dCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IHBheWxvYWQuYXNzaXN0YW50SWQsXG4gICAgICAgICAgICAgICAgaWZfZXhpc3RzOiBwYXlsb2FkLmlmRXhpc3RzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcGF5bG9hZC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIHVwZGF0aW5nIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgYXNzaXN0YW50LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL2Fzc2lzdGFudHMvJHthc3Npc3RhbnRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBncmFwaF9pZDogcGF5bG9hZC5ncmFwaElkLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZC5jb25maWcsXG4gICAgICAgICAgICAgICAgY29udGV4dDogcGF5bG9hZC5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcGF5bG9hZC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYXNzaXN0YW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGFzc2lzdGFudElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXNzaXN0YW50cy5cbiAgICAgKiBAcGFyYW0gcXVlcnkgUXVlcnkgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIGFzc2lzdGFudHMuXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL2Fzc2lzdGFudHMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgZ3JhcGhfaWQ6IHF1ZXJ5Py5ncmFwaElkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcXVlcnk/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcXVlcnk/Lm9mZnNldCA/PyAwLFxuICAgICAgICAgICAgICAgIHNvcnRfYnk6IHF1ZXJ5Py5zb3J0QnkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvcnRfb3JkZXI6IHF1ZXJ5Py5zb3J0T3JkZXIgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogcXVlcnk/LnNlbGVjdCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnQgYXNzaXN0YW50cyBtYXRjaGluZyBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5Lm1ldGFkYXRhIE1ldGFkYXRhIHRvIGZpbHRlciBieS4gRXhhY3QgbWF0Y2ggZm9yIGVhY2gga2V5L3ZhbHVlLlxuICAgICAqIEBwYXJhbSBxdWVyeS5ncmFwaElkIE9wdGlvbmFsIGdyYXBoIGlkIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYXNzaXN0YW50cyBtYXRjaGluZyB0aGUgY3JpdGVyaWEuXG4gICAgICovXG4gICAgYXN5bmMgY291bnQocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzL2NvdW50YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBncmFwaF9pZDogcXVlcnk/LmdyYXBoSWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHZlcnNpb25zIG9mIGFuIGFzc2lzdGFudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBJRCBvZiB0aGUgYXNzaXN0YW50LlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgYXNzaXN0YW50IHZlcnNpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZlcnNpb25zKGFzc2lzdGFudElkLCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvYXNzaXN0YW50cy8ke2Fzc2lzdGFudElkfS92ZXJzaW9uc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQ/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogcGF5bG9hZD8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXlsb2FkPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIHZlcnNpb24gb2YgYW4gYXNzaXN0YW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2lzdGFudElkIElEIG9mIHRoZSBhc3Npc3RhbnQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIHZlcnNpb24gdG8gY2hhbmdlIHRvLlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGFzc2lzdGFudC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRMYXRlc3QoYXNzaXN0YW50SWQsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC9hc3Npc3RhbnRzLyR7YXNzaXN0YW50SWR9L2xhdGVzdGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiB7IHZlcnNpb24gfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRocmVhZHNDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB0aHJlYWQgYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdGhyZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldCh0aHJlYWRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgdGhyZWFkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHRocmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGF5bG9hZCkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdHRsIHRvIGFuIG9iamVjdCBpZiBhIG51bWJlciBpcyBwcm92aWRlZFxuICAgICAgICBjb25zdCB0dGxQYXlsb2FkID0gdHlwZW9mIHBheWxvYWQ/LnR0bCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyB7IHR0bDogcGF5bG9hZC50dGwsIHN0cmF0ZWd5OiBcImRlbGV0ZVwiIH1cbiAgICAgICAgICAgIDogcGF5bG9hZD8udHRsO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBheWxvYWQ/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBncmFwaF9pZDogcGF5bG9hZD8uZ3JhcGhJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocmVhZF9pZDogcGF5bG9hZD8udGhyZWFkSWQsXG4gICAgICAgICAgICAgICAgaWZfZXhpc3RzOiBwYXlsb2FkPy5pZkV4aXN0cyxcbiAgICAgICAgICAgICAgICBzdXBlcnN0ZXBzOiBwYXlsb2FkPy5zdXBlcnN0ZXBzPy5tYXAoKHMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXM6IHMudXBkYXRlcy5tYXAoKHUpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHUudmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogdS5jb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNfbm9kZTogdS5hc05vZGUsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgdHRsOiB0dGxQYXlsb2FkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgYW4gZXhpc3RpbmcgdGhyZWFkXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQgdG8gYmUgY29waWVkXG4gICAgICogQHJldHVybnMgTmV3bHkgY29waWVkIHRocmVhZFxuICAgICAqL1xuICAgIGFzeW5jIGNvcHkodGhyZWFkSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L2NvcHlgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgdXBkYXRpbmcgdGhlIHRocmVhZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHRocmVhZElkLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHR0bFBheWxvYWQgPSB0eXBlb2YgcGF5bG9hZD8udHRsID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IHsgdHRsOiBwYXlsb2FkLnR0bCwgc3RyYXRlZ3k6IFwiZGVsZXRlXCIgfVxuICAgICAgICAgICAgOiBwYXlsb2FkPy50dGw7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAganNvbjogeyBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsIHR0bDogdHRsUGF5bG9hZCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHRocmVhZElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdGhyZWFkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IFF1ZXJ5IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIHRocmVhZHNcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvdGhyZWFkcy9zZWFyY2hcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcXVlcnk/Lm1ldGFkYXRhID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpZHM6IHF1ZXJ5Py5pZHMgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBxdWVyeT8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBxdWVyeT8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBxdWVyeT8uc3RhdHVzLFxuICAgICAgICAgICAgICAgIHNvcnRfYnk6IHF1ZXJ5Py5zb3J0QnksXG4gICAgICAgICAgICAgICAgc29ydF9vcmRlcjogcXVlcnk/LnNvcnRPcmRlcixcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHF1ZXJ5Py5zZWxlY3QgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IHRocmVhZHMgbWF0Y2hpbmcgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeS5tZXRhZGF0YSBUaHJlYWQgbWV0YWRhdGEgdG8gZmlsdGVyIG9uLlxuICAgICAqIEBwYXJhbSBxdWVyeS52YWx1ZXMgU3RhdGUgdmFsdWVzIHRvIGZpbHRlciBvbi5cbiAgICAgKiBAcGFyYW0gcXVlcnkuc3RhdHVzIFRocmVhZCBzdGF0dXMgdG8gZmlsdGVyIG9uLlxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiB0aHJlYWRzIG1hdGNoaW5nIHRoZSBjcml0ZXJpYS5cbiAgICAgKi9cbiAgICBhc3luYyBjb3VudChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvY291bnRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBxdWVyeT8ubWV0YWRhdGEgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHZhbHVlczogcXVlcnk/LnZhbHVlcyA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBxdWVyeT8uc3RhdHVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RhdGUgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnMgVGhyZWFkIHN0YXRlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRlKHRocmVhZElkLCBjaGVja3BvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChjaGVja3BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hlY2twb2ludCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9zdGF0ZS9jaGVja3BvaW50YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7IGNoZWNrcG9pbnQsIHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGUvJHtjaGVja3BvaW50fWAsIHsgcGFyYW1zOiB7IHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0YXRlYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7IHN1YmdyYXBoczogb3B0aW9ucz8uc3ViZ3JhcGhzIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgc3RhdGUgdG8gYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVTdGF0ZSh0aHJlYWRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlczogb3B0aW9ucy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludF9pZDogb3B0aW9ucy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICAgICAgY2hlY2twb2ludDogb3B0aW9ucy5jaGVja3BvaW50LFxuICAgICAgICAgICAgICAgIGFzX25vZGU6IG9wdGlvbnM/LmFzTm9kZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXRjaCB0aGUgbWV0YWRhdGEgb2YgYSB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWRPckNvbmZpZyBUaHJlYWQgSUQgb3IgY29uZmlnIHRvIHBhdGNoIHRoZSBzdGF0ZSBvZi5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgTWV0YWRhdGEgdG8gcGF0Y2ggdGhlIHN0YXRlIHdpdGguXG4gICAgICovXG4gICAgYXN5bmMgcGF0Y2hTdGF0ZSh0aHJlYWRJZE9yQ29uZmlnLCBtZXRhZGF0YSkge1xuICAgICAgICBsZXQgdGhyZWFkSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGhyZWFkSWRPckNvbmZpZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aHJlYWRJZE9yQ29uZmlnLmNvbmZpZ3VyYWJsZT8udGhyZWFkX2lkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhyZWFkIElEIGlzIHJlcXVpcmVkIHdoZW4gdXBkYXRpbmcgc3RhdGUgd2l0aCBhIGNvbmZpZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJlYWRJZCA9IHRocmVhZElkT3JDb25maWcuY29uZmlndXJhYmxlLnRocmVhZF9pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocmVhZElkID0gdGhyZWFkSWRPckNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vc3RhdGVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGpzb246IHsgbWV0YWRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcGFzdCBzdGF0ZXMgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgdGhyZWFkIHN0YXRlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRIaXN0b3J5KHRocmVhZElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9oaXN0b3J5YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAsXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBvcHRpb25zPy5iZWZvcmUsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnM/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGNoZWNrcG9pbnQ6IG9wdGlvbnM/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgKmpvaW5TdHJlYW0odGhyZWFkSWQsIG9wdGlvbnNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICBsZXQgW3VybCwgaW5pdF0gPSB0aGlzLnByZXBhcmVGZXRjaE9wdGlvbnMoYC90aHJlYWRzLyR7dGhyZWFkSWR9L3N0cmVhbWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnM/Lmxhc3RFdmVudElkXG4gICAgICAgICAgICAgICAgPyB7IFwiTGFzdC1FdmVudC1JRFwiOiBvcHRpb25zLmxhc3RFdmVudElkIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmFtczogb3B0aW9ucz8uc3RyZWFtTW9kZVxuICAgICAgICAgICAgICAgID8geyBzdHJlYW1fbW9kZTogb3B0aW9ucy5zdHJlYW1Nb2RlIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9uUmVxdWVzdCAhPSBudWxsKVxuICAgICAgICAgICAgaW5pdCA9IGF3YWl0IHRoaXMub25SZXF1ZXN0KHVybCwgaW5pdCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hc3luY0NhbGxlci5mZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBzdHJlYW0gPSAocmVzcG9uc2UuYm9keSB8fCBuZXcgUmVhZGFibGVTdHJlYW0oeyBzdGFydDogKGN0cmwpID0+IGN0cmwuY2xvc2UoKSB9KSlcbiAgICAgICAgICAgIC5waXBlVGhyb3VnaChCeXRlc0xpbmVEZWNvZGVyKCkpXG4gICAgICAgICAgICAucGlwZVRocm91Z2goU1NFRGVjb2RlcigpKTtcbiAgICAgICAgeWllbGQqIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bnNDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBydW4gYW5kIHN0cmVhbSB0aGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBydW4uXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBydW4uXG4gICAgICovXG4gICAgYXN5bmMgKnN0cmVhbSh0aHJlYWRJZCwgYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHBheWxvYWQ/LmNvbW1hbmQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQ/LmNvbnRleHQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBzdHJlYW1fbW9kZTogcGF5bG9hZD8uc3RyZWFtTW9kZSxcbiAgICAgICAgICAgIHN0cmVhbV9zdWJncmFwaHM6IHBheWxvYWQ/LnN0cmVhbVN1YmdyYXBocyxcbiAgICAgICAgICAgIHN0cmVhbV9yZXN1bWFibGU6IHBheWxvYWQ/LnN0cmVhbVJlc3VtYWJsZSxcbiAgICAgICAgICAgIGZlZWRiYWNrX2tleXM6IHBheWxvYWQ/LmZlZWRiYWNrS2V5cyxcbiAgICAgICAgICAgIGFzc2lzdGFudF9pZDogYXNzaXN0YW50SWQsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYmVmb3JlOiBwYXlsb2FkPy5pbnRlcnJ1cHRCZWZvcmUsXG4gICAgICAgICAgICBpbnRlcnJ1cHRfYWZ0ZXI6IHBheWxvYWQ/LmludGVycnVwdEFmdGVyLFxuICAgICAgICAgICAgY2hlY2twb2ludDogcGF5bG9hZD8uY2hlY2twb2ludCxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHBheWxvYWQ/LmNoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgIHdlYmhvb2s6IHBheWxvYWQ/LndlYmhvb2ssXG4gICAgICAgICAgICBtdWx0aXRhc2tfc3RyYXRlZ3k6IHBheWxvYWQ/Lm11bHRpdGFza1N0cmF0ZWd5LFxuICAgICAgICAgICAgb25fY29tcGxldGlvbjogcGF5bG9hZD8ub25Db21wbGV0aW9uLFxuICAgICAgICAgICAgb25fZGlzY29ubmVjdDogcGF5bG9hZD8ub25EaXNjb25uZWN0LFxuICAgICAgICAgICAgYWZ0ZXJfc2Vjb25kczogcGF5bG9hZD8uYWZ0ZXJTZWNvbmRzLFxuICAgICAgICAgICAgaWZfbm90X2V4aXN0czogcGF5bG9hZD8uaWZOb3RFeGlzdHMsXG4gICAgICAgICAgICBjaGVja3BvaW50X2R1cmluZzogcGF5bG9hZD8uY2hlY2twb2ludER1cmluZyxcbiAgICAgICAgICAgIGR1cmFiaWxpdHk6IHBheWxvYWQ/LmR1cmFiaWxpdHksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhyZWFkSWQgPT0gbnVsbCA/IGAvcnVucy9zdHJlYW1gIDogYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvc3RyZWFtYDtcbiAgICAgICAgbGV0IFt1cmwsIGluaXRdID0gdGhpcy5wcmVwYXJlRmV0Y2hPcHRpb25zKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRpbWVvdXRNczogbnVsbCxcbiAgICAgICAgICAgIHNpZ25hbDogcGF5bG9hZD8uc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub25SZXF1ZXN0ICE9IG51bGwpXG4gICAgICAgICAgICBpbml0ID0gYXdhaXQgdGhpcy5vblJlcXVlc3QodXJsLCBpbml0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jQ2FsbGVyLmZldGNoKHVybCwgaW5pdCk7XG4gICAgICAgIGNvbnN0IHJ1bk1ldGFkYXRhID0gZ2V0UnVuTWV0YWRhdGFGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBpZiAocnVuTWV0YWRhdGEpXG4gICAgICAgICAgICBwYXlsb2FkPy5vblJ1bkNyZWF0ZWQ/LihydW5NZXRhZGF0YSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IChyZXNwb25zZS5ib2R5IHx8IG5ldyBSZWFkYWJsZVN0cmVhbSh7IHN0YXJ0OiAoY3RybCkgPT4gY3RybC5jbG9zZSgpIH0pKVxuICAgICAgICAgICAgLnBpcGVUaHJvdWdoKEJ5dGVzTGluZURlY29kZXIoKSlcbiAgICAgICAgICAgIC5waXBlVGhyb3VnaChTU0VEZWNvZGVyKCkpO1xuICAgICAgICB5aWVsZCogSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRJZCBBc3Npc3RhbnQgSUQgdG8gdXNlIGZvciB0aGlzIHJ1bi5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBydW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHRocmVhZElkLCBhc3Npc3RhbnRJZCwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQ/LmlucHV0LFxuICAgICAgICAgICAgY29tbWFuZDogcGF5bG9hZD8uY29tbWFuZCxcbiAgICAgICAgICAgIGNvbmZpZzogcGF5bG9hZD8uY29uZmlnLFxuICAgICAgICAgICAgY29udGV4dDogcGF5bG9hZD8uY29udGV4dCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIHN0cmVhbV9tb2RlOiBwYXlsb2FkPy5zdHJlYW1Nb2RlLFxuICAgICAgICAgICAgc3RyZWFtX3N1YmdyYXBoczogcGF5bG9hZD8uc3RyZWFtU3ViZ3JhcGhzLFxuICAgICAgICAgICAgc3RyZWFtX3Jlc3VtYWJsZTogcGF5bG9hZD8uc3RyZWFtUmVzdW1hYmxlLFxuICAgICAgICAgICAgYXNzaXN0YW50X2lkOiBhc3Npc3RhbnRJZCxcbiAgICAgICAgICAgIGludGVycnVwdF9iZWZvcmU6IHBheWxvYWQ/LmludGVycnVwdEJlZm9yZSxcbiAgICAgICAgICAgIGludGVycnVwdF9hZnRlcjogcGF5bG9hZD8uaW50ZXJydXB0QWZ0ZXIsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgY2hlY2twb2ludDogcGF5bG9hZD8uY2hlY2twb2ludCxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IHBheWxvYWQ/LmNoZWNrcG9pbnRJZCxcbiAgICAgICAgICAgIG11bHRpdGFza19zdHJhdGVneTogcGF5bG9hZD8ubXVsdGl0YXNrU3RyYXRlZ3ksXG4gICAgICAgICAgICBhZnRlcl9zZWNvbmRzOiBwYXlsb2FkPy5hZnRlclNlY29uZHMsXG4gICAgICAgICAgICBpZl9ub3RfZXhpc3RzOiBwYXlsb2FkPy5pZk5vdEV4aXN0cyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfZHVyaW5nOiBwYXlsb2FkPy5jaGVja3BvaW50RHVyaW5nLFxuICAgICAgICAgICAgZHVyYWJpbGl0eTogcGF5bG9hZD8uZHVyYWJpbGl0eSxcbiAgICAgICAgICAgIGxhbmdzbWl0aF90cmFjZXI6IHBheWxvYWQ/Ll9sYW5nc21pdGhUcmFjZXJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwYXlsb2FkPy5fbGFuZ3NtaXRoVHJhY2VyPy5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZV9pZDogcGF5bG9hZD8uX2xhbmdzbWl0aFRyYWNlcj8uZXhhbXBsZUlkLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aHJlYWRJZCA9PT0gbnVsbCA/IFwiL3J1bnNcIiA6IGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYDtcbiAgICAgICAgY29uc3QgW3J1biwgcmVzcG9uc2VdID0gYXdhaXQgdGhpcy5mZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICBzaWduYWw6IHBheWxvYWQ/LnNpZ25hbCxcbiAgICAgICAgICAgIHdpdGhSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1ldGFkYXRhID0gZ2V0UnVuTWV0YWRhdGFGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBpZiAocnVuTWV0YWRhdGEpXG4gICAgICAgICAgICBwYXlsb2FkPy5vblJ1bkNyZWF0ZWQ/LihydW5NZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGJhdGNoIG9mIHN0YXRlbGVzcyBiYWNrZ3JvdW5kIHJ1bnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF5bG9hZHMgQW4gYXJyYXkgb2YgcGF5bG9hZHMgZm9yIGNyZWF0aW5nIHJ1bnMuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgY3JlYXRlZCBydW5zLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJhdGNoKHBheWxvYWRzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUGF5bG9hZHMgPSBwYXlsb2Fkc1xuICAgICAgICAgICAgLm1hcCgocGF5bG9hZCkgPT4gKHsgLi4ucGF5bG9hZCwgYXNzaXN0YW50X2lkOiBwYXlsb2FkLmFzc2lzdGFudElkIH0pKVxuICAgICAgICAgICAgLm1hcCgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhwYXlsb2FkKS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9ydW5zL2JhdGNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiBmaWx0ZXJlZFBheWxvYWRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVuIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC5cbiAgICAgKiBAcGFyYW0gYXNzaXN0YW50SWQgQXNzaXN0YW50IElEIHRvIHVzZSBmb3IgdGhpcyBydW4uXG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCBmb3IgY3JlYXRpbmcgYSBydW4uXG4gICAgICogQHJldHVybnMgVGhlIGxhc3QgdmFsdWVzIGNodW5rIG9mIHRoZSB0aHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh0aHJlYWRJZCwgYXNzaXN0YW50SWQsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkPy5pbnB1dCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHBheWxvYWQ/LmNvbW1hbmQsXG4gICAgICAgICAgICBjb25maWc6IHBheWxvYWQ/LmNvbmZpZyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHBheWxvYWQ/LmNvbnRleHQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZD8ubWV0YWRhdGEsXG4gICAgICAgICAgICBhc3Npc3RhbnRfaWQ6IGFzc2lzdGFudElkLFxuICAgICAgICAgICAgaW50ZXJydXB0X2JlZm9yZTogcGF5bG9hZD8uaW50ZXJydXB0QmVmb3JlLFxuICAgICAgICAgICAgaW50ZXJydXB0X2FmdGVyOiBwYXlsb2FkPy5pbnRlcnJ1cHRBZnRlcixcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHBheWxvYWQ/LmNoZWNrcG9pbnQsXG4gICAgICAgICAgICBjaGVja3BvaW50X2lkOiBwYXlsb2FkPy5jaGVja3BvaW50SWQsXG4gICAgICAgICAgICB3ZWJob29rOiBwYXlsb2FkPy53ZWJob29rLFxuICAgICAgICAgICAgbXVsdGl0YXNrX3N0cmF0ZWd5OiBwYXlsb2FkPy5tdWx0aXRhc2tTdHJhdGVneSxcbiAgICAgICAgICAgIG9uX2NvbXBsZXRpb246IHBheWxvYWQ/Lm9uQ29tcGxldGlvbixcbiAgICAgICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IHBheWxvYWQ/Lm9uRGlzY29ubmVjdCxcbiAgICAgICAgICAgIGFmdGVyX3NlY29uZHM6IHBheWxvYWQ/LmFmdGVyU2Vjb25kcyxcbiAgICAgICAgICAgIGlmX25vdF9leGlzdHM6IHBheWxvYWQ/LmlmTm90RXhpc3RzLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kdXJpbmc6IHBheWxvYWQ/LmNoZWNrcG9pbnREdXJpbmcsXG4gICAgICAgICAgICBkdXJhYmlsaXR5OiBwYXlsb2FkPy5kdXJhYmlsaXR5LFxuICAgICAgICAgICAgbGFuZ3NtaXRoX3RyYWNlcjogcGF5bG9hZD8uX2xhbmdzbWl0aFRyYWNlclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHBheWxvYWQ/Ll9sYW5nc21pdGhUcmFjZXI/LnByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBleGFtcGxlX2lkOiBwYXlsb2FkPy5fbGFuZ3NtaXRoVHJhY2VyPy5leGFtcGxlSWQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRocmVhZElkID09IG51bGwgPyBgL3J1bnMvd2FpdGAgOiBgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy93YWl0YDtcbiAgICAgICAgY29uc3QgW3J1biwgcmVzcG9uc2VdID0gYXdhaXQgdGhpcy5mZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0aW1lb3V0TXM6IG51bGwsXG4gICAgICAgICAgICBzaWduYWw6IHBheWxvYWQ/LnNpZ25hbCxcbiAgICAgICAgICAgIHdpdGhSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bk1ldGFkYXRhID0gZ2V0UnVuTWV0YWRhdGFGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBpZiAocnVuTWV0YWRhdGEpXG4gICAgICAgICAgICBwYXlsb2FkPy5vblJ1bkNyZWF0ZWQ/LihydW5NZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHJhaXNlRXJyb3IgPSBwYXlsb2FkPy5yYWlzZUVycm9yICE9PSB1bmRlZmluZWQgPyBwYXlsb2FkLnJhaXNlRXJyb3IgOiB0cnVlO1xuICAgICAgICBpZiAocmFpc2VFcnJvciAmJlxuICAgICAgICAgICAgXCJfX2Vycm9yX19cIiBpbiBydW4gJiZcbiAgICAgICAgICAgIHR5cGVvZiBydW4uX19lcnJvcl9fID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBydW4uX19lcnJvcl9fICYmXG4gICAgICAgICAgICBcImVycm9yXCIgaW4gcnVuLl9fZXJyb3JfXyAmJlxuICAgICAgICAgICAgXCJtZXNzYWdlXCIgaW4gcnVuLl9fZXJyb3JfXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3J1bi5fX2Vycm9yX18/LmVycm9yfTogJHtydW4uX19lcnJvcl9fPy5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHJ1bnMgZm9yIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgcnVucy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KHRocmVhZElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zYCwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBvcHRpb25zPy5zdGF0dXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogb3B0aW9ucz8uc2VsZWN0ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydW4gYnkgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEByZXR1cm5zIFRoZSBydW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHRocmVhZElkLCBydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChgL3RocmVhZHMvJHt0aHJlYWRJZH0vcnVucy8ke3J1bklkfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZWFkSWQgVGhlIElEIG9mIHRoZSB0aHJlYWQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSB3YWl0IFdoZXRoZXIgdG8gYmxvY2sgd2hlbiBjYW5jZWxpbmdcbiAgICAgKiBAcGFyYW0gYWN0aW9uIEFjdGlvbiB0byB0YWtlIHdoZW4gY2FuY2VsbGluZyB0aGUgcnVuLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBpbnRlcnJ1cHRgIG9yIGByb2xsYmFja2AuIERlZmF1bHQgaXMgYGludGVycnVwdGAuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwodGhyZWFkSWQsIHJ1bklkLCB3YWl0ID0gZmFsc2UsIGFjdGlvbiA9IFwiaW50ZXJydXB0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH0vY2FuY2VsYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIHdhaXQ6IHdhaXQgPyBcIjFcIiA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbG9jayB1bnRpbCBhIHJ1biBpcyBkb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGpvaW4odGhyZWFkSWQsIHJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L2pvaW5gLCB7XG4gICAgICAgICAgICB0aW1lb3V0TXM6IG51bGwsXG4gICAgICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvdXRwdXQgZnJvbSBhIHJ1biBpbiByZWFsLXRpbWUsIHVudGlsIHRoZSBydW4gaXMgZG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlYWRJZCBUaGUgSUQgb2YgdGhlIHRocmVhZC4gQ2FuIGJlIHNldCB0byBgbnVsbGAgfCBgdW5kZWZpbmVkYCBmb3Igc3RhdGVsZXNzIHJ1bnMuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgY29udHJvbGxpbmcgdGhlIHN0cmVhbSBiZWhhdmlvcjpcbiAgICAgKiAgIC0gc2lnbmFsOiBBbiBBYm9ydFNpZ25hbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgc3RyZWFtIHJlcXVlc3RcbiAgICAgKiAgIC0gbGFzdEV2ZW50SWQ6IFRoZSBJRCBvZiB0aGUgbGFzdCBldmVudCByZWNlaXZlZC4gQ2FuIGJlIHVzZWQgdG8gcmVjb25uZWN0IHRvIGEgc3RyZWFtIHdpdGhvdXQgbG9zaW5nIGV2ZW50cy5cbiAgICAgKiAgIC0gY2FuY2VsT25EaXNjb25uZWN0OiBXaGVuIHRydWUsIGF1dG9tYXRpY2FsbHkgY2FuY2VscyB0aGUgcnVuIGlmIHRoZSBjbGllbnQgZGlzY29ubmVjdHMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICogICAtIHN0cmVhbU1vZGU6IENvbnRyb2xzIHdoYXQgdHlwZXMgb2YgZXZlbnRzIHRvIHJlY2VpdmUgZnJvbSB0aGUgc3RyZWFtIChjYW4gYmUgYSBzaW5nbGUgbW9kZSBvciBhcnJheSBvZiBtb2RlcylcbiAgICAgKiAgICAgICAgTXVzdCBiZSBhIHN1YnNldCBvZiB0aGUgc3RyZWFtIG1vZGVzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBydW4uIEJhY2tncm91bmQgcnVucyBkZWZhdWx0IHRvIGhhdmluZyB0aGUgdW5pb24gb2YgYWxsXG4gICAgICogICAgICAgIHN0cmVhbSBtb2RlcyBlbmFibGVkLlxuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jIGdlbmVyYXRvciB5aWVsZGluZyBzdHJlYW0gcGFydHMuXG4gICAgICovXG4gICAgYXN5bmMgKmpvaW5TdHJlYW0odGhyZWFkSWQsIHJ1bklkLCBvcHRpb25zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBvcHRpb25zICE9IG51bGwgJiZcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIG9wdGlvbnMgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbFxuICAgICAgICAgICAgPyB7IHNpZ25hbDogb3B0aW9ucyB9XG4gICAgICAgICAgICA6IG9wdGlvbnM7XG4gICAgICAgIGxldCBbdXJsLCBpbml0XSA9IHRoaXMucHJlcGFyZUZldGNoT3B0aW9ucyh0aHJlYWRJZCAhPSBudWxsXG4gICAgICAgICAgICA/IGAvdGhyZWFkcy8ke3RocmVhZElkfS9ydW5zLyR7cnVuSWR9L3N0cmVhbWBcbiAgICAgICAgICAgIDogYC9ydW5zLyR7cnVuSWR9L3N0cmVhbWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIHRpbWVvdXRNczogbnVsbCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cz8uc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczogb3B0cz8ubGFzdEV2ZW50SWRcbiAgICAgICAgICAgICAgICA/IHsgXCJMYXN0LUV2ZW50LUlEXCI6IG9wdHMubGFzdEV2ZW50SWQgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsX29uX2Rpc2Nvbm5lY3Q6IG9wdHM/LmNhbmNlbE9uRGlzY29ubmVjdCA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgc3RyZWFtX21vZGU6IG9wdHM/LnN0cmVhbU1vZGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub25SZXF1ZXN0ICE9IG51bGwpXG4gICAgICAgICAgICBpbml0ID0gYXdhaXQgdGhpcy5vblJlcXVlc3QodXJsLCBpbml0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jQ2FsbGVyLmZldGNoKHVybCwgaW5pdCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IChyZXNwb25zZS5ib2R5IHx8IG5ldyBSZWFkYWJsZVN0cmVhbSh7IHN0YXJ0OiAoY3RybCkgPT4gY3RybC5jbG9zZSgpIH0pKVxuICAgICAgICAgICAgLnBpcGVUaHJvdWdoKEJ5dGVzTGluZURlY29kZXIoKSlcbiAgICAgICAgICAgIC5waXBlVGhyb3VnaChTU0VEZWNvZGVyKCkpO1xuICAgICAgICB5aWVsZCogSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRocmVhZElkIFRoZSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh0aHJlYWRJZCwgcnVuSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goYC90aHJlYWRzLyR7dGhyZWFkSWR9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTdG9yZUNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFN0b3JlIG9yIHVwZGF0ZSBhbiBpdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBBIGxpc3Qgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG5hbWVzcGFjZSBwYXRoLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgaXRlbSB3aXRoaW4gdGhlIG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGl0ZW0ncyBkYXRhLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluZGV4IENvbnRyb2xzIHNlYXJjaCBpbmRleGluZyAtIG51bGwgKHVzZSBkZWZhdWx0cyksIGZhbHNlIChkaXNhYmxlKSwgb3IgbGlzdCBvZiBmaWVsZCBwYXRocyB0byBpbmRleC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50dGwgT3B0aW9uYWwgdGltZS10by1saXZlIGluIG1pbnV0ZXMgZm9yIHRoZSBpdGVtLCBvciBudWxsIGZvciBubyBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGF3YWl0IGNsaWVudC5zdG9yZS5wdXRJdGVtKFxuICAgICAqICAgW1wiZG9jdW1lbnRzXCIsIFwidXNlcjEyM1wiXSxcbiAgICAgKiAgIFwiaXRlbTQ1NlwiLFxuICAgICAqICAgeyB0aXRsZTogXCJNeSBEb2N1bWVudFwiLCBjb250ZW50OiBcIkhlbGxvIFdvcmxkXCIgfSxcbiAgICAgKiAgIHsgdHRsOiA2MCB9IC8vIGV4cGlyZXMgaW4gNjAgbWludXRlc1xuICAgICAqICk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcHV0SXRlbShuYW1lc3BhY2UsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgbmFtZXNwYWNlLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAobGFiZWwuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZSBsYWJlbCAnJHtsYWJlbH0nLiBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBjb250YWluIHBlcmlvZHMgKCcuJylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGluZGV4OiBvcHRpb25zPy5pbmRleCxcbiAgICAgICAgICAgIHR0bDogb3B0aW9ucz8udHRsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcIi9zdG9yZS9pdGVtc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBqc29uOiBwYXlsb2FkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBzaW5nbGUgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgQSBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBuYW1lc3BhY2UgcGF0aC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGl0ZW0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmcmVzaFR0bCBXaGV0aGVyIHRvIHJlZnJlc2ggdGhlIFRUTCBvbiB0aGlzIHJlYWQgb3BlcmF0aW9uLiBJZiBudWxsLCB1c2VzIHRoZSBzdG9yZSdzIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxJdGVtPlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXRlbSA9IGF3YWl0IGNsaWVudC5zdG9yZS5nZXRJdGVtKFxuICAgICAqICAgW1wiZG9jdW1lbnRzXCIsIFwidXNlcjEyM1wiXSxcbiAgICAgKiAgIFwiaXRlbTQ1NlwiLFxuICAgICAqICAgeyByZWZyZXNoVHRsOiB0cnVlIH1cbiAgICAgKiApO1xuICAgICAqIGNvbnNvbGUubG9nKGl0ZW0pO1xuICAgICAqIC8vIHtcbiAgICAgKiAvLyAgIG5hbWVzcGFjZTogW1wiZG9jdW1lbnRzXCIsIFwidXNlcjEyM1wiXSxcbiAgICAgKiAvLyAgIGtleTogXCJpdGVtNDU2XCIsXG4gICAgICogLy8gICB2YWx1ZTogeyB0aXRsZTogXCJNeSBEb2N1bWVudFwiLCBjb250ZW50OiBcIkhlbGxvIFdvcmxkXCIgfSxcbiAgICAgKiAvLyAgIGNyZWF0ZWRBdDogXCIyMDI0LTA3LTMwVDEyOjAwOjAwWlwiLFxuICAgICAqIC8vICAgdXBkYXRlZEF0OiBcIjIwMjQtMDctMzBUMTI6MDA6MDBaXCJcbiAgICAgKiAvLyB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SXRlbShuYW1lc3BhY2UsIGtleSwgb3B0aW9ucykge1xuICAgICAgICBuYW1lc3BhY2UuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChsYWJlbC5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmFtZXNwYWNlIGxhYmVsICcke2xhYmVsfScuIE5hbWVzcGFjZSBsYWJlbHMgY2Fubm90IGNvbnRhaW4gcGVyaW9kcyAoJy4nKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2Uuam9pbihcIi5cIiksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zPy5yZWZyZXNoVHRsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5yZWZyZXNoX3R0bCA9IG9wdGlvbnMucmVmcmVzaFR0bDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXNcIiwge1xuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHJlc3BvbnNlLmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiByZXNwb25zZS51cGRhdGVkX2F0LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gaXRlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgQSBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBuYW1lc3BhY2UgcGF0aC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGl0ZW0uXG4gICAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUl0ZW0obmFtZXNwYWNlLCBrZXkpIHtcbiAgICAgICAgbmFtZXNwYWNlLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAobGFiZWwuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5hbWVzcGFjZSBsYWJlbCAnJHtsYWJlbH0nLiBOYW1lc3BhY2UgbGFiZWxzIGNhbm5vdCBjb250YWluIHBlcmlvZHMgKCcuJylgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiL3N0b3JlL2l0ZW1zXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGpzb246IHsgbmFtZXNwYWNlLCBrZXkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgaXRlbXMgd2l0aGluIGEgbmFtZXNwYWNlIHByZWZpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2VQcmVmaXggTGlzdCBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlIHByZWZpeC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWx0ZXIgT3B0aW9uYWwgZGljdGlvbmFyeSBvZiBrZXktdmFsdWUgcGFpcnMgdG8gZmlsdGVyIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuIChkZWZhdWx0IGlzIDEwKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgTnVtYmVyIG9mIGl0ZW1zIHRvIHNraXAgYmVmb3JlIHJldHVybmluZyByZXN1bHRzIChkZWZhdWx0IGlzIDApLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5IE9wdGlvbmFsIHNlYXJjaCBxdWVyeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZyZXNoVHRsIFdoZXRoZXIgdG8gcmVmcmVzaCB0aGUgVFRMIG9uIGl0ZW1zIHJldHVybmVkIGJ5IHRoaXMgc2VhcmNoLiBJZiBudWxsLCB1c2VzIHRoZSBzdG9yZSdzIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxTZWFyY2hJdGVtc1Jlc3BvbnNlPlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNsaWVudC5zdG9yZS5zZWFyY2hJdGVtcyhcbiAgICAgKiAgIFtcImRvY3VtZW50c1wiXSxcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgZmlsdGVyOiB7IGF1dGhvcjogXCJKb2huIERvZVwiIH0sXG4gICAgICogICAgIGxpbWl0OiA1LFxuICAgICAqICAgICByZWZyZXNoVHRsOiB0cnVlXG4gICAgICogICB9XG4gICAgICogKTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAgICAgKiAvLyB7XG4gICAgICogLy8gICBpdGVtczogW1xuICAgICAqIC8vICAgICB7XG4gICAgICogLy8gICAgICAgbmFtZXNwYWNlOiBbXCJkb2N1bWVudHNcIiwgXCJ1c2VyMTIzXCJdLFxuICAgICAqIC8vICAgICAgIGtleTogXCJpdGVtNzg5XCIsXG4gICAgICogLy8gICAgICAgdmFsdWU6IHsgdGl0bGU6IFwiQW5vdGhlciBEb2N1bWVudFwiLCBhdXRob3I6IFwiSm9obiBEb2VcIiB9LFxuICAgICAqIC8vICAgICAgIGNyZWF0ZWRBdDogXCIyMDI0LTA3LTMwVDEyOjAwOjAwWlwiLFxuICAgICAqIC8vICAgICAgIHVwZGF0ZWRBdDogXCIyMDI0LTA3LTMwVDEyOjAwOjAwWlwiXG4gICAgICogLy8gICAgIH0sXG4gICAgICogLy8gICAgIC8vIC4uLiBhZGRpdGlvbmFsIGl0ZW1zIC4uLlxuICAgICAqIC8vICAgXVxuICAgICAqIC8vIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hJdGVtcyhuYW1lc3BhY2VQcmVmaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZV9wcmVmaXg6IG5hbWVzcGFjZVByZWZpeCxcbiAgICAgICAgICAgIGZpbHRlcjogb3B0aW9ucz8uZmlsdGVyLFxuICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDEwLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zPy5xdWVyeSxcbiAgICAgICAgICAgIHJlZnJlc2hfdHRsOiBvcHRpb25zPy5yZWZyZXNoVHRsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goXCIvc3RvcmUvaXRlbXMvc2VhcmNoXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBqc29uOiBwYXlsb2FkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1zOiByZXNwb25zZS5pdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGl0ZW0uY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IGl0ZW0udXBkYXRlZF9hdCxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBuYW1lc3BhY2VzIHdpdGggb3B0aW9uYWwgbWF0Y2ggY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnByZWZpeCBPcHRpb25hbCBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBwcmVmaXggdG8gZmlsdGVyIG5hbWVzcGFjZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3VmZml4IE9wdGlvbmFsIGxpc3Qgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIHN1ZmZpeCB0byBmaWx0ZXIgbmFtZXNwYWNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhEZXB0aCBPcHRpb25hbCBpbnRlZ2VyIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gZGVwdGggb2YgbmFtZXNwYWNlcyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgTWF4aW11bSBudW1iZXIgb2YgbmFtZXNwYWNlcyB0byByZXR1cm4gKGRlZmF1bHQgaXMgMTAwKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgTnVtYmVyIG9mIG5hbWVzcGFjZXMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMgKGRlZmF1bHQgaXMgMCkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxMaXN0TmFtZXNwYWNlUmVzcG9uc2U+XG4gICAgICovXG4gICAgYXN5bmMgbGlzdE5hbWVzcGFjZXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgcHJlZml4OiBvcHRpb25zPy5wcmVmaXgsXG4gICAgICAgICAgICBzdWZmaXg6IG9wdGlvbnM/LnN1ZmZpeCxcbiAgICAgICAgICAgIG1heF9kZXB0aDogb3B0aW9ucz8ubWF4RGVwdGgsXG4gICAgICAgICAgICBsaW1pdDogb3B0aW9ucz8ubGltaXQgPz8gMTAwLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gMCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCIvc3RvcmUvbmFtZXNwYWNlc1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAganNvbjogcGF5bG9hZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVWlDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICBzdGF0aWMgZ2V0T3JDYWNoZWQoa2V5LCBmbikge1xuICAgICAgICBpZiAoVWlDbGllbnQucHJvbWlzZUNhY2hlW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFVpQ2xpZW50LnByb21pc2VDYWNoZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBmbigpO1xuICAgICAgICBVaUNsaWVudC5wcm9taXNlQ2FjaGVba2V5XSA9IHByb21pc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb21wb25lbnQoYXNzaXN0YW50SWQsIGFnZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gVWlDbGllbnQuZ2V0T3JDYWNoZWQoYCR7dGhpcy5hcGlVcmx9LSR7YXNzaXN0YW50SWR9LSR7YWdlbnROYW1lfWAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCBbdXJsLCBpbml0XSA9IHRoaXMucHJlcGFyZUZldGNoT3B0aW9ucyhgL3VpLyR7YXNzaXN0YW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQWNjZXB0OiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAganNvbjogeyBuYW1lOiBhZ2VudE5hbWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25SZXF1ZXN0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdCA9IGF3YWl0IHRoaXMub25SZXF1ZXN0KHVybCwgaW5pdCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNDYWxsZXIuZmV0Y2godXJsLCBpbml0KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVaUNsaWVudCwgXCJwcm9taXNlQ2FjaGVcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7fVxufSk7XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggYXNzaXN0YW50cy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzc2lzdGFudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhyZWFkcy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRocmVhZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggcnVucy5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggY3JvbiBydW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3JvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIEtWIHN0b3JlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFVJLlxuICAgICAgICAgKiBAaW50ZXJuYWwgVXNlZCBieSBMb2FkRXh0ZXJuYWxDb21wb25lbnQgYW5kIHRoZSBBUEkgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ+dWlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbCBVc2VkIHRvIG9idGFpbiBhIHN0YWJsZSBrZXkgcmVwcmVzZW50aW5nIHRoZSBjbGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ+Y29uZmlnSGFzaFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW1wifmNvbmZpZ0hhc2hcIl0gPSAoKCkgPT4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYXBpVXJsOiBjb25maWc/LmFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogY29uZmlnPy5hcGlLZXksXG4gICAgICAgICAgICB0aW1lb3V0TXM6IGNvbmZpZz8udGltZW91dE1zLFxuICAgICAgICAgICAgZGVmYXVsdEhlYWRlcnM6IGNvbmZpZz8uZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogY29uZmlnPy5jYWxsZXJPcHRpb25zPy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IGNvbmZpZz8uY2FsbGVyT3B0aW9ucz8ubWF4UmV0cmllcyxcbiAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBjb25maWc/LmNhbGxlck9wdGlvbnM/Lm9uRmFpbGVkUmVzcG9uc2VIb29rICE9IG51bGwsXG4gICAgICAgICAgICAgICAgb25SZXF1ZXN0OiBjb25maWc/Lm9uUmVxdWVzdCAhPSBudWxsLFxuICAgICAgICAgICAgICAgIGZldGNoOiBjb25maWc/LmNhbGxlck9wdGlvbnM/LmZldGNoICE9IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSkoKTtcbiAgICAgICAgdGhpcy5hc3Npc3RhbnRzID0gbmV3IEFzc2lzdGFudHNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZHNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5ydW5zID0gbmV3IFJ1bnNDbGllbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5jcm9ucyA9IG5ldyBDcm9uc0NsaWVudChjb25maWcpO1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IFN0b3JlQ2xpZW50KGNvbmZpZyk7XG4gICAgICAgIHRoaXNbXCJ+dWlcIl0gPSBuZXcgVWlDbGllbnQoY29uZmlnKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbCBVc2VkIHRvIG9idGFpbiBhIHN0YWJsZSBrZXkgcmVwcmVzZW50aW5nIHRoZSBjbGllbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRDb25maWdIYXNoKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnRbXCJ+Y29uZmlnSGFzaFwiXTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   getApiKey: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.getApiKey),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_1__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/client.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IENsaWVudCwgZ2V0QXBpS2V5IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js":
/*!************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"lg:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch function to use.\n */\nconst overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\n/**\n * @internal\n */\nconst _getFetchImplementation = () => {\n    return (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n        DEFAULT_FETCH_IMPLEMENTATION);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3NpbmdsZXRvbnMvZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLy8gV3JhcCB0aGUgZGVmYXVsdCBmZXRjaCBjYWxsIGR1ZSB0byBpc3N1ZXMgd2l0aCBpbGxlZ2FsIGludm9jYXRpb25zXG4vLyBpbiBzb21lIGVudmlyb25tZW50czpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5ODc2ODU5L3doeS1kb2VzLWJpbmQtZml4LWZhaWxlZC10by1leGVjdXRlLWZldGNoLW9uLXdpbmRvdy1pbGxlZ2FsLWludm9jYXRpb24tZXJyXG4vLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG5jb25zdCBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuY29uc3QgTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSA9IFN5bWJvbC5mb3IoXCJsZzpmZXRjaF9pbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBMYW5nU21pdGggY2FsbHMuXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBmZXRjaFxuICogb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBnbG9iYWwgKGUuZy4gZm9yIGRlYWxpbmcgd2l0aCBwcm94aWVzKS5cbiAqIEBwYXJhbSBmZXRjaCBUaGUgbmV3IGZldGNoIGZ1bmN0aW9uIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChmZXRjaCkgPT4ge1xuICAgIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPSBmZXRjaDtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2dldEZldGNoSW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID8/XG4gICAgICAgIERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04pO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/@langchain/langgraph-sdk/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400, // Bad Request\n    401, // Unauthorized\n    402, // Payment required\n    403, // Forbidden\n    404, // Not Found\n    405, // Method Not Allowed\n    406, // Not Acceptable\n    407, // Proxy Authentication Required\n    408, // Request Timeout\n    409, // Conflict\n    422, // Unprocessable Entity\n];\n/**\n * Do not rely on globalThis.Response, rather just\n * do duck typing\n */\nfunction isResponse(x) {\n    if (x == null || typeof x !== \"object\")\n        return false;\n    return \"status\" in x && \"statusText\" in x && \"text\" in x;\n}\n/**\n * Utility error to properly handle failed requests\n */\nclass HTTPError extends Error {\n    constructor(status, message, response) {\n        super(`HTTP ${status}: ${message}`);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"text\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.status = status;\n        this.text = message;\n        this.response = response;\n    }\n    static async fromResponse(response, options) {\n        try {\n            return new HTTPError(response.status, await response.text(), options?.includeResponse ? response : undefined);\n        }\n        catch {\n            return new HTTPError(response.status, response.statusText, options?.includeResponse ? response : undefined);\n        }\n    }\n}\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 5. This\n * means that by default, each call will be retried up to 5 times, with an\n * exponential backoff between each attempt.\n */\nclass AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customFetch\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 4;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n        this.customFetch = params.fetch;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const { onFailedResponseHook } = this;\n        return this.queue.add(() => p_retry__WEBPACK_IMPORTED_MODULE_0__(() => callable(...args).catch(async (error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else if (isResponse(error)) {\n                throw await HTTPError.fromResponse(error, {\n                    includeResponse: !!onFailedResponseHook,\n                });\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            async onFailedAttempt(error) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (error instanceof HTTPError) {\n                    if (STATUS_NO_RETRY.includes(error.status)) {\n                        throw error;\n                    }\n                    if (onFailedResponseHook && error.response) {\n                        await onFailedResponseHook(error.response);\n                    }\n                }\n            },\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        const fetchFn = this.customFetch ?? (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)();\n        return this.call(() => fetchFn(...args).then((res) => (res.ok ? res : Promise.reject(res))));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxJQUFJLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksS0FBc0I7QUFDbEM7QUFDQSw2QkFBNkIsK0NBQWlCO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBUyxHQUFHLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLG9DQUFvQyxvQ0FBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2RUFBdUI7QUFDbkU7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2FjaGluL3Byb2plY3RzL2ZpbmFuY2UtYXBwL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2xhbmdncmFwaC1zZGsvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuaW1wb3J0IHsgX2dldEZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCwgLy8gQmFkIFJlcXVlc3RcbiAgICA0MDEsIC8vIFVuYXV0aG9yaXplZFxuICAgIDQwMiwgLy8gUGF5bWVudCByZXF1aXJlZFxuICAgIDQwMywgLy8gRm9yYmlkZGVuXG4gICAgNDA0LCAvLyBOb3QgRm91bmRcbiAgICA0MDUsIC8vIE1ldGhvZCBOb3QgQWxsb3dlZFxuICAgIDQwNiwgLy8gTm90IEFjY2VwdGFibGVcbiAgICA0MDcsIC8vIFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbiAgICA0MDksIC8vIENvbmZsaWN0XG4gICAgNDIyLCAvLyBVbnByb2Nlc3NhYmxlIEVudGl0eVxuXTtcbi8qKlxuICogRG8gbm90IHJlbHkgb24gZ2xvYmFsVGhpcy5SZXNwb25zZSwgcmF0aGVyIGp1c3RcbiAqIGRvIGR1Y2sgdHlwaW5nXG4gKi9cbmZ1bmN0aW9uIGlzUmVzcG9uc2UoeCkge1xuICAgIGlmICh4ID09IG51bGwgfHwgdHlwZW9mIHggIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gXCJzdGF0dXNcIiBpbiB4ICYmIFwic3RhdHVzVGV4dFwiIGluIHggJiYgXCJ0ZXh0XCIgaW4geDtcbn1cbi8qKlxuICogVXRpbGl0eSBlcnJvciB0byBwcm9wZXJseSBoYW5kbGUgZmFpbGVkIHJlcXVlc3RzXG4gKi9cbmNsYXNzIEhUVFBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMsIG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKGBIVFRQICR7c3RhdHVzfTogJHttZXNzYWdlfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNwb25zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy50ZXh0ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhUVFBFcnJvcihyZXNwb25zZS5zdGF0dXMsIGF3YWl0IHJlc3BvbnNlLnRleHQoKSwgb3B0aW9ucz8uaW5jbHVkZVJlc3BvbnNlID8gcmVzcG9uc2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSFRUUEVycm9yKHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCwgb3B0aW9ucz8uaW5jbHVkZVJlc3BvbnNlID8gcmVzcG9uc2UgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA1LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNSB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZFJlc3BvbnNlSG9va1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjdXN0b21GZXRjaFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA0O1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZCh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2sgPSBwYXJhbXM/Lm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgICAgICB0aGlzLmN1c3RvbUZldGNoID0gcGFyYW1zLmZldGNoO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBvbkZhaWxlZFJlc3BvbnNlSG9vayB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0IEhUVFBFcnJvci5mcm9tUmVzcG9uc2UoZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJlc3BvbnNlOiAhIW9uRmFpbGVkUmVzcG9uc2VIb29rLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSFRUUEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmFpbGVkUmVzcG9uc2VIb29rICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvbkZhaWxlZFJlc3BvbnNlSG9vayhlcnJvci5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICBjb25zdCBmZXRjaEZuID0gdGhpcy5jdXN0b21GZXRjaCA/PyBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IGZldGNoRm4oLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/env.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable)\n/* harmony export */ });\nfunction getEnvironmentVariable(name) {\n    // Certain setups (Deno, frontend) will throw an error if you try to access environment variables\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL2Vudi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBzZXR1cHMgKERlbm8sIGZyb250ZW5kKSB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudj8uW25hbWVdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeSignals: () => (/* binding */ mergeSignals)\n/* harmony export */ });\nfunction mergeSignals(...signals) {\n    const nonZeroSignals = signals.filter((signal) => signal != null);\n    if (nonZeroSignals.length === 0)\n        return undefined;\n    if (nonZeroSignals.length === 1)\n        return nonZeroSignals[0];\n    const controller = new AbortController();\n    for (const signal of signals) {\n        if (signal?.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal?.addEventListener(\"abort\", () => controller.abort(signal.reason), {\n            once: true,\n        });\n    }\n    return controller.signal;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc2lnbmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL3NpZ25hbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU2lnbmFscyguLi5zaWduYWxzKSB7XG4gICAgY29uc3Qgbm9uWmVyb1NpZ25hbHMgPSBzaWduYWxzLmZpbHRlcigoc2lnbmFsKSA9PiBzaWduYWwgIT0gbnVsbCk7XG4gICAgaWYgKG5vblplcm9TaWduYWxzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAobm9uWmVyb1NpZ25hbHMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gbm9uWmVyb1NpZ25hbHNbMF07XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzKSB7XG4gICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gY29udHJvbGxlci5hYm9ydChzaWduYWwucmVhc29uKSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/signals.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesLineDecoder: () => (/* binding */ BytesLineDecoder),\n/* harmony export */   SSEDecoder: () => (/* binding */ SSEDecoder)\n/* harmony export */ });\nconst CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nfunction BytesLineDecoder() {\n    let buffer = [];\n    let trailingCr = false;\n    return new TransformStream({\n        start() {\n            buffer = [];\n            trailingCr = false;\n        },\n        transform(chunk, controller) {\n            // See https://docs.python.org/3/glossary.html#term-universal-newlines\n            let text = chunk;\n            // Handle trailing CR from previous chunk\n            if (trailingCr) {\n                text = joinArrays([[CR], text]);\n                trailingCr = false;\n            }\n            // Check for trailing CR in current chunk\n            if (text.length > 0 && text.at(-1) === CR) {\n                trailingCr = true;\n                text = text.subarray(0, -1);\n            }\n            if (!text.length)\n                return;\n            const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n            const lastIdx = text.length - 1;\n            const { lines } = text.reduce((acc, cur, idx) => {\n                if (acc.from > idx)\n                    return acc;\n                if (cur === CR || cur === LF) {\n                    acc.lines.push(text.subarray(acc.from, idx));\n                    if (cur === CR && text[idx + 1] === LF) {\n                        acc.from = idx + 2;\n                    }\n                    else {\n                        acc.from = idx + 1;\n                    }\n                }\n                if (idx === lastIdx && acc.from <= lastIdx) {\n                    acc.lines.push(text.subarray(acc.from));\n                }\n                return acc;\n            }, { lines: [], from: 0 });\n            if (lines.length === 1 && !trailingNewline) {\n                buffer.push(lines[0]);\n                return;\n            }\n            if (buffer.length) {\n                // Include existing buffer in first line\n                buffer.push(lines[0]);\n                lines[0] = joinArrays(buffer);\n                buffer = [];\n            }\n            if (!trailingNewline) {\n                // If the last segment is not newline terminated,\n                // buffer it for the next chunk\n                if (lines.length)\n                    buffer = [lines.pop()];\n            }\n            // Enqueue complete lines\n            for (const line of lines) {\n                controller.enqueue(line);\n            }\n        },\n        flush(controller) {\n            if (buffer.length) {\n                controller.enqueue(joinArrays(buffer));\n            }\n        },\n    });\n}\nfunction SSEDecoder() {\n    let event = \"\";\n    let data = [];\n    let lastEventId = \"\";\n    let retry = null;\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            // Handle empty line case\n            if (!chunk.length) {\n                if (!event && !data.length && !lastEventId && retry == null)\n                    return;\n                const sse = {\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                };\n                // NOTE: as per the SSE spec, do not reset lastEventId\n                event = \"\";\n                data = [];\n                retry = null;\n                controller.enqueue(sse);\n                return;\n            }\n            // Ignore comments\n            if (chunk[0] === COLON)\n                return;\n            const sepIdx = chunk.indexOf(COLON);\n            if (sepIdx === -1)\n                return;\n            const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n            let value = chunk.subarray(sepIdx + 1);\n            if (value[0] === SPACE)\n                value = value.subarray(1);\n            if (fieldName === \"event\") {\n                event = decoder.decode(value);\n            }\n            else if (fieldName === \"data\") {\n                data.push(value);\n            }\n            else if (fieldName === \"id\") {\n                if (value.indexOf(NULL) === -1)\n                    lastEventId = decoder.decode(value);\n            }\n            else if (fieldName === \"retry\") {\n                const retryNum = Number.parseInt(decoder.decode(value), 10);\n                if (!Number.isNaN(retryNum))\n                    retry = retryNum;\n            }\n        },\n        flush(controller) {\n            if (event) {\n                controller.enqueue({\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                });\n            }\n        },\n    });\n}\nfunction joinArrays(data) {\n    const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n    const merged = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const c of data) {\n        merged.set(c, offset);\n        offset += c.length;\n    }\n    return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n    return JSON.parse(decoder.decode(joinArrays(data)));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3NlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL3NzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDUiA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IExGID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgTlVMTCA9IFwiXFwwXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IENPTE9OID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFNQQUNFID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IFRSQUlMSU5HX05FV0xJTkUgPSBbQ1IsIExGXTtcbmV4cG9ydCBmdW5jdGlvbiBCeXRlc0xpbmVEZWNvZGVyKCkge1xuICAgIGxldCBidWZmZXIgPSBbXTtcbiAgICBsZXQgdHJhaWxpbmdDciA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRyYWlsaW5nQ3IgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9nbG9zc2FyeS5odG1sI3Rlcm0tdW5pdmVyc2FsLW5ld2xpbmVzXG4gICAgICAgICAgICBsZXQgdGV4dCA9IGNodW5rO1xuICAgICAgICAgICAgLy8gSGFuZGxlIHRyYWlsaW5nIENSIGZyb20gcHJldmlvdXMgY2h1bmtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0NyKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGpvaW5BcnJheXMoW1tDUl0sIHRleHRdKTtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdHJhaWxpbmcgQ1IgaW4gY3VycmVudCBjaHVua1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0LmF0KC0xKSA9PT0gQ1IpIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJhcnJheSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsaW5nTmV3bGluZSA9IFRSQUlMSU5HX05FV0xJTkUuaW5jbHVkZXModGV4dC5hdCgtMSkpO1xuICAgICAgICAgICAgY29uc3QgbGFzdElkeCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGluZXMgfSA9IHRleHQucmVkdWNlKChhY2MsIGN1ciwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjYy5mcm9tID4gaWR4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IENSIHx8IGN1ciA9PT0gTEYpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLmxpbmVzLnB1c2godGV4dC5zdWJhcnJheShhY2MuZnJvbSwgaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IENSICYmIHRleHRbaWR4ICsgMV0gPT09IExGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2MuZnJvbSA9IGlkeCArIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2MuZnJvbSA9IGlkeCArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gbGFzdElkeCAmJiBhY2MuZnJvbSA8PSBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5saW5lcy5wdXNoKHRleHQuc3ViYXJyYXkoYWNjLmZyb20pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHsgbGluZXM6IFtdLCBmcm9tOiAwIH0pO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSAmJiAhdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2gobGluZXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBleGlzdGluZyBidWZmZXIgaW4gZmlyc3QgbGluZVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGxpbmVzWzBdKTtcbiAgICAgICAgICAgICAgICBsaW5lc1swXSA9IGpvaW5BcnJheXMoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3Qgc2VnbWVudCBpcyBub3QgbmV3bGluZSB0ZXJtaW5hdGVkLFxuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlciBpdCBmb3IgdGhlIG5leHQgY2h1bmtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBbbGluZXMucG9wKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5xdWV1ZSBjb21wbGV0ZSBsaW5lc1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShqb2luQXJyYXlzKGJ1ZmZlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFNTRURlY29kZXIoKSB7XG4gICAgbGV0IGV2ZW50ID0gXCJcIjtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIGxldCBsYXN0RXZlbnRJZCA9IFwiXCI7XG4gICAgbGV0IHJldHJ5ID0gbnVsbDtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBlbXB0eSBsaW5lIGNhc2VcbiAgICAgICAgICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudCAmJiAhZGF0YS5sZW5ndGggJiYgIWxhc3RFdmVudElkICYmIHJldHJ5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBzc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBsYXN0RXZlbnRJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLmxlbmd0aCA/IGRlY29kZUFycmF5c1RvSnNvbihkZWNvZGVyLCBkYXRhKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBhcyBwZXIgdGhlIFNTRSBzcGVjLCBkbyBub3QgcmVzZXQgbGFzdEV2ZW50SWRcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoc3NlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZ25vcmUgY29tbWVudHNcbiAgICAgICAgICAgIGlmIChjaHVua1swXSA9PT0gQ09MT04pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3Qgc2VwSWR4ID0gY2h1bmsuaW5kZXhPZihDT0xPTik7XG4gICAgICAgICAgICBpZiAoc2VwSWR4ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBkZWNvZGVyLmRlY29kZShjaHVuay5zdWJhcnJheSgwLCBzZXBJZHgpKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNodW5rLnN1YmFycmF5KHNlcElkeCArIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBTUEFDRSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoTlVMTCkgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZCA9IGRlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gXCJyZXRyeVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlOdW0gPSBOdW1iZXIucGFyc2VJbnQoZGVjb2Rlci5kZWNvZGUodmFsdWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0cnlOdW0pKVxuICAgICAgICAgICAgICAgICAgICByZXRyeSA9IHJldHJ5TnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogbGFzdEV2ZW50SWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5sZW5ndGggPyBkZWNvZGVBcnJheXNUb0pzb24oZGVjb2RlciwgZGF0YSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gam9pbkFycmF5cyhkYXRhKSB7XG4gICAgY29uc3QgdG90YWxMZW5ndGggPSBkYXRhLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYyBvZiBkYXRhKSB7XG4gICAgICAgIG1lcmdlZC5zZXQoYywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZnVuY3Rpb24gZGVjb2RlQXJyYXlzVG9Kc29uKGRlY29kZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShqb2luQXJyYXlzKGRhdGEpKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/sse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js":
/*!********************************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IterableReadableStream: () => (/* binding */ IterableReadableStream)\n/* harmony export */ });\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nclass IterableReadableStream extends ReadableStream {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"reader\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    ensureReader() {\n        if (!this.reader) {\n            this.reader = this.getReader();\n        }\n    }\n    async next() {\n        this.ensureReader();\n        try {\n            const result = await this.reader.read();\n            if (result.done) {\n                this.reader.releaseLock(); // release lock when stream becomes closed\n                return {\n                    done: true,\n                    value: undefined,\n                };\n            }\n            else {\n                return {\n                    done: false,\n                    value: result.value,\n                };\n            }\n        }\n        catch (e) {\n            this.reader.releaseLock(); // release lock when stream becomes errored\n            throw e;\n        }\n    }\n    async return() {\n        this.ensureReader();\n        // If wrapped in a Node stream, cancel is already called.\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        return { done: true, value: undefined };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async throw(e) {\n        this.ensureReader();\n        if (this.locked) {\n            const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n            this.reader.releaseLock(); // release lock first\n            await cancelPromise; // now await it\n        }\n        throw e;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not present in Node 18 types, required in latest Node 22\n    async [Symbol.asyncDispose]() {\n        await this.return();\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    static fromReadableStream(stream) {\n        // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n        const reader = stream.getReader();\n        return new IterableReadableStream({\n            start(controller) {\n                return pump();\n                function pump() {\n                    return reader.read().then(({ done, value }) => {\n                        // When no more data needs to be consumed, close the stream\n                        if (done) {\n                            controller.close();\n                            return;\n                        }\n                        // Enqueue the next data chunk into our target stream\n                        controller.enqueue(value);\n                        return pump();\n                    });\n                }\n            },\n            cancel() {\n                reader.releaseLock();\n            },\n        });\n    }\n    static fromAsyncGenerator(generator) {\n        return new IterableReadableStream({\n            async pull(controller) {\n                const { value, done } = await generator.next();\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                    controller.close();\n                }\n                // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n                controller.enqueue(value);\n            },\n            async cancel(reason) {\n                await generator.return(reason);\n            },\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9sYW5nZ3JhcGgtc2RrL2Rpc3QvdXRpbHMvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYWNoaW4vcHJvamVjdHMvZmluYW5jZS1hcHAvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vbGFuZ2dyYXBoLXNkay9kaXN0L3V0aWxzL3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogU3VwcG9ydCBhc3luYyBpdGVyYXRvciBzeW50YXggZm9yIFJlYWRhYmxlU3RyZWFtcyBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbnN1cmVSZWFkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gdGhpcy5nZXRSZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICB0aGlzLmVuc3VyZVJlYWRlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIC8vIElmIHdyYXBwZWQgaW4gYSBOb2RlIHN0cmVhbSwgY2FuY2VsIGlzIGFscmVhZHkgY2FsbGVkLlxuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSB0aGlzLnJlYWRlci5jYW5jZWwoKTsgLy8gY2FuY2VsIGZpcnN0LCBidXQgZG9uJ3QgYXdhaXQgeWV0XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgZmlyc3RcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7IC8vIG5vdyBhd2FpdCBpdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB0aHJvdyhlKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgTm90IHByZXNlbnQgaW4gTm9kZSAxOCB0eXBlcywgcmVxdWlyZWQgaW4gbGF0ZXN0IE5vZGUgMjJcbiAgICBhc3luYyBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmV0dXJuKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdHJlYW1zX0FQSS9Vc2luZ19yZWFkYWJsZV9zdHJlYW1zI3JlYWRpbmdfdGhlX3N0cmVhbVxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIHRoZSBuZXh0IGRhdGEgY2h1bmsgaW50byBvdXIgdGFyZ2V0IHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc3luY0dlbmVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpeDogYGVsc2UgaWYgKHZhbHVlKWAgd2lsbCBoYW5nIHRoZSBzdHJlYW1pbmcgd2hlbiBudWxsaXNoIHZhbHVlIChlLmcuIGVtcHR5IHN0cmluZykgaXMgcHVsbGVkXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2VuZXJhdG9yLnJldHVybihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@langchain/langgraph-sdk/dist/utils/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@langchain/langgraph-sdk/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@langchain/langgraph-sdk/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),
/* harmony export */   getApiKey: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getApiKey),
/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "(rsc)/./node_modules/@langchain/langgraph-sdk/dist/index.js");


/***/ })

};
;