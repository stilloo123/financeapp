"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gtoken";
exports.ids = ["vendor-chunks/gtoken"];
exports.modules = {

/***/ "(rsc)/./node_modules/gtoken/build/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/gtoken/build/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GoogleToken = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst readFile = fs.readFile\n    ? (0, util_1.promisify)(fs.readFile)\n    : async () => {\n        // if running in the web-browser, fs.readFile may not have been shimmed.\n        throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n    };\nconst GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';\nconst GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\nclass ErrorWithCode extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nlet getPem;\nclass GoogleToken {\n    /**\n     * Create a GoogleToken.\n     *\n     * @param options  Configuration object.\n     */\n    constructor(options) {\n        this.transporter = {\n            request: opts => (0, gaxios_1.request)(opts),\n        };\n        this.configure(options);\n    }\n    get accessToken() {\n        return this.rawToken ? this.rawToken.access_token : undefined;\n    }\n    get idToken() {\n        return this.rawToken ? this.rawToken.id_token : undefined;\n    }\n    get tokenType() {\n        return this.rawToken ? this.rawToken.token_type : undefined;\n    }\n    get refreshToken() {\n        return this.rawToken ? this.rawToken.refresh_token : undefined;\n    }\n    /**\n     * Returns whether the token has expired.\n     *\n     * @return true if the token has expired, false otherwise.\n     */\n    hasExpired() {\n        const now = new Date().getTime();\n        if (this.rawToken && this.expiresAt) {\n            return now >= this.expiresAt;\n        }\n        else {\n            return true;\n        }\n    }\n    /**\n     * Returns whether the token will expire within eagerRefreshThresholdMillis\n     *\n     * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n     */\n    isTokenExpiring() {\n        var _a;\n        const now = new Date().getTime();\n        const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;\n        if (this.rawToken && this.expiresAt) {\n            return this.expiresAt <= now + eagerRefreshThresholdMillis;\n        }\n        else {\n            return true;\n        }\n    }\n    getToken(callback, opts = {}) {\n        if (typeof callback === 'object') {\n            opts = callback;\n            callback = undefined;\n        }\n        opts = Object.assign({\n            forceRefresh: false,\n        }, opts);\n        if (callback) {\n            const cb = callback;\n            this.getTokenAsync(opts).then(t => cb(null, t), callback);\n            return;\n        }\n        return this.getTokenAsync(opts);\n    }\n    /**\n     * Given a keyFile, extract the key and client email if available\n     * @param keyFile Path to a json, pem, or p12 file that contains the key.\n     * @returns an object with privateKey and clientEmail properties\n     */\n    async getCredentials(keyFile) {\n        const ext = path.extname(keyFile);\n        switch (ext) {\n            case '.json': {\n                const key = await readFile(keyFile, 'utf8');\n                const body = JSON.parse(key);\n                const privateKey = body.private_key;\n                const clientEmail = body.client_email;\n                if (!privateKey || !clientEmail) {\n                    throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n                }\n                return { privateKey, clientEmail };\n            }\n            case '.der':\n            case '.crt':\n            case '.pem': {\n                const privateKey = await readFile(keyFile, 'utf8');\n                return { privateKey };\n            }\n            case '.p12':\n            case '.pfx': {\n                // NOTE:  The loading of `google-p12-pem` is deferred for performance\n                // reasons.  The `node-forge` npm module in `google-p12-pem` adds a fair\n                // bit time to overall module loading, and is likely not frequently\n                // used.  In a future release, p12 support will be entirely removed.\n                if (!getPem) {\n                    getPem = (await Promise.resolve().then(() => __webpack_require__(/*! google-p12-pem */ \"(rsc)/./node_modules/google-p12-pem/build/src/index.js\"))).getPem;\n                }\n                const privateKey = await getPem(keyFile);\n                return { privateKey };\n            }\n            default:\n                throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' +\n                    'Current supported extensions are *.json, *.pem, and *.p12.', 'UNKNOWN_CERTIFICATE_TYPE');\n        }\n    }\n    async getTokenAsync(opts) {\n        if (this.inFlightRequest && !opts.forceRefresh) {\n            return this.inFlightRequest;\n        }\n        try {\n            return await (this.inFlightRequest = this.getTokenAsyncInner(opts));\n        }\n        finally {\n            this.inFlightRequest = undefined;\n        }\n    }\n    async getTokenAsyncInner(opts) {\n        if (this.isTokenExpiring() === false && opts.forceRefresh === false) {\n            return Promise.resolve(this.rawToken);\n        }\n        if (!this.key && !this.keyFile) {\n            throw new Error('No key or keyFile set.');\n        }\n        if (!this.key && this.keyFile) {\n            const creds = await this.getCredentials(this.keyFile);\n            this.key = creds.privateKey;\n            this.iss = creds.clientEmail || this.iss;\n            if (!creds.clientEmail) {\n                this.ensureEmail();\n            }\n        }\n        return this.requestToken();\n    }\n    ensureEmail() {\n        if (!this.iss) {\n            throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n        }\n    }\n    revokeToken(callback) {\n        if (callback) {\n            this.revokeTokenAsync().then(() => callback(), callback);\n            return;\n        }\n        return this.revokeTokenAsync();\n    }\n    async revokeTokenAsync() {\n        if (!this.accessToken) {\n            throw new Error('No token to revoke.');\n        }\n        const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n        await this.transporter.request({ url });\n        this.configure({\n            email: this.iss,\n            sub: this.sub,\n            key: this.key,\n            keyFile: this.keyFile,\n            scope: this.scope,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Configure the GoogleToken for re-use.\n     * @param  {object} options Configuration object.\n     */\n    configure(options = {}) {\n        this.keyFile = options.keyFile;\n        this.key = options.key;\n        this.rawToken = undefined;\n        this.iss = options.email || options.iss;\n        this.sub = options.sub;\n        this.additionalClaims = options.additionalClaims;\n        if (typeof options.scope === 'object') {\n            this.scope = options.scope.join(' ');\n        }\n        else {\n            this.scope = options.scope;\n        }\n        this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n        if (options.transporter) {\n            this.transporter = options.transporter;\n        }\n    }\n    /**\n     * Request the token from Google.\n     */\n    async requestToken() {\n        var _a, _b;\n        const iat = Math.floor(new Date().getTime() / 1000);\n        const additionalClaims = this.additionalClaims || {};\n        const payload = Object.assign({\n            iss: this.iss,\n            scope: this.scope,\n            aud: GOOGLE_TOKEN_URL,\n            exp: iat + 3600,\n            iat,\n            sub: this.sub,\n        }, additionalClaims);\n        const signedJWT = jws.sign({\n            header: { alg: 'RS256' },\n            payload,\n            secret: this.key,\n        });\n        try {\n            const r = await this.transporter.request({\n                method: 'POST',\n                url: GOOGLE_TOKEN_URL,\n                data: {\n                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                    assertion: signedJWT,\n                },\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n                responseType: 'json',\n            });\n            this.rawToken = r.data;\n            this.expiresAt =\n                r.data.expires_in === null || r.data.expires_in === undefined\n                    ? undefined\n                    : (iat + r.data.expires_in) * 1000;\n            return this.rawToken;\n        }\n        catch (e) {\n            this.rawToken = undefined;\n            this.tokenExpires = undefined;\n            const body = e.response && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data)\n                ? (_b = e.response) === null || _b === void 0 ? void 0 : _b.data\n                : {};\n            if (body.error) {\n                const desc = body.error_description\n                    ? `: ${body.error_description}`\n                    : '';\n                e.message = `${body.error}${desc}`;\n            }\n            throw e;\n        }\n    }\n}\nexports.GoogleToken = GoogleToken;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3Rva2VuL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsOERBQVE7QUFDakMsWUFBWSxtQkFBTyxDQUFDLDhDQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN6RjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwyQkFBMkIscURBQXFEO0FBQ2hGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQSwrQkFBK0IsV0FBVyxFQUFFLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhY2hpbi9wcm9qZWN0cy9maW5hbmNlLWFwcC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZ3Rva2VuL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogU2VlIGZpbGUgTElDRU5TRSBmb3IgZGV0YWlsIG9yIGNvcHkgYXQgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgandzID0gcmVxdWlyZShcImp3c1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgcmVhZEZpbGUgPSBmcy5yZWFkRmlsZVxuICAgID8gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzLnJlYWRGaWxlKVxuICAgIDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBpZiBydW5uaW5nIGluIHRoZSB3ZWItYnJvd3NlciwgZnMucmVhZEZpbGUgbWF5IG5vdCBoYXZlIGJlZW4gc2hpbW1lZC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aENvZGUoJ3VzZSBrZXkgcmF0aGVyIHRoYW4ga2V5RmlsZS4nLCAnTUlTU0lOR19DUkVERU5USUFMUycpO1xuICAgIH07XG5jb25zdCBHT09HTEVfVE9LRU5fVVJMID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL29hdXRoMi92NC90b2tlbic7XG5jb25zdCBHT09HTEVfUkVWT0tFX1RPS0VOX1VSTCA9ICdodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvcmV2b2tlP3Rva2VuPSc7XG5jbGFzcyBFcnJvcldpdGhDb2RlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxubGV0IGdldFBlbTtcbmNsYXNzIEdvb2dsZVRva2VuIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBHb29nbGVUb2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zICBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIgPSB7XG4gICAgICAgICAgICByZXF1ZXN0OiBvcHRzID0+ICgwLCBnYXhpb3NfMS5yZXF1ZXN0KShvcHRzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLmFjY2Vzc190b2tlbiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGlkVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1Rva2VuID8gdGhpcy5yYXdUb2tlbi5pZF90b2tlbiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW4gPyB0aGlzLnJhd1Rva2VuLnRva2VuX3R5cGUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1Rva2VuID8gdGhpcy5yYXdUb2tlbi5yZWZyZXNoX3Rva2VuIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIGhhcyBleHBpcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSB0b2tlbiBoYXMgZXhwaXJlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhc0V4cGlyZWQoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiAodGhpcy5yYXdUb2tlbiAmJiB0aGlzLmV4cGlyZXNBdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdyA+PSB0aGlzLmV4cGlyZXNBdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgdG9rZW4gd2lsbCBleHBpcmUgd2l0aGluIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSB0b2tlbiB3aWxsIGJlIGV4cGlyZWQgd2l0aGluIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzVG9rZW5FeHBpcmluZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gKF9hID0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmICh0aGlzLnJhd1Rva2VuICYmIHRoaXMuZXhwaXJlc0F0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBpcmVzQXQgPD0gbm93ICsgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VG9rZW4oY2FsbGJhY2ssIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0cyA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5Bc3luYyhvcHRzKS50aGVuKHQgPT4gY2IobnVsbCwgdCksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkFzeW5jKG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGtleUZpbGUsIGV4dHJhY3QgdGhlIGtleSBhbmQgY2xpZW50IGVtYWlsIGlmIGF2YWlsYWJsZVxuICAgICAqIEBwYXJhbSBrZXlGaWxlIFBhdGggdG8gYSBqc29uLCBwZW0sIG9yIHAxMiBmaWxlIHRoYXQgY29udGFpbnMgdGhlIGtleS5cbiAgICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBjbGllbnRFbWFpbCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3JlZGVudGlhbHMoa2V5RmlsZSkge1xuICAgICAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUoa2V5RmlsZSk7XG4gICAgICAgIHN3aXRjaCAoZXh0KSB7XG4gICAgICAgICAgICBjYXNlICcuanNvbic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCByZWFkRmlsZShrZXlGaWxlLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnBhcnNlKGtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGJvZHkucHJpdmF0ZV9rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50RW1haWwgPSBib2R5LmNsaWVudF9lbWFpbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByaXZhdGVLZXkgfHwgIWNsaWVudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhDb2RlKCdwcml2YXRlX2tleSBhbmQgY2xpZW50X2VtYWlsIGFyZSByZXF1aXJlZC4nLCAnTUlTU0lOR19DUkVERU5USUFMUycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBwcml2YXRlS2V5LCBjbGllbnRFbWFpbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnLmRlcic6XG4gICAgICAgICAgICBjYXNlICcuY3J0JzpcbiAgICAgICAgICAgIGNhc2UgJy5wZW0nOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHJlYWRGaWxlKGtleUZpbGUsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnLnAxMic6XG4gICAgICAgICAgICBjYXNlICcucGZ4Jzoge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6ICBUaGUgbG9hZGluZyBvZiBgZ29vZ2xlLXAxMi1wZW1gIGlzIGRlZmVycmVkIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIC8vIHJlYXNvbnMuICBUaGUgYG5vZGUtZm9yZ2VgIG5wbSBtb2R1bGUgaW4gYGdvb2dsZS1wMTItcGVtYCBhZGRzIGEgZmFpclxuICAgICAgICAgICAgICAgIC8vIGJpdCB0aW1lIHRvIG92ZXJhbGwgbW9kdWxlIGxvYWRpbmcsIGFuZCBpcyBsaWtlbHkgbm90IGZyZXF1ZW50bHlcbiAgICAgICAgICAgICAgICAvLyB1c2VkLiAgSW4gYSBmdXR1cmUgcmVsZWFzZSwgcDEyIHN1cHBvcnQgd2lsbCBiZSBlbnRpcmVseSByZW1vdmVkLlxuICAgICAgICAgICAgICAgIGlmICghZ2V0UGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBlbSA9IChhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHJlcXVpcmUoJ2dvb2dsZS1wMTItcGVtJykpKS5nZXRQZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBhd2FpdCBnZXRQZW0oa2V5RmlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoQ29kZSgnVW5rbm93biBjZXJ0aWZpY2F0ZSB0eXBlLiBUeXBlIGlzIGRldGVybWluZWQgYmFzZWQgb24gZmlsZSBleHRlbnNpb24uICcgK1xuICAgICAgICAgICAgICAgICAgICAnQ3VycmVudCBzdXBwb3J0ZWQgZXh0ZW5zaW9ucyBhcmUgKi5qc29uLCAqLnBlbSwgYW5kICoucDEyLicsICdVTktOT1dOX0NFUlRJRklDQVRFX1RZUEUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbkFzeW5jKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5GbGlnaHRSZXF1ZXN0ICYmICFvcHRzLmZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5GbGlnaHRSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuaW5GbGlnaHRSZXF1ZXN0ID0gdGhpcy5nZXRUb2tlbkFzeW5jSW5uZXIob3B0cykpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5pbkZsaWdodFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW5Bc3luY0lubmVyKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUb2tlbkV4cGlyaW5nKCkgPT09IGZhbHNlICYmIG9wdHMuZm9yY2VSZWZyZXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJhd1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMua2V5ICYmICF0aGlzLmtleUZpbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5IG9yIGtleUZpbGUgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5rZXkgJiYgdGhpcy5rZXlGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHModGhpcy5rZXlGaWxlKTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0gY3JlZHMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIHRoaXMuaXNzID0gY3JlZHMuY2xpZW50RW1haWwgfHwgdGhpcy5pc3M7XG4gICAgICAgICAgICBpZiAoIWNyZWRzLmNsaWVudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVFbWFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RUb2tlbigpO1xuICAgIH1cbiAgICBlbnN1cmVFbWFpbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aENvZGUoJ2VtYWlsIGlzIHJlcXVpcmVkLicsICdNSVNTSU5HX0NSRURFTlRJQUxTJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV2b2tlVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJldm9rZVRva2VuQXN5bmMoKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXZva2VUb2tlbkFzeW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIHJldm9rZVRva2VuQXN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0b2tlbiB0byByZXZva2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gR09PR0xFX1JFVk9LRV9UT0tFTl9VUkwgKyB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3QoeyB1cmwgfSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKHtcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmlzcyxcbiAgICAgICAgICAgIHN1YjogdGhpcy5zdWIsXG4gICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICBhZGRpdGlvbmFsQ2xhaW1zOiB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIEdvb2dsZVRva2VuIGZvciByZS11c2UuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5rZXlGaWxlID0gb3B0aW9ucy5rZXlGaWxlO1xuICAgICAgICB0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuICAgICAgICB0aGlzLnJhd1Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzcyA9IG9wdGlvbnMuZW1haWwgfHwgb3B0aW9ucy5pc3M7XG4gICAgICAgIHRoaXMuc3ViID0gb3B0aW9ucy5zdWI7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcyA9IG9wdGlvbnMuYWRkaXRpb25hbENsYWltcztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjb3BlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGUuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZSA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgPSBvcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcbiAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNwb3J0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIgPSBvcHRpb25zLnRyYW5zcG9ydGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgdGhlIHRva2VuIGZyb20gR29vZ2xlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RUb2tlbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaWF0ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2xhaW1zID0gdGhpcy5hZGRpdGlvbmFsQ2xhaW1zIHx8IHt9O1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBpc3M6IHRoaXMuaXNzLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICBhdWQ6IEdPT0dMRV9UT0tFTl9VUkwsXG4gICAgICAgICAgICBleHA6IGlhdCArIDM2MDAsXG4gICAgICAgICAgICBpYXQsXG4gICAgICAgICAgICBzdWI6IHRoaXMuc3ViLFxuICAgICAgICB9LCBhZGRpdGlvbmFsQ2xhaW1zKTtcbiAgICAgICAgY29uc3Qgc2lnbmVkSldUID0gandzLnNpZ24oe1xuICAgICAgICAgICAgaGVhZGVyOiB7IGFsZzogJ1JTMjU2JyB9LFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHNlY3JldDogdGhpcy5rZXksXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgdXJsOiBHT09HTEVfVE9LRU5fVVJMLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmp3dC1iZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRpb246IHNpZ25lZEpXVCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmF3VG9rZW4gPSByLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmV4cGlyZXNBdCA9XG4gICAgICAgICAgICAgICAgci5kYXRhLmV4cGlyZXNfaW4gPT09IG51bGwgfHwgci5kYXRhLmV4cGlyZXNfaW4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IChpYXQgKyByLmRhdGEuZXhwaXJlc19pbikgKiAxMDAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3VG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmF3VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRva2VuRXhwaXJlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlLnJlc3BvbnNlICYmICgoX2EgPSBlLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSlcbiAgICAgICAgICAgICAgICA/IChfYiA9IGUucmVzcG9uc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kYXRhXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IGJvZHkuZXJyb3JfZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgOiAke2JvZHkuZXJyb3JfZGVzY3JpcHRpb259YFxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGAke2JvZHkuZXJyb3J9JHtkZXNjfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVUb2tlbiA9IEdvb2dsZVRva2VuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/gtoken/build/src/index.js\n");

/***/ })

};
;